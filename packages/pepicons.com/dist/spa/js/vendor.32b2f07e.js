(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[1],{

/***/ "004f":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return clearSelection; });
/* harmony import */ var _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5094");

function clearSelection() {
  if (window.getSelection !== void 0) {
    const selection = window.getSelection();

    if (selection.empty !== void 0) {
      selection.empty();
    } else if (selection.removeAllRanges !== void 0) {
      selection.removeAllRanges();
      _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"].is.mobile !== true && selection.addRange(document.createRange());
    }
  } else if (document.selection !== void 0) {
    document.selection.empty();
  }
}

/***/ }),

/***/ "0446":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("da06");
var Iterators = __webpack_require__("5bb7");
var wellKnownSymbol = __webpack_require__("7d53");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "0471":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return t; });
var e={"":["<em>","</em>"],_:["<strong>","</strong>"],"*":["<strong>","</strong>"],"~":["<s>","</s>"],"\n":["<br />"]," ":["<br />"],"-":["<hr />"]};function n(e){return e.replace(RegExp("^"+(e.match(/^(\t| )+/)||"")[0],"gm"),"")}function r(e){return(e+"").replace(/"/g,"&quot;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}function t(a,c){var o,l,g,s,p,u=/((?:^|\n+)(?:\n---+|\* \*(?: \*)+)\n)|(?:^``` *(\w*)\n([\s\S]*?)\n```$)|((?:(?:^|\n+)(?:\t|  {2,}).+)+\n*)|((?:(?:^|\n)([>*+-]|\d+\.)\s+.*)+)|(?:!\[([^\]]*?)\]\(([^)]+?)\))|(\[)|(\](?:\(([^)]+?)\))?)|(?:(?:^|\n+)([^\s].*)\n(-{3,}|={3,})(?:\n+|$))|(?:(?:^|\n+)(#{1,6})\s*(.+)(?:\n+|$))|(?:`([^`].*?)`)|(  \n\n*|\n{2,}|__|\*\*|[_*]|~~)/gm,m=[],h="",i=c||{},d=0;function f(n){var r=e[n[1]||""],t=m[m.length-1]==n;return r?r[1]?(t?m.pop():m.push(n),r[0|t]):r[0]:n}function $(){for(var e="";m.length;)e+=f(m[m.length-1]);return e}for(a=a.replace(/^\[(.+?)\]:\s*(.+)$/gm,function(e,n,r){return i[n.toLowerCase()]=r,""}).replace(/^\n+|\n+$/g,"");g=u.exec(a);)l=a.substring(d,g.index),d=u.lastIndex,o=g[0],l.match(/[^\\](\\\\)*\\$/)||((p=g[3]||g[4])?o='<pre class="code '+(g[4]?"poetry":g[2].toLowerCase())+'"><code'+(g[2]?' class="language-'+g[2].toLowerCase()+'"':"")+">"+n(r(p).replace(/^\n+|\n+$/g,""))+"</code></pre>":(p=g[6])?(p.match(/\./)&&(g[5]=g[5].replace(/^\d+/gm,"")),s=t(n(g[5].replace(/^\s*[>*+.-]/gm,""))),">"==p?p="blockquote":(p=p.match(/\./)?"ol":"ul",s=s.replace(/^(.*)(\n|$)/gm,"<li>$1</li>")),o="<"+p+">"+s+"</"+p+">"):g[8]?o='<img src="'+r(g[8])+'" alt="'+r(g[7])+'">':g[10]?(h=h.replace("<a>",'<a href="'+r(g[11]||i[l.toLowerCase()])+'">'),o=$()+"</a>"):g[9]?o="<a>":g[12]||g[14]?o="<"+(p="h"+(g[14]?g[14].length:g[13]>"="?1:2))+">"+t(g[12]||g[15],i)+"</"+p+">":g[16]?o="<code>"+r(g[16])+"</code>":(g[17]||g[1])&&(o=f(g[17]||"--"))),h+=l,h+=o;return(h+a.substring(d)+$()).replace(/^\n+|\n+$/g,"")}
//# sourceMappingURL=snarkdown.es.js.map


/***/ }),

/***/ "047a":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "05e4":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "06b9":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_Pepicon_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("0c6d");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_Pepicon_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_Pepicon_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "072e":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _key_composition_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("1b63");

const handlers = [];
let escDown = false;
/* harmony default export */ __webpack_exports__["a"] = ({
  __install() {
    this.__installed = true;
    window.addEventListener('keydown', evt => {
      escDown = evt.keyCode === 27;
    });
    window.addEventListener('blur', () => {
      escDown === true && (escDown = false);
    });
    window.addEventListener('keyup', evt => {
      if (escDown === true) {
        escDown = false;

        if (handlers.length !== 0 && Object(_key_composition_js__WEBPACK_IMPORTED_MODULE_0__[/* isKeyCode */ "a"])(evt, 27) === true) {
          handlers[handlers.length - 1].fn(evt);
        }
      }
    });
  },

  register(comp, fn) {
    if (comp.$q.platform.is.desktop === true) {
      this.__installed !== true && this.__install();
      handlers.push({
        comp,
        fn
      });
    }
  },

  pop(comp) {
    if (comp.$q.platform.is.desktop === true) {
      const index = handlers.findIndex(h => h.comp === comp);

      if (index > -1) {
        handlers.splice(index, 1);
      }
    }
  }

});

/***/ }),

/***/ "07d9":
/***/ (function(module, exports, __webpack_require__) {

exports.nextTick = function nextTick(fn) {
    var args = Array.prototype.slice.call(arguments);
    args.shift();
    setTimeout(function () {
        fn.apply(null, args);
    }, 0);
};

exports.platform = exports.arch = 
exports.execPath = exports.title = 'browser';
exports.pid = 1;
exports.browser = true;
exports.env = {};
exports.argv = [];

exports.binding = function (name) {
	throw new Error('No such module. (Possibly not yet loaded)')
};

(function () {
    var cwd = '/';
    var path;
    exports.cwd = function () { return cwd };
    exports.chdir = function (dir) {
        if (!path) path = __webpack_require__("a0d5");
        cwd = path.resolve(dir, cwd);
    };
})();

exports.exit = exports.kill = 
exports.umask = exports.dlopen = 
exports.uptime = exports.memoryUsage = 
exports.uvCounters = function() {};
exports.features = {};


/***/ }),

/***/ "083f":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("7526");

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "0a1e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getBuiltIn = __webpack_require__("5428");
var definePropertyModule = __webpack_require__("abdf");
var wellKnownSymbol = __webpack_require__("7d53");
var DESCRIPTORS = __webpack_require__("d4cb");

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),

/***/ "0aa9":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _utils_selection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("004f");
/* harmony import */ var _utils_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("9ac9");
/* harmony import */ var _utils_touch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("36df");
/* harmony import */ var _utils_key_composition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("1b63");




/* harmony default export */ __webpack_exports__["a"] = ({
  props: {
    target: {
      default: true
    },
    noParentEvent: Boolean,
    contextMenu: Boolean
  },
  watch: {
    contextMenu(val) {
      if (this.anchorEl !== void 0) {
        this.__unconfigureAnchorEl();

        this.__configureAnchorEl(val);
      }
    },

    target() {
      if (this.anchorEl !== void 0) {
        this.__unconfigureAnchorEl();
      }

      this.__pickAnchorEl();
    },

    noParentEvent(val) {
      if (this.anchorEl !== void 0) {
        if (val === true) {
          this.__unconfigureAnchorEl();
        } else {
          this.__configureAnchorEl();
        }
      }
    }

  },
  methods: {
    __showCondition(evt) {
      // abort with no parent configured or on multi-touch
      if (this.anchorEl === void 0) {
        return false;
      }

      if (evt === void 0) {
        return true;
      }

      return evt.touches === void 0 || evt.touches.length <= 1;
    },

    __contextClick(evt) {
      this.hide(evt);
      this.$nextTick(() => {
        this.show(evt);
      });
      Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_1__[/* prevent */ "i"])(evt);
    },

    __toggleKey(evt) {
      Object(_utils_key_composition_js__WEBPACK_IMPORTED_MODULE_3__[/* isKeyCode */ "a"])(evt, 13) === true && this.toggle(evt);
    },

    __mobileCleanup(evt) {
      this.anchorEl.classList.remove('non-selectable');
      clearTimeout(this.touchTimer);

      if (this.showing === true && evt !== void 0) {
        Object(_utils_selection_js__WEBPACK_IMPORTED_MODULE_0__[/* clearSelection */ "a"])();
      }
    },

    __mobilePrevent: _utils_event_js__WEBPACK_IMPORTED_MODULE_1__[/* prevent */ "i"],

    __mobileTouch(evt) {
      this.__mobileCleanup(evt);

      if (this.__showCondition(evt) !== true) {
        return;
      }

      this.hide(evt);
      this.anchorEl.classList.add('non-selectable');
      const target = Object(_utils_touch_js__WEBPACK_IMPORTED_MODULE_2__[/* getTouchTarget */ "b"])(evt.target);
      Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_1__[/* addEvt */ "a"])(this, 'anchor', [[target, 'touchmove', '__mobileCleanup', 'passive'], [target, 'touchend', '__mobileCleanup', 'passive'], [target, 'touchcancel', '__mobileCleanup', 'passive'], [this.anchorEl, 'contextmenu', '__mobilePrevent', 'notPassive']]);
      this.touchTimer = setTimeout(() => {
        this.show(evt);
      }, 300);
    },

    __unconfigureAnchorEl() {
      Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_1__[/* cleanEvt */ "b"])(this, 'anchor');
    },

    __configureAnchorEl(context = this.contextMenu) {
      if (this.noParentEvent === true || this.anchorEl === void 0) {
        return;
      }

      let evts;

      if (context === true) {
        if (this.$q.platform.is.mobile === true) {
          evts = [[this.anchorEl, 'touchstart', '__mobileTouch', 'passive']];
        } else {
          evts = [[this.anchorEl, 'click', 'hide', 'passive'], [this.anchorEl, 'contextmenu', '__contextClick', 'notPassive']];
        }
      } else {
        evts = [[this.anchorEl, 'click', 'toggle', 'passive'], [this.anchorEl, 'keyup', '__toggleKey', 'passive']];
      }

      Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_1__[/* addEvt */ "a"])(this, 'anchor', evts);
    },

    __setAnchorEl(el) {
      this.anchorEl = el;

      while (this.anchorEl.classList.contains('q-anchor--skip')) {
        this.anchorEl = this.anchorEl.parentNode;
      }

      this.__configureAnchorEl();
    },

    __pickAnchorEl() {
      if (this.target === false || this.target === '') {
        this.anchorEl = void 0;
      } else if (this.target === true) {
        this.__setAnchorEl(this.parentEl);
      } else {
        let el = this.target;

        if (typeof this.target === 'string') {
          try {
            el = document.querySelector(this.target);
          } catch (err) {
            el = void 0;
          }
        }

        if (el !== void 0 && el !== null) {
          this.anchorEl = el._isVue === true && el.$el !== void 0 ? el.$el : el;

          this.__configureAnchorEl();
        } else {
          this.anchorEl = void 0;
          console.error(`Anchor: target "${this.target}" not found`, this);
        }
      }
    },

    __changeScrollEvent(scrollTarget, fn) {
      const fnProp = `${fn !== void 0 ? 'add' : 'remove'}EventListener`;
      const fnHandler = fn !== void 0 ? fn : this.__scrollFn;

      if (scrollTarget !== window) {
        scrollTarget[fnProp]('scroll', fnHandler, _utils_event_js__WEBPACK_IMPORTED_MODULE_1__[/* listenOpts */ "f"].passive);
      }

      window[fnProp]('scroll', fnHandler, _utils_event_js__WEBPACK_IMPORTED_MODULE_1__[/* listenOpts */ "f"].passive);
      this.__scrollFn = fn;
    }

  },

  created() {
    if (typeof this.__configureScrollTarget === 'function' && typeof this.__unconfigureScrollTarget === 'function') {
      this.noParentEventWatcher = this.$watch('noParentEvent', () => {
        if (this.__scrollTarget !== void 0) {
          this.__unconfigureScrollTarget();

          this.__configureScrollTarget();
        }
      });
    }
  },

  mounted() {
    this.parentEl = this.$el.parentNode;

    this.__pickAnchorEl();

    if (this.value === true && this.anchorEl === void 0) {
      this.$emit('input', false);
    }
  },

  beforeDestroy() {
    clearTimeout(this.touchTimer);
    this.noParentEventWatcher !== void 0 && this.noParentEventWatcher();
    this.__anchorCleanup !== void 0 && this.__anchorCleanup();

    this.__unconfigureAnchorEl();
  }

});

/***/ }),

/***/ "0c47":
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__("c91c");
var enumBugKeys = __webpack_require__("b17e");

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "0c6d":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "0e39":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("f1a7");
var toObject = __webpack_require__("37d1");
var sharedKey = __webpack_require__("332c");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__("802e");

var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype : null;
};


/***/ }),

/***/ "0e93":
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "0fb0":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _utils_cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("6459");

/* harmony default export */ __webpack_exports__["a"] = (Object(_utils_cache_js__WEBPACK_IMPORTED_MODULE_0__[/* getPropCacheMixin */ "c"])('$listeners', 'qListeners'));

/***/ }),

/***/ "1108":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "1194":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("d578");

/* harmony default export */ __webpack_exports__["a"] = (Object(_size_js__WEBPACK_IMPORTED_MODULE_0__[/* getSizeMixin */ "b"])({
  xs: 30,
  sm: 35,
  md: 40,
  lg: 50,
  xl: 60
}));

/***/ }),

/***/ "130d":
/***/ (function(module, exports) {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ "134d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return rgbToHex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return rgbToString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return hexToRgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return hsvToRgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return rgbToHsv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return textToRgb; });
/* unused harmony export lighten */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return luminosity; });
/* unused harmony export brightness */
/* unused harmony export blend */
/* unused harmony export changeAlpha */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return setBrand; });
/* unused harmony export getBrand */
/* unused harmony export getPaletteColor */
/* unused harmony export stringToRgb */
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("32f5");
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_string_trim_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("b55a");
/* harmony import */ var core_js_modules_es_string_trim_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_trim_js__WEBPACK_IMPORTED_MODULE_1__);


const reRGBA = /^rgb(a)?\((\d{1,3}),(\d{1,3}),(\d{1,3}),?([01]?\.?\d*?)?\)$/;
function rgbToHex({
  r,
  g,
  b,
  a
}) {
  const alpha = a !== void 0;
  r = Math.round(r);
  g = Math.round(g);
  b = Math.round(b);

  if (r > 255 || g > 255 || b > 255 || alpha && a > 100) {
    throw new TypeError('Expected 3 numbers below 256 (and optionally one below 100)');
  }

  a = alpha ? (Math.round(255 * a / 100) | 1 << 8).toString(16).slice(1) : '';
  return '#' + (b | g << 8 | r << 16 | 1 << 24).toString(16).slice(1) + a;
}
function rgbToString({
  r,
  g,
  b,
  a
}) {
  return `rgb${a !== void 0 ? 'a' : ''}(${r},${g},${b}${a !== void 0 ? ',' + a / 100 : ''})`;
}
function hexToRgb(hex) {
  if (typeof hex !== 'string') {
    throw new TypeError('Expected a string');
  }

  hex = hex.replace(/^#/, '');

  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  } else if (hex.length === 4) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
  }

  const num = parseInt(hex, 16);
  return hex.length > 6 ? {
    r: num >> 24 & 255,
    g: num >> 16 & 255,
    b: num >> 8 & 255,
    a: Math.round((num & 255) / 2.55)
  } : {
    r: num >> 16,
    g: num >> 8 & 255,
    b: num & 255
  };
}
function hsvToRgb({
  h,
  s,
  v,
  a
}) {
  let r, g, b;
  s = s / 100;
  v = v / 100;
  h = h / 360;
  const i = Math.floor(h * 6),
        f = h * 6 - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s);

  switch (i % 6) {
    case 0:
      r = v;
      g = t;
      b = p;
      break;

    case 1:
      r = q;
      g = v;
      b = p;
      break;

    case 2:
      r = p;
      g = v;
      b = t;
      break;

    case 3:
      r = p;
      g = q;
      b = v;
      break;

    case 4:
      r = t;
      g = p;
      b = v;
      break;

    case 5:
      r = v;
      g = p;
      b = q;
      break;
  }

  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255),
    a
  };
}
function rgbToHsv({
  r,
  g,
  b,
  a
}) {
  const max = Math.max(r, g, b),
        min = Math.min(r, g, b),
        d = max - min,
        s = max === 0 ? 0 : d / max,
        v = max / 255;
  let h;

  switch (max) {
    case min:
      h = 0;
      break;

    case r:
      h = g - b + d * (g < b ? 6 : 0);
      h /= 6 * d;
      break;

    case g:
      h = b - r + d * 2;
      h /= 6 * d;
      break;

    case b:
      h = r - g + d * 4;
      h /= 6 * d;
      break;
  }

  return {
    h: Math.round(h * 360),
    s: Math.round(s * 100),
    v: Math.round(v * 100),
    a
  };
}
function textToRgb(str) {
  if (typeof str !== 'string') {
    throw new TypeError('Expected a string');
  }

  const color = str.replace(/ /g, '');
  const m = reRGBA.exec(color);

  if (m === null) {
    return hexToRgb(color);
  }

  const rgb = {
    r: Math.min(255, parseInt(m[2], 10)),
    g: Math.min(255, parseInt(m[3], 10)),
    b: Math.min(255, parseInt(m[4], 10))
  };

  if (m[1]) {
    const alpha = parseFloat(m[5]);
    rgb.a = Math.min(1, isNaN(alpha) === true ? 1 : alpha) * 100;
  }

  return rgb;
}
/* works as darken if percent < 0 */

function lighten(color, percent) {
  if (typeof color !== 'string') {
    throw new TypeError('Expected a string as color');
  }

  if (typeof percent !== 'number') {
    throw new TypeError('Expected a numeric percent');
  }

  const rgb = textToRgb(color),
        t = percent < 0 ? 0 : 255,
        p = Math.abs(percent) / 100,
        R = rgb.r,
        G = rgb.g,
        B = rgb.b;
  return '#' + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);
}
function luminosity(color) {
  if (typeof color !== 'string' && (!color || color.r === void 0)) {
    throw new TypeError('Expected a string or a {r, g, b} object as color');
  }

  const rgb = typeof color === 'string' ? textToRgb(color) : color,
        r = rgb.r / 255,
        g = rgb.g / 255,
        b = rgb.b / 255,
        R = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4),
        G = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4),
        B = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
  return 0.2126 * R + 0.7152 * G + 0.0722 * B;
}
function brightness(color) {
  if (typeof color !== 'string' && (!color || color.r === void 0)) {
    throw new TypeError('Expected a string or a {r, g, b} object as color');
  }

  const rgb = typeof color === 'string' ? textToRgb(color) : color;
  return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
}
function blend(fgColor, bgColor) {
  if (typeof fgColor !== 'string' && (!fgColor || fgColor.r === void 0)) {
    throw new TypeError('Expected a string or a {r, g, b[, a]} object as fgColor');
  }

  if (typeof bgColor !== 'string' && (!bgColor || bgColor.r === void 0)) {
    throw new TypeError('Expected a string or a {r, g, b[, a]} object as bgColor');
  }

  const rgb1 = typeof fgColor === 'string' ? textToRgb(fgColor) : fgColor,
        r1 = rgb1.r / 255,
        g1 = rgb1.g / 255,
        b1 = rgb1.b / 255,
        a1 = rgb1.a !== void 0 ? rgb1.a / 100 : 1,
        rgb2 = typeof bgColor === 'string' ? textToRgb(bgColor) : bgColor,
        r2 = rgb2.r / 255,
        g2 = rgb2.g / 255,
        b2 = rgb2.b / 255,
        a2 = rgb2.a !== void 0 ? rgb2.a / 100 : 1,
        a = a1 + a2 * (1 - a1),
        r = Math.round((r1 * a1 + r2 * a2 * (1 - a1)) / a * 255),
        g = Math.round((g1 * a1 + g2 * a2 * (1 - a1)) / a * 255),
        b = Math.round((b1 * a1 + b2 * a2 * (1 - a1)) / a * 255);
  const ret = {
    r,
    g,
    b,
    a: Math.round(a * 100)
  };
  return typeof fgColor === 'string' ? rgbToHex(ret) : ret;
}
function changeAlpha(color, offset) {
  if (typeof color !== 'string') {
    throw new TypeError('Expected a string as color');
  }

  if (offset === void 0 || offset < -1 || offset > 1) {
    throw new TypeError('Expected offset to be between -1 and 1');
  }

  const {
    r,
    g,
    b,
    a
  } = textToRgb(color);
  const alpha = a !== void 0 ? a / 100 : 0;
  return rgbToHex({
    r,
    g,
    b,
    a: Math.round(Math.min(1, Math.max(0, alpha + offset)) * 100)
  });
}
function setBrand(color, value, element = document.body) {
  if (typeof color !== 'string') {
    throw new TypeError('Expected a string as color');
  }

  if (typeof value !== 'string') {
    throw new TypeError('Expected a string as value');
  }

  if (!(element instanceof Element)) {
    throw new TypeError('Expected a DOM element');
  }

  element.style.setProperty(`--q-color-${color}`, value);
}
function getBrand(color, element = document.body) {
  if (typeof color !== 'string') {
    throw new TypeError('Expected a string as color');
  }

  if (!(element instanceof Element)) {
    throw new TypeError('Expected a DOM element');
  }

  return getComputedStyle(element).getPropertyValue(`--q-color-${color}`).trim() || null;
}
function getPaletteColor(colorName) {
  if (typeof colorName !== 'string') {
    throw new TypeError('Expected a string as color');
  }

  const el = document.createElement('div');
  el.className = `text-${colorName} invisible fixed no-pointer-events`;
  document.body.appendChild(el);
  const result = getComputedStyle(el).getPropertyValue('color');
  el.remove();
  return rgbToHex(textToRgb(result));
} // TODO: remove in v2

const stringToRgb = textToRgb;
/* harmony default export */ __webpack_exports__["a"] = ({
  rgbToHex,
  hexToRgb,
  hsvToRgb,
  rgbToHsv,
  textToRgb,
  lighten,
  luminosity,
  brightness,
  blend,
  changeAlpha,
  setBrand,
  getBrand,
  getPaletteColor
});

/***/ }),

/***/ "1351":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarAnchor_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("e04d");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarAnchor_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarAnchor_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "13a5":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/components/atoms/CategoryPanel.vue?vue&type=template&id=26f0da30&
var CategoryPanelvue_type_template_id_26f0da30_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('BlitzForm',_vm._g(_vm._b({key:_vm.isPlainObject(_vm.$attrs.value) ? String(_vm.$attrs.value.value) : '_',staticClass:"planetar-category-panel",attrs:{"schema":_vm.schemaCalculated,"mode":_vm.mode,"labelPosition":"left"}},'BlitzForm',_vm.$attrs,false),_vm.$listeners))}
var staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/components/atoms/CategoryPanel.vue?vue&type=template&id=26f0da30&

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue/dist/vue.runtime.esm.js
var vue_runtime_esm = __webpack_require__("9869");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzForm.vue?vue&type=template&id=50a7f219&
var BlitzFormvue_type_template_id_50a7f219_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(_vm.innerFormComponent,{ref:"refBlitzForm",tag:"component",class:("blitz-form blitz-form--nav-" + _vm.actionButtonsPosition)},[(_vm.formComponent === 'QForm')?[_c('button',{staticStyle:{"display":"none"},attrs:{"type":"submit","disabled":"","aria-hidden":"true"}}),(_vm.isFullString(_vm.formErrorMsg) || _vm.actionButtonsSchema.length)?_c('div',{class:("blitz-form__nav-row blitz-form__nav-row--" + _vm.actionButtonsPosition)},[(_vm.isFullString(_vm.formErrorMsg))?_c('div',{staticClass:"blitz-form__validation-error text-negative"},[_vm._v("\n        "+_vm._s(_vm.formErrorMsg)+"\n      ")]):_vm._e(),_vm._l((_vm.actionButtonsSchema),function(blueprint,i){return _c('BlitzField',_vm._g(_vm._b({key:blueprint.id || i},'BlitzField',blueprint,false),blueprint.events))})],2):_vm._e()]:_vm._e(),_vm._t("default",[_c('div',{staticClass:"blitz-form__form",style:(("grid-template-columns:" + (' 1fr'.repeat(_vm.columnCount)) + "; grid-gap: " + _vm.gridGap))},_vm._l((_vm.cSchema),function(field){return _c('BlitzField',_vm._b({key:field.id,style:(field.span
            ? ("grid-column: " + (field.span === true ? '1 / -1' : ("span " + (field.span))))
            : ''),attrs:{"value":_vm.formDataFlat[field.id]},on:{"input":function (value, origin) { return _vm.fieldInput({ id: field.id, value: value, origin: origin }); }}},'BlitzField',Object.assign({}, field, {span: undefined}),false))}),1)],null,{ schema: _vm.cSchema, formDataFlat: _vm.formDataFlat })],2)}
var BlitzFormvue_type_template_id_50a7f219_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzForm.vue?vue&type=template&id=50a7f219&

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.symbol.description.js
var es_symbol_description = __webpack_require__("8d0f");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/web.dom-collections.iterator.js
var web_dom_collections_iterator = __webpack_require__("918c");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.array.reduce.js
var es_array_reduce = __webpack_require__("28eb");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.promise.js
var es_promise = __webpack_require__("26d3");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@babel/runtime/helpers/objectSpread2.js
var objectSpread2 = __webpack_require__("ca22");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2);

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/listeners.js
var listeners = __webpack_require__("0fb0");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("9ac9");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/slot.js
var utils_slot = __webpack_require__("a4b3");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/form/QForm.js







/* harmony default export */ var QForm = (vue_runtime_esm["default"].extend({
  name: 'QForm',
  mixins: [listeners["a" /* default */]],
  props: {
    autofocus: Boolean,
    noErrorFocus: Boolean,
    noResetFocus: Boolean,
    greedy: Boolean
  },
  computed: {
    onEvents() {
      return objectSpread2_default()(objectSpread2_default()({}, this.qListeners), {}, {
        submit: this.submit,
        reset: this.reset
      });
    }

  },

  mounted() {
    this.validateIndex = 0;
    this.autofocus === true && this.focus();
  },

  methods: {
    validate(shouldFocus) {
      const promises = [];
      const focus = typeof shouldFocus === 'boolean' ? shouldFocus : this.noErrorFocus !== true;
      this.validateIndex++;
      const components = this.getValidationComponents();

      const emit = (res, ref) => {
        this.$emit('validation-' + (res === true ? 'success' : 'error'), ref);
      };

      for (let i = 0; i < components.length; i++) {
        const comp = components[i];
        const valid = comp.validate();

        if (typeof valid.then === 'function') {
          promises.push(valid.then(valid => ({
            valid,
            comp
          }), error => ({
            valid: false,
            comp,
            error
          })));
        } else if (valid !== true) {
          if (this.greedy === false) {
            emit(false, comp);

            if (focus === true && typeof comp.focus === 'function') {
              comp.focus();
            }

            return Promise.resolve(false);
          }

          promises.push({
            valid: false,
            comp
          });
        }
      }

      if (promises.length === 0) {
        emit(true);
        return Promise.resolve(true);
      }

      const index = this.validateIndex;
      return Promise.all(promises).then(res => {
        if (index === this.validateIndex) {
          const errors = res.filter(r => r.valid !== true);

          if (errors.length === 0) {
            emit(true);
            return true;
          }

          const {
            valid,
            comp
          } = errors[0];
          emit(false, comp);

          if (focus === true && valid !== true && typeof comp.focus === 'function') {
            comp.focus();
          }

          return false;
        }
      });
    },

    resetValidation() {
      this.validateIndex++;
      this.getValidationComponents().forEach(comp => {
        typeof comp.resetValidation === 'function' && comp.resetValidation();
      });
    },

    submit(evt) {
      evt !== void 0 && Object(utils_event["l" /* stopAndPrevent */])(evt);
      this.validate().then(val => {
        if (val === true) {
          if (this.qListeners.submit !== void 0) {
            this.$emit('submit', evt);
          } else if (evt !== void 0 && evt.target !== void 0 && typeof evt.target.submit === 'function') {
            evt.target.submit();
          }
        }
      });
    },

    reset(evt) {
      evt !== void 0 && Object(utils_event["l" /* stopAndPrevent */])(evt);
      this.$emit('reset');
      this.$nextTick(() => {
        // allow userland to reset values before
        this.resetValidation();

        if (this.autofocus === true && this.noResetFocus !== true) {
          this.focus();
        }
      });
    },

    focus() {
      const target = this.$el.querySelector('[autofocus], [data-autofocus]') || Array.prototype.find.call(this.$el.querySelectorAll('[tabindex]'), el => el.tabIndex > -1);
      target !== null && target !== void 0 && target.focus();
    },

    getValidationComponents() {
      return Array.prototype.map.call(this.$el.getElementsByClassName('q-validation-component'), field => field.__vue__).filter(c => c !== void 0 && typeof c.validate === 'function');
    }

  },

  render(h) {
    return h('form', {
      staticClass: 'q-form',
      on: this.onEvents
    }, Object(utils_slot["c" /* slot */])(this, 'default'));
  }

}));
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/merge-anything/dist/index.esm.js + 1 modules
var index_esm = __webpack_require__("502a");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/copy-anything/node_modules/is-what/dist/index.esm.js
/**
 * Returns the object type of the given payload
 *
 * @param {*} payload
 * @returns {string}
 */
function getType(payload) {
    return Object.prototype.toString.call(payload).slice(8, -1);
}
/**
 * Returns whether the payload is undefined
 *
 * @param {*} payload
 * @returns {payload is undefined}
 */
function isUndefined(payload) {
    return getType(payload) === 'Undefined';
}
/**
 * Returns whether the payload is null
 *
 * @param {*} payload
 * @returns {payload is null}
 */
function isNull(payload) {
    return getType(payload) === 'Null';
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isPlainObject(payload) {
    if (getType(payload) !== 'Object')
        return false;
    return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isObject(payload) {
    return isPlainObject(payload);
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is { [K in any]: never }}
 */
function isEmptyObject(payload) {
    return isPlainObject(payload) && Object.keys(payload).length === 0;
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isFullObject(payload) {
    return isPlainObject(payload) && Object.keys(payload).length > 0;
}
/**
 * Returns whether the payload is an any kind of object (including special classes or objects with different prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isAnyObject(payload) {
    return getType(payload) === 'Object';
}
/**
 * Returns whether the payload is an object like a type passed in < >
 *
 * Usage: isObjectLike<{id: any}>(payload) // will make sure it's an object and has an `id` prop.
 *
 * @template T this must be passed in < >
 * @param {*} payload
 * @returns {payload is T}
 */
function isObjectLike(payload) {
    return isAnyObject(payload);
}
/**
 * Returns whether the payload is a function (regular or async)
 *
 * @param {*} payload
 * @returns {payload is AnyFunction}
 */
function isFunction(payload) {
    return typeof payload === 'function';
}
/**
 * Returns whether the payload is an array
 *
 * @param {any} payload
 * @returns {payload is any[]}
 */
function isArray(payload) {
    return getType(payload) === 'Array';
}
/**
 * Returns whether the payload is a an array with at least 1 item
 *
 * @param {*} payload
 * @returns {payload is any[]}
 */
function isFullArray(payload) {
    return isArray(payload) && payload.length > 0;
}
/**
 * Returns whether the payload is a an empty array
 *
 * @param {*} payload
 * @returns {payload is []}
 */
function isEmptyArray(payload) {
    return isArray(payload) && payload.length === 0;
}
/**
 * Returns whether the payload is a string
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isString(payload) {
    return getType(payload) === 'String';
}
/**
 * Returns whether the payload is a string, BUT returns false for ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isFullString(payload) {
    return isString(payload) && payload !== '';
}
/**
 * Returns whether the payload is ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isEmptyString(payload) {
    return payload === '';
}
/**
 * Returns whether the payload is a number (but not NaN)
 *
 * This will return `false` for `NaN`!!
 *
 * @param {*} payload
 * @returns {payload is number}
 */
function isNumber(payload) {
    return getType(payload) === 'Number' && !isNaN(payload);
}
/**
 * Returns whether the payload is a boolean
 *
 * @param {*} payload
 * @returns {payload is boolean}
 */
function isBoolean(payload) {
    return getType(payload) === 'Boolean';
}
/**
 * Returns whether the payload is a regular expression (RegExp)
 *
 * @param {*} payload
 * @returns {payload is RegExp}
 */
function isRegExp(payload) {
    return getType(payload) === 'RegExp';
}
/**
 * Returns whether the payload is a Map
 *
 * @param {*} payload
 * @returns {payload is Map<any, any>}
 */
function isMap(payload) {
    return getType(payload) === 'Map';
}
/**
 * Returns whether the payload is a WeakMap
 *
 * @param {*} payload
 * @returns {payload is WeakMap<any, any>}
 */
function isWeakMap(payload) {
    return getType(payload) === 'WeakMap';
}
/**
 * Returns whether the payload is a Set
 *
 * @param {*} payload
 * @returns {payload is Set<any>}
 */
function isSet(payload) {
    return getType(payload) === 'Set';
}
/**
 * Returns whether the payload is a WeakSet
 *
 * @param {*} payload
 * @returns {payload is WeakSet<any>}
 */
function isWeakSet(payload) {
    return getType(payload) === 'WeakSet';
}
/**
 * Returns whether the payload is a Symbol
 *
 * @param {*} payload
 * @returns {payload is symbol}
 */
function isSymbol(payload) {
    return getType(payload) === 'Symbol';
}
/**
 * Returns whether the payload is a Date, and that the date is valid
 *
 * @param {*} payload
 * @returns {payload is Date}
 */
function isDate(payload) {
    return getType(payload) === 'Date' && !isNaN(payload);
}
/**
 * Returns whether the payload is a Blob
 *
 * @param {*} payload
 * @returns {payload is Blob}
 */
function isBlob(payload) {
    return getType(payload) === 'Blob';
}
/**
 * Returns whether the payload is a File
 *
 * @param {*} payload
 * @returns {payload is File}
 */
function isFile(payload) {
    return getType(payload) === 'File';
}
/**
 * Returns whether the payload is a Promise
 *
 * @param {*} payload
 * @returns {payload is Promise<any>}
 */
function isPromise(payload) {
    return getType(payload) === 'Promise';
}
/**
 * Returns whether the payload is an Error
 *
 * @param {*} payload
 * @returns {payload is Error}
 */
function isError(payload) {
    return getType(payload) === 'Error';
}
/**
 * Returns whether the payload is literally the value `NaN` (it's `NaN` and also a `number`)
 *
 * @param {*} payload
 * @returns {payload is typeof NaN}
 */
function isNaNValue(payload) {
    return getType(payload) === 'Number' && isNaN(payload);
}
/**
 * Returns whether the payload is a primitive type (eg. Boolean | Null | Undefined | Number | String | Symbol)
 *
 * @param {*} payload
 * @returns {(payload is boolean | null | undefined | number | string | symbol)}
 */
function isPrimitive(payload) {
    return (isBoolean(payload) ||
        isNull(payload) ||
        isUndefined(payload) ||
        isNumber(payload) ||
        isString(payload) ||
        isSymbol(payload));
}
/**
 * Returns true whether the payload is null or undefined
 *
 * @param {*} payload
 * @returns {(payload is null | undefined)}
 */
var isNullOrUndefined = isOneOf(isNull, isUndefined);
function isOneOf(a, b, c, d, e) {
    return function (value) {
        return a(value) || b(value) || (!!c && c(value)) || (!!d && d(value)) || (!!e && e(value));
    };
}
/**
 * Does a generic check to check that the given payload is of a given type.
 * In cases like Number, it will return true for NaN as NaN is a Number (thanks javascript!);
 * It will, however, differentiate between object and null
 *
 * @template T
 * @param {*} payload
 * @param {T} type
 * @throws {TypeError} Will throw type error if type is an invalid type
 * @returns {payload is T}
 */
function isType(payload, type) {
    if (!(type instanceof Function)) {
        throw new TypeError('Type must be a function');
    }
    if (!Object.prototype.hasOwnProperty.call(type, 'prototype')) {
        throw new TypeError('Type is not a class');
    }
    // Classes usually have names (as functions usually have names)
    var name = type.name;
    return getType(payload) === name || Boolean(payload && payload.constructor === type);
}



// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/copy-anything/dist/index.esm.js


/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
    var propType = {}.propertyIsEnumerable.call(originalObject, key)
        ? 'enumerable'
        : 'nonenumerable';
    if (propType === 'enumerable')
        carry[key] = newVal;
    if (includeNonenumerable && propType === 'nonenumerable') {
        Object.defineProperty(carry, key, {
            value: newVal,
            enumerable: false,
            writable: true,
            configurable: true,
        });
    }
}
/**
 * Copy (clone) an object and all its props recursively to get rid of any prop referenced of the original object. Arrays are also cloned, however objects inside arrays are still linked.
 *
 * @export
 * @template T
 * @param {T} target Target can be anything
 * @param {Options} [options = {}] Options can be `props` or `nonenumerable`
 * @returns {T} the target with replaced values
 * @export
 */
function copy(target, options) {
    if (options === void 0) { options = {}; }
    if (isArray(target))
        return target.map(function (item) { return copy(item, options); });
    if (!isPlainObject(target))
        return target;
    var props = Object.getOwnPropertyNames(target);
    var symbols = Object.getOwnPropertySymbols(target);
    return __spreadArrays(props, symbols).reduce(function (carry, key) {
        if (isArray(options.props) && !options.props.includes(key)) {
            return carry;
        }
        var val = target[key];
        var newVal = copy(val, options);
        assignProp(carry, key, newVal, target, options.nonenumerable);
        return carry;
    }, {});
}



// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/node_modules/is-what/dist/index.esm.js
/**
 * Returns the object type of the given payload
 *
 * @param {*} payload
 * @returns {string}
 */
function index_esm_getType(payload) {
    return Object.prototype.toString.call(payload).slice(8, -1);
}
/**
 * Returns whether the payload is undefined
 *
 * @param {*} payload
 * @returns {payload is undefined}
 */
function index_esm_isUndefined(payload) {
    return index_esm_getType(payload) === 'Undefined';
}
/**
 * Returns whether the payload is null
 *
 * @param {*} payload
 * @returns {payload is null}
 */
function index_esm_isNull(payload) {
    return index_esm_getType(payload) === 'Null';
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function index_esm_isPlainObject(payload) {
    if (index_esm_getType(payload) !== 'Object')
        return false;
    return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function index_esm_isObject(payload) {
    return index_esm_isPlainObject(payload);
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is { [K in any]: never }}
 */
function index_esm_isEmptyObject(payload) {
    return index_esm_isPlainObject(payload) && Object.keys(payload).length === 0;
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function index_esm_isFullObject(payload) {
    return index_esm_isPlainObject(payload) && Object.keys(payload).length > 0;
}
/**
 * Returns whether the payload is an any kind of object (including special classes or objects with different prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function index_esm_isAnyObject(payload) {
    return index_esm_getType(payload) === 'Object';
}
/**
 * Returns whether the payload is an object like a type passed in < >
 *
 * Usage: isObjectLike<{id: any}>(payload) // will make sure it's an object and has an `id` prop.
 *
 * @template T this must be passed in < >
 * @param {*} payload
 * @returns {payload is T}
 */
function index_esm_isObjectLike(payload) {
    return index_esm_isAnyObject(payload);
}
/**
 * Returns whether the payload is a function (regular or async)
 *
 * @param {*} payload
 * @returns {payload is AnyFunction}
 */
function index_esm_isFunction(payload) {
    return typeof payload === 'function';
}
/**
 * Returns whether the payload is an array
 *
 * @param {any} payload
 * @returns {payload is any[]}
 */
function index_esm_isArray(payload) {
    return index_esm_getType(payload) === 'Array';
}
/**
 * Returns whether the payload is a an array with at least 1 item
 *
 * @param {*} payload
 * @returns {payload is any[]}
 */
function index_esm_isFullArray(payload) {
    return index_esm_isArray(payload) && payload.length > 0;
}
/**
 * Returns whether the payload is a an empty array
 *
 * @param {*} payload
 * @returns {payload is []}
 */
function index_esm_isEmptyArray(payload) {
    return index_esm_isArray(payload) && payload.length === 0;
}
/**
 * Returns whether the payload is a string
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function index_esm_isString(payload) {
    return index_esm_getType(payload) === 'String';
}
/**
 * Returns whether the payload is a string, BUT returns false for ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function index_esm_isFullString(payload) {
    return index_esm_isString(payload) && payload !== '';
}
/**
 * Returns whether the payload is ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function index_esm_isEmptyString(payload) {
    return payload === '';
}
/**
 * Returns whether the payload is a number (but not NaN)
 *
 * This will return `false` for `NaN`!!
 *
 * @param {*} payload
 * @returns {payload is number}
 */
function index_esm_isNumber(payload) {
    return index_esm_getType(payload) === 'Number' && !isNaN(payload);
}
/**
 * Returns whether the payload is a boolean
 *
 * @param {*} payload
 * @returns {payload is boolean}
 */
function index_esm_isBoolean(payload) {
    return index_esm_getType(payload) === 'Boolean';
}
/**
 * Returns whether the payload is a regular expression (RegExp)
 *
 * @param {*} payload
 * @returns {payload is RegExp}
 */
function index_esm_isRegExp(payload) {
    return index_esm_getType(payload) === 'RegExp';
}
/**
 * Returns whether the payload is a Map
 *
 * @param {*} payload
 * @returns {payload is Map<any, any>}
 */
function index_esm_isMap(payload) {
    return index_esm_getType(payload) === 'Map';
}
/**
 * Returns whether the payload is a WeakMap
 *
 * @param {*} payload
 * @returns {payload is WeakMap<any, any>}
 */
function index_esm_isWeakMap(payload) {
    return index_esm_getType(payload) === 'WeakMap';
}
/**
 * Returns whether the payload is a Set
 *
 * @param {*} payload
 * @returns {payload is Set<any>}
 */
function index_esm_isSet(payload) {
    return index_esm_getType(payload) === 'Set';
}
/**
 * Returns whether the payload is a WeakSet
 *
 * @param {*} payload
 * @returns {payload is WeakSet<any>}
 */
function index_esm_isWeakSet(payload) {
    return index_esm_getType(payload) === 'WeakSet';
}
/**
 * Returns whether the payload is a Symbol
 *
 * @param {*} payload
 * @returns {payload is symbol}
 */
function index_esm_isSymbol(payload) {
    return index_esm_getType(payload) === 'Symbol';
}
/**
 * Returns whether the payload is a Date, and that the date is valid
 *
 * @param {*} payload
 * @returns {payload is Date}
 */
function index_esm_isDate(payload) {
    return index_esm_getType(payload) === 'Date' && !isNaN(payload);
}
/**
 * Returns whether the payload is a Blob
 *
 * @param {*} payload
 * @returns {payload is Blob}
 */
function index_esm_isBlob(payload) {
    return index_esm_getType(payload) === 'Blob';
}
/**
 * Returns whether the payload is a File
 *
 * @param {*} payload
 * @returns {payload is File}
 */
function index_esm_isFile(payload) {
    return index_esm_getType(payload) === 'File';
}
/**
 * Returns whether the payload is a Promise
 *
 * @param {*} payload
 * @returns {payload is Promise<any>}
 */
function index_esm_isPromise(payload) {
    return index_esm_getType(payload) === 'Promise';
}
/**
 * Returns whether the payload is an Error
 *
 * @param {*} payload
 * @returns {payload is Error}
 */
function index_esm_isError(payload) {
    return index_esm_getType(payload) === 'Error';
}
/**
 * Returns whether the payload is literally the value `NaN` (it's `NaN` and also a `number`)
 *
 * @param {*} payload
 * @returns {payload is typeof NaN}
 */
function index_esm_isNaNValue(payload) {
    return index_esm_getType(payload) === 'Number' && isNaN(payload);
}
/**
 * Returns whether the payload is a primitive type (eg. Boolean | Null | Undefined | Number | String | Symbol)
 *
 * @param {*} payload
 * @returns {(payload is boolean | null | undefined | number | string | symbol)}
 */
function index_esm_isPrimitive(payload) {
    return (index_esm_isBoolean(payload) ||
        index_esm_isNull(payload) ||
        index_esm_isUndefined(payload) ||
        index_esm_isNumber(payload) ||
        index_esm_isString(payload) ||
        index_esm_isSymbol(payload));
}
/**
 * Returns true whether the payload is null or undefined
 *
 * @param {*} payload
 * @returns {(payload is null | undefined)}
 */
var index_esm_isNullOrUndefined = index_esm_isOneOf(index_esm_isNull, index_esm_isUndefined);
function index_esm_isOneOf(a, b, c, d, e) {
    return function (value) {
        return a(value) || b(value) || (!!c && c(value)) || (!!d && d(value)) || (!!e && e(value));
    };
}
/**
 * Does a generic check to check that the given payload is of a given type.
 * In cases like Number, it will return true for NaN as NaN is a Number (thanks javascript!);
 * It will, however, differentiate between object and null
 *
 * @template T
 * @param {*} payload
 * @param {T} type
 * @throws {TypeError} Will throw type error if type is an invalid type
 * @returns {payload is T}
 */
function index_esm_isType(payload, type) {
    if (!(type instanceof Function)) {
        throw new TypeError('Type must be a function');
    }
    if (!Object.prototype.hasOwnProperty.call(type, 'prototype')) {
        throw new TypeError('Type is not a class');
    }
    // Classes usually have names (as functions usually have names)
    var name = type.name;
    return index_esm_getType(payload) === name || Boolean(payload && payload.constructor === type);
}



// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/nestify-anything/dist/index.esm.js


/**
 * creates an object from a path
 *
 * @param {string} path a.path.like.this
 * @param {unknown} payload the value to attach to the nested prop
 * @returns {Record<string, unknown>} eg. {a: {path: {like: {this: 'payload'}}}}
 * @export
 */
function createObjectFromPath(path, payload) {
    var _a;
    // edge cases
    if (!path.includes('.'))
        return _a = {}, _a[path] = payload, _a;
    // start
    var newValue = payload;
    // important to set the result here and not return the reduce directly!
    var result = {};
    path.match(/[^.]+/g).reduce(function (carry, _prop, index, array) {
        _prop = _prop.replace('_____dot_____', '.');
        var container = index === array.length - 1 ? newValue : {};
        carry[_prop] = container;
        return container;
    }, result);
    return result;
}
/**
 * Recreates an object from any `nested.props` in a passed target object.
 *
 * @param {Record<string, unknown>} payload object with flat prop paths - eg. {'size.h': 0, 'size.w': 0}
 * @returns {Record<string, unknown>} object with nested props - eg. {size: {h: 0, w: 0}}
 * @export
 */
function nestifyObject(payload) {
    return Object.entries(payload).reduce(function (carry, _a) {
        var key = _a[0], value = _a[1];
        var nestedObject = createObjectFromPath(key, value);
        return Object(index_esm["a" /* merge */])(carry, nestedObject);
    }, {});
}



// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/flatten-anything/node_modules/is-what/dist/index.esm.js
/**
 * Returns the object type of the given payload
 *
 * @param {*} payload
 * @returns {string}
 */
function dist_index_esm_getType(payload) {
    return Object.prototype.toString.call(payload).slice(8, -1);
}
/**
 * Returns whether the payload is undefined
 *
 * @param {*} payload
 * @returns {payload is undefined}
 */
function dist_index_esm_isUndefined(payload) {
    return dist_index_esm_getType(payload) === 'Undefined';
}
/**
 * Returns whether the payload is null
 *
 * @param {*} payload
 * @returns {payload is null}
 */
function dist_index_esm_isNull(payload) {
    return dist_index_esm_getType(payload) === 'Null';
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function dist_index_esm_isPlainObject(payload) {
    if (dist_index_esm_getType(payload) !== 'Object')
        return false;
    return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function dist_index_esm_isObject(payload) {
    return dist_index_esm_isPlainObject(payload);
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is { [K in any]: never }}
 */
function dist_index_esm_isEmptyObject(payload) {
    return dist_index_esm_isPlainObject(payload) && Object.keys(payload).length === 0;
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function dist_index_esm_isFullObject(payload) {
    return dist_index_esm_isPlainObject(payload) && Object.keys(payload).length > 0;
}
/**
 * Returns whether the payload is an any kind of object (including special classes or objects with different prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function dist_index_esm_isAnyObject(payload) {
    return dist_index_esm_getType(payload) === 'Object';
}
/**
 * Returns whether the payload is an object like a type passed in < >
 *
 * Usage: isObjectLike<{id: any}>(payload) // will make sure it's an object and has an `id` prop.
 *
 * @template T this must be passed in < >
 * @param {*} payload
 * @returns {payload is T}
 */
function dist_index_esm_isObjectLike(payload) {
    return dist_index_esm_isAnyObject(payload);
}
/**
 * Returns whether the payload is a function (regular or async)
 *
 * @param {*} payload
 * @returns {payload is AnyFunction}
 */
function dist_index_esm_isFunction(payload) {
    return typeof payload === 'function';
}
/**
 * Returns whether the payload is an array
 *
 * @param {any} payload
 * @returns {payload is any[]}
 */
function dist_index_esm_isArray(payload) {
    return dist_index_esm_getType(payload) === 'Array';
}
/**
 * Returns whether the payload is a an array with at least 1 item
 *
 * @param {*} payload
 * @returns {payload is any[]}
 */
function dist_index_esm_isFullArray(payload) {
    return dist_index_esm_isArray(payload) && payload.length > 0;
}
/**
 * Returns whether the payload is a an empty array
 *
 * @param {*} payload
 * @returns {payload is []}
 */
function dist_index_esm_isEmptyArray(payload) {
    return dist_index_esm_isArray(payload) && payload.length === 0;
}
/**
 * Returns whether the payload is a string
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function dist_index_esm_isString(payload) {
    return dist_index_esm_getType(payload) === 'String';
}
/**
 * Returns whether the payload is a string, BUT returns false for ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function dist_index_esm_isFullString(payload) {
    return dist_index_esm_isString(payload) && payload !== '';
}
/**
 * Returns whether the payload is ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function dist_index_esm_isEmptyString(payload) {
    return payload === '';
}
/**
 * Returns whether the payload is a number (but not NaN)
 *
 * This will return `false` for `NaN`!!
 *
 * @param {*} payload
 * @returns {payload is number}
 */
function dist_index_esm_isNumber(payload) {
    return dist_index_esm_getType(payload) === 'Number' && !isNaN(payload);
}
/**
 * Returns whether the payload is a boolean
 *
 * @param {*} payload
 * @returns {payload is boolean}
 */
function dist_index_esm_isBoolean(payload) {
    return dist_index_esm_getType(payload) === 'Boolean';
}
/**
 * Returns whether the payload is a regular expression (RegExp)
 *
 * @param {*} payload
 * @returns {payload is RegExp}
 */
function dist_index_esm_isRegExp(payload) {
    return dist_index_esm_getType(payload) === 'RegExp';
}
/**
 * Returns whether the payload is a Map
 *
 * @param {*} payload
 * @returns {payload is Map<any, any>}
 */
function dist_index_esm_isMap(payload) {
    return dist_index_esm_getType(payload) === 'Map';
}
/**
 * Returns whether the payload is a WeakMap
 *
 * @param {*} payload
 * @returns {payload is WeakMap<any, any>}
 */
function dist_index_esm_isWeakMap(payload) {
    return dist_index_esm_getType(payload) === 'WeakMap';
}
/**
 * Returns whether the payload is a Set
 *
 * @param {*} payload
 * @returns {payload is Set<any>}
 */
function dist_index_esm_isSet(payload) {
    return dist_index_esm_getType(payload) === 'Set';
}
/**
 * Returns whether the payload is a WeakSet
 *
 * @param {*} payload
 * @returns {payload is WeakSet<any>}
 */
function dist_index_esm_isWeakSet(payload) {
    return dist_index_esm_getType(payload) === 'WeakSet';
}
/**
 * Returns whether the payload is a Symbol
 *
 * @param {*} payload
 * @returns {payload is symbol}
 */
function dist_index_esm_isSymbol(payload) {
    return dist_index_esm_getType(payload) === 'Symbol';
}
/**
 * Returns whether the payload is a Date, and that the date is valid
 *
 * @param {*} payload
 * @returns {payload is Date}
 */
function dist_index_esm_isDate(payload) {
    return dist_index_esm_getType(payload) === 'Date' && !isNaN(payload);
}
/**
 * Returns whether the payload is a Blob
 *
 * @param {*} payload
 * @returns {payload is Blob}
 */
function dist_index_esm_isBlob(payload) {
    return dist_index_esm_getType(payload) === 'Blob';
}
/**
 * Returns whether the payload is a File
 *
 * @param {*} payload
 * @returns {payload is File}
 */
function dist_index_esm_isFile(payload) {
    return dist_index_esm_getType(payload) === 'File';
}
/**
 * Returns whether the payload is a Promise
 *
 * @param {*} payload
 * @returns {payload is Promise<any>}
 */
function dist_index_esm_isPromise(payload) {
    return dist_index_esm_getType(payload) === 'Promise';
}
/**
 * Returns whether the payload is an Error
 *
 * @param {*} payload
 * @returns {payload is Error}
 */
function dist_index_esm_isError(payload) {
    return dist_index_esm_getType(payload) === 'Error';
}
/**
 * Returns whether the payload is literally the value `NaN` (it's `NaN` and also a `number`)
 *
 * @param {*} payload
 * @returns {payload is typeof NaN}
 */
function dist_index_esm_isNaNValue(payload) {
    return dist_index_esm_getType(payload) === 'Number' && isNaN(payload);
}
/**
 * Returns whether the payload is a primitive type (eg. Boolean | Null | Undefined | Number | String | Symbol)
 *
 * @param {*} payload
 * @returns {(payload is boolean | null | undefined | number | string | symbol)}
 */
function dist_index_esm_isPrimitive(payload) {
    return (dist_index_esm_isBoolean(payload) ||
        dist_index_esm_isNull(payload) ||
        dist_index_esm_isUndefined(payload) ||
        dist_index_esm_isNumber(payload) ||
        dist_index_esm_isString(payload) ||
        dist_index_esm_isSymbol(payload));
}
/**
 * Returns true whether the payload is null or undefined
 *
 * @param {*} payload
 * @returns {(payload is null | undefined)}
 */
var dist_index_esm_isNullOrUndefined = dist_index_esm_isOneOf(dist_index_esm_isNull, dist_index_esm_isUndefined);
function dist_index_esm_isOneOf(a, b, c, d, e) {
    return function (value) {
        return a(value) || b(value) || (!!c && c(value)) || (!!d && d(value)) || (!!e && e(value));
    };
}
/**
 * Does a generic check to check that the given payload is of a given type.
 * In cases like Number, it will return true for NaN as NaN is a Number (thanks javascript!);
 * It will, however, differentiate between object and null
 *
 * @template T
 * @param {*} payload
 * @param {T} type
 * @throws {TypeError} Will throw type error if type is an invalid type
 * @returns {payload is T}
 */
function dist_index_esm_isType(payload, type) {
    if (!(type instanceof Function)) {
        throw new TypeError('Type must be a function');
    }
    if (!Object.prototype.hasOwnProperty.call(type, 'prototype')) {
        throw new TypeError('Type is not a class');
    }
    // Classes usually have names (as functions usually have names)
    var name = type.name;
    return dist_index_esm_getType(payload) === name || Boolean(payload && payload.constructor === type);
}



// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/filter-anything/node_modules/is-what/dist/index.esm.js
/**
 * Returns the object type of the given payload
 *
 * @param {*} payload
 * @returns {string}
 */
function is_what_dist_index_esm_getType(payload) {
    return Object.prototype.toString.call(payload).slice(8, -1);
}
/**
 * Returns whether the payload is undefined
 *
 * @param {*} payload
 * @returns {payload is undefined}
 */
function is_what_dist_index_esm_isUndefined(payload) {
    return is_what_dist_index_esm_getType(payload) === 'Undefined';
}
/**
 * Returns whether the payload is null
 *
 * @param {*} payload
 * @returns {payload is null}
 */
function is_what_dist_index_esm_isNull(payload) {
    return is_what_dist_index_esm_getType(payload) === 'Null';
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function is_what_dist_index_esm_isPlainObject(payload) {
    if (is_what_dist_index_esm_getType(payload) !== 'Object')
        return false;
    return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function is_what_dist_index_esm_isObject(payload) {
    return is_what_dist_index_esm_isPlainObject(payload);
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is { [K in any]: never }}
 */
function is_what_dist_index_esm_isEmptyObject(payload) {
    return is_what_dist_index_esm_isPlainObject(payload) && Object.keys(payload).length === 0;
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function is_what_dist_index_esm_isFullObject(payload) {
    return is_what_dist_index_esm_isPlainObject(payload) && Object.keys(payload).length > 0;
}
/**
 * Returns whether the payload is an any kind of object (including special classes or objects with different prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function is_what_dist_index_esm_isAnyObject(payload) {
    return is_what_dist_index_esm_getType(payload) === 'Object';
}
/**
 * Returns whether the payload is an object like a type passed in < >
 *
 * Usage: isObjectLike<{id: any}>(payload) // will make sure it's an object and has an `id` prop.
 *
 * @template T this must be passed in < >
 * @param {*} payload
 * @returns {payload is T}
 */
function is_what_dist_index_esm_isObjectLike(payload) {
    return is_what_dist_index_esm_isAnyObject(payload);
}
/**
 * Returns whether the payload is a function (regular or async)
 *
 * @param {*} payload
 * @returns {payload is AnyFunction}
 */
function is_what_dist_index_esm_isFunction(payload) {
    return typeof payload === 'function';
}
/**
 * Returns whether the payload is an array
 *
 * @param {any} payload
 * @returns {payload is any[]}
 */
function is_what_dist_index_esm_isArray(payload) {
    return is_what_dist_index_esm_getType(payload) === 'Array';
}
/**
 * Returns whether the payload is a an array with at least 1 item
 *
 * @param {*} payload
 * @returns {payload is any[]}
 */
function is_what_dist_index_esm_isFullArray(payload) {
    return is_what_dist_index_esm_isArray(payload) && payload.length > 0;
}
/**
 * Returns whether the payload is a an empty array
 *
 * @param {*} payload
 * @returns {payload is []}
 */
function is_what_dist_index_esm_isEmptyArray(payload) {
    return is_what_dist_index_esm_isArray(payload) && payload.length === 0;
}
/**
 * Returns whether the payload is a string
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function is_what_dist_index_esm_isString(payload) {
    return is_what_dist_index_esm_getType(payload) === 'String';
}
/**
 * Returns whether the payload is a string, BUT returns false for ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function is_what_dist_index_esm_isFullString(payload) {
    return is_what_dist_index_esm_isString(payload) && payload !== '';
}
/**
 * Returns whether the payload is ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function is_what_dist_index_esm_isEmptyString(payload) {
    return payload === '';
}
/**
 * Returns whether the payload is a number (but not NaN)
 *
 * This will return `false` for `NaN`!!
 *
 * @param {*} payload
 * @returns {payload is number}
 */
function is_what_dist_index_esm_isNumber(payload) {
    return is_what_dist_index_esm_getType(payload) === 'Number' && !isNaN(payload);
}
/**
 * Returns whether the payload is a boolean
 *
 * @param {*} payload
 * @returns {payload is boolean}
 */
function is_what_dist_index_esm_isBoolean(payload) {
    return is_what_dist_index_esm_getType(payload) === 'Boolean';
}
/**
 * Returns whether the payload is a regular expression (RegExp)
 *
 * @param {*} payload
 * @returns {payload is RegExp}
 */
function is_what_dist_index_esm_isRegExp(payload) {
    return is_what_dist_index_esm_getType(payload) === 'RegExp';
}
/**
 * Returns whether the payload is a Map
 *
 * @param {*} payload
 * @returns {payload is Map<any, any>}
 */
function is_what_dist_index_esm_isMap(payload) {
    return is_what_dist_index_esm_getType(payload) === 'Map';
}
/**
 * Returns whether the payload is a WeakMap
 *
 * @param {*} payload
 * @returns {payload is WeakMap<any, any>}
 */
function is_what_dist_index_esm_isWeakMap(payload) {
    return is_what_dist_index_esm_getType(payload) === 'WeakMap';
}
/**
 * Returns whether the payload is a Set
 *
 * @param {*} payload
 * @returns {payload is Set<any>}
 */
function is_what_dist_index_esm_isSet(payload) {
    return is_what_dist_index_esm_getType(payload) === 'Set';
}
/**
 * Returns whether the payload is a WeakSet
 *
 * @param {*} payload
 * @returns {payload is WeakSet<any>}
 */
function is_what_dist_index_esm_isWeakSet(payload) {
    return is_what_dist_index_esm_getType(payload) === 'WeakSet';
}
/**
 * Returns whether the payload is a Symbol
 *
 * @param {*} payload
 * @returns {payload is symbol}
 */
function is_what_dist_index_esm_isSymbol(payload) {
    return is_what_dist_index_esm_getType(payload) === 'Symbol';
}
/**
 * Returns whether the payload is a Date, and that the date is valid
 *
 * @param {*} payload
 * @returns {payload is Date}
 */
function is_what_dist_index_esm_isDate(payload) {
    return is_what_dist_index_esm_getType(payload) === 'Date' && !isNaN(payload);
}
/**
 * Returns whether the payload is a Blob
 *
 * @param {*} payload
 * @returns {payload is Blob}
 */
function is_what_dist_index_esm_isBlob(payload) {
    return is_what_dist_index_esm_getType(payload) === 'Blob';
}
/**
 * Returns whether the payload is a File
 *
 * @param {*} payload
 * @returns {payload is File}
 */
function is_what_dist_index_esm_isFile(payload) {
    return is_what_dist_index_esm_getType(payload) === 'File';
}
/**
 * Returns whether the payload is a Promise
 *
 * @param {*} payload
 * @returns {payload is Promise<any>}
 */
function is_what_dist_index_esm_isPromise(payload) {
    return is_what_dist_index_esm_getType(payload) === 'Promise';
}
/**
 * Returns whether the payload is an Error
 *
 * @param {*} payload
 * @returns {payload is Error}
 */
function is_what_dist_index_esm_isError(payload) {
    return is_what_dist_index_esm_getType(payload) === 'Error';
}
/**
 * Returns whether the payload is literally the value `NaN` (it's `NaN` and also a `number`)
 *
 * @param {*} payload
 * @returns {payload is typeof NaN}
 */
function is_what_dist_index_esm_isNaNValue(payload) {
    return is_what_dist_index_esm_getType(payload) === 'Number' && isNaN(payload);
}
/**
 * Returns whether the payload is a primitive type (eg. Boolean | Null | Undefined | Number | String | Symbol)
 *
 * @param {*} payload
 * @returns {(payload is boolean | null | undefined | number | string | symbol)}
 */
function is_what_dist_index_esm_isPrimitive(payload) {
    return (is_what_dist_index_esm_isBoolean(payload) ||
        is_what_dist_index_esm_isNull(payload) ||
        is_what_dist_index_esm_isUndefined(payload) ||
        is_what_dist_index_esm_isNumber(payload) ||
        is_what_dist_index_esm_isString(payload) ||
        is_what_dist_index_esm_isSymbol(payload));
}
/**
 * Returns true whether the payload is null or undefined
 *
 * @param {*} payload
 * @returns {(payload is null | undefined)}
 */
var is_what_dist_index_esm_isNullOrUndefined = is_what_dist_index_esm_isOneOf(is_what_dist_index_esm_isNull, is_what_dist_index_esm_isUndefined);
function is_what_dist_index_esm_isOneOf(a, b, c, d, e) {
    return function (value) {
        return a(value) || b(value) || (!!c && c(value)) || (!!d && d(value)) || (!!e && e(value));
    };
}
/**
 * Does a generic check to check that the given payload is of a given type.
 * In cases like Number, it will return true for NaN as NaN is a Number (thanks javascript!);
 * It will, however, differentiate between object and null
 *
 * @template T
 * @param {*} payload
 * @param {T} type
 * @throws {TypeError} Will throw type error if type is an invalid type
 * @returns {payload is T}
 */
function is_what_dist_index_esm_isType(payload, type) {
    if (!(type instanceof Function)) {
        throw new TypeError('Type must be a function');
    }
    if (!Object.prototype.hasOwnProperty.call(type, 'prototype')) {
        throw new TypeError('Type is not a class');
    }
    // Classes usually have names (as functions usually have names)
    var name = type.name;
    return is_what_dist_index_esm_getType(payload) === name || Boolean(payload && payload.constructor === type);
}



// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/filter-anything/dist/index.esm.js


function pathsAreEqual(path, wildcardPath) {
    var wildcardPathPieces = wildcardPath.split('.');
    var pathWithWildcards = path
        .split('.')
        .reduce(function (carry, piece, index) {
        var add = wildcardPathPieces[index] === '*' ? '*' : piece;
        carry.push(add);
        return carry;
    }, [])
        .join('.');
    return pathWithWildcards === wildcardPath;
}

function recursiveOmit(obj, omittedKeys, pathUntilNow) {
    if (pathUntilNow === void 0) { pathUntilNow = ''; }
    if (!is_what_dist_index_esm_isPlainObject(obj)) {
        return obj;
    }
    return Object.entries(obj).reduce(function (carry, _a) {
        var key = _a[0], value = _a[1];
        var path = pathUntilNow;
        if (path)
            path += '.';
        path += key;
        if (omittedKeys.some(function (guardPath) { return pathsAreEqual(path, guardPath); })) {
            return carry;
        }
        // no further recursion needed
        if (!is_what_dist_index_esm_isPlainObject(value)) {
            carry[key] = value;
            return carry;
        }
        carry[key] = recursiveOmit(obj[key], omittedKeys, path);
        return carry;
    }, {});
}

function recursivePick(obj, pickedKeys, pathUntilNow) {
    if (pathUntilNow === void 0) { pathUntilNow = ''; }
    if (!is_what_dist_index_esm_isPlainObject(obj)) {
        return obj;
    }
    return Object.entries(obj).reduce(function (carry, _a) {
        var key = _a[0], value = _a[1];
        var path = pathUntilNow;
        if (path)
            path += '.';
        path += key;
        // check pickedKeys up to this point
        if (pickedKeys.length) {
            var passed_1 = false;
            pickedKeys.forEach(function (pickedKey) {
                var pathDepth = path.split('.').length;
                var pickedKeyDepth = pickedKey.split('.').length;
                var pickedKeyUpToNow = pickedKey.split('.').slice(0, pathDepth).join('.');
                var pathUpToPickedKeyDepth = path.split('.').slice(0, pickedKeyDepth).join('.');
                if (pathsAreEqual(pathUpToPickedKeyDepth, pickedKeyUpToNow))
                    passed_1 = true;
            });
            // there's not one pickedKey that allows up to now
            if (!passed_1)
                return carry;
        }
        // no further recursion needed
        if (!is_what_dist_index_esm_isPlainObject(value)) {
            carry[key] = value;
            return carry;
        }
        carry[key] = recursivePick(obj[key], pickedKeys, path);
        return carry;
    }, {});
}

/**
 * pick returns a new object with only the props you pick
 *
 * @export
 * @template T
 * @template K
 * @param {T} obj the target object to pick props from
 * @param {K[]} keys an array of prop names you want to keep - allows dot-notation for nested props, eg. `nested.prop` will keep just `{ nested: { prop: 1 } }`
 * @returns {O.Pick<T, K>} a new object with just the picked props
 */
function pick(obj, keys) {
    if (!is_what_dist_index_esm_isFullArray(keys))
        return {};
    return recursivePick(obj, keys);
}
var fillable = pick;
/**
 * omit returns a new object without the props you omit
 *
 * @export
 * @template T
 * @template K
 * @param {T} obj the target object to omit props from
 * @param {K[]} keys the prop names you want to omit
 * @returns {O.Omit<T, K>} a new object without the omitted props
 */
function omit(obj, keys) {
    if (!is_what_dist_index_esm_isFullArray(keys))
        return obj;
    return recursiveOmit(obj, keys);
}
var guard = omit;



// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/flatten-anything/dist/index.esm.js



/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function retrievePaths(object, path, result, untilDepth) {
    if (!dist_index_esm_isPlainObject(object) ||
        !Object.keys(object).length ||
        object.methodName === 'FieldValue.serverTimestamp') {
        if (!path)
            return object;
        result[path] = object;
        return result;
    }
    if (dist_index_esm_isNumber(untilDepth))
        untilDepth--;
    return Object.keys(object).reduce(function (carry, key) {
        var _a;
        var pathUntilNow = path ? path + '.' : '';
        var newPath = pathUntilNow + key;
        // last iteration or not
        var extra = untilDepth === -1
            ? (_a = {}, _a[newPath] = object[key], _a) : retrievePaths(object[key], newPath, result, untilDepth);
        return Object.assign(carry, extra);
    }, {});
}
/**
 * Flattens an object from `{a: {b: {c: 'd'}}}` to `{'a.b.c': 'd'}`
 *
 * @export
 * @param {Record<string, any>} object the object to flatten
 * @param {untilDepth} [number] how deep you want to flatten. 1 for flattening only the first nested prop, and keeping deeper objects as is.
 * @returns {Record<string, any>} the flattened object
 */
function flattenObject(object, untilDepth) {
    var result = {};
    return retrievePaths(object, null, result, untilDepth);
}
/**
 * Flattens an array from `[1, ['a', ['z']], 2]` to `[1, 'a', 'z', 2]`
 *
 * @export
 * @param {any[]} array the array to flatten
 * @returns {any[]} the flattened array
 */
function flattenArray(array) {
    return array.reduce(function (carry, item) {
        return dist_index_esm_isArray(item) ? __spread(carry, flattenArray(item)) : __spread(carry, [item]);
    }, []);
}
/**
 * Flattens certain props of an object.
 *
 * @export
 * @param {Record<string, any>} object the object to flatten Eg. `{a: {subA: 1}, b: {subB: 1}}`
 * @param {string[]} [props=[]] the prop names you want to flatten. Eg. `['a']` will return `{'a.subA': 1, b: {subB: 1}}`
 * @returns {Record<string, any>} the flattened object
 */
function flattenObjectProps(object, props) {
    if (props === void 0) { props = []; }
    var flatObject = props.reduce(function (carry, propPath) {
        var _a;
        var firstPropKey = propPath.split('.')[0];
        var target = (_a = {}, _a[firstPropKey] = object[firstPropKey], _a);
        // calculate a certain depth to flatten or `null` to flatten everything
        var untilDepth = propPath.split('.').length - 1 || null;
        var flatPart = flattenObject(target, untilDepth);
        var flatPartFiltered = Object.entries(flatPart).reduce(function (carry, _a) {
            var _b = __read(_a, 2), key = _b[0], value = _b[1];
            if (!key.startsWith(propPath))
                return carry;
            carry[key] = value;
            return carry;
        }, {});
        return __assign(__assign({}, carry), flatPartFiltered);
    }, {});
    var omittedProps = props;
    var objectWithoutFlatProps = omit(object, omittedProps);
    return __assign(__assign({}, objectWithoutFlatProps), flatObject);
}
/**
 * Flattens an object or array.
 * Object example: `{a: {b: {c: 'd'}}}` to `{'a.b.c': 'd'}`
 * Array example: `[1, ['a', ['z']], 2]` to `[1, 'a', 'z', 2]`
 *
 * @export
 * @param {(Record<string, any> | any[])} objectOrArray the payload to flatten
 * @param {untilDepth} [number] how deep you want to flatten. (currently only works with objects) 1 for flattening only the first nested prop, and keeping deeper objects as is.
 * @returns {(Record<string, any> | any[])} the flattened result
 */
function flatten(objectOrArray, untilDepth) {
    return dist_index_esm_isArray(objectOrArray)
        ? flattenArray(objectOrArray)
        : flattenObject(objectOrArray, untilDepth);
}



// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/utils/node_modules/is-what/dist/index.esm.js
/**
 * Returns the object type of the given payload
 *
 * @param {*} payload
 * @returns {string}
 */
function node_modules_is_what_dist_index_esm_getType(payload) {
    return Object.prototype.toString.call(payload).slice(8, -1);
}
/**
 * Returns whether the payload is undefined
 *
 * @param {*} payload
 * @returns {payload is undefined}
 */
function node_modules_is_what_dist_index_esm_isUndefined(payload) {
    return node_modules_is_what_dist_index_esm_getType(payload) === 'Undefined';
}
/**
 * Returns whether the payload is null
 *
 * @param {*} payload
 * @returns {payload is null}
 */
function node_modules_is_what_dist_index_esm_isNull(payload) {
    return node_modules_is_what_dist_index_esm_getType(payload) === 'Null';
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function node_modules_is_what_dist_index_esm_isPlainObject(payload) {
    if (node_modules_is_what_dist_index_esm_getType(payload) !== 'Object')
        return false;
    return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function node_modules_is_what_dist_index_esm_isObject(payload) {
    return node_modules_is_what_dist_index_esm_isPlainObject(payload);
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is { [K in any]: never }}
 */
function node_modules_is_what_dist_index_esm_isEmptyObject(payload) {
    return node_modules_is_what_dist_index_esm_isPlainObject(payload) && Object.keys(payload).length === 0;
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function node_modules_is_what_dist_index_esm_isFullObject(payload) {
    return node_modules_is_what_dist_index_esm_isPlainObject(payload) && Object.keys(payload).length > 0;
}
/**
 * Returns whether the payload is an any kind of object (including special classes or objects with different prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function node_modules_is_what_dist_index_esm_isAnyObject(payload) {
    return node_modules_is_what_dist_index_esm_getType(payload) === 'Object';
}
/**
 * Returns whether the payload is an object like a type passed in < >
 *
 * Usage: isObjectLike<{id: any}>(payload) // will make sure it's an object and has an `id` prop.
 *
 * @template T this must be passed in < >
 * @param {*} payload
 * @returns {payload is T}
 */
function node_modules_is_what_dist_index_esm_isObjectLike(payload) {
    return node_modules_is_what_dist_index_esm_isAnyObject(payload);
}
/**
 * Returns whether the payload is a function (regular or async)
 *
 * @param {*} payload
 * @returns {payload is AnyFunction}
 */
function node_modules_is_what_dist_index_esm_isFunction(payload) {
    return typeof payload === 'function';
}
/**
 * Returns whether the payload is an array
 *
 * @param {any} payload
 * @returns {payload is any[]}
 */
function node_modules_is_what_dist_index_esm_isArray(payload) {
    return node_modules_is_what_dist_index_esm_getType(payload) === 'Array';
}
/**
 * Returns whether the payload is a an array with at least 1 item
 *
 * @param {*} payload
 * @returns {payload is any[]}
 */
function node_modules_is_what_dist_index_esm_isFullArray(payload) {
    return node_modules_is_what_dist_index_esm_isArray(payload) && payload.length > 0;
}
/**
 * Returns whether the payload is a an empty array
 *
 * @param {*} payload
 * @returns {payload is []}
 */
function node_modules_is_what_dist_index_esm_isEmptyArray(payload) {
    return node_modules_is_what_dist_index_esm_isArray(payload) && payload.length === 0;
}
/**
 * Returns whether the payload is a string
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function node_modules_is_what_dist_index_esm_isString(payload) {
    return node_modules_is_what_dist_index_esm_getType(payload) === 'String';
}
/**
 * Returns whether the payload is a string, BUT returns false for ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function node_modules_is_what_dist_index_esm_isFullString(payload) {
    return node_modules_is_what_dist_index_esm_isString(payload) && payload !== '';
}
/**
 * Returns whether the payload is ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function node_modules_is_what_dist_index_esm_isEmptyString(payload) {
    return payload === '';
}
/**
 * Returns whether the payload is a number (but not NaN)
 *
 * This will return `false` for `NaN`!!
 *
 * @param {*} payload
 * @returns {payload is number}
 */
function node_modules_is_what_dist_index_esm_isNumber(payload) {
    return node_modules_is_what_dist_index_esm_getType(payload) === 'Number' && !isNaN(payload);
}
/**
 * Returns whether the payload is a boolean
 *
 * @param {*} payload
 * @returns {payload is boolean}
 */
function node_modules_is_what_dist_index_esm_isBoolean(payload) {
    return node_modules_is_what_dist_index_esm_getType(payload) === 'Boolean';
}
/**
 * Returns whether the payload is a regular expression (RegExp)
 *
 * @param {*} payload
 * @returns {payload is RegExp}
 */
function node_modules_is_what_dist_index_esm_isRegExp(payload) {
    return node_modules_is_what_dist_index_esm_getType(payload) === 'RegExp';
}
/**
 * Returns whether the payload is a Map
 *
 * @param {*} payload
 * @returns {payload is Map<any, any>}
 */
function node_modules_is_what_dist_index_esm_isMap(payload) {
    return node_modules_is_what_dist_index_esm_getType(payload) === 'Map';
}
/**
 * Returns whether the payload is a WeakMap
 *
 * @param {*} payload
 * @returns {payload is WeakMap<any, any>}
 */
function node_modules_is_what_dist_index_esm_isWeakMap(payload) {
    return node_modules_is_what_dist_index_esm_getType(payload) === 'WeakMap';
}
/**
 * Returns whether the payload is a Set
 *
 * @param {*} payload
 * @returns {payload is Set<any>}
 */
function node_modules_is_what_dist_index_esm_isSet(payload) {
    return node_modules_is_what_dist_index_esm_getType(payload) === 'Set';
}
/**
 * Returns whether the payload is a WeakSet
 *
 * @param {*} payload
 * @returns {payload is WeakSet<any>}
 */
function node_modules_is_what_dist_index_esm_isWeakSet(payload) {
    return node_modules_is_what_dist_index_esm_getType(payload) === 'WeakSet';
}
/**
 * Returns whether the payload is a Symbol
 *
 * @param {*} payload
 * @returns {payload is symbol}
 */
function node_modules_is_what_dist_index_esm_isSymbol(payload) {
    return node_modules_is_what_dist_index_esm_getType(payload) === 'Symbol';
}
/**
 * Returns whether the payload is a Date, and that the date is valid
 *
 * @param {*} payload
 * @returns {payload is Date}
 */
function node_modules_is_what_dist_index_esm_isDate(payload) {
    return node_modules_is_what_dist_index_esm_getType(payload) === 'Date' && !isNaN(payload);
}
/**
 * Returns whether the payload is a Blob
 *
 * @param {*} payload
 * @returns {payload is Blob}
 */
function node_modules_is_what_dist_index_esm_isBlob(payload) {
    return node_modules_is_what_dist_index_esm_getType(payload) === 'Blob';
}
/**
 * Returns whether the payload is a File
 *
 * @param {*} payload
 * @returns {payload is File}
 */
function node_modules_is_what_dist_index_esm_isFile(payload) {
    return node_modules_is_what_dist_index_esm_getType(payload) === 'File';
}
/**
 * Returns whether the payload is a Promise
 *
 * @param {*} payload
 * @returns {payload is Promise<any>}
 */
function node_modules_is_what_dist_index_esm_isPromise(payload) {
    return node_modules_is_what_dist_index_esm_getType(payload) === 'Promise';
}
/**
 * Returns whether the payload is an Error
 *
 * @param {*} payload
 * @returns {payload is Error}
 */
function node_modules_is_what_dist_index_esm_isError(payload) {
    return node_modules_is_what_dist_index_esm_getType(payload) === 'Error';
}
/**
 * Returns whether the payload is literally the value `NaN` (it's `NaN` and also a `number`)
 *
 * @param {*} payload
 * @returns {payload is typeof NaN}
 */
function node_modules_is_what_dist_index_esm_isNaNValue(payload) {
    return node_modules_is_what_dist_index_esm_getType(payload) === 'Number' && isNaN(payload);
}
/**
 * Returns whether the payload is a primitive type (eg. Boolean | Null | Undefined | Number | String | Symbol)
 *
 * @param {*} payload
 * @returns {(payload is boolean | null | undefined | number | string | symbol)}
 */
function node_modules_is_what_dist_index_esm_isPrimitive(payload) {
    return (node_modules_is_what_dist_index_esm_isBoolean(payload) ||
        node_modules_is_what_dist_index_esm_isNull(payload) ||
        node_modules_is_what_dist_index_esm_isUndefined(payload) ||
        node_modules_is_what_dist_index_esm_isNumber(payload) ||
        node_modules_is_what_dist_index_esm_isString(payload) ||
        node_modules_is_what_dist_index_esm_isSymbol(payload));
}
/**
 * Returns true whether the payload is null or undefined
 *
 * @param {*} payload
 * @returns {(payload is null | undefined)}
 */
var node_modules_is_what_dist_index_esm_isNullOrUndefined = node_modules_is_what_dist_index_esm_isOneOf(node_modules_is_what_dist_index_esm_isNull, node_modules_is_what_dist_index_esm_isUndefined);
function node_modules_is_what_dist_index_esm_isOneOf(a, b, c, d, e) {
    return function (value) {
        return a(value) || b(value) || (!!c && c(value)) || (!!d && d(value)) || (!!e && e(value));
    };
}
/**
 * Does a generic check to check that the given payload is of a given type.
 * In cases like Number, it will return true for NaN as NaN is a Number (thanks javascript!);
 * It will, however, differentiate between object and null
 *
 * @template T
 * @param {*} payload
 * @param {T} type
 * @throws {TypeError} Will throw type error if type is an invalid type
 * @returns {payload is T}
 */
function node_modules_is_what_dist_index_esm_isType(payload, type) {
    if (!(type instanceof Function)) {
        throw new TypeError('Type must be a function');
    }
    if (!Object.prototype.hasOwnProperty.call(type, 'prototype')) {
        throw new TypeError('Type is not a class');
    }
    // Classes usually have names (as functions usually have names)
    var name = type.name;
    return node_modules_is_what_dist_index_esm_getType(payload) === name || Boolean(payload && payload.constructor === type);
}



// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/commafy-anything/dist/index.esm.js
/**
 * Adds comma's to a number
 *
 * @export
 * @param {(string | number)} num the number to commafy
 * @param {{ stripDecimals?: boolean, spacedDecimals?: boolean, thousandsComma?: boolean, K?: boolean }} [options] By default thousandsComma is enabled, if disabled it shows `1000` without comma (but `10,000` with)
 * @returns {string} eg. '1,000,000'
 */
function commafy(num, options) {
    var _a = options || {}, _b = _a.stripDecimals, stripDecimals = _b === void 0 ? false : _b, _c = _a.spacedDecimals, spacedDecimals = _c === void 0 ? false : _c, _d = _a.thousandsComma, thousandsComma = _d === void 0 ? true : _d, _e = _a.K, K = _e === void 0 ? false : _e;
    var _f = num.toString().split('.'), wholeNrStr = _f[0], _g = _f[1], decimalStr = _g === void 0 ? '' : _g;
    var str = [wholeNrStr, decimalStr];
    var minLength = thousandsComma ? 4 : 5;
    if (!K && wholeNrStr.length >= minLength) {
        str[0] = wholeNrStr.replace(/(\d)(?=(\d{3})+$)/g, '$1,');
    }
    if (K && wholeNrStr.length > 3) {
        var numInK = Math.round(num / 1000);
        var commafied = numInK.toString().replace(/(\d)(?=(\d{3})+$)/g, '$1,');
        str[0] = commafied + 'K';
    }
    if (stripDecimals || !decimalStr || K)
        return str[0];
    if (spacedDecimals && decimalStr.length >= minLength) {
        str[1] = decimalStr.replace(/(\d{3})/g, '$1 ').trim();
    }
    return str.join('.');
}



// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/utils/dist/index.esm.js




/**
 * Flattens an object to be in line with a schema.
 *
 * @export
 * @param {Record<string, any>} target the target object
 * @param {Record<string, any> | (Record<string, any>[])} schema
 * @returns {Record<string, any>}
 */
function flattenPerSchema(target, schema) {
    const schemaArray = node_modules_is_what_dist_index_esm_isArray(schema) ? schema : Object.values(schema);
    const schemaNestedIds = schemaArray
        .map((blueprint) => blueprint.id)
        .filter((id) => id && id.includes('.'));
    return flattenObjectProps(target, schemaNestedIds);
}

/**
 * takes a value and returns the parsed value based on a BlitzField blueprint provided.
 *
 * @export
 * @param {*} value any value. In our example blueprint `1` should be returned as `'one'`
 * @param {Record<string, any>} blueprint a blueprint like eg.
 *     - `{options: [{value: 1, label: 'one'}]}` out of which the "label" will be retrieved.
 *     - Besides `options` you can also have `prefix` and `suffix`.
 *     - When `valueType: 'date'` and the value is a `Date` type, it will be printed as toLocaleDateString().
 *     - When `valueType: 'number'` it will receive thousand separators.
 * @returns {*} the parsed value
 */
function parseFieldValue(value, blueprint) {
    if (!blueprint)
        return value;
    const { valueType, options, multiple, suffix, prefix, slot, slots, component } = blueprint;
    const valueArray = !node_modules_is_what_dist_index_esm_isArray(value) ? [value] : value;
    const newValue = valueArray.map((val) => {
        var _a;
        let newVal = val;
        // special handling for HTML5 'select' fields:
        const isHtml5SelectField = component === 'select' && (node_modules_is_what_dist_index_esm_isArray(slot) || node_modules_is_what_dist_index_esm_isArray(slots === null || slots === void 0 ? void 0 : slots.default));
        const selectOptions = isHtml5SelectField ? slot || (slots === null || slots === void 0 ? void 0 : slots.default) : options;
        if (node_modules_is_what_dist_index_esm_isArray(selectOptions)) {
            if (valueType === 'object' && node_modules_is_what_dist_index_esm_isPlainObject(value)) {
                newVal = multiple
                    ? Object.values(value)
                        .filter((v) => v)
                        .join(', ')
                    : value.label;
            }
            else {
                if (node_modules_is_what_dist_index_esm_isPlainObject(val)) {
                    newVal = val.label;
                }
                else {
                    const option = selectOptions.find((o) => o.value === val) || {};
                    newVal = option.label || option.slot || ((_a = option.slots) === null || _a === void 0 ? void 0 : _a.default) || val;
                }
            }
        }
        if (valueType === 'date' && node_modules_is_what_dist_index_esm_isDate(value))
            newVal = value.toLocaleDateString();
        if (valueType === 'number' && node_modules_is_what_dist_index_esm_isNumber(value))
            newVal = commafy(newVal);
        if (suffix)
            newVal = `${newVal}${suffix}`;
        if (prefix)
            newVal = `${prefix}${newVal}`;
        return newVal;
    });
    return newValue.join(', ');
}



// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/meta/lang.js
// when changing the default, do it for both BlitzForm; BlitzField and lang.js
var defaultLang = function defaultLang() {
  return {
    archive: 'Archive',
    delete: 'Delete',
    cancel: 'Cancel',
    edit: 'Edit',
    save: 'Save',
    requiredField: 'Field is required',
    formValidationError: 'There are remaining errors.'
  };
};
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/helpers/validation.js
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }




function createRequiredRule(requiredFieldErrorMsg) {
  return function (val) {
    return val === 0 || !!val || requiredFieldErrorMsg;
  };
}
/**
 * @typedef ValidationResultField
 * @type {boolean | (string | boolean)[]}
 */

/**
 * @typedef ValidationResultForm
 * @type {{ [fieldId: string]: ValidationResultField }}
 */

/**
 * Validates a field data based on its blueprint
 *
 * @export
 * @param {*} payload
 * @param {Blueprint} { rules = [], required }
 * @param {Context} context
 * @returns {ValidationResultField}
 */

function validateFieldPerSchema(payload, _ref) {
  var _ref$rules = _ref.rules,
      rules = _ref$rules === void 0 ? [] : _ref$rules,
      required = _ref.required;
  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var lang = context.lang || defaultLang();
  var rulesEvaluated = !index_esm_isFunction(rules) ? rules : rules(payload, context);
  var requiredEvaluated = !index_esm_isFunction(required) ? required : required(payload, context);
  var requiredRule = createRequiredRule(lang.requiredField);
  var rulesToTest = !requiredEvaluated ? rulesEvaluated : [requiredRule].concat(_toConsumableArray(rulesEvaluated));
  var results = rulesToTest.reduce(function (carry, rule) {
    carry.push(rule(payload));
    return carry;
  }, []);
  var hasAnError = Object.values(results).some(function (result) {
    return result !== true;
  });
  return !hasAnError || results;
}
/**
 * Validates a form data based on its schema
 *
 * @export
 * @param {PlainObject} formData the form data in an object that looks like: `{[fieldId: string]: any}`
 * @param {Schema} schema
 * @param {StringObject} lang the lang object with at least the key `requiredField` used as error message for required fields
 * @returns {ValidationResultForm}
 */

function validateFormPerSchema(formData, schema, lang) {
  var schemaObject = !index_esm_isArray(schema) ? schema : schema.reduce(function (carry, blueprint) {
    carry[blueprint.id] = blueprint;
    return carry;
  }, {});
  var formDataFlatEmpty = Object.keys(schemaObject).reduce(function (carry, key) {
    return Object.assign({}, carry, _defineProperty({}, key, null));
  }, {}); // prettier-ignore

  var formDataFlatCurrent = flattenPerSchema(formData, schema);
  var formDataFlat = Object.assign({}, formDataFlatEmpty, formDataFlatCurrent);
  var resultPerField = Object.entries(formDataFlat).reduce(function (carry, _ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
        fieldId = _ref3[0],
        fieldValue = _ref3[1];

    if (fieldId === 'undefined') return carry;
    var blueprint = schemaObject[fieldId];
    var context = {
      formData: formData,
      formDataFlat: formDataFlat,
      lang: lang
    };
    carry[fieldId] = !blueprint || validateFieldPerSchema(fieldValue, blueprint, context);
    return carry;
  }, {});
  return resultPerField;
}
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzField.vue?vue&type=template&id=3f71ad59&
var BlitzFieldvue_type_template_id_3f71ad59_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.evalPropOrAttr('showCondition'))?_c('div',{class:[
      'blitz-field',
      ("blitz-field--" + (_vm.evalPropOrAttr('mode'))),
      ("blitz-field--" + _vm.componentName),
      ("blitz-field--label-" + _vm.labelPosition),
      {
        'blitz-field--no-label': !_vm.labelUsedHere,
        'blitz-field--no-sub-label': !_vm.subLabelHtmlUsedHere,
        'blitz-field--no-component': !_vm.componentName,
      },
      _vm.evalPropOrAttr('fieldClasses') ].flat(),style:(_vm.evalPropOrAttr('fieldStyle'))},[(_vm.labelUsedHere || (_vm.evalPropOrAttr('slots') && _vm.evalPropOrAttr('slots').label))?_c('div',{class:['blitz-field__label', _vm.evalPropOrAttr('labelClasses')].flat(),style:(_vm.evalPropOrAttr('labelStyle'))},[_vm._v("\n    "+_vm._s(_vm.labelUsedHere)+"\n    "),_vm._t("label",[(_vm.evalPropOrAttr('slots') && _vm.evalPropOrAttr('slots').label)?_c('BlitzH',{attrs:{"options":_vm.evalPropOrAttr('slots').label}}):_vm._e()])],2):_vm._e(),(_vm.subLabelHtmlUsedHere)?_c('div',{staticClass:"blitz-field__sub-label",domProps:{"innerHTML":_vm._s(_vm.subLabelHtmlUsedHere)}}):_vm._e(),(!_vm.evalPropOrAttr('component'))?void 0:(_vm.evalPropOrAttr('mode') === 'raw')?_c('BlitzH',{attrs:{"options":{
      component: 'div',
      slot: _vm.parsedFieldValue,
      class: ['blitz-field__component', _vm.evalPropOrAttr('componentClasses')].flat(),
      style: _vm.evalPropOrAttr('componentStyle'),
    }}}):(_vm.usesInternalOrNoErrors && _vm.evalPropOrAttr('component') === 'input')?(((_vm.propsAndAttrsToPass).type)==='checkbox')?_c('input',_vm._g(_vm._b({directives:[{name:"model",rawName:"v-model",value:(_vm.cValue),expression:"cValue"}],class:['blitz-field__component', _vm.evalPropOrAttr('componentClasses')].flat(),style:(_vm.evalPropOrAttr('componentStyle')),attrs:{"type":"checkbox"},domProps:{"checked":Array.isArray(_vm.cValue)?_vm._i(_vm.cValue,null)>-1:(_vm.cValue)},on:{"change":function($event){var $$a=_vm.cValue,$$el=$event.target,$$c=$$el.checked?(true):(false);if(Array.isArray($$a)){var $$v=null,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.cValue=$$a.concat([$$v]))}else{$$i>-1&&(_vm.cValue=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{_vm.cValue=$$c}}}},'input',_vm.propsAndAttrsToPass,false),_vm.eventsCalculated)):(((_vm.propsAndAttrsToPass).type)==='radio')?_c('input',_vm._g(_vm._b({directives:[{name:"model",rawName:"v-model",value:(_vm.cValue),expression:"cValue"}],class:['blitz-field__component', _vm.evalPropOrAttr('componentClasses')].flat(),style:(_vm.evalPropOrAttr('componentStyle')),attrs:{"type":"radio"},domProps:{"checked":_vm._q(_vm.cValue,null)},on:{"change":function($event){_vm.cValue=null}}},'input',_vm.propsAndAttrsToPass,false),_vm.eventsCalculated)):_c('input',_vm._g(_vm._b({directives:[{name:"model",rawName:"v-model",value:(_vm.cValue),expression:"cValue"}],class:['blitz-field__component', _vm.evalPropOrAttr('componentClasses')].flat(),style:(_vm.evalPropOrAttr('componentStyle')),attrs:{"type":(_vm.propsAndAttrsToPass).type},domProps:{"value":(_vm.cValue)},on:{"input":function($event){if($event.target.composing){ return; }_vm.cValue=$event.target.value}}},'input',_vm.propsAndAttrsToPass,false),_vm.eventsCalculated)):(_vm.usesInternalOrNoErrors && _vm.evalPropOrAttr('component') === 'select')?_c('select',_vm._g(_vm._b({directives:[{name:"model",rawName:"v-model",value:(_vm.cValue),expression:"cValue"}],class:['blitz-field__component', _vm.evalPropOrAttr('componentClasses')].flat(),style:(_vm.evalPropOrAttr('componentStyle')),on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.cValue=$event.target.multiple ? $$selectedVal : $$selectedVal[0]}}},'select',_vm.propsAndAttrsToPass,false),_vm.eventsCalculated),[(_vm.defaultSlotCalculated)?_c('BlitzH',{attrs:{"options":_vm.defaultSlotCalculated}}):_vm._e()],1):(_vm.usesInternalOrNoErrors)?_c(_vm.evalPropOrAttr('component'),_vm._g(_vm._b({tag:"component",class:['blitz-field__component', _vm.evalPropOrAttr('componentClasses')].flat(),style:(_vm.evalPropOrAttr('componentStyle')),model:{value:(_vm.cValue),callback:function ($$v) {_vm.cValue=$$v},expression:"cValue"}},'component',_vm.propsAndAttrsToPass,false),_vm.eventsCalculated),[(_vm.defaultSlotCalculated)?_c('BlitzH',{attrs:{"options":_vm.defaultSlotCalculated}}):_vm._e()],1):_c('QField',_vm._b({staticClass:"blitz-field__component-validation",scopedSlots:_vm._u([{key:"control",fn:function(){return [(((_vm.propsAndAttrsToPass).type)==='checkbox'&&(_vm.evalPropOrAttr('component') === 'input'))?_c('input',_vm._g(_vm._b({directives:[{name:"model",rawName:"v-model",value:(_vm.cValue),expression:"cValue"}],class:['blitz-field__component' ].concat( _vm.evalPropOrAttr('componentClasses')),style:(_vm.evalPropOrAttr('componentStyle')),attrs:{"type":"checkbox"},domProps:{"checked":Array.isArray(_vm.cValue)?_vm._i(_vm.cValue,null)>-1:(_vm.cValue)},on:{"change":function($event){var $$a=_vm.cValue,$$el=$event.target,$$c=$$el.checked?(true):(false);if(Array.isArray($$a)){var $$v=null,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.cValue=$$a.concat([$$v]))}else{$$i>-1&&(_vm.cValue=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{_vm.cValue=$$c}}}},'input',_vm.propsAndAttrsToPass,false),_vm.eventsCalculated)):(((_vm.propsAndAttrsToPass).type)==='radio'&&(_vm.evalPropOrAttr('component') === 'input'))?_c('input',_vm._g(_vm._b({directives:[{name:"model",rawName:"v-model",value:(_vm.cValue),expression:"cValue"}],class:['blitz-field__component' ].concat( _vm.evalPropOrAttr('componentClasses')),style:(_vm.evalPropOrAttr('componentStyle')),attrs:{"type":"radio"},domProps:{"checked":_vm._q(_vm.cValue,null)},on:{"change":function($event){_vm.cValue=null}}},'input',_vm.propsAndAttrsToPass,false),_vm.eventsCalculated)):(_vm.evalPropOrAttr('component') === 'input')?_c('input',_vm._g(_vm._b({directives:[{name:"model",rawName:"v-model",value:(_vm.cValue),expression:"cValue"}],class:['blitz-field__component' ].concat( _vm.evalPropOrAttr('componentClasses')),style:(_vm.evalPropOrAttr('componentStyle')),attrs:{"type":(_vm.propsAndAttrsToPass).type},domProps:{"value":(_vm.cValue)},on:{"input":function($event){if($event.target.composing){ return; }_vm.cValue=$event.target.value}}},'input',_vm.propsAndAttrsToPass,false),_vm.eventsCalculated)):(_vm.evalPropOrAttr('component') === 'select')?_c('select',_vm._g(_vm._b({directives:[{name:"model",rawName:"v-model",value:(_vm.cValue),expression:"cValue"}],class:['blitz-field__component' ].concat( _vm.evalPropOrAttr('componentClasses')),style:(_vm.evalPropOrAttr('componentStyle')),on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.cValue=$event.target.multiple ? $$selectedVal : $$selectedVal[0]}}},'select',_vm.propsAndAttrsToPass,false),_vm.eventsCalculated),[(_vm.defaultSlotCalculated)?_c('BlitzH',{attrs:{"options":_vm.defaultSlotCalculated}}):_vm._e()],1):_c(_vm.evalPropOrAttr('component'),_vm._g(_vm._b({tag:"component",class:['blitz-field__component' ].concat( _vm.evalPropOrAttr('componentClasses')),style:(_vm.evalPropOrAttr('componentStyle')),model:{value:(_vm.cValue),callback:function ($$v) {_vm.cValue=$$v},expression:"cValue"}},'component',_vm.propsAndAttrsToPass,false),_vm.eventsCalculated),[(_vm.defaultSlotCalculated)?_c('BlitzH',{attrs:{"options":_vm.defaultSlotCalculated}}):_vm._e()],1)]},proxy:true}],null,false,1254128562),model:{value:(_vm.cValue),callback:function ($$v) {_vm.cValue=$$v},expression:"cValue"}},'QField',_vm.propsAndAttrsToPassForQField,false))],2):_vm._e()}
var BlitzFieldvue_type_template_id_3f71ad59_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzField.vue?vue&type=template&id=3f71ad59&

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/snarkdown/dist/snarkdown.es.js
var snarkdown_es = __webpack_require__("0471");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/field/QField.js + 2 modules
var QField = __webpack_require__("b693");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/map-anything/dist/index.esm.js
var dist_index_esm = __webpack_require__("9ed5");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzH.vue?vue&type=script&lang=js&


/**
 * @typedef BlitzHOption
 * @type {{
  component: string,
  slot: any,
  events: {},
  class: string | Record<string, any> | (string | Record<string, any>)[],
  style: string | Record<string, any> | (string | Record<string, any>)[],
  [key: string]: any,
}}
 */

/**
 * I'm still thinking about the best syntax for BlitzH
 */

/* harmony default export */ var BlitzHvue_type_script_lang_js_ = ({
  name: 'BlitzH',
  functional: true,
  props: {
    /**
     * @type {string | BlitzHOption | BlitzHOption[]}
     */
    options: {
      type: [String, Object, Array]
    }
  },
  render: function render(h, ctx) {
    var optionsArray = index_esm_isArray(ctx.props.options) ? ctx.props.options : [ctx.props.options];
    return optionsArray.map(function (o) {
      if (index_esm_isString(o)) return ctx._v(o);
      var children;

      if (o.slot) {
        children = [h('BlitzH', {
          props: {
            options: o.slot
          }
        })];
      } else if (o.slots && o.slots.default) {
        children = [h('BlitzH', {
          props: {
            options: o.slots.default
          }
        })];
      }

      return h(o.component, {
        props: o,
        attrs: omit(o, ['lang', 'rules', 'label', 'hint', 'readonly', 'component', 'slots', 'class', 'style', 'events']),
        on: o.events,
        class: o.class,
        style: o.style
      }, children);
    });
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzH.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_BlitzHvue_type_script_lang_js_ = (BlitzHvue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__("2be6");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzH.vue
var BlitzH_render, BlitzH_staticRenderFns




/* normalize component */

var BlitzH_component = Object(componentNormalizer["a" /* default */])(
  components_BlitzHvue_type_script_lang_js_,
  BlitzH_render,
  BlitzH_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var BlitzH = (BlitzH_component.exports);
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzField.vue?vue&type=script&lang=js&




//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
function BlitzFieldvue_type_script_lang_js_slicedToArray(arr, i) {
  return BlitzFieldvue_type_script_lang_js_arrayWithHoles(arr) || BlitzFieldvue_type_script_lang_js_iterableToArrayLimit(arr, i) || BlitzFieldvue_type_script_lang_js_unsupportedIterableToArray(arr, i) || BlitzFieldvue_type_script_lang_js_nonIterableRest();
}

function BlitzFieldvue_type_script_lang_js_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function BlitzFieldvue_type_script_lang_js_iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function BlitzFieldvue_type_script_lang_js_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function BlitzFieldvue_type_script_lang_js_toConsumableArray(arr) {
  return BlitzFieldvue_type_script_lang_js_arrayWithoutHoles(arr) || BlitzFieldvue_type_script_lang_js_iterableToArray(arr) || BlitzFieldvue_type_script_lang_js_unsupportedIterableToArray(arr) || BlitzFieldvue_type_script_lang_js_nonIterableSpread();
}

function BlitzFieldvue_type_script_lang_js_nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function BlitzFieldvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return BlitzFieldvue_type_script_lang_js_arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return BlitzFieldvue_type_script_lang_js_arrayLikeToArray(o, minLen);
}

function BlitzFieldvue_type_script_lang_js_iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function BlitzFieldvue_type_script_lang_js_arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return BlitzFieldvue_type_script_lang_js_arrayLikeToArray(arr);
}

function BlitzFieldvue_type_script_lang_js_arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}


;








function evaluateProp(propValue, componentValue, componentInstance) {
  return index_esm_isFunction(propValue) ? propValue(componentValue, componentInstance) : propValue;
}
/**
 * @typedef FormContext
 * @type {{
  formData: Record<string, any>,
  fieldInput: (payload: { id: string, value: any }) => void,
  [key: string]: any
}}
 */

/**
 * @typedef EvaluatedProp<T>
 * @type {(val: any, formContext: FormContext) => T}
 */

/**
 * @typedef Any
 * @type {{}}
 */

/**
`<BlitzField />` is what is used by BlitzForm under the hood to render the form fields.

Use this API Card to check out all the possible props you can use in a single field of a schema.
 */


/* harmony default export */ var BlitzFieldvue_type_script_lang_js_ = ({
  name: 'BlitzField',
  inheritAttrs: false,
  components: {
    QField: QField["a" /* default */],
    BlitzH: BlitzH
  },
  props: {
    /**
     * The value of the field. The BlitzForm formData is an object with the value of each field and the id for key.
     * @type {any}
     * @category model
     */
    value: {
      type: undefined
    },

    /**
     * An 'id' is required for the BlitzForm to be able to know which fields have which value.
     *
     * A string with dot notation will become a nested field in the formData.
     * @type {string}
     * @category model
     */
    id: {
      type: String
    },

    /**
     * A defaultValue value to be used when the 'value' is `undefined`.
     *
     * You can also pass a function that will receive two params you can work with: `(formData, context)`
     * - `formData` is the value object of your BlitzForm. This will be undefined when BlitzField is used as stand-alone (without BlitzForm) unless you manually pass it.
     * - `context` is either your BlitzForm or BlitzField context with many usefull props. See the documentation on "Evaluated Props" for more info.
     * @type {(formData: Record<string, any>, formContext: FormContext) => any | any}
     * @category model
     */
    defaultValue: {
      type: undefined
    },

    /**
     * A function that modifies a value before it is used in the actual component. (see `parseInput` for the reverse)
     * @type {(val: any) => any}
     * @example val => val && val.split(' ').map(str => !str ? '' : `${str[0].toUpperCase()}${str.slice(1)}`).join(' ')
     * @example val => Number(val)
     * @example val => Date(val)
     * @category model
     */
    parseValue: {
      type: Function
    },

    /**
     * A function that modifies a value after user input but before the value is emitted. (see `parseValue` for the reverse)
     * @type {(val: any) => any}
     * @example val => (val || '').toLowerCase()
     * @example val => val.toISOString()
     * @category model
     */
    parseInput: {
      type: Function
    },

    /**
     * The component to be used for the field. Is mounted via `<component :is="component" />`. You can pass the name of a native HTML5 element or Vue component that is globally registered. You can also import the Vue file and directly pass the imported object, just like you would when you add it to a Vue file's components prop.
     * @type {string | Function | EvaluatedProp<string | Function>}
     * @example 'input'
     * @example 'MyCustomField'
     * @category content
     */
    component: {
      type: [String, Function, Object]
    },
    // object for imported vue instances

    /**
     * An Object with keys for the slot names and an object for values. The object you pass to a slot is itself applied as a `<component is="" />`.
     *
     * The last example below shows how this is actually used under the hood.
     * @type {{ label?: string | Record<string, any> | Record<string, any>[], default?: string | Record<string, any> | Record<string, any>[] } | EvaluatedProp<{ label?: string | Record<string, any> | Record<string, any>[], default?: string | Record<string, any> | Record<string, any>[] }>}
     * @example { label: { component: 'MyTooltip', tip: 'hi' } } }
     * @example <slot name="label"><component :is="slots.label.component" v-bind="slots.label" /></slot>
     * @category content
     */
    slots: {
      type: [Object, Function]
    },

    /**
     * The text used in the UI for the action buttons and some error messages.
     *
     * The example shows how the "required fields" error message is overwritten.
     * @type {{ archive?: string, delete?: string, cancel?: string, edit?: string, save?: string, requiredField?: string, formValidationError?: string } | EvaluatedProp<{ archive?: string, delete?: string, cancel?: string, edit?: string, save?: string, requiredField?: string, formValidationError?: string }>}
     * @example { requiredField: `Don't forget this field!` }
     * @category content
     */
    lang: {
      type: [Object, Function],
      // when changing the default, do it for both BlitzForm; BlitzField and lang.js
      default: function _default() {
        return {
          archive: 'Archive',
          delete: 'Delete',
          cancel: 'Cancel',
          edit: 'Edit',
          save: 'Save',
          requiredField: 'Field is required',
          formValidationError: 'There are remaining errors.'
        };
      }
    },

    /**
     * The field label.
     * @type {string | EvaluatedProp<string>}
     * @example 'Your Name'
     * @category content
     */
    label: {
      type: [String, Function]
    },

    /**
     * A smaller label for extra info.
     * @type {string | EvaluatedProp<string>}
     * @example 'first and last'
     * @category content
     */
    subLabel: {
      type: [String, Function]
    },

    /**
     * The mode represents how fields are rendered
     * - `'edit'`: (default) Show editable fields based on the schema
     * - `'view'`: Show each field with `readonly: true`.
     * - `'disabled'`: Show each field with `disabled: true`.
     * - `'raw'`: Used to show raw data of your form. No fields are generated, just divs with the labels and values. This mode is powerful because it will automatically map values to the schema provided (eg. adding pre-/suffix; mapping to options of a select; etc.)
     * - `'add'`: The same as 'edit'
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {'edit' | 'view' | 'disabled' | 'raw' | 'add' | EvaluatedProp<'edit' | 'view' | 'disabled' | 'raw' | 'add'>}
     * @category state
     */
    mode: {
      type: [String, Function],
      default: 'edit'
    },

    /**
     * An Object with an event name as key and the handler function as value. The function you pass will receive the native event payload as first parameter and the BlitzField context (the component instance) as second: `($event, context) => {}`
     * @type {Record<string, (event: any, formContext: FormContext) => any> | EvaluatedProp<Record<string, (event: any, formContext: FormContext) => any>>}
     * @example { click: (val, { formData }) => console.log(formData) }
     * @category behavior
     */
    events: {
      type: [Object, Function],
      default: function _default() {
        return {};
      }
    },

    /**
     * Whether or not the field is required or not. If a field is marked 'required' it will add a default rule like so: `[val => (val !== null && val !== undefined) || 'Field is required']`. The default message can be set in the `lang` prop as `requiredField`.
     * @type {boolean | EvaluatedProp<boolean>}
     * @category behavior
     */
    required: {
      type: [Boolean, Function]
    },

    /**
     * An array of rule functions that receive the value of the field as parameter and should return `true` if the rule passes or a `string` if the rule fails. The string represents the error message that is then shown underneath the field in red.
     * @type {((val: any) => (true | string))[] | EvaluatedProp<((val: any) => (true | string))[]>}
     * @example [val => (val && val.length <= 3) || 'Maximum 3 characters']
     * @category behavior
     */
    rules: {
      type: [Array, Function],
      default: function _default() {
        return [];
      }
    },

    /**
     * An array with prop names that should be treated as "Evaluated Props" when passed a function.
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {string[]}
     * @category behavior
     */
    evaluatedProps: {
      type: Array,
      default: function _default() {
        return ['component', 'showCondition', 'label', 'subLabel', 'required', 'rules', 'fieldStyle', 'fieldClasses', 'componentStyle', 'componentClasses', 'disable', 'events', 'lang'];
      }
    },

    /**
     * Set to `true` if the component has its own labels and you do not want the BlitzField to show a label.
     *
     * When `true` subLabels will also be hidden and passed to the component instead as a prop called 'hint'.
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {boolean | undefined | EvaluatedProp<boolean | undefined>}
     * @category style
     */
    internalLabels: {
      type: [Boolean, undefined],
      required: false,
      default: undefined
    },

    /**
     * Set to true if the component has its own error handling. This makes sure it passes on props like `rules` and does nothing with them in the BlitzField.
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {boolean | undefined | EvaluatedProp<boolean | undefined>}
     * @category behavior
     */
    internalErrors: {
      type: [Boolean, undefined],
      required: false,
      default: undefined
    },

    /**
     * Setting to `false` will hide the field. When using as an Evaluated Prop it can used to conditionally hide fields based on the other formData.
     * @type {boolean | EvaluatedProp<boolean>}
     * @example (val, { mode }) => (mode === 'edit')
     * @example false
     * @category state
     */
    showCondition: {
      type: [Boolean, Function],
      default: true
    },

    /**
     * `readonly` defaults to `true` on `mode: 'view'
     * @type {boolean | 'readonly' | EvaluatedProp<boolean | 'readonly'>}
     * @category state
     */
    readonly: {
      type: [Boolean, Function, String, undefined],
      default: undefined
    },

    /**
     * `disabled` defaults to `true` on `mode: 'disabled'.
     * @type {boolean | 'disabled' | EvaluatedProp<boolean | 'disabled'>}
     * @category state
     */
    disabled: {
      type: [Boolean, Function, String, undefined],
      default: undefined
    },

    /**
     * The position of the label in comparison to the field.
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {'top' | 'left' | EvaluatedProp<'top' | 'left'>}
     * @category style
     */
    labelPosition: {
      type: [String, Function],
      default: 'top',
      validator: function validator(prop) {
        return ['top', 'left'].includes(prop);
      }
    },

    /**
     * Custom styling to be applied to the BlitzField. Applied like so `:style="fieldStyle"`. Can be an Evaluated Prop (this is why I opted to have a different name from `style`).
     *
     * In a BlitzForm schema you can also just write `style: '...'` and BlitzForm will pass that as fieldStyle for you, because "style" is not a valid prop name.
     * @type {string | Record<string, boolean> | (string | Record<string, boolean>)[] | EvaluatedProp<string | Record<string, boolean> | (string | Record<string, boolean>)[]>}
     * @example 'padding: 0.5em; color: white'
     * @category style
     */
    fieldStyle: {
      type: [Object, Array, String, Function]
    },

    /**
     * Custom classes to be applied to the BlitzField. Applied like so `:class="fieldClasses"`. Can be an Evaluated Prop (this is why I opted to have a different name from `class`).
     *
     * In a BlitzForm schema you can also just write `class: '...'` and BlitzForm will pass that as fieldClasses for you, because "class" is not a valid prop name.
     * @type {string | Record<string, boolean> | (string | Record<string, boolean>)[] | EvaluatedProp<string | Record<string, boolean> | (string | Record<string, boolean>)[]>}
     * @example ['dark-theme']
     * @category style
     */
    fieldClasses: {
      type: [Object, Array, String, Function]
    },

    /**
     * Custom styling to be applied to the inner component of BlitzField. Applied like so `:style="componentStyle"`. Can be an Evaluated Prop.
     * @type {string | Record<string, boolean> | (string | Record<string, boolean>)[] | EvaluatedProp<string | Record<string, boolean> | (string | Record<string, boolean>)[]>}
     * @example 'padding: 1em;'
     * @category style
     */
    componentStyle: {
      type: [Object, Array, String, Function]
    },

    /**
     * Custom classes to be applied to the inner component of BlitzField. Applied like so `:class="componentClasses"`. Can be an Evaluated Prop.
     * @type {string | Record<string, boolean> | (string | Record<string, boolean>)[] | EvaluatedProp<string | Record<string, boolean> | (string | Record<string, boolean>)[]>}
     * @example ['dark-theme']
     * @category style
     */
    componentClasses: {
      type: [Object, Array, String, Function]
    },

    /**
     * Custom styling to be applied to the label of BlitzField. Applied like so `:style="componentStyle"`. Can be an Evaluated Prop.
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {string | Record<string, boolean> | (string | Record<string, boolean>)[] | EvaluatedProp<string | Record<string, boolean> | (string | Record<string, boolean>)[]>}
     * @example 'font-weight: 200;'
     * @category style
     */
    labelStyle: {
      type: [Object, Array, String, Function]
    },

    /**
     * Custom classes to be applied to the label of BlitzField. Applied like so `:class="labelClasses"`. Can be an Evaluated Prop.
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {string | Record<string, boolean> | (string | Record<string, boolean>)[] | EvaluatedProp<string | Record<string, boolean> | (string | Record<string, boolean>)[]>}
     * @example ['text-h1']
     * @category style
     */
    labelClasses: {
      type: [Object, Array, String, Function]
    },

    /**
     * This is the *nested* data of all the fields inside a BlitzForm.
     *
     * It's not something you can pass via the schema, but something that BlitzForm will automatically pass to each of its fields so you can use it in Evaluated Props.
     * @type {Record<string, any>}
     * @category readonly
     */
    formData: {
      type: Object
    },

    /**
     * This is the *flattened* data of all the fields inside a BlitzForm.
     *
     * It's not something you can pass via the schema, but something that BlitzForm will automatically pass to each of its fields so you can use it in Evaluated Props.
     * @type {Record<string, any>}
     * @category readonly
     */
    formDataFlat: {
      type: Object
    },

    /**
     * A manually set 'id' of the BlitzForm. This only exists if you passed an id directly to the BlitzForm.
     *
     * It's not something you can pass via the schema, but something that BlitzForm will automatically pass to each of its fields so you can use it in Evaluated Props.
     * @type {string}
     * @category readonly
     */
    formId: {
      type: String
    },

    /**
     * The `fieldInput` function of BlitzForm. Is passed so it can be used in the input event: `events: { input: (value, { fieldInput } => fieldInput({ id: 'otherField', value }))}`
     *
     * It's not something you can pass via the schema, but something that BlitzForm will automatically pass to each of its fields so you can use it in Evaluated Props.
     * @type {(val: any, formContext: FormContext) => void}
     * @category readonly
     */
    fieldInput: {
      type: Function
    }
  },
  data: function data() {
    var value = this.value,
        defaultValue = this.defaultValue,
        formData = this.formData;
    if (!index_esm_isUndefined(value)) return {
      innerValue: value
    };
    var innerValue = index_esm_isFunction(defaultValue) ? defaultValue(formData, this) : defaultValue;
    this.event('input', innerValue, 'default');
    return {
      innerValue: innerValue
    };
  },
  watch: {
    value: function value(newValue) {
      this.innerValue = newValue;
    }
  },
  methods: {
    evalPropOrAttr: function evalPropOrAttr(propOrAttr) {
      var evaluatedPropsDataObject = this.evaluatedPropsDataObject;
      if (propOrAttr in evaluatedPropsDataObject) return evaluatedPropsDataObject[propOrAttr];
      if (propOrAttr in this) return this[propOrAttr];
      return this.$attrs[propOrAttr];
    },

    /**
     * @param {'input'} eventName
     * @param {any} payload
     * @param {'default' | '' | undefined} origin
     */
    event: function event(eventName, payload, origin) {
      if (eventName === 'input') {
        /**
         * This event enables the field to be usable with `v-model="value"`
         * @property {any} payload the updated value
         * @property {'default' | '' | undefined} origin the cause of the input event:
         * - `'default'` means that the event was emitted when the form was mounted and all fields have initialised their default values.
         * - input events from user input won't have an origin.
         */
        this.$emit('input', payload, origin);
      }
    }
  },
  computed: {
    cValue: {
      get: function get() {
        var parseValue = this.parseValue,
            innerValue = this.innerValue;
        if (index_esm_isFunction(parseValue)) return parseValue(innerValue, this);
        return innerValue;
      },
      set: function set(val) {
        var parseInput = this.parseInput,
            evalPropOrAttr = this.evalPropOrAttr;
        var events = evalPropOrAttr('events');
        if (index_esm_isFunction(parseInput)) val = parseInput(val, this);
        if (index_esm_isFunction(events.input)) events.input(val, this);

        for (var _len = arguments.length, otherArguments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          otherArguments[_key - 1] = arguments[_key];
        }

        this.event.apply(this, ['input', val].concat(otherArguments));
      }
    },
    evaluatedPropsDataObject: function evaluatedPropsDataObject() {
      var evaluatedProps = this.evaluatedProps,
          cValue = this.cValue;
      var context = this;
      return evaluatedProps.reduce(function (carry, propKey) {
        if (propKey === 'slots' || propKey === 'slot') {
          var slotsValue = 'slots' in context ? context['slots'] : context.$attrs['slots'];
          carry['slots'] = index_esm_isPlainObject(slotsValue) ? Object(dist_index_esm["a" /* mapObject */])(slotsValue, function (propValue) {
            return evaluateProp(propValue, cValue, context);
          }) : evaluateProp(slotsValue, cValue, context);
          return carry;
        }

        var propValue = propKey in context ? context[propKey] : context.$attrs[propKey];
        carry[propKey] = evaluateProp(propValue, cValue, context);
        return carry;
      }, {});
    },
    defaultSlotCalculated: function defaultSlotCalculated() {
      var evalPropOrAttr = this.evalPropOrAttr;
      var slots = evalPropOrAttr('slots');
      if (index_esm_isPlainObject(slots)) return slots.default;
    },
    componentName: function componentName() {
      var evalPropOrAttr = this.evalPropOrAttr;
      var component = evalPropOrAttr('component');
      if (index_esm_isString(component)) return component;

      var _ref = component || {},
          name = _ref.name;

      return name;
    },
    usesInternalOrNoErrors: function usesInternalOrNoErrors() {
      var evalPropOrAttr = this.evalPropOrAttr,
          componentName = this.componentName,
          rulesCalculated = this.rulesCalculated;
      var internalErrors = evalPropOrAttr('internalErrors');
      if (internalErrors !== undefined) return internalErrors;
      return !rulesCalculated.length;
    },
    usesInternalLabels: function usesInternalLabels() {
      var evalPropOrAttr = this.evalPropOrAttr,
          componentName = this.componentName;
      var internalLabels = evalPropOrAttr('internalLabels');
      return internalLabels && !index_esm_isNullOrUndefined(componentName);
    },
    langCalculated: function langCalculated() {
      var evalPropOrAttr = this.evalPropOrAttr;
      var defaults = defaultLang() || {};
      var lang = evalPropOrAttr('lang') || {};
      return Object(index_esm["a" /* merge */])(defaults, lang);
    },
    rulesCalculated: function rulesCalculated() {
      var evalPropOrAttr = this.evalPropOrAttr,
          langCalculated = this.langCalculated;
      var required = evalPropOrAttr('required');
      var rules = evalPropOrAttr('rules');

      if (required) {
        var requiredRule = createRequiredRule(langCalculated['requiredField']);
        return [requiredRule].concat(BlitzFieldvue_type_script_lang_js_toConsumableArray(rules));
      }

      return rules;
    },
    eventsCalculated: function eventsCalculated() {
      var evalPropOrAttr = this.evalPropOrAttr;
      var context = this;
      var events = evalPropOrAttr('events');
      return Object.entries(events).reduce(function (carry, _ref2) {
        var _ref3 = BlitzFieldvue_type_script_lang_js_slicedToArray(_ref2, 2),
            eventName = _ref3[0],
            eventFn = _ref3[1]; // input event is handled in cValue


        if (eventName === 'input') return carry;

        carry[eventName] = function (val) {
          for (var _len2 = arguments.length, otherArguments = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            otherArguments[_key2 - 1] = arguments[_key2];
          }

          return eventFn.apply(void 0, [val, context].concat(otherArguments));
        };

        return carry;
      }, {});
    },
    propsAndAttrsToPass: function propsAndAttrsToPass() {
      var evalPropOrAttr = this.evalPropOrAttr;
      var propsToPass = {
        // we always wanna pass only this prop:
        required: evalPropOrAttr('required')
      }; // only pass rules when it has internal errors

      if (this.usesInternalOrNoErrors) {
        propsToPass.rules = this.rulesCalculated;
      } // only pass label and hint when it has internal labels


      if (this.usesInternalLabels) {
        propsToPass.label = evalPropOrAttr('label');
        propsToPass.hint = evalPropOrAttr('subLabel') || evalPropOrAttr('hint');
      } else {
        propsToPass.hint = evalPropOrAttr('hint');
      } // if readonly is set as prop


      var readonly = evalPropOrAttr('readonly');

      if (index_esm_isBoolean(readonly) || readonly === 'readonly') {
        propsToPass.readonly = readonly;
      } else {
        propsToPass.readonly = evalPropOrAttr('mode') === 'view';
      } // if disabled is set as prop


      var disabled = evalPropOrAttr('disabled');

      if (index_esm_isBoolean(disabled) || disabled === 'disabled') {
        propsToPass.disabled = disabled;
        propsToPass.disable = disabled;
      } else {
        propsToPass.disabled = evalPropOrAttr('mode') === 'disabled';
        propsToPass.disable = evalPropOrAttr('mode') === 'disabled';
      }

      var attrsToPass = Object.keys(this.$attrs).reduce(function (carry, attrKey) {
        carry[attrKey] = evalPropOrAttr(attrKey);
        return carry;
      }, {});
      return Object.assign({}, propsToPass, attrsToPass);
    },
    propsAndAttrsToPassForQField: function propsAndAttrsToPassForQField() {
      return Object(index_esm["a" /* merge */])(this.propsAndAttrsToPass, {
        rules: this.rulesCalculated,
        // defaults for UI
        borderless: true,
        stackLabel: true,
        // always disable prefix suffix for QField
        prefix: undefined,
        suffix: undefined
      });
    },
    labelUsedHere: function labelUsedHere() {
      var usesInternalLabels = this.usesInternalLabels,
          evalPropOrAttr = this.evalPropOrAttr;
      return usesInternalLabels ? undefined : evalPropOrAttr('label');
    },
    subLabelHtmlUsedHere: function subLabelHtmlUsedHere() {
      var usesInternalLabels = this.usesInternalLabels,
          evalPropOrAttr = this.evalPropOrAttr;
      var subLabel = usesInternalLabels ? undefined : evalPropOrAttr('subLabel');
      if (!index_esm_isFullString(subLabel)) return null;
      return Object(snarkdown_es["a" /* default */])(subLabel);
    },
    parsedFieldValue: function parsedFieldValue() {
      var cValue = this.cValue,
          evalPropOrAttr = this.evalPropOrAttr;
      var blueprint = {
        valueType: evalPropOrAttr('valueType'),
        type: evalPropOrAttr('type'),
        dateFormat: evalPropOrAttr('dateFormat'),
        suffix: evalPropOrAttr('suffix'),
        prefix: evalPropOrAttr('prefix'),
        options: evalPropOrAttr('options'),
        multiple: evalPropOrAttr('multiple'),
        slots: evalPropOrAttr('slots'),
        component: evalPropOrAttr('component')
      };
      return parseFieldValue(cValue, blueprint);
    }
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzField.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_BlitzFieldvue_type_script_lang_js_ = (BlitzFieldvue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzField.vue?vue&type=style&index=0&lang=css&
var BlitzFieldvue_type_style_index_0_lang_css_ = __webpack_require__("28d3");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/runtime.auto-import.js
var runtime_auto_import = __webpack_require__("e279");
var runtime_auto_import_default = /*#__PURE__*/__webpack_require__.n(runtime_auto_import);

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzField.vue






/* normalize component */

var BlitzField_component = Object(componentNormalizer["a" /* default */])(
  components_BlitzFieldvue_type_script_lang_js_,
  BlitzFieldvue_type_template_id_3f71ad59_render,
  BlitzFieldvue_type_template_id_3f71ad59_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var BlitzField = (BlitzField_component.exports);


runtime_auto_import_default()(BlitzField_component, 'components', {QField: QField["a" /* default */]});

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzForm.vue?vue&type=script&lang=js&





//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
function BlitzFormvue_type_script_lang_js_slicedToArray(arr, i) {
  return BlitzFormvue_type_script_lang_js_arrayWithHoles(arr) || BlitzFormvue_type_script_lang_js_iterableToArrayLimit(arr, i) || BlitzFormvue_type_script_lang_js_unsupportedIterableToArray(arr, i) || BlitzFormvue_type_script_lang_js_nonIterableRest();
}

function BlitzFormvue_type_script_lang_js_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function BlitzFormvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return BlitzFormvue_type_script_lang_js_arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return BlitzFormvue_type_script_lang_js_arrayLikeToArray(o, minLen);
}

function BlitzFormvue_type_script_lang_js_arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function BlitzFormvue_type_script_lang_js_iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function BlitzFormvue_type_script_lang_js_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

;








/**
Here you can find all the information on the available props & events of BlitzForm.

If any of the documentation is unclear, feel free to [open an issue](https://github.com/cycraft/blitzar/issues) to ask for clarification!
 */

/* harmony default export */ var BlitzFormvue_type_script_lang_js_ = ({
  name: 'BlitzForm',
  components: {
    BlitzField: BlitzField,
    QForm: QForm
  },
  inheritAttrs: false,
  props: {
    /**
     * An object with the data of the entire form. The object keys are the ids of the fields passed in the 'schema'.
     *
     * To be used with `:value` or `v-model`.
     * @type {Record<string, any>}
     * @example { name: '' }
     * @category model
     */
    value: {
      type: Object,
      default: function _default() {
        return {};
      }
    },

    /**
     * A manually set 'id' of the BlitzForm. This prop is accessible in the `context` (as `formId`) of any "evaluated prop" and event.
     *
     * Read more on Evaluated Props in its dedicated page.
     * @type {string}
     * @category model
     */
    id: {
      type: String
    },

    /**
     * This is the heart of your BlitzForm. It's the schema that will defined what fields will be generated.
     *
     * The possible props you can pass are:
     * - BlitzField props (see BlitzField API Card in the documentation)
     * - any props of the actual component you define
     * @type {Record<string, any>[]}
     * @example [{id: 'name', label: 'Name', component: 'input', style: 'color: white'}, {id: 'age', label: 'Age', component: 'input', type: 'number', style: 'color: white'}]
     * @category model
     */
    schema: {
      type: Array,
      required: true
    },

    /**
     * Buttons on top of the form that control the 'mode' of the form. The possible pre-made buttons are:
     * - 'edit' a button which puts the form in 'edit' mode & does `emit('edit')`
     * - 'cancel' a button which puts the form in 'view' mode & does `emit('cancel')`
     * - 'save' a button which puts the form in 'edit' mode & does `emit('save', {newData, oldData})`
     * - 'delete' a red button which does `emit('delete')`
     * - 'archive' a red button which does `emit('archive')`
     *
     * You can also pass custom buttons with the same schema to generate forms.
     *
     * See the documentation on "Action Buttons" for more info.
     * @type {('edit' | 'cancel' | 'save' | 'delete' | 'archive' | Record<string, any>)[]}
     * @example ['delete', 'cancel', 'edit', 'save']
     * @example [{component: 'button', type: 'button', slot: 'log', events: {click: console.log}}]
     * @category content
     */
    actionButtons: {
      type: Array,
      default: function _default() {
        return [];
      }
    },

    /**
     * You can overwrite the schema used for the default action buttons for edit, cancel, save, delete & archive.
     * @type {{ edit?: Record<string, any>, cancel?: Record<string, any>, save?: Record<string, any>, delete?: Record<string, any>, archive?: Record<string, any>, }}
     * @example {'save': {push: true}, 'delete': {color: 'secondary'}}
     * @category content
     */
    actionButtonDefaults: {
      type: Object,
      default: function _default() {
        return {};
      }
    },

    /**
     * The position of the action buttons.
     * @type {'top' | 'bottom' | 'right' | 'left'}
     * @category content
     */
    actionButtonsPosition: {
      type: String,
      default: 'top',
      validator: function validator(prop) {
        return ['top', 'bottom', 'right', 'left'].includes(prop);
      }
    },

    /**
     * A function which serves as global validator for your form. It will receive the edited data as first param and the original data (before user edits) as second. It should return true if all is OK or a string with error message.
     * @type {(newData: Record<string, any>, oldData: Record<string, any>) => (true | string)}
     * @example (newData, oldData) => newData.pass1 === newData.pass2 || 'passwords don't match'
     * @category behavior
     */
    validator: {
      type: Function
    },

    /**
     * The amount of columns the form should have.
     *
     * Each field can set a specific 'span' to be able to span multiple columns.
     * @type {number}
     * @category style
     */
    columnCount: {
      type: Number,
      default: 1
    },

    /**
     * The gap between each field in the form.
     * @type {string}
     * @category style
     */
    gridGap: {
      type: String,
      default: '1em'
    },

    /**
     * The text used in the UI for the action buttons and some error messages.
     * @type {{ archive?: string, delete?: string, cancel?: string, edit?: string, save?: string, requiredField?: string, formValidationError?: string } | EvaluatedProp<{ archive?: string, delete?: string, cancel?: string, edit?: string, save?: string, requiredField?: string, formValidationError?: string }>}
     * @example { cancel: '', edit: '', save: '' }
     * @category content
     */
    lang: {
      type: Object,
      // when changing the default, do it for both BlitzForm; BlitzField and lang.js
      default: function _default() {
        return {
          archive: 'Archive',
          delete: 'Delete',
          cancel: 'Cancel',
          edit: 'Edit',
          save: 'Save',
          requiredField: 'Field is required',
          formValidationError: 'There are remaining errors.'
        };
      }
    },
    // shared props

    /**
     * The mode represents how fields are rendered
     * - `'edit'`: (default) Show editable fields based on the schema
     * - `'view'`: Show each field with `readonly: true`.
     * - `'disabled'`: Show each field with `disabled: true`.
     * - `'raw'`: Used to show raw data of your form. No fields are generated, just divs with the labels and values. This mode is powerful because it will automatically map values to the schema provided (eg. adding pre-/suffix; mapping to options of a select; etc.)
     * - `'add'`: The same as 'edit'
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {'edit' | 'view' | 'disabled' | 'raw' | 'add'}
     * @category state
     */
    mode: {
      type: String,
      default: 'edit',
      validator: function validator(prop) {
        return ['edit', 'view', 'disabled', 'raw', 'add'].includes(prop);
      }
    },

    /**
     * The position of the label in comparison to the field.
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {'top' | 'left'}
     * @category style
     */
    labelPosition: {
      type: [String, Function],
      default: 'top',
      validator: function validator(prop) {
        return ['top', 'left'].includes(prop);
      }
    },

    /**
     * Custom styling to be applied to the label of BlitzField. Applied like so `:style="componentStyle"`. Can be an Evaluated Prop.
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {string | Record<string, boolean> | (string | Record<string, boolean>)[] | EvaluatedProp<string | Record<string, boolean> | (string | Record<string, boolean>)[]>}
     * @example 'font-weight: 200;'
     * @category style
     */
    labelStyle: {
      type: [Object, Array, String, Function]
    },

    /**
     * Custom classes to be applied to the label of BlitzField. Applied like so `:class="labelClasses"`. Can be an Evaluated Prop.
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {string | Record<string, boolean> | (string | Record<string, boolean>)[] | EvaluatedProp<string | Record<string, boolean> | (string | Record<string, boolean>)[]>}
     * @example ['text-h1']
     * @category style
     */
    labelClasses: {
      type: [Object, Array, String, Function]
    },

    /**
     * An array with prop names that should be treated as "Evaluated Props" when passed a function.
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {string[]}
     * @category behavior
     */
    evaluatedProps: {
      type: Array,
      default: function _default() {
        return ['component', 'showCondition', 'label', 'subLabel', 'required', 'rules', 'fieldStyle', 'fieldClasses', 'componentStyle', 'componentClasses', 'disable', 'events', 'lang'];
      }
    },

    /**
     * Set to true if the entire form has its own labels and you do not want the BlitzField to show a label.
     *
     * When `true` subLabels will be passed as a prop called 'hint'.
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {boolean | undefined}
     * @category behavior
     */
    internalLabels: {
      type: [Boolean, undefined],
      required: false,
      default: undefined
    },

    /**
     * Set to true if the entire form has its own error handling. This makes sure it passes on props like `rules` and does nothing with them in the BlitzField.
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {boolean | undefined}
     * @category behavior
     */
    internalErrors: {
      type: [Boolean, undefined],
      required: false,
      default: undefined
    },

    /**
     * Pass the component names (without `.vue`) that have internal error handling. This makes sure it passes on props like `rules` and does nothing with them in the BlitzField.
     * @type {string[]}
     * @category behavior
     */
    internalErrorsFor: {
      type: Array,
      default: function _default() {
        return ['QInput', 'QSelect', 'QField', 'q-input', 'q-select', 'q-field'];
      }
    },

    /**
     * The component that should be used to generate the form. Defaults to QForm. You can pass the name of a native HTML5 element or Vue component that is globally registered. You can also import the Vue file and directly pass the imported object, just like you would when you add it to a Vue file's components prop.
     * @type {string | Function}
     * @example 'form'
     * @example 'tr'
     * @example 'MyFormWrapper'
     */
    formComponent: {
      type: [String, Function],
      default: 'QForm'
    }
  },
  data: function data() {
    var _this = this;

    var mode = this.mode,
        id = this.id,
        value = this.value,
        schema = this.schema,
        lang = this.lang; // merge user provided lang onto defaults

    var innerLang = Object(index_esm["a" /* merge */])(defaultLang(), lang);
    var innerMode = mode;
    var formId = id;
    var dataFlat = flattenPerSchema(value, schema);
    var schemaArray = index_esm_isArray(schema) ? schema : Object.values(schema);
    var dataFlatDefaults = schemaArray.reduce(function (carry, _ref) {
      var id = _ref.id,
          defaultValue = _ref.defaultValue;
      if (!index_esm_isFullString(id)) return carry;
      carry[id] = index_esm_isFunction(defaultValue) ? defaultValue(value, _this) : defaultValue;
      return carry;
    }, {});
    var formDataFlat = Object(index_esm["a" /* merge */])(dataFlatDefaults, copy(dataFlat));
    return {
      innerLang: innerLang,
      innerMode: innerMode,
      formId: formId,
      edited: false,
      editedFields: [],
      formDataFlat: formDataFlat,
      formDataFlatBackups: [copy(formDataFlat)],
      formErrorMsg: '',
      innerFormComponent: this.formComponent === 'QForm' ? QForm : this.formComponent
    };
  },
  watch: {
    mode: function mode(newValue) {
      this.innerMode = newValue;
    },
    id: function id(newValue) {
      this.formId = newValue;
    },
    lang: function lang(newValue) {
      this.innerLang = Object(index_esm["a" /* merge */])(defaultLang(), newValue);
    }
  },
  computed: {
    formData: function formData() {
      return nestifyObject(this.formDataFlat);
    },
    schemaObject: function schemaObject() {
      return this.schema.reduce(function (carry, blueprint) {
        carry[blueprint.id] = blueprint;
        return carry;
      }, {});
    },
    cMode: {
      get: function get() {
        return this.innerMode;
      },
      set: function set(val) {
        this.innerMode = val;
        this.event('update:mode', val);
      }
    },
    schemaOverwritableDefaults: function schemaOverwritableDefaults() {
      var innerMode = this.innerMode,
          innerLang = this.innerLang;
      return {
        // used here & pass
        lang: innerLang,
        mode: innerMode,
        fieldInput: this.fieldInput,
        // just pass
        labelPosition: this.labelPosition,
        labelStyle: this.labelStyle,
        labelClasses: this.labelClasses,
        evaluatedProps: this.evaluatedProps,
        internalLabels: this.internalLabels,
        internalErrors: this.internalErrors
      };
    },
    schemaForcedDefaults: function schemaForcedDefaults() {
      var formData = this.formData,
          formDataFlat = this.formDataFlat,
          formId = this.formId;
      return {
        formData: formData,
        formDataFlat: formDataFlat,
        formId: formId
      };
    },
    cSchema: function cSchema() {
      // slot, class, style are 3 prop names we cannot directly pass via `v-bind`.
      // - slot: we pass as `slots: { default: ... }`
      // - class: we pass as `fieldClasses`
      // - style: we pass as `fieldStyle`
      var schema = this.schema,
          schemaOverwritableDefaults = this.schemaOverwritableDefaults,
          schemaForcedDefaults = this.schemaForcedDefaults,
          internalErrorsFor = this.internalErrorsFor;
      return schema.map(function (blueprint) {
        var internalErrorDefaults = internalErrorsFor.includes(blueprint.component) ? {
          internalErrors: true
        } : {};
        var overwrites = {};

        if (blueprint.slot) {
          overwrites.slots = Object(index_esm["a" /* merge */])(blueprint.slots || {}, {
            default: blueprint.slot
          });
        }

        var fieldClasses = blueprint.fieldClasses || blueprint.class;
        if (fieldClasses) overwrites.fieldClasses = fieldClasses;
        var fieldStyle = blueprint.fieldStyle || blueprint.style;
        if (fieldStyle) overwrites.fieldStyle = fieldStyle;
        var blueprintParsed = Object(index_esm["a" /* merge */])(schemaOverwritableDefaults, internalErrorDefaults, blueprint, overwrites, schemaForcedDefaults);
        return blueprintParsed;
      });
    },
    actionButtonsMap: function actionButtonsMap() {
      var innerLang = this.innerLang,
          tapDelete = this.tapDelete,
          tapEdit = this.tapEdit,
          tapArchive = this.tapArchive,
          tapCancel = this.tapCancel,
          tapSave = this.tapSave,
          actionButtonDefaults = this.actionButtonDefaults;
      var map = {
        delete: {
          component: 'button',
          type: 'button',
          slot: innerLang['delete'],
          color: 'negative',
          events: {
            click: tapDelete
          }
        },
        archive: {
          component: 'button',
          type: 'button',
          slot: innerLang['archive'],
          color: 'negative',
          events: {
            click: tapArchive
          }
        },
        edit: {
          component: 'button',
          type: 'button',
          showCondition: function showCondition(_, _ref2) {
            var mode = _ref2.mode;
            return ['view', 'raw'].includes(mode);
          },
          slot: innerLang['edit'],
          events: {
            click: tapEdit
          }
        },
        cancel: {
          component: 'button',
          type: 'button',
          showCondition: function showCondition(_, _ref3) {
            var mode = _ref3.mode;
            return ['edit', 'add'].includes(mode);
          },
          slot: innerLang['cancel'],
          events: {
            click: tapCancel
          }
        },
        save: {
          component: 'button',
          type: 'button',
          showCondition: function showCondition(_, _ref4) {
            var mode = _ref4.mode;
            return ['edit', 'add'].includes(mode);
          },
          slot: innerLang['save'],
          events: {
            click: tapSave
          }
        }
      };
      return Object(index_esm["a" /* merge */])(map, actionButtonDefaults);
    },
    actionButtonsSchema: function actionButtonsSchema() {
      var actionButtons = this.actionButtons,
          schemaOverwritableDefaults = this.schemaOverwritableDefaults,
          schemaForcedDefaults = this.schemaForcedDefaults,
          actionButtonsMap = this.actionButtonsMap,
          formDataFlat = this.formDataFlat;
      return actionButtons.map(function (blueprint) {
        var _bp = index_esm_isString(blueprint) ? actionButtonsMap[blueprint] : blueprint;

        var slotsOverwrite = !_bp.slot ? {} : {
          slots: Object(index_esm["a" /* merge */])(_bp.slots || {}, {
            default: _bp.slot
          })
        };
        var events = _bp.events || {};
        var eventsOverwrites = !events.input ? {} : {
          events: {
            input: function input(value, origin) {
              return fieldInput({
                id: field.id,
                value: value,
                origin: origin
              });
            }
          }
        };
        var overwrites = Object.assign({
          span: undefined,
          value: formDataFlat[_bp.id]
        }, slotsOverwrite, eventsOverwrites);
        var blueprintParsed = Object(index_esm["a" /* merge */])(schemaOverwritableDefaults, _bp, overwrites, schemaForcedDefaults);
        return blueprintParsed;
      });
    },
    dataBackup: function dataBackup() {
      var formDataFlatBackups = this.formDataFlatBackups;
      if (!formDataFlatBackups.length) return {};
      var lastBackup = formDataFlatBackups.slice(-1)[0];
      var dataNested = nestifyObject(lastBackup);
      return dataNested;
    },
    dataEdited: function dataEdited() {
      var editedFields = this.editedFields,
          formDataFlat = this.formDataFlat;
      var dataFlat = editedFields.reduce(function (carry, prop) {
        carry[prop] = formDataFlat[prop];
        return carry;
      }, {});
      var dataNested = nestifyObject(dataFlat);
      return dataNested;
    }
  },
  methods: {
    isFullString: index_esm_isFullString,

    /**
     * @param {'update:mode' | 'field-input' | 'input' | 'edit' | 'cancel' | 'save' | 'delete' | 'archive'} eventName
     * @param {any} payload
     * @param {'default' | 'cancel' | '' | undefined} origin
     */
    event: function event(eventName, payload, origin) {
      if (eventName === 'update:mode') {
        /**
         * This event makes it possible to sync the prop 'mode' like so: `:mode.sync="mode"`
         * @property {'edit' | 'view' | 'disabled' | 'raw' | 'add'} payload event payload
         */
        this.$emit('update:mode', payload);
      }

      if (eventName === 'field-input') {
        /**
         * This event triggers every time a field gets updated.
         *
         * The payload is an object with `id` for the field id and `value` as the new value.
         *
         * The `origin` prop of the event payload is what caused field-input event:
         * - `'default'` means that the event was emitted when the form was mounted and all fields have initialised their default values.
         * - `'cancel'` means that the 'cancel' button was clicked and the event data was reset to what it was before it was edited.
         * - field-input events from user input won't have an origin.
         * - A custom origin can be added when you execute `fieldInput` from inside an evaluatuated prop.
         *
         * @property {{ id: string, value: any, origin?: 'default' | 'cancel' | '' }} payload event payload
         */
        this.$emit('field-input', payload);
      }

      if (eventName === 'input') {
        /**
         * This event enables the form to be usable with `v-model="formData"`
         * @property {{ [id in string]: any }} payload event payload
         * @property {'default' | 'cancel' | '' | undefined} origin the cause of the input event:
         * - `'default'` means that the event was emitted when the form was mounted and all fields have initialised their default values.
         * - `'cancel'` means that the 'cancel' button was clicked and the event data was reset to what it was before it was edited.
         * - input events from user input won't have an origin.
         */
        this.$emit('input', payload, origin);
      }

      if (eventName === 'edit') {
        /**
         * (no payload) The edit-button was tapped and the form was put into "edit" mode
         */
        this.$emit('edit');
      }

      if (eventName === 'cancel') {
        /**
         * (no payload) The cancel-button was tapped and the form was put back into "view" mode & reverted to its original state
         */
        this.$emit('cancel');
      }

      if (eventName === 'save') {
        /**
         * The save-button was tapped and the form was put back into "view" mode & kept the modified content
         * @property {{newData: { [id in string]: any }, oldData: { [id in string]: any }}} payload event payload
         */
        this.$emit('save', payload);
      }

      if (eventName === 'delete') {
        /**
         * (no payload) The delete-button was tapped (you must implement your own logic)
         */
        this.$emit('delete');
      }

      if (eventName === 'archive') {
        /**
         * (no payload) The archive-button was tapped (you must implement your own logic)
         */
        this.$emit('archive');
      }
    },
    fieldInput: function fieldInput(_ref5) {
      var id = _ref5.id,
          value = _ref5.value,
          origin = _ref5.origin; // no idea why I do this:

      this.edited = true; // keep a list of edited field ids

      if (!this.editedFields.includes(id)) this.editedFields.push(id); // set the new value onto the formData (might be an empty object)

      this.$set(this.formDataFlat, id, value); // emit field-input with field's id and new data

      this.event('field-input', {
        id: id,
        value: value,
        origin: origin
      }); // emit input with entire formData

      this.event('input', this.formData, origin); // do not extract `this` from here
      // if the form has a formErrorMsg, validate gain to check to see if it's solved

      if (index_esm_isFullString(this.formErrorMsg)) {
        var res = validateFormPerSchema(this.formData, this.schema, this.innerLang);
        var errorsRemain = Object.values(res).some(function (val) {
          return val !== true;
        });
        if (!errorsRemain) this.formErrorMsg = null;
      }
    },
    resetState: function resetState() {
      this.cMode = 'view';
      this.edited = false;
      this.editedFields = [];
      this.formDataFlatBackups.push(copy(this.formDataFlat));
      this.formErrorMsg = '';
    },
    restoreBackup: function restoreBackup() {
      if (!this.formDataFlatBackups.length) return;
      var lastBackup = this.formDataFlatBackups.pop();
      this.formDataFlat = lastBackup;
    },
    tapCancel: function tapCancel() {
      var _this2 = this;

      this.restoreBackup();
      this.resetState();
      var origin = 'cancel';
      Object.entries(this.formDataFlat).forEach(function (_ref6) {
        var _ref7 = BlitzFormvue_type_script_lang_js_slicedToArray(_ref6, 2),
            id = _ref7[0],
            value = _ref7[1]; // emit field-input with field's id and new data


        _this2.event('field-input', {
          id: id,
          value: value,
          origin: origin
        });
      }); // emit input with entire formData

      this.event('input', this.formData, origin); // do not extract `this` from here

      this.event('cancel');
    },
    validate: function validate() {
      // validate will focus the field with error, so only use it when the user is not typing something else
      var $refs = this.$refs,
          innerLang = this.innerLang,
          validator = this.validator,
          dataEdited = this.dataEdited,
          dataBackup = this.dataBackup,
          schema = this.schema,
          formDataFlat = this.formDataFlat;
      return new Promise(function (resolve, reject) {
        if (index_esm_isFunction(validator)) {
          var validatorRes = validator(dataEdited, dataBackup);
          if (index_esm_isFullString(validatorRes)) reject(validatorRes);
        }

        $refs.refBlitzForm.validate().then(function (success) {
          if (success) return resolve();
          reject(innerLang['formValidationError']);
        }).catch(function (e) {
          return reject(innerLang['formValidationError']);
        });
      });
    },
    tapEdit: function tapEdit() {
      this.cMode = 'edit';
      this.event('edit');
    },
    tapSave: function tapSave() {
      var _this3 = this;

      var validate = this.validate,
          dataEdited = this.dataEdited,
          dataBackup = this.dataBackup,
          resetState = this.resetState;
      validate().then(function () {
        var newData = copy(dataEdited);
        var oldData = copy(dataBackup);

        _this3.event('save', {
          newData: newData,
          oldData: oldData
        });

        resetState();
      }).catch(function (formErrorMsg) {
        _this3.formErrorMsg = formErrorMsg;
      });
    },
    tapDelete: function tapDelete() {
      this.event('delete');
    },
    tapArchive: function tapArchive() {
      this.event('archive');
    }
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzForm.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_BlitzFormvue_type_script_lang_js_ = (BlitzFormvue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzForm.vue?vue&type=style&index=0&lang=css&
var BlitzFormvue_type_style_index_0_lang_css_ = __webpack_require__("1ce9");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/input/QInput.js + 2 modules
var QInput = __webpack_require__("bc74");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/select/QSelect.js + 7 modules
var QSelect = __webpack_require__("3946");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzForm.vue






/* normalize component */

var BlitzForm_component = Object(componentNormalizer["a" /* default */])(
  components_BlitzFormvue_type_script_lang_js_,
  BlitzFormvue_type_template_id_50a7f219_render,
  BlitzFormvue_type_template_id_50a7f219_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var BlitzForm = (BlitzForm_component.exports);





runtime_auto_import_default()(BlitzForm_component, 'components', {QInput: QInput["a" /* default */],QSelect: QSelect["a" /* default */],QField: QField["a" /* default */],QForm: QForm});

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzMiniForm.vue?vue&type=template&id=17c0bfe5&
var BlitzMiniFormvue_type_template_id_17c0bfe5_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"ef-mini-form"},[_c('div',{staticClass:"ef-mini-form__row",style:(("grid-template-columns: " + _vm.gridTemplateColumnsCalculated))},_vm._l((_vm.schemaLabels),function(subfield,fieldIndex){return _c('BlitzField',_vm._b({key:fieldIndex,staticClass:"ef-mini-form__sub-field"},'BlitzField',subfield,false))}),1),_vm._l((_vm.cValue),function(row,rowIndex){return _c('div',{key:rowIndex,staticClass:"ef-mini-form__row",style:(("grid-template-columns: " + _vm.gridTemplateColumnsCalculated))},_vm._l((_vm.cSchema),function(subfield,fieldIndex){return _c('BlitzField',_vm._b({key:fieldIndex,staticClass:"ef-mini-form__sub-field",attrs:{"rowIndex":rowIndex,"rowData":_vm.cValue[rowIndex],"rowInput":function (params) { return _vm.setSubFieldValue({ id: params.id, value: params.value, rowIndex: rowIndex }); },"value":_vm.cValue[rowIndex][subfield.id]},on:{"input":function (val, origin) { return _vm.setSubFieldValue({ id: subfield.id, value: val, rowIndex: rowIndex }, origin); }},nativeOn:{"keyup":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"delete",[8,46],$event.key,["Backspace","Delete","Del"])){ return null; }return _vm.onDeleteKey(rowIndex, subfield.id)}}},'BlitzField',subfield,false))}),1)})],2)}
var BlitzMiniFormvue_type_template_id_17c0bfe5_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzMiniForm.vue?vue&type=template&id=17c0bfe5&

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzMiniForm.vue?vue&type=script&lang=js&


//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
function BlitzMiniFormvue_type_script_lang_js_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}





/**
With BlitzMiniForm you can pass a "schema" just like a BlitzForm. The difference is that BlitzMiniForm is more like a (as the name says) "mini" form. 

The "schema" you specify is shown as a single row. New rows are added automatically on user input.`,
 */

/* harmony default export */ var BlitzMiniFormvue_type_script_lang_js_ = ({
  name: 'BlitzMiniForm',
  inheritAttrs: false,
  components: {
    BlitzField: BlitzField
  },
  props: {
    // prop categories: behavior content general model state style

    /**
     * @category model
     */
    value: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    // EF props:

    /**
     * This is the information on the columns you want to be shown. An array of objects just like a BlitzForm.
     * @category content
     */
    schema: {
      type: Array,
      default: function _default() {
        return [{
          component: 'QInput'
        }];
      },
      examples: ["[{label: 'Amount', id: 'amount', component: 'QInput', type: 'number'}, {label: 'Currency', id: 'curr', component: 'QSelect', options: [{label: 'USD', value: 'usd'}]}]"]
    },

    /**
     * A list of prop (attribute) names to be passed on to each single BlitzField generated in the mini form.
     *
     * This is useful when you want to use Evaluated Props in the schema of the mine form but need information from the top level BlitzForm.
     * @category content
     */
    attrsToPass: {
      type: Array,
      default: function _default() {
        return ['formData', 'formDataFlat', 'formId', 'mode', 'fieldInput', 'lang'];
      },
      examples: ["['formData', 'mode', 'myCustomProp']"]
    },

    /**
     * Allows to limit the max amount of rows.
     * @category content
     */
    maxRows: {
      type: Number
    },
    // props of which to inherit "description" etc. from BlitzField:
    disable: {
      type: Boolean
    },
    readonly: {
      type: Boolean
    }
  },
  computed: {
    cValue: {
      get: function get() {
        var value = this.value,
            schema = this.schema,
            disable = this.disable,
            readonly = this.readonly,
            maxRows = this.maxRows;
        var emptyRow = schema.reduce(function (carry, _ref) {
          var id = _ref.id;
          return Object.assign({}, carry, BlitzMiniFormvue_type_script_lang_js_defineProperty({}, id, undefined));
        }, {});

        if (!disable && !readonly && (!index_esm_isNumber(maxRows) || maxRows > value.length)) {
          return value.concat([emptyRow]);
        }

        return value;
      },
      set: function set(val) {
        this.$emit('input', val);
      }
    },
    miniFormAttrsToPass: function miniFormAttrsToPass() {
      var attrsToPass = this.attrsToPass,
          getPropOrAttrOrParentProp = this.getPropOrAttrOrParentProp;
      return attrsToPass.reduce(function (carry, attrKey) {
        carry[attrKey] = getPropOrAttrOrParentProp(attrKey);
        return carry;
      }, {});
    },
    cSchema: function cSchema() {
      var schema = this.schema,
          disable = this.disable,
          readonly = this.readonly,
          miniFormAttrsToPass = this.miniFormAttrsToPass;
      return schema.map(function (subfield) {
        return Object(index_esm["a" /* merge */])(miniFormAttrsToPass, {
          disable: disable,
          readonly: readonly
        }, subfield, {
          label: '',
          subLabel: ''
        });
      });
    },
    schemaLabels: function schemaLabels() {
      var schema = this.schema,
          miniFormAttrsToPass = this.miniFormAttrsToPass;
      return schema.map(function (subfield) {
        return Object(index_esm["a" /* merge */])(miniFormAttrsToPass, subfield, {
          component: undefined
        });
      });
    },
    gridTemplateColumnsCalculated: function gridTemplateColumnsCalculated() {
      var schema = this.schema;
      return schema.reduce(function (total, field) {
        var fr = Number(field.span);
        if (index_esm_isNumber(fr)) return "".concat(total, " ").concat(fr, "fr");
        return "".concat(total, " ").concat(field.span || '1fr');
      }, '');
    }
  },
  methods: {
    getPropOrAttrOrParentProp: function getPropOrAttrOrParentProp(propKey) {
      if (propKey in this) return this[propKey];
      if (propKey in this.$attrs) return this.$attrs[propKey];
      if (propKey in this.$parent) return this.$parent[propKey];
      return this.$parent.$parent[propKey];
    },
    deleteRow: function deleteRow(rowIndex) {
      var value = this.value;
      var allRows = copy(value);
      if (allRows[rowIndex] === undefined) return;
      allRows.splice(rowIndex, 1);
      this.$emit('input', allRows);
    },
    setSubFieldValue: function setSubFieldValue(_ref2, origin) {
      var id = _ref2.id,
          newValue = _ref2.value,
          rowIndex = _ref2.rowIndex; // do not emit when the origin is from the default value initialisation

      if (origin === 'default') return;
      var oldValue = this.value;
      var allRows = copy(oldValue);
      if (allRows[rowIndex] === undefined) this.$set(allRows, rowIndex, {});
      allRows[rowIndex][id] = newValue;
      this.$emit('input', allRows);
    },
    onDeleteKey: function onDeleteKey(rowIndex, fieldId) {
      var value = this.value,
          deleteRow = this.deleteRow;
      var allRows = value;
      var row = allRows[rowIndex];
      if (!row) return;

      if (Object.keys(row).every(function (key) {
        return row[key] === '' || row[key] === 0;
      })) {
        deleteRow(rowIndex);
      }
    }
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzMiniForm.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_BlitzMiniFormvue_type_script_lang_js_ = (BlitzMiniFormvue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzMiniForm.vue?vue&type=style&index=0&lang=css&
var BlitzMiniFormvue_type_style_index_0_lang_css_ = __webpack_require__("c918");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/components/BlitzMiniForm.vue






/* normalize component */

var BlitzMiniForm_component = Object(componentNormalizer["a" /* default */])(
  components_BlitzMiniFormvue_type_script_lang_js_,
  BlitzMiniFormvue_type_template_id_17c0bfe5_render,
  BlitzMiniFormvue_type_template_id_17c0bfe5_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var BlitzMiniForm = (BlitzMiniForm_component.exports);
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@blitzar/form/dist/index.js






/* harmony default export */ var dist = ({
  BlitzForm: BlitzForm,
  BlitzField: BlitzField,
  BlitzH: BlitzH,
  BlitzMiniForm: BlitzMiniForm,
  validateFormPerSchema: validateFormPerSchema,
  install: function install(Vue) {
    Vue.component(BlitzField.name, BlitzField);
    Vue.component(BlitzForm.name, BlitzForm);
    Vue.component(BlitzH.name, BlitzH);
    Vue.component(BlitzMiniForm.name, BlitzMiniForm);
  }
});
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/node_modules/is-what/dist/index.esm.js
var is_what_dist_index_esm = __webpack_require__("7dfd");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/index.js + 32 modules
var atoms_dist = __webpack_require__("9d47");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/components/atoms/CategoryPanel.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//



 // used in BlitzForm

vue_runtime_esm["default"].component('PlanetarInput', atoms_dist["b" /* PlanetarInput */]);
vue_runtime_esm["default"].component('PlanetarToggle', atoms_dist["f" /* PlanetarToggle */]);
vue_runtime_esm["default"].component('PlanetarSelect', atoms_dist["d" /* PlanetarSelect */]);
/* harmony default export */ var CategoryPanelvue_type_script_lang_js_ = ({
  name: 'CategoryPanel',
  components: {
    BlitzForm: BlitzForm
  },
  props: {
    schema: {
      type: Array,
      required: true
    },

    /**
     * @type {'edit' | 'view' | 'raw'}
     */
    mode: {
      type: String,
      default: 'edit'
    }
  },
  data: function data() {
    return {};
  },
  computed: {
    schemaCalculated: function schemaCalculated() {
      if (this.mode === 'edit') return this.schema;
      return this.schema.map(function (s) {
        return Object.assign({}, s, {
          component: undefined
        });
      });
    }
  },
  methods: {
    isPlainObject: is_what_dist_index_esm["c" /* isPlainObject */]
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/components/atoms/CategoryPanel.vue?vue&type=script&lang=js&
 /* harmony default export */ var atoms_CategoryPanelvue_type_script_lang_js_ = (CategoryPanelvue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/components/atoms/CategoryPanel.vue?vue&type=style&index=0&lang=css&
var CategoryPanelvue_type_style_index_0_lang_css_ = __webpack_require__("36cb");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/color/QColor.js + 3 modules
var QColor = __webpack_require__("dfd0");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/components/atoms/CategoryPanel.vue






/* normalize component */

var CategoryPanel_component = Object(componentNormalizer["a" /* default */])(
  atoms_CategoryPanelvue_type_script_lang_js_,
  CategoryPanelvue_type_template_id_26f0da30_render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var CategoryPanel = __webpack_exports__["a"] = (CategoryPanel_component.exports);



runtime_auto_import_default()(CategoryPanel_component, 'components', {QField: QField["a" /* default */],QColor: QColor["a" /* default */]});


/***/ }),

/***/ "1411":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ca22");
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("9869");
/* harmony import */ var _mixins_dark_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("87b2");
/* harmony import */ var _mixins_panel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("217b");




/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_1__["default"].extend({
  name: 'QTabPanels',
  mixins: [_mixins_dark_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], _mixins_panel_js__WEBPACK_IMPORTED_MODULE_3__[/* PanelParentMixin */ "b"]],
  computed: {
    classes() {
      return 'q-tab-panels q-panel-parent' + (this.isDark === true ? ' q-tab-panels--dark q-dark' : '');
    }

  },
  methods: {
    __renderPanels(h) {
      return h('div', {
        class: this.classes,
        directives: this.panelDirectives,
        on: _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.qListeners)
      }, this.__getPanelContent(h));
    }

  }
}));

/***/ }),

/***/ "1515":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("8d0f");
/* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("918c");
/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("32f5");
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_array_reduce_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("28eb");
/* harmony import */ var core_js_modules_es_array_reduce_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_reduce_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _planetar_atoms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("9d47");
/* harmony import */ var _atoms_CategoryPanel_vue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("13a5");
/* harmony import */ var quasar_src_components_tab_panels_QTabPanels_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("1411");
/* harmony import */ var quasar_src_components_tab_panels_QTabPanel_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("1d98");
/* harmony import */ var is_what__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("7dfd");
/* harmony import */ var case_anything__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("9c21");
/* harmony import */ var merge_anything__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("502a");
/* harmony import */ var _helpers_vueDocgenToBlitzForm__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("9163");
/* harmony import */ var _planetar_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("4173");
/* harmony import */ var _helpers_errors__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("bb1b");
/* harmony import */ var _types_vueDocgen_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("eca6");
/* harmony import */ var _types_vueDocgen_js__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_types_vueDocgen_js__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _helpers_evaluateString__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("8c14");





//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}



;








var FIXED_CATS = {
  description: 'description',
  slots: 'slots',
  events: 'events',
  methods: 'methods'
};
var fixedCategoryNames = Object.values(FIXED_CATS);

var fixedCatToCustomTag = function fixedCatToCustomTag(cat) {
  return {
    tags: {
      category: [{
        description: cat,
        title: 'category'
      }]
    }
  };
};

function getCategoryPlanetarListItems(categorySchemaMap) {
  // fixed cats
  var fixedCategories = fixedCategoryNames.filter(function (c) {
    return Object(is_what__WEBPACK_IMPORTED_MODULE_8__[/* isArray */ "a"])(categorySchemaMap[c]) && categorySchemaMap[c].length;
  }).map(function (c, i) {
    return {
      name: c,
      tag: i === 0 ? undefined : categorySchemaMap[c].length
    };
  }); // divider

  if (fixedCategories.length) {
    fixedCategories.push({
      name: 'props',
      isDivider: true
    });
  } // prop cats


  var propCategories = Object.keys(categorySchemaMap).filter(function (c) {
    return !fixedCategoryNames.includes(c);
  }).map(function (c) {
    return {
      name: c,
      tag: categorySchemaMap[c].length
    };
  });
  return fixedCategories.concat(propCategories);
}
/**
 * @param {string} hay
 * @param {string} needle
 * @returns {boolean}
 */


function checkIfContains(hay, needle) {
  return Object(is_what__WEBPACK_IMPORTED_MODULE_8__[/* isString */ "d"])(hay) && hay.toLowerCase().includes(needle.toLowerCase());
}

/* harmony default export */ __webpack_exports__["a"] = ({
  name: 'ApiCard',
  components: {
    PlanetarInput: _planetar_atoms__WEBPACK_IMPORTED_MODULE_4__[/* PlanetarInput */ "b"],
    PlanetarList: _planetar_atoms__WEBPACK_IMPORTED_MODULE_4__[/* PlanetarList */ "c"],
    QTabPanels: quasar_src_components_tab_panels_QTabPanels_js__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"],
    QTabPanel: quasar_src_components_tab_panels_QTabPanel_js__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"],
    CategoryPanel: _atoms_CategoryPanel_vue__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]
  },
  props: {
    /**
     * Relative from the `src` folder.
     * @example 'components/atoms/MyBtn.vue'
     */
    filePath: {
      type: String,
      required: true
    },

    /**
     * The props object to be synced with whatever can be written in the API Card input fields
     * This object will be evaluated before emited via $emit('input', parse(value))
     * If `undefined` no edit controls will be shown, and the ApiCard will just work like a static information card.
     */
    value: {
      type: [Object, undefined],
      default: undefined
    }
  },
  created: function created() {
    var filePath = this.filePath,
        parseVueDocgenData = this.parseVueDocgenData;
    var extension = filePath.split('.').slice(-1)[0];
    Object(_planetar_utils__WEBPACK_IMPORTED_MODULE_12__[/* dynamicImport */ "a"])(filePath, extension, 'vue-docgen').then(function (vueDocgenData) {
      return parseVueDocgenData(vueDocgenData);
    }); // prettier-ignore
  },
  data: function data() {
    var propsSeparateTab = this.propsSeparateTab,
        filePath = this.filePath;
    var fileName = filePath.split('/').slice(-1)[0].replace('.vue', '').replace('.jsx', '').replace('.tsx', '');
    return {
      fileName: fileName,
      searchValue: '',
      activeTab: '',

      /**
       * @type {{ [category: string]: object[] }}
       */
      categorySchemaMap: {}
    };
  },
  computed: {
    propsObject: {
      get: function get() {
        return this.value;
      },
      set: function set(newValue) {
        this.$emit('input', newValue);
      }
    },
    categorySchemaMapFiltered: function categorySchemaMapFiltered() {
      var categorySchemaMap = this.categorySchemaMap,
          s = this.searchValue;
      if (!s) return categorySchemaMap;
      return Object.entries(categorySchemaMap).reduce(function (carry, _ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            category = _ref2[0],
            schema = _ref2[1];

        var searchIncludesCategory = checkIfContains(category, s);

        if (category === FIXED_CATS.description || searchIncludesCategory) {
          carry[category] = schema;
          return carry;
        }

        var check = function check(_ref3) {
          var label = _ref3.label,
              subLabel = _ref3.subLabel;
          return checkIfContains(label, s) || checkIfContains(subLabel, s);
        };

        var schemaFiltered = schema.filter(check);

        if (schemaFiltered.length) {
          carry[category] = schemaFiltered;
        }

        return carry;
      }, {});
    },

    /**
     * @type {{ name: string, isDivider?: boolean }[]}
     */
    categoryPlanetarListItems: function categoryPlanetarListItems() {
      var categorySchemaMapFiltered = this.categorySchemaMapFiltered;
      return getCategoryPlanetarListItems(categorySchemaMapFiltered);
    }
  },
  methods: {
    isPlainObject: is_what__WEBPACK_IMPORTED_MODULE_8__[/* isPlainObject */ "c"],
    kebabCase: case_anything__WEBPACK_IMPORTED_MODULE_9__[/* kebabCase */ "a"],

    /**
     * @param {ComponentDoc} vueDocgenData
     */
    parseVueDocgenData: function parseVueDocgenData() {
      var _this = this;

      var vueDocgenData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (process && process.env && false) console.log("vueDocgenData \u2192 ", vueDocgenData);
      var categorySchemaMap = this.categorySchemaMap,
          getExample = this.getExample,
          value = this.value;
      var modelToEmit = Object.assign({}, value);
      var description = vueDocgenData.description,
          _vueDocgenData$props = vueDocgenData.props,
          props = _vueDocgenData$props === void 0 ? [] : _vueDocgenData$props,
          _vueDocgenData$method = vueDocgenData.methods,
          methods = _vueDocgenData$method === void 0 ? [] : _vueDocgenData$method,
          _vueDocgenData$slots = vueDocgenData.slots,
          slots = _vueDocgenData$slots === void 0 ? [] : _vueDocgenData$slots,
          _vueDocgenData$events = vueDocgenData.events,
          events = _vueDocgenData$events === void 0 ? [] : _vueDocgenData$events,
          _vueDocgenData$tags = vueDocgenData.tags,
          componentJSDocTags = _vueDocgenData$tags === void 0 ? {} : _vueDocgenData$tags;

      if (Object(is_what__WEBPACK_IMPORTED_MODULE_8__[/* isFullString */ "b"])(description)) {
        this.$set(categorySchemaMap, FIXED_CATS.description, [{
          subLabel: description
        }]);
      }

      var fixedCats = [].concat(_toConsumableArray(slots.map(function (s) {
        return Object(merge_anything__WEBPACK_IMPORTED_MODULE_10__[/* mergeAndConcat */ "b"])(s, fixedCatToCustomTag(FIXED_CATS.slots));
      })), _toConsumableArray(events.map(function (e) {
        return Object(merge_anything__WEBPACK_IMPORTED_MODULE_10__[/* mergeAndConcat */ "b"])(e, fixedCatToCustomTag(FIXED_CATS.events));
      })), _toConsumableArray(methods.map(function (m) {
        return Object(merge_anything__WEBPACK_IMPORTED_MODULE_10__[/* mergeAndConcat */ "b"])(m, fixedCatToCustomTag(FIXED_CATS.methods));
      })));
      [].concat(_toConsumableArray(props), _toConsumableArray(fixedCats)).forEach(function (prop
      /* PropDescriptor */
      , index) {
        var schemaInfo = Object(_helpers_vueDocgenToBlitzForm__WEBPACK_IMPORTED_MODULE_11__[/* propToPropSchema */ "a"])(prop);
        var categories = schemaInfo.categories,
            schema = schemaInfo.schema; // only add to `modelToEmit` if it's an actual prop.

        var isProp = index < props.length;

        if (isProp) {
          if (schema.defaultValue !== undefined) {
            var ex = getExample(prop);
            modelToEmit[schema.id] = ex !== undefined ? ex : schema.defaultValue;
          }

          if (schema.defaultValue === undefined) {
            modelToEmit[schema.id] = getExample(prop, prop.required);
          }
        }

        categories.forEach(function (category) {
          if (!(category in categorySchemaMap)) _this.$set(categorySchemaMap, category, []);
          categorySchemaMap[category].push(schema);
        });
      }); // use top level example props for generating api-card example

      var _componentJSDocTags$e = componentJSDocTags.examples,
          examples = _componentJSDocTags$e === void 0 ? [] : _componentJSDocTags$e;

      if (examples.length) {
        try {
          var propsForApiCardExample = Object(_helpers_evaluateString__WEBPACK_IMPORTED_MODULE_15__[/* evaluateString */ "b"])(examples[0].content);
          Object.entries(propsForApiCardExample).forEach(function (_ref4) {
            var _ref5 = _slicedToArray(_ref4, 2),
                k = _ref5[0],
                v = _ref5[1];

            return modelToEmit[k] = v;
          });
        } catch (error) {}
      }

      this.$emit('input', modelToEmit);
      this.$emit('mounted');
      this.$nextTick(function () {
        if (!_this.activeTab) _this.activeTab = (_this.categoryPlanetarListItems[0] || {}).name || '';
      });
    },

    /**
     * @param {PropDescriptor} prop
     * @param {boolean} isRequired if not required it will not throw an error
     * @returns {*}
     */
    getExample: function getExample(prop, isRequired) {
      var name = prop.name,
          tags = prop.tags;

      try {
        var example = tags.example;
        var defaultValue = example[0].description;
        return defaultValue;
      } catch (error) {
        if (!isRequired) return;
        console.error(_helpers_errors__WEBPACK_IMPORTED_MODULE_13__[/* noRequiredPropExampleErrorMsg */ "a"]);
      }
    }
  }
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("07d9")))

/***/ }),

/***/ "157c":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("7526");

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};


/***/ }),

/***/ "1608":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@babel/runtime/helpers/objectSpread2.js
var objectSpread2 = __webpack_require__("ca22");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2);

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue/dist/vue.runtime.esm.js
var vue_runtime_esm = __webpack_require__("9869");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/dialog/QDialog.js + 2 modules
var QDialog = __webpack_require__("e81c");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/btn/QBtn.js + 1 modules
var QBtn = __webpack_require__("2ef0");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/clone.js
/* harmony default export */ var clone = (function (data) {
  const s = JSON.stringify(data);

  if (s) {
    return JSON.parse(s);
  }
});
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/key-composition.js
var key_composition = __webpack_require__("1b63");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.array.flat.js
var es_array_flat = __webpack_require__("ba53");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/dark.js
var dark = __webpack_require__("87b2");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/tag.js
var tag = __webpack_require__("5cad");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/listeners.js
var listeners = __webpack_require__("0fb0");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/slot.js
var slot = __webpack_require__("a4b3");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/card/QCard.js







/* harmony default export */ var QCard = (vue_runtime_esm["default"].extend({
  name: 'QCard',
  mixins: [listeners["a" /* default */], dark["a" /* default */], tag["a" /* default */]],
  props: {
    square: Boolean,
    flat: Boolean,
    bordered: Boolean
  },
  computed: {
    classes() {
      return 'q-card' + (this.isDark === true ? ' q-card--dark q-dark' : '') + (this.bordered === true ? ' q-card--bordered' : '') + (this.square === true ? ' q-card--square no-border-radius' : '') + (this.flat === true ? ' q-card--flat no-shadow' : '');
    }

  },

  render(h) {
    return h(this.tag, {
      class: this.classes,
      on: objectSpread2_default()({}, this.qListeners)
    }, Object(slot["c" /* slot */])(this, 'default'));
  }

}));
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/card/QCardSection.js





/* harmony default export */ var QCardSection = (vue_runtime_esm["default"].extend({
  name: 'QCardSection',
  mixins: [listeners["a" /* default */], tag["a" /* default */]],
  props: {
    horizontal: Boolean
  },
  computed: {
    classes() {
      return 'q-card__section ' + `q-card__section--${this.horizontal === true ? 'horiz row no-wrap' : 'vert'}`;
    }

  },

  render(h) {
    return h(this.tag, {
      class: this.classes,
      on: objectSpread2_default()({}, this.qListeners)
    }, Object(slot["c" /* slot */])(this, 'default'));
  }

}));
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/align.js
var align = __webpack_require__("d23a");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/card/QCardActions.js





/* harmony default export */ var QCardActions = (vue_runtime_esm["default"].extend({
  name: 'QCardActions',
  mixins: [listeners["a" /* default */], align["a" /* default */]],
  props: {
    vertical: Boolean
  },
  computed: {
    classes() {
      return `q-card__actions--${this.vertical === true ? 'vert column' : 'horiz row'} ${this.alignClass}`;
    }

  },

  render(h) {
    return h('div', {
      staticClass: 'q-card__actions',
      class: this.classes,
      on: objectSpread2_default()({}, this.qListeners)
    }, Object(slot["c" /* slot */])(this, 'default'));
  }

}));
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/separator/QSeparator.js




const insetMap = {
  true: 'inset',
  item: 'item-inset',
  'item-thumbnail': 'item-thumbnail-inset'
};
const margins = {
  xs: 2,
  sm: 4,
  md: 8,
  lg: 16,
  xl: 24
};
/* harmony default export */ var QSeparator = (vue_runtime_esm["default"].extend({
  name: 'QSeparator',
  mixins: [dark["a" /* default */], listeners["a" /* default */]],
  props: {
    spaced: [Boolean, String],
    inset: [Boolean, String],
    vertical: Boolean,
    color: String,
    size: String
  },
  computed: {
    orientation() {
      return this.vertical === true ? 'vertical' : 'horizontal';
    },

    classPrefix() {
      return ` q-separator--${this.orientation}`;
    },

    insetClass() {
      return this.inset !== false ? `${this.classPrefix}-${insetMap[this.inset]}` : '';
    },

    classes() {
      return `q-separator${this.classPrefix}${this.insetClass}` + (this.color !== void 0 ? ` bg-${this.color}` : '') + (this.isDark === true ? ' q-separator--dark' : '');
    },

    style() {
      const style = {};

      if (this.size !== void 0) {
        style[this.vertical === true ? 'width' : 'height'] = this.size;
      }

      if (this.spaced !== false) {
        const size = this.spaced === true ? `${margins.md}px` : this.spaced in margins ? `${margins[this.spaced]}px` : this.spaced;
        const props = this.vertical === true ? ['Left', 'Right'] : ['Top', 'Bottom'];
        style[`margin${props[0]}`] = style[`margin${props[1]}`] = size;
      }

      return style;
    },

    attrs() {
      return {
        role: 'separator',
        'aria-orientation': this.orientation
      };
    }

  },

  render(h) {
    return h('hr', {
      staticClass: 'q-separator',
      class: this.classes,
      style: this.style,
      attrs: this.attrs,
      on: objectSpread2_default()({}, this.qListeners)
    });
  }

}));
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/input/QInput.js + 2 modules
var QInput = __webpack_require__("bc74");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/option-size.js
var option_size = __webpack_require__("1194");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/form.js
var mixins_form = __webpack_require__("87c8");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/refocus-target.js
var refocus_target = __webpack_require__("6a94");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("9ac9");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/cache.js
var cache = __webpack_require__("6459");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/radio/QRadio.js








/* harmony default export */ var QRadio = (vue_runtime_esm["default"].extend({
  name: 'QRadio',
  mixins: [dark["a" /* default */], option_size["a" /* default */], mixins_form["b" /* default */], refocus_target["a" /* default */]],
  props: {
    value: {
      required: true
    },
    val: {
      required: true
    },
    label: String,
    leftLabel: Boolean,
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    disable: Boolean,
    tabindex: [String, Number]
  },
  computed: {
    isTrue() {
      return this.value === this.val;
    },

    classes() {
      return 'q-radio cursor-pointer no-outline row inline no-wrap items-center' + (this.disable === true ? ' disabled' : '') + (this.isDark === true ? ' q-radio--dark' : '') + (this.dense === true ? ' q-radio--dense' : '') + (this.leftLabel === true ? ' reverse' : '');
    },

    innerClass() {
      const color = this.color !== void 0 && (this.keepColor === true || this.isTrue === true) ? ` text-${this.color}` : '';
      return `q-radio__inner--${this.isTrue === true ? 'truthy' : 'falsy'}${color}`;
    },

    computedTabindex() {
      return this.disable === true ? -1 : this.tabindex || 0;
    },

    formAttrs() {
      const prop = {
        type: 'radio'
      };
      this.name !== void 0 && Object.assign(prop, {
        name: this.name,
        value: this.val
      });
      return prop;
    },

    formDomProps() {
      if (this.name !== void 0 && this.isTrue === true) {
        return {
          checked: true
        };
      }
    },

    attrs() {
      const attrs = {
        tabindex: this.computedTabindex,
        role: 'radio',
        'aria-label': this.label,
        'aria-checked': this.isTrue === true ? 'true' : 'false'
      };

      if (this.disable === true) {
        attrs['aria-disabled'] = 'true';
      }

      return attrs;
    }

  },
  methods: {
    set(e) {
      if (e !== void 0) {
        Object(utils_event["l" /* stopAndPrevent */])(e);

        this.__refocusTarget(e);
      }

      if (this.disable !== true && this.isTrue !== true) {
        this.$emit('input', this.val, e);
      }
    }

  },

  render(h) {
    const content = [h('svg', {
      staticClass: 'q-radio__bg absolute non-selectable',
      attrs: {
        focusable: 'false'
        /* needed for IE11 */
        ,
        viewBox: '0 0 24 24',
        'aria-hidden': 'true'
      }
    }, [h('path', {
      attrs: {
        d: 'M12,22a10,10 0 0 1 -10,-10a10,10 0 0 1 10,-10a10,10 0 0 1 10,10a10,10 0 0 1 -10,10m0,-22a12,12 0 0 0 -12,12a12,12 0 0 0 12,12a12,12 0 0 0 12,-12a12,12 0 0 0 -12,-12'
      }
    }), h('path', {
      staticClass: 'q-radio__check',
      attrs: {
        d: 'M12,6a6,6 0 0 0 -6,6a6,6 0 0 0 6,6a6,6 0 0 0 6,-6a6,6 0 0 0 -6,-6'
      }
    })])];
    this.disable !== true && this.__injectFormInput(content, 'unshift', 'q-radio__native q-ma-none q-pa-none');
    const child = [h('div', {
      staticClass: 'q-radio__inner relative-position',
      class: this.innerClass,
      style: this.sizeStyle
    }, content)];

    if (this.__refocusTargetEl !== void 0) {
      child.push(this.__refocusTargetEl);
    }

    const label = this.label !== void 0 ? Object(slot["a" /* mergeSlot */])([this.label], this, 'default') : Object(slot["c" /* slot */])(this, 'default');
    label !== void 0 && child.push(h('div', {
      staticClass: 'q-radio__label q-anchor--skip'
    }, label));
    return h('div', {
      class: this.classes,
      attrs: this.attrs,
      on: Object(cache["b" /* default */])(this, 'inpExt', {
        click: this.set,
        keydown: e => {
          if (e.keyCode === 13 || e.keyCode === 32) {
            Object(utils_event["l" /* stopAndPrevent */])(e);
          }
        },
        keyup: e => {
          if (e.keyCode === 13 || e.keyCode === 32) {
            this.set(e);
          }
        }
      })
    }, child);
  }

}));
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/checkbox.js
var mixins_checkbox = __webpack_require__("3abb");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/checkbox/QCheckbox.js


/* harmony default export */ var QCheckbox = (vue_runtime_esm["default"].extend({
  name: 'QCheckbox',
  mixins: [mixins_checkbox["a" /* default */]],
  methods: {
    __getInner(h) {
      return [h('div', {
        staticClass: 'q-checkbox__bg absolute'
      }, [h('svg', {
        staticClass: 'q-checkbox__svg fit absolute-full',
        attrs: {
          focusable: 'false'
          /* needed for IE11 */
          ,
          viewBox: '0 0 24 24',
          'aria-hidden': 'true'
        }
      }, [h('path', {
        staticClass: 'q-checkbox__truthy',
        attrs: {
          fill: 'none',
          d: 'M1.73,12.91 8.1,19.28 22.79,4.59'
        }
      }), h('path', {
        staticClass: 'q-checkbox__indet',
        attrs: {
          d: 'M4,14H20V10H4'
        }
      })])])];
    }

  },

  created() {
    this.type = 'checkbox';
  }

}));
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/toggle/QToggle.js
var QToggle = __webpack_require__("3d3c");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/option-group/QOptionGroup.js








const components = {
  radio: QRadio,
  checkbox: QCheckbox,
  toggle: QToggle["a" /* default */]
};
const typeValues = Object.keys(components);
/* harmony default export */ var QOptionGroup = (vue_runtime_esm["default"].extend({
  name: 'QOptionGroup',
  mixins: [dark["a" /* default */], listeners["a" /* default */]],
  props: {
    value: {
      required: true
    },
    options: {
      type: Array,

      validator(opts) {
        return opts.every(opt => 'value' in opt && 'label' in opt);
      }

    },
    name: String,
    type: {
      default: 'radio',
      validator: v => typeValues.includes(v)
    },
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    size: String,
    leftLabel: Boolean,
    inline: Boolean,
    disable: Boolean
  },
  computed: {
    component() {
      return components[this.type];
    },

    model() {
      return Array.isArray(this.value) ? this.value.slice() : this.value;
    },

    classes() {
      return 'q-option-group q-gutter-x-sm' + (this.inline === true ? ' q-option-group--inline' : '');
    },

    attrs() {
      if (this.type === 'radio') {
        const attrs = {
          role: 'radiogroup'
        };

        if (this.disable === true) {
          attrs['aria-disabled'] = 'true';
        }

        return attrs;
      }
    }

  },
  methods: {
    __update(value) {
      this.$emit('input', value);
    }

  },

  created() {
    const isArray = Array.isArray(this.value);

    if (this.type === 'radio') {
      if (isArray) {
        console.error('q-option-group: model should not be array');
      }
    } else if (isArray === false) {
      console.error('q-option-group: model should be array in your case');
    }
  },

  render(h) {
    return h('div', {
      class: this.classes,
      attrs: this.attrs,
      on: objectSpread2_default()({}, this.qListeners)
    }, this.options.map(opt => h('div', [h(this.component, {
      props: {
        value: this.value,
        val: opt.value,
        name: opt.name === void 0 ? this.name : opt.name,
        disable: this.disable || opt.disable,
        label: opt.label,
        leftLabel: opt.leftLabel === void 0 ? this.leftLabel : opt.leftLabel,
        color: opt.color === void 0 ? this.color : opt.color,
        checkedIcon: opt.checkedIcon,
        uncheckedIcon: opt.uncheckedIcon,
        dark: opt.dark || this.isDark,
        size: opt.size === void 0 ? this.size : opt.size,
        dense: this.dense,
        keepColor: opt.keepColor === void 0 ? this.keepColor : opt.keepColor
      },
      on: Object(cache["b" /* default */])(this, 'inp', {
        input: this.__update
      })
    })])));
  }

}));
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/spinner/QSpinner.js + 1 modules
var QSpinner = __webpack_require__("9cbe");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/attrs.js
var mixins_attrs = __webpack_require__("ffad");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/dialog-plugin/DialogPlugin.js
















/* harmony default export */ var DialogPlugin = (vue_runtime_esm["default"].extend({
  name: 'DialogPlugin',
  mixins: [dark["a" /* default */], mixins_attrs["b" /* default */]],
  inheritAttrs: false,
  props: {
    title: String,
    message: String,
    prompt: Object,
    options: Object,
    progress: [Boolean, Object],
    html: Boolean,
    ok: {
      type: [String, Object, Boolean],
      default: true
    },
    cancel: [String, Object, Boolean],
    focus: {
      type: String,
      default: 'ok',
      validator: v => ['ok', 'cancel', 'none'].includes(v)
    },
    stackButtons: Boolean,
    color: String,
    cardClass: [String, Array, Object],
    cardStyle: [String, Array, Object]
  },
  computed: {
    classes() {
      return 'q-dialog-plugin' + (this.isDark === true ? ' q-dialog-plugin--dark q-dark' : '') + (this.progress !== false ? ' q-dialog-plugin--progress' : '');
    },

    spinner() {
      if (this.progress !== false) {
        return Object(this.progress) === this.progress ? {
          component: this.progress.spinner || QSpinner["a" /* default */],
          props: {
            color: this.progress.color || this.vmColor
          }
        } : {
          component: QSpinner["a" /* default */],
          props: {
            color: this.vmColor
          }
        };
      }
    },

    hasForm() {
      return this.prompt !== void 0 || this.options !== void 0;
    },

    okLabel() {
      return Object(this.ok) === this.ok ? this.$q.lang.label.ok : this.ok === true ? this.$q.lang.label.ok : this.ok;
    },

    cancelLabel() {
      return Object(this.cancel) === this.cancel ? this.$q.lang.label.cancel : this.cancel === true ? this.$q.lang.label.cancel : this.cancel;
    },

    vmColor() {
      return this.color || (this.isDark === true ? 'amber' : 'primary');
    },

    okDisabled() {
      if (this.prompt !== void 0) {
        return this.prompt.isValid !== void 0 && this.prompt.isValid(this.prompt.model) !== true;
      }

      if (this.options !== void 0) {
        return this.options.isValid !== void 0 && this.options.isValid(this.options.model) !== true;
      }
    },

    okProps() {
      return objectSpread2_default()(objectSpread2_default()({
        color: this.vmColor,
        label: this.okLabel,
        ripple: false
      }, Object(this.ok) === this.ok ? this.ok : {
        flat: true
      }), {}, {
        disable: this.okDisabled
      });
    },

    cancelProps() {
      return objectSpread2_default()({
        color: this.vmColor,
        label: this.cancelLabel,
        ripple: false
      }, Object(this.cancel) === this.cancel ? this.cancel : {
        flat: true
      });
    }

  },
  methods: {
    show() {
      this.$refs.dialog.show();
    },

    hide() {
      this.$refs.dialog.hide();
    },

    getPrompt(h) {
      return [h(QInput["a" /* default */], {
        props: {
          value: this.prompt.model,
          type: this.prompt.type,
          label: this.prompt.label,
          stackLabel: this.prompt.stackLabel,
          outlined: this.prompt.outlined,
          filled: this.prompt.filled,
          standout: this.prompt.standout,
          rounded: this.prompt.rounded,
          square: this.prompt.square,
          counter: this.prompt.counter,
          maxlength: this.prompt.maxlength,
          prefix: this.prompt.prefix,
          suffix: this.prompt.suffix,
          color: this.vmColor,
          dense: true,
          autofocus: true,
          dark: this.isDark
        },
        attrs: this.prompt.attrs,
        on: Object(cache["b" /* default */])(this, 'prompt', {
          input: v => {
            this.prompt.model = v;
          },
          keyup: evt => {
            // if ENTER key
            if (this.okDisabled !== true && this.prompt.type !== 'textarea' && Object(key_composition["a" /* isKeyCode */])(evt, 13) === true) {
              this.onOk();
            }
          }
        })
      })];
    },

    getOptions(h) {
      return [h(QOptionGroup, {
        props: {
          value: this.options.model,
          type: this.options.type,
          color: this.vmColor,
          inline: this.options.inline,
          options: this.options.items,
          dark: this.isDark
        },
        on: Object(cache["b" /* default */])(this, 'opts', {
          input: v => {
            this.options.model = v;
          }
        })
      })];
    },

    getButtons(h) {
      const child = [];
      this.cancel && child.push(h(QBtn["a" /* default */], {
        props: this.cancelProps,
        attrs: {
          'data-autofocus': this.focus === 'cancel' && this.hasForm !== true
        },
        on: Object(cache["b" /* default */])(this, 'cancel', {
          click: this.onCancel
        })
      }));
      this.ok && child.push(h(QBtn["a" /* default */], {
        props: this.okProps,
        attrs: {
          'data-autofocus': this.focus === 'ok' && this.hasForm !== true
        },
        on: Object(cache["b" /* default */])(this, 'ok', {
          click: this.onOk
        })
      }));

      if (child.length > 0) {
        return h(QCardActions, {
          staticClass: this.stackButtons === true ? 'items-end' : null,
          props: {
            vertical: this.stackButtons,
            align: 'right'
          }
        }, child);
      }
    },

    onOk() {
      this.$emit('ok', clone(this.getData()));
      this.hide();
    },

    onCancel() {
      this.hide();
    },

    getData() {
      return this.prompt !== void 0 ? this.prompt.model : this.options !== void 0 ? this.options.model : void 0;
    },

    getSection(h, staticClass, text) {
      return this.html === true ? h(QCardSection, {
        staticClass,
        domProps: {
          innerHTML: text
        }
      }) : h(QCardSection, {
        staticClass
      }, [text]);
    }

  },

  render(h) {
    const child = [];
    this.title && child.push(this.getSection(h, 'q-dialog__title', this.title));
    this.progress !== false && child.push(h(QCardSection, {
      staticClass: 'q-dialog__progress'
    }, [h(this.spinner.component, {
      props: this.spinner.props
    })]));
    this.message && child.push(this.getSection(h, 'q-dialog__message', this.message));

    if (this.prompt !== void 0) {
      child.push(h(QCardSection, {
        staticClass: 'scroll q-dialog-plugin__form'
      }, this.getPrompt(h)));
    } else if (this.options !== void 0) {
      child.push(h(QSeparator, {
        props: {
          dark: this.isDark
        }
      }), h(QCardSection, {
        staticClass: 'scroll q-dialog-plugin__form'
      }, this.getOptions(h)), h(QSeparator, {
        props: {
          dark: this.isDark
        }
      }));
    }

    if (this.ok || this.cancel) {
      child.push(this.getButtons(h));
    }

    return h(QDialog["a" /* default */], {
      ref: 'dialog',
      props: objectSpread2_default()(objectSpread2_default()({}, this.qAttrs), {}, {
        value: this.value
      }),
      on: Object(cache["b" /* default */])(this, 'hide', {
        hide: () => {
          this.$emit('hide');
        }
      })
    }, [h(QCard, {
      staticClass: this.classes,
      style: this.cardStyle,
      class: this.cardClass,
      props: {
        dark: this.isDark
      }
    }, child)]);
  }

}));
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@babel/runtime/helpers/objectWithoutProperties.js
var objectWithoutProperties = __webpack_require__("9b70");
var objectWithoutProperties_default = /*#__PURE__*/__webpack_require__.n(objectWithoutProperties);

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/plugins/Platform.js
var Platform = __webpack_require__("5094");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/global-dialog.js




const ssrAPI = {
  onOk: () => ssrAPI,
  okCancel: () => ssrAPI,
  hide: () => ssrAPI,
  update: () => ssrAPI
};
function merge(target, source) {
  for (const key in source) {
    if (key !== 'spinner' && Object(source[key]) === source[key]) {
      target[key] = Object(target[key]) !== target[key] ? {} : objectSpread2_default()({}, target[key]);
      merge(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }
}
/* harmony default export */ var global_dialog = (function (DefaultComponent) {
  return (_ref) => {
    let {
      className,
      class: klass,
      style,
      component,
      root,
      parent
    } = _ref,
        props = objectWithoutProperties_default()(_ref, ["className", "class", "style", "component", "root", "parent"]);

    if (Platform["f" /* isSSR */] === true) {
      return ssrAPI;
    }

    klass !== void 0 && (props.cardClass = klass);
    style !== void 0 && (props.cardStyle = style);
    const isCustom = component !== void 0;
    let DialogComponent, attrs;

    if (isCustom === true) {
      DialogComponent = component;
    } else {
      DialogComponent = DefaultComponent;
      attrs = props;
    }

    const okFns = [],
          cancelFns = [],
          API = {
      onOk(fn) {
        okFns.push(fn);
        return API;
      },

      onCancel(fn) {
        cancelFns.push(fn);
        return API;
      },

      onDismiss(fn) {
        okFns.push(fn);
        cancelFns.push(fn);
        return API;
      },

      hide() {
        vm.$refs.dialog.hide();
        return API;
      },

      update(_ref2) {
        let {
          className,
          class: klass,
          style,
          component,
          root,
          parent
        } = _ref2,
            cfg = objectWithoutProperties_default()(_ref2, ["className", "class", "style", "component", "root", "parent"]);

        if (vm !== null) {
          klass !== void 0 && (cfg.cardClass = klass);
          style !== void 0 && (cfg.cardStyle = style);

          if (isCustom === true) {
            Object.assign(props, cfg);
          } else {
            merge(props, cfg); // need to change "attrs" reference to
            // actually reflect it in underlying component
            // when we force update it

            attrs = objectSpread2_default()({}, props);
          }

          vm.$forceUpdate();
        }

        return API;
      }

    };
    const node = document.createElement('div');
    document.body.appendChild(node);
    let emittedOK = false;
    const on = {
      ok: data => {
        emittedOK = true;
        okFns.forEach(fn => {
          fn(data);
        });
      },
      hide: () => {
        vm.$destroy();
        vm.$el.remove();
        vm = null;

        if (emittedOK !== true) {
          cancelFns.forEach(fn => {
            fn();
          });
        }
      }
    };
    let vm = new vue_runtime_esm["default"]({
      name: 'QGlobalDialog',
      el: node,
      parent: parent === void 0 ? root : parent,

      render(h) {
        return h(DialogComponent, {
          ref: 'dialog',
          props,
          attrs,
          on
        });
      },

      mounted() {
        if (this.$refs.dialog !== void 0) {
          this.$refs.dialog.show();
        } else {
          on['hook:mounted'] = () => {
            this.$refs.dialog !== void 0 && this.$refs.dialog.show();
          };
        }
      }

    });
    return API;
  };
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/plugins/Dialog.js


/* harmony default export */ var Dialog = __webpack_exports__["a"] = ({
  install({
    $q
  }) {
    this.create = $q.dialog = global_dialog(DialogPlugin);
  }

});

/***/ }),

/***/ "1801":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ComponentPickerGrid_vue_vue_type_style_index_0_id_154aa186_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("31b4");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ComponentPickerGrid_vue_vue_type_style_index_0_id_154aa186_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ComponentPickerGrid_vue_vue_type_style_index_0_id_154aa186_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "185a":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("d4cb");
var propertyIsEnumerableModule = __webpack_require__("e129");
var createPropertyDescriptor = __webpack_require__("9618");
var toIndexedObject = __webpack_require__("378c");
var toPrimitive = __webpack_require__("083f");
var has = __webpack_require__("f1a7");
var IE8_DOM_DEFINE = __webpack_require__("7c3f");

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),

/***/ "1ad6":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ Pepicon; });

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-pepicons/src/Pepicon.vue?vue&type=template&id=27e9eefa&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"pepicon",domProps:{"innerHTML":_vm._s(_vm.svg)}})}
var staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-pepicons/src/Pepicon.vue?vue&type=template&id=27e9eefa&

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/pepicons/dist/index.esm.js
var index_esm = __webpack_require__("f284");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-pepicons/src/Pepicon.vue?vue&type=script&lang=js&

/* harmony default export */ var Pepiconvue_type_script_lang_js_ = ({
  name: 'Pepicon',
  props: {
    /**
     * The icon name as per the reference at https://pepicons.com
     * @type {'airplane' | 'angle-down' | 'angle-left' | 'angle-right' | 'angle-up' | 'battery' | 'bell' | 'bell-off' | 'bicycle' | 'bluetooth' | 'book' | 'bookmark' | 'bookmark-filled' | 'building' | 'calculator' | 'calendar' | 'camera' | 'can' | 'car' | 'cart' | 'checkmark' | 'circle' | 'circle-filled' | 'clipboard' | 'clock' | 'cloud' | 'cloud-down' | 'cloud-down-filled' | 'cloud-filled' | 'cloud-up' | 'cloud-up-filled' | 'coctail' | 'color-picker' | 'contract' | 'controller' | 'credit-card' | 'cup' | 'division' | 'dots-x' | 'dots-y' | 'dress' | 'duplicate' | 'electricity' | 'exclamation' | 'exclamation-filled' | 'expand' | 'eye' | 'eye-closed' | 'eye-off' | 'file' | 'film-frame' | 'flag' | 'flower' | 'flower-bud' | 'folder' | 'gear' | 'gift' | 'grab' | 'hamburger' | 'headphone' | 'heart' | 'house' | 'info' | 'info-filled' | 'internet' | 'key' | 'knive-fork' | 'letter' | 'lock-closed' | 'lock-open' | 'loop' | 'loop-minus' | 'loop-plus' | 'map' | 'microphone' | 'minus' | 'monitor' | 'monitor2' | 'moon' | 'moon-filled' | 'motorcycle' | 'music-note-double' | 'music-note-single' | 'open' | 'paint-pallet' | 'pen' | 'person' | 'person-filled' | 'phone' | 'photo-camera' | 'pill' | 'pinpoint' | 'pinpoint-filled' | 'pinpoint-off' | 'pinpoint-off-filled' | 'plus' | 'power' | 'printer' | 'refresh' | 'reload' | 'scissors' | 'send' | 'share-android' | 'share-ios' | 'smartphone' | 'smartphone2' | 'soft-drink' | 'speaker-high' | 'speaker-low' | 'speaker-off' | 'square' | 'square-filled' | 'star' | 'sun' | 'sun-filled' | 'syringe' | 't-shirt' | 'taxi' | 'television' | 'text-bubble' | 'times' | 'tool' | 'train' | 'trash' | 'triangle-down' | 'triangle-down-filled' | 'triangle-left' | 'triangle-left-filled' | 'triangle-right' | 'triangle-right-filled' | 'triangle-up' | 'triangle-up-filled' | 'truck' | 'umbrella' | 'wifi'}
     * @example 'airplane'
     */
    name: {
      type: String,
      required: true
    },

    /**
     * Either 'pop' or 'print'
     * @type { 'pop' | 'print' }
     */
    type: {
      type: String,
      default: 'print'
    },

    /**
     * You can pass a hex or rgba color, this is applied to the svg tag
     *
     * (you can also just manually apply a color via style or a class)
     */
    color: {
      type: String
    },

    /**
     * A number between 0 and 1; where 0 is transparent
     * - in "pop" style: opacity will be set to the entire icon
     * - in "print" style: opacity will be set to the colored drop shadow
     */
    opacity: {
      type: Number
    },

    /**
     * The stroke color is only applied on 'print' type icons and is black by default
     */
    stroke: {
      type: String,
      default: 'black'
    },

    /**
     * When you pass a size, it's applied via the style attribute.
     * - 'sm' / 'md' / 'lg' / 'xl' which becomes 20 / 24 / 30 / 36 px
     * - a number for a "px" size. eg. 10 will become 10px
     * - a string for any size value that will be applied to the width
     *
     * (you can also just manually apply a width & height via style or a class)
     * @type { 'sm' | 'md' | 'lg' | 'xl' | number | string }
     */
    size: {
      type: [String, Number],
      default: 'md'
    }
  },
  computed: {
    svg() {
      const {
        name,
        type,
        color,
        opacity,
        size,
        stroke
      } = this;
      return Object(index_esm["c" /* pepiconSvgString */])({
        name,
        type,
        color,
        opacity,
        size,
        stroke
      });
    }

  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-pepicons/src/Pepicon.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_Pepiconvue_type_script_lang_js_ = (Pepiconvue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-pepicons/src/Pepicon.vue?vue&type=style&index=0&lang=css&
var Pepiconvue_type_style_index_0_lang_css_ = __webpack_require__("06b9");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__("2be6");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-pepicons/src/Pepicon.vue






/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  src_Pepiconvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var Pepicon = (component.exports);
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-pepicons/src/index.js




/* harmony default export */ var src = ({
  install(Vue) {
    Vue.component(Pepicon.name, Pepicon)
  },
});


/***/ }),

/***/ "1b63":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return onKeyDownComposition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return shouldIgnoreKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isKeyCode; });
let lastKeyCompositionStatus = false;
function onKeyDownComposition(evt) {
  lastKeyCompositionStatus = evt.isComposing === true;
}
function shouldIgnoreKey(evt) {
  return lastKeyCompositionStatus === true || evt !== Object(evt) || evt.isComposing === true || evt.qKeyEvent === true;
}
function isKeyCode(evt, keyCodes) {
  return shouldIgnoreKey(evt) === true ? false : [].concat(keyCodes).includes(evt.keyCode);
}

/***/ }),

/***/ "1c35":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return copyTextToClipboard; });
function copyTextToClipboard(input, {target = document.body} = {}) {
	const element = document.createElement('textarea');
	const previouslyFocusedElement = document.activeElement;

	element.value = input;

	// Prevent keyboard from showing on mobile
	element.setAttribute('readonly', '');

	element.style.contain = 'strict';
	element.style.position = 'absolute';
	element.style.left = '-9999px';
	element.style.fontSize = '12pt'; // Prevent zooming on iOS

	const selection = document.getSelection();
	let originalRange = false;
	if (selection.rangeCount > 0) {
		originalRange = selection.getRangeAt(0);
	}

	target.append(element);
	element.select();

	// Explicit selection workaround for iOS
	element.selectionStart = 0;
	element.selectionEnd = input.length;

	let isSuccess = false;
	try {
		isSuccess = document.execCommand('copy');
	} catch {}

	element.remove();

	if (originalRange) {
		selection.removeAllRanges();
		selection.addRange(originalRange);
	}

	// Get the focus back on the previously focused element, if any
	if (previouslyFocusedElement) {
		previouslyFocusedElement.focus();
	}

	return isSuccess;
}


/***/ }),

/***/ "1ce9":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_BlitzForm_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("dbe0");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_BlitzForm_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_BlitzForm_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "1d2e":
/***/ (function(module, exports, __webpack_require__) {

var userAgent = __webpack_require__("64e4");

module.exports = /web0s(?!.*chrome)/i.test(userAgent);


/***/ }),

/***/ "1d8a":
/***/ (function(module, exports) {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};


/***/ }),

/***/ "1d98":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ca22");
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("9869");
/* harmony import */ var _mixins_panel_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("217b");
/* harmony import */ var _utils_slot_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("a4b3");




/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_1__["default"].extend({
  name: 'QTabPanel',
  mixins: [_mixins_panel_js__WEBPACK_IMPORTED_MODULE_2__[/* PanelChildMixin */ "a"]],

  render(h) {
    return h('div', {
      staticClass: 'q-tab-panel',
      on: _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.qListeners)
    }, Object(_utils_slot_js__WEBPACK_IMPORTED_MODULE_3__[/* slot */ "c"])(this, 'default'));
  }

}));

/***/ }),

/***/ "1f5e":
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__("378c");
var toLength = __webpack_require__("b495");
var toAbsoluteIndex = __webpack_require__("9a0f");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "1f75":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_TableOfContents_vue_vue_type_style_index_0_id_315e9983_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("703a");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_TableOfContents_vue_vue_type_style_index_0_id_315e9983_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_TableOfContents_vue_vue_type_style_index_0_id_315e9983_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "2117":
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__("8697");

// optional / simple context binding
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "2169":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("6b1d");
var global = __webpack_require__("f498");
var arrayBufferModule = __webpack_require__("cf50");
var setSpecies = __webpack_require__("0a1e");

var ARRAY_BUFFER = 'ArrayBuffer';
var ArrayBuffer = arrayBufferModule[ARRAY_BUFFER];
var NativeArrayBuffer = global[ARRAY_BUFFER];

// `ArrayBuffer` constructor
// https://tc39.es/ecma262/#sec-arraybuffer-constructor
$({ global: true, forced: NativeArrayBuffer !== ArrayBuffer }, {
  ArrayBuffer: ArrayBuffer
});

setSpecies(ARRAY_BUFFER);


/***/ }),

/***/ "217b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ PanelParentMixin; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ PanelChildMixin; });

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue/dist/vue.runtime.esm.js
var vue_runtime_esm = __webpack_require__("9869");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/plugins/Platform.js
var Platform = __webpack_require__("5094");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/touch.js
var touch = __webpack_require__("36df");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("9ac9");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/selection.js
var selection = __webpack_require__("004f");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/directives/TouchSwipe.js





function parseArg(arg) {
  // delta (min velocity -- dist / time)
  // mobile min distance on first move
  // desktop min distance until deciding if it's a swipe or not
  const data = [0.06, 6, 50];

  if (typeof arg === 'string' && arg.length) {
    arg.split(':').forEach((val, index) => {
      const v = parseFloat(val);
      v && (data[index] = v);
    });
  }

  return data;
}

function destroy(el) {
  const ctx = el.__qtouchswipe;

  if (ctx !== void 0) {
    Object(utils_event["b" /* cleanEvt */])(ctx, 'main');
    Object(utils_event["b" /* cleanEvt */])(ctx, 'temp');
    Platform["a" /* client */].is.firefox === true && Object(utils_event["j" /* preventDraggable */])(el, false);
    ctx.styleCleanup !== void 0 && ctx.styleCleanup();
    delete el.__qtouchswipe;
  }
}

/* harmony default export */ var TouchSwipe = ({
  name: 'touch-swipe',

  bind(el, {
    value,
    arg,
    modifiers
  }) {
    if (el.__qtouchswipe !== void 0) {
      destroy(el);
      el.__qtouchswipe_destroyed = true;
    } // early return, we don't need to do anything


    if (modifiers.mouse !== true && Platform["a" /* client */].has.touch !== true) {
      return;
    }

    const mouseCapture = modifiers.mouseCapture === true ? 'Capture' : '';
    const ctx = {
      handler: value,
      sensitivity: parseArg(arg),
      modifiers: modifiers,
      direction: Object(touch["a" /* getModifierDirections */])(modifiers),
      noop: utils_event["g" /* noop */],

      mouseStart(evt) {
        if (Object(touch["c" /* shouldStart */])(evt, ctx) && Object(utils_event["e" /* leftClick */])(evt)) {
          Object(utils_event["a" /* addEvt */])(ctx, 'temp', [[document, 'mousemove', 'move', `notPassive${mouseCapture}`], [document, 'mouseup', 'end', 'notPassiveCapture']]);
          ctx.start(evt, true);
        }
      },

      touchStart(evt) {
        if (Object(touch["c" /* shouldStart */])(evt, ctx)) {
          const target = Object(touch["b" /* getTouchTarget */])(evt.target);
          Object(utils_event["a" /* addEvt */])(ctx, 'temp', [[target, 'touchmove', 'move', 'notPassiveCapture'], [target, 'touchcancel', 'end', 'notPassiveCapture'], [target, 'touchend', 'end', 'notPassiveCapture']]);
          ctx.start(evt);
        }
      },

      start(evt, mouseEvent) {
        Platform["a" /* client */].is.firefox === true && Object(utils_event["j" /* preventDraggable */])(el, true);
        const pos = Object(utils_event["h" /* position */])(evt);
        ctx.event = {
          x: pos.left,
          y: pos.top,
          time: Date.now(),
          mouse: mouseEvent === true,
          dir: false
        };
      },

      move(evt) {
        if (ctx.event === void 0) {
          return;
        }

        if (ctx.event.dir !== false) {
          Object(utils_event["l" /* stopAndPrevent */])(evt);
          return;
        }

        const time = Date.now() - ctx.event.time;

        if (time === 0) {
          return;
        }

        const pos = Object(utils_event["h" /* position */])(evt),
              distX = pos.left - ctx.event.x,
              absX = Math.abs(distX),
              distY = pos.top - ctx.event.y,
              absY = Math.abs(distY);

        if (ctx.event.mouse !== true) {
          if (absX < ctx.sensitivity[1] && absY < ctx.sensitivity[1]) {
            ctx.end(evt);
            return;
          }
        } else if (absX < ctx.sensitivity[2] && absY < ctx.sensitivity[2]) {
          return;
        }

        const velX = absX / time,
              velY = absY / time;

        if (ctx.direction.vertical === true && absX < absY && absX < 100 && velY > ctx.sensitivity[0]) {
          ctx.event.dir = distY < 0 ? 'up' : 'down';
        }

        if (ctx.direction.horizontal === true && absX > absY && absY < 100 && velX > ctx.sensitivity[0]) {
          ctx.event.dir = distX < 0 ? 'left' : 'right';
        }

        if (ctx.direction.up === true && absX < absY && distY < 0 && absX < 100 && velY > ctx.sensitivity[0]) {
          ctx.event.dir = 'up';
        }

        if (ctx.direction.down === true && absX < absY && distY > 0 && absX < 100 && velY > ctx.sensitivity[0]) {
          ctx.event.dir = 'down';
        }

        if (ctx.direction.left === true && absX > absY && distX < 0 && absY < 100 && velX > ctx.sensitivity[0]) {
          ctx.event.dir = 'left';
        }

        if (ctx.direction.right === true && absX > absY && distX > 0 && absY < 100 && velX > ctx.sensitivity[0]) {
          ctx.event.dir = 'right';
        }

        if (ctx.event.dir !== false) {
          Object(utils_event["l" /* stopAndPrevent */])(evt);

          if (ctx.event.mouse === true) {
            document.body.classList.add('no-pointer-events--children');
            document.body.classList.add('non-selectable');
            Object(selection["a" /* clearSelection */])();

            ctx.styleCleanup = withDelay => {
              ctx.styleCleanup = void 0;
              document.body.classList.remove('non-selectable');

              const remove = () => {
                document.body.classList.remove('no-pointer-events--children');
              };

              if (withDelay === true) {
                setTimeout(remove, 50);
              } else {
                remove();
              }
            };
          }

          ctx.handler({
            evt,
            touch: ctx.event.mouse !== true,
            mouse: ctx.event.mouse,
            direction: ctx.event.dir,
            duration: time,
            distance: {
              x: absX,
              y: absY
            }
          });
        } else {
          ctx.end(evt);
        }
      },

      end(evt) {
        if (ctx.event === void 0) {
          return;
        }

        Object(utils_event["b" /* cleanEvt */])(ctx, 'temp');
        Platform["a" /* client */].is.firefox === true && Object(utils_event["j" /* preventDraggable */])(el, false);
        ctx.styleCleanup !== void 0 && ctx.styleCleanup(true);
        evt !== void 0 && ctx.event.dir !== false && Object(utils_event["l" /* stopAndPrevent */])(evt);
        ctx.event = void 0;
      }

    };
    el.__qtouchswipe = ctx;
    modifiers.mouse === true && Object(utils_event["a" /* addEvt */])(ctx, 'main', [[el, 'mousedown', 'mouseStart', `passive${mouseCapture}`]]);
    Platform["a" /* client */].has.touch === true && Object(utils_event["a" /* addEvt */])(ctx, 'main', [[el, 'touchstart', 'touchStart', `passive${modifiers.capture === true ? 'Capture' : ''}`], [el, 'touchmove', 'noop', `notPassiveCapture`]]);
  },

  update(el, {
    oldValue,
    value
  }) {
    const ctx = el.__qtouchswipe;

    if (ctx !== void 0 && oldValue !== value) {
      typeof value !== 'function' && ctx.end();
      ctx.handler = value;
    }
  },

  unbind(el) {
    if (el.__qtouchswipe_destroyed === void 0) {
      destroy(el);
    } else {
      delete el.__qtouchswipe_destroyed;
    }
  }

});
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/listeners.js
var listeners = __webpack_require__("0fb0");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/slot.js
var slot = __webpack_require__("a4b3");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/cache.js
var cache = __webpack_require__("6459");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/panel.js







function getPanelWrapper(h) {
  return h('div', {
    staticClass: 'q-panel scroll',
    attrs: {
      role: 'tabpanel'
    },
    // stop propagation of content emitted @input
    // which would tamper with Panel's model
    on: Object(cache["b" /* default */])(this, 'stop', {
      input: utils_event["k" /* stop */]
    })
  }, Object(slot["c" /* slot */])(this, 'default'));
}

const PanelWrapper = vue_runtime_esm["default"].extend({
  render: getPanelWrapper
});
const PanelParentMixin = {
  mixins: [listeners["a" /* default */]],
  directives: {
    TouchSwipe: TouchSwipe
  },
  props: {
    value: {
      required: true
    },
    animated: Boolean,
    infinite: Boolean,
    swipeable: Boolean,
    vertical: Boolean,
    transitionPrev: String,
    transitionNext: String,
    keepAlive: Boolean,
    keepAliveInclude: [String, Array, RegExp],
    keepAliveExclude: [String, Array, RegExp],
    keepAliveMax: Number
  },

  data() {
    return {
      panelIndex: null,
      panelTransition: null
    };
  },

  computed: {
    panelDirectives() {
      if (this.swipeable === true) {
        return [{
          name: 'touch-swipe',
          value: this.__swipe,
          modifiers: {
            horizontal: this.vertical !== true,
            vertical: this.vertical,
            mouse: true
          }
        }];
      }
    },

    contentKey() {
      return typeof this.value === 'string' || typeof this.value === 'number' ? this.value : String(this.value);
    },

    transitionPrevComputed() {
      return this.transitionPrev || `slide-${this.vertical === true ? 'down' : 'right'}`;
    },

    transitionNextComputed() {
      return this.transitionNext || `slide-${this.vertical === true ? 'up' : 'left'}`;
    },

    keepAliveProps() {
      return {
        include: this.keepAliveInclude,
        exclude: this.keepAliveExclude,
        max: this.keepAliveMax
      };
    },

    needsUniqueWrapper() {
      return this.keepAliveInclude !== void 0 || this.keepAliveExclude !== void 0;
    }

  },
  watch: {
    value(newVal, oldVal) {
      const index = this.__isValidPanelName(newVal) === true ? this.__getPanelIndex(newVal) : -1;

      if (this.__forcedPanelTransition !== true) {
        this.__updatePanelTransition(index === -1 ? 0 : index < this.__getPanelIndex(oldVal) ? -1 : 1);
      }

      if (this.panelIndex !== index) {
        this.panelIndex = index;
        this.$emit('before-transition', newVal, oldVal);
        this.$nextTick(() => {
          this.$emit('transition', newVal, oldVal);
        });
      }
    }

  },
  methods: {
    next() {
      this.__go(1);
    },

    previous() {
      this.__go(-1);
    },

    goTo(name) {
      this.$emit('input', name);
    },

    __isValidPanelName(name) {
      return name !== void 0 && name !== null && name !== '';
    },

    __getPanelIndex(name) {
      return this.panels.findIndex(panel => {
        const opt = panel.componentOptions.propsData;
        return opt.name === name && opt.disable !== '' && opt.disable !== true;
      });
    },

    __getEnabledPanels() {
      return this.panels.filter(panel => {
        const opt = panel.componentOptions.propsData;
        return opt.disable !== '' && opt.disable !== true;
      });
    },

    __updatePanelTransition(direction) {
      const val = direction !== 0 && this.animated === true && this.panelIndex !== -1 ? 'q-transition--' + (direction === -1 ? this.transitionPrevComputed : this.transitionNextComputed) : null;

      if (this.panelTransition !== val) {
        this.panelTransition = val;
      }
    },

    __go(direction, startIndex = this.panelIndex) {
      let index = startIndex + direction;
      const slots = this.panels;

      while (index > -1 && index < slots.length) {
        const opt = slots[index].componentOptions;

        if (opt !== void 0 && opt.propsData.disable !== '' && opt.propsData.disable !== true) {
          this.__updatePanelTransition(direction);

          this.__forcedPanelTransition = true;
          this.$emit('input', slots[index].componentOptions.propsData.name);
          setTimeout(() => {
            this.__forcedPanelTransition = false;
          });
          return;
        }

        index += direction;
      }

      if (this.infinite === true && slots.length > 0 && startIndex !== -1 && startIndex !== slots.length) {
        this.__go(direction, direction === -1 ? slots.length : -1);
      }
    },

    __swipe(evt) {
      const dir = this.vertical === true ? 'up' : 'left';

      this.__go((this.$q.lang.rtl === true ? -1 : 1) * (evt.direction === dir ? 1 : -1));
    },

    __updatePanelIndex() {
      const index = this.__getPanelIndex(this.value);

      if (this.panelIndex !== index) {
        this.panelIndex = index;
      }

      return true;
    },

    __getPanelContent(h) {
      if (this.panels.length === 0) {
        return;
      }

      const panel = this.__isValidPanelName(this.value) && this.__updatePanelIndex() && this.panels[this.panelIndex];
      const content = this.keepAlive === true ? [h('keep-alive', {
        props: this.keepAliveProps
      }, [h(this.needsUniqueWrapper === true ? Object(cache["a" /* cacheWithFn */])(this, this.contentKey, () => vue_runtime_esm["default"].extend({
        name: this.contentKey,
        render: getPanelWrapper
      })) : PanelWrapper, {
        key: this.contentKey
      }, [panel])])] : [h('div', {
        staticClass: 'q-panel scroll',
        key: this.contentKey,
        attrs: {
          role: 'tabpanel'
        },
        // stop propagation of content emitted @input
        // which would tamper with Panel's model
        on: Object(cache["b" /* default */])(this, 'stop', {
          input: utils_event["k" /* stop */]
        })
      }, [panel])];
      return this.animated === true ? [h('transition', {
        props: {
          name: this.panelTransition
        }
      }, content)] : content;
    }

  },

  render(h) {
    this.panels = Object(slot["c" /* slot */])(this, 'default', []).filter(panel => panel !== void 0 && panel.componentOptions !== void 0 && panel.componentOptions.propsData !== void 0 && this.__isValidPanelName(panel.componentOptions.propsData.name));
    return this.__renderPanels(h);
  }

};
const PanelChildMixin = {
  mixins: [listeners["a" /* default */]],
  props: {
    name: {
      required: true
    },
    disable: Boolean
  }
};

/***/ }),

/***/ "2402":
/***/ (function(module, exports) {

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "2435":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("f498");
var fails = __webpack_require__("72df");
var bind = __webpack_require__("2117");
var html = __webpack_require__("9324");
var createElement = __webpack_require__("f2bf");
var IS_IOS = __webpack_require__("e03e");
var IS_NODE = __webpack_require__("f117");

var location = global.location;
var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function (id) {
  // eslint-disable-next-line no-prototype-builtins -- safe
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var listener = function (event) {
  run(event.data);
};

var post = function (id) {
  // old engines have not location.origin
  global.postMessage(id + '', location.protocol + '//' + location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func -- spec requirement
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (IS_NODE) {
    defer = function (id) {
      process.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    global.addEventListener &&
    typeof postMessage == 'function' &&
    !global.importScripts &&
    location && location.protocol !== 'file:' &&
    !fails(post)
  ) {
    defer = post;
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};


/***/ }),

/***/ "26d3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("6b1d");
var IS_PURE = __webpack_require__("0e93");
var global = __webpack_require__("f498");
var getBuiltIn = __webpack_require__("5428");
var NativePromise = __webpack_require__("2903");
var redefine = __webpack_require__("b8ba");
var redefineAll = __webpack_require__("b203");
var setToStringTag = __webpack_require__("fa46");
var setSpecies = __webpack_require__("0a1e");
var isObject = __webpack_require__("7526");
var aFunction = __webpack_require__("8697");
var anInstance = __webpack_require__("4cce");
var inspectSource = __webpack_require__("df6f");
var iterate = __webpack_require__("b578");
var checkCorrectnessOfIteration = __webpack_require__("3211");
var speciesConstructor = __webpack_require__("433a");
var task = __webpack_require__("2435").set;
var microtask = __webpack_require__("8573");
var promiseResolve = __webpack_require__("9c36");
var hostReportErrors = __webpack_require__("422d");
var newPromiseCapabilityModule = __webpack_require__("881c");
var perform = __webpack_require__("42ba");
var InternalStateModule = __webpack_require__("cdcd");
var isForced = __webpack_require__("ebac");
var wellKnownSymbol = __webpack_require__("7d53");
var IS_NODE = __webpack_require__("f117");
var V8_VERSION = __webpack_require__("4fed");

var SPECIES = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var PromiseConstructor = NativePromise;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var $fetch = getBuiltIn('fetch');
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent == 'function';
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

var FORCED = isForced(PROMISE, function () {
  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
  if (!GLOBAL_CORE_JS_PROMISE) {
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (V8_VERSION === 66) return true;
    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    if (!IS_NODE && !NATIVE_REJECTION_EVENT) return true;
  }
  // We need Promise#finally in the pure version for preventing prototype pollution
  if (IS_PURE && !PromiseConstructor.prototype['finally']) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor)) return false;
  // Detect correctness of subclassing with @@species support
  var promise = PromiseConstructor.resolve(1);
  var FakePromise = function (exec) {
    exec(function () { /* empty */ }, function () { /* empty */ });
  };
  var constructor = promise.constructor = {};
  constructor[SPECIES] = FakePromise;
  return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
});

var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
});

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  var chain = state.reactions;
  microtask(function () {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var index = 0;
    // variable length - can't use forEach
    while (chain.length > index) {
      var reaction = chain[index++];
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // can throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    }
    state.reactions = [];
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (!NATIVE_REJECTION_EVENT && (handler = global['on' + name])) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (state) {
  task.call(global, function () {
    var promise = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (state) {
  task.call(global, function () {
    var promise = state.facade;
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};

var internalReject = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};

var internalResolve = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value) throw TypeError("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          then.call(value,
            bind(internalResolve, wrapper, state),
            bind(internalReject, wrapper, state)
          );
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({ done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromiseConstructor, PROMISE);
    aFunction(executor);
    Internal.call(this);
    var state = getInternalState(this);
    try {
      executor(bind(internalResolve, state), bind(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: [],
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };
  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
    // `Promise.prototype.then` method
    // https://tc39.es/ecma262/#sec-promise.prototype.then
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = IS_NODE ? process.domain : undefined;
      state.parent = true;
      state.reactions.push(reaction);
      if (state.state != PENDING) notify(state, false);
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.es/ecma262/#sec-promise.prototype.catch
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, state);
    this.reject = bind(internalReject, state);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  if (!IS_PURE && typeof NativePromise == 'function') {
    nativeThen = NativePromise.prototype.then;

    // wrap native Promise#then for native async functions
    redefine(NativePromise.prototype, 'then', function then(onFulfilled, onRejected) {
      var that = this;
      return new PromiseConstructor(function (resolve, reject) {
        nativeThen.call(that, resolve, reject);
      }).then(onFulfilled, onRejected);
    // https://github.com/zloirock/core-js/issues/640
    }, { unsafe: true });

    // wrap fetch result
    if (typeof $fetch == 'function') $({ global: true, enumerable: true, forced: true }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      fetch: function fetch(input /* , init */) {
        return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));
      }
    });
  }
}

$({ global: true, wrap: true, forced: FORCED }, {
  Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);

PromiseWrapper = getBuiltIn(PROMISE);

// statics
$({ target: PROMISE, stat: true, forced: FORCED }, {
  // `Promise.reject` method
  // https://tc39.es/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    capability.reject.call(undefined, r);
    return capability.promise;
  }
});

$({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
  // `Promise.resolve` method
  // https://tc39.es/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
  }
});

$({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
  // `Promise.all` method
  // https://tc39.es/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        $promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.es/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      iterate(iterable, function (promise) {
        $promiseResolve.call(C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ "2746":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "2843":
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "28d3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_BlitzField_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5027");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_BlitzField_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_BlitzField_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "28eb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("6b1d");
var $reduce = __webpack_require__("98f3").left;
var arrayMethodIsStrict = __webpack_require__("7f8a");
var CHROME_VERSION = __webpack_require__("4fed");
var IS_NODE = __webpack_require__("f117");

var STRICT_METHOD = arrayMethodIsStrict('reduce');
// Chrome 80-82 has a critical bug
// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;

// `Array.prototype.reduce` method
// https://tc39.es/ecma262/#sec-array.prototype.reduce
$({ target: 'Array', proto: true, forced: !STRICT_METHOD || CHROME_BUG }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "2903":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("f498");

module.exports = global.Promise;


/***/ }),

/***/ "29cd":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__("37d1");
var toAbsoluteIndex = __webpack_require__("9a0f");
var toLength = __webpack_require__("b495");

// `Array.prototype.fill` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ "2a7b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export getType */
/* unused harmony export isAnyObject */
/* unused harmony export isArray */
/* unused harmony export isBlob */
/* unused harmony export isBoolean */
/* unused harmony export isDate */
/* unused harmony export isEmptyArray */
/* unused harmony export isEmptyObject */
/* unused harmony export isEmptyString */
/* unused harmony export isError */
/* unused harmony export isFile */
/* unused harmony export isFullArray */
/* unused harmony export isFullObject */
/* unused harmony export isFullString */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isFunction; });
/* unused harmony export isMap */
/* unused harmony export isNaNValue */
/* unused harmony export isNull */
/* unused harmony export isNullOrUndefined */
/* unused harmony export isNumber */
/* unused harmony export isObject */
/* unused harmony export isObjectLike */
/* unused harmony export isOneOf */
/* unused harmony export isPlainObject */
/* unused harmony export isPrimitive */
/* unused harmony export isPromise */
/* unused harmony export isRegExp */
/* unused harmony export isSet */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isString; });
/* unused harmony export isSymbol */
/* unused harmony export isType */
/* unused harmony export isUndefined */
/* unused harmony export isWeakMap */
/* unused harmony export isWeakSet */
/**
 * Returns the object type of the given payload
 *
 * @param {*} payload
 * @returns {string}
 */
function getType(payload) {
    return Object.prototype.toString.call(payload).slice(8, -1);
}
/**
 * Returns whether the payload is undefined
 *
 * @param {*} payload
 * @returns {payload is undefined}
 */
function isUndefined(payload) {
    return getType(payload) === 'Undefined';
}
/**
 * Returns whether the payload is null
 *
 * @param {*} payload
 * @returns {payload is null}
 */
function isNull(payload) {
    return getType(payload) === 'Null';
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isPlainObject(payload) {
    if (getType(payload) !== 'Object')
        return false;
    return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isObject(payload) {
    return isPlainObject(payload);
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is { [K in any]: never }}
 */
function isEmptyObject(payload) {
    return isPlainObject(payload) && Object.keys(payload).length === 0;
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isFullObject(payload) {
    return isPlainObject(payload) && Object.keys(payload).length > 0;
}
/**
 * Returns whether the payload is an any kind of object (including special classes or objects with different prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isAnyObject(payload) {
    return getType(payload) === 'Object';
}
/**
 * Returns whether the payload is an object like a type passed in < >
 *
 * Usage: isObjectLike<{id: any}>(payload) // will make sure it's an object and has an `id` prop.
 *
 * @template T this must be passed in < >
 * @param {*} payload
 * @returns {payload is T}
 */
function isObjectLike(payload) {
    return isAnyObject(payload);
}
/**
 * Returns whether the payload is a function (regular or async)
 *
 * @param {*} payload
 * @returns {payload is AnyFunction}
 */
function isFunction(payload) {
    return typeof payload === 'function';
}
/**
 * Returns whether the payload is an array
 *
 * @param {any} payload
 * @returns {payload is any[]}
 */
function isArray(payload) {
    return getType(payload) === 'Array';
}
/**
 * Returns whether the payload is a an array with at least 1 item
 *
 * @param {*} payload
 * @returns {payload is any[]}
 */
function isFullArray(payload) {
    return isArray(payload) && payload.length > 0;
}
/**
 * Returns whether the payload is a an empty array
 *
 * @param {*} payload
 * @returns {payload is []}
 */
function isEmptyArray(payload) {
    return isArray(payload) && payload.length === 0;
}
/**
 * Returns whether the payload is a string
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isString(payload) {
    return getType(payload) === 'String';
}
/**
 * Returns whether the payload is a string, BUT returns false for ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isFullString(payload) {
    return isString(payload) && payload !== '';
}
/**
 * Returns whether the payload is ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isEmptyString(payload) {
    return payload === '';
}
/**
 * Returns whether the payload is a number (but not NaN)
 *
 * This will return `false` for `NaN`!!
 *
 * @param {*} payload
 * @returns {payload is number}
 */
function isNumber(payload) {
    return getType(payload) === 'Number' && !isNaN(payload);
}
/**
 * Returns whether the payload is a boolean
 *
 * @param {*} payload
 * @returns {payload is boolean}
 */
function isBoolean(payload) {
    return getType(payload) === 'Boolean';
}
/**
 * Returns whether the payload is a regular expression (RegExp)
 *
 * @param {*} payload
 * @returns {payload is RegExp}
 */
function isRegExp(payload) {
    return getType(payload) === 'RegExp';
}
/**
 * Returns whether the payload is a Map
 *
 * @param {*} payload
 * @returns {payload is Map<any, any>}
 */
function isMap(payload) {
    return getType(payload) === 'Map';
}
/**
 * Returns whether the payload is a WeakMap
 *
 * @param {*} payload
 * @returns {payload is WeakMap<any, any>}
 */
function isWeakMap(payload) {
    return getType(payload) === 'WeakMap';
}
/**
 * Returns whether the payload is a Set
 *
 * @param {*} payload
 * @returns {payload is Set<any>}
 */
function isSet(payload) {
    return getType(payload) === 'Set';
}
/**
 * Returns whether the payload is a WeakSet
 *
 * @param {*} payload
 * @returns {payload is WeakSet<any>}
 */
function isWeakSet(payload) {
    return getType(payload) === 'WeakSet';
}
/**
 * Returns whether the payload is a Symbol
 *
 * @param {*} payload
 * @returns {payload is symbol}
 */
function isSymbol(payload) {
    return getType(payload) === 'Symbol';
}
/**
 * Returns whether the payload is a Date, and that the date is valid
 *
 * @param {*} payload
 * @returns {payload is Date}
 */
function isDate(payload) {
    return getType(payload) === 'Date' && !isNaN(payload);
}
/**
 * Returns whether the payload is a Blob
 *
 * @param {*} payload
 * @returns {payload is Blob}
 */
function isBlob(payload) {
    return getType(payload) === 'Blob';
}
/**
 * Returns whether the payload is a File
 *
 * @param {*} payload
 * @returns {payload is File}
 */
function isFile(payload) {
    return getType(payload) === 'File';
}
/**
 * Returns whether the payload is a Promise
 *
 * @param {*} payload
 * @returns {payload is Promise<any>}
 */
function isPromise(payload) {
    return getType(payload) === 'Promise';
}
/**
 * Returns whether the payload is an Error
 *
 * @param {*} payload
 * @returns {payload is Error}
 */
function isError(payload) {
    return getType(payload) === 'Error';
}
/**
 * Returns whether the payload is literally the value `NaN` (it's `NaN` and also a `number`)
 *
 * @param {*} payload
 * @returns {payload is typeof NaN}
 */
function isNaNValue(payload) {
    return getType(payload) === 'Number' && isNaN(payload);
}
/**
 * Returns whether the payload is a primitive type (eg. Boolean | Null | Undefined | Number | String | Symbol)
 *
 * @param {*} payload
 * @returns {(payload is boolean | null | undefined | number | string | symbol)}
 */
function isPrimitive(payload) {
    return (isBoolean(payload) ||
        isNull(payload) ||
        isUndefined(payload) ||
        isNumber(payload) ||
        isString(payload) ||
        isSymbol(payload));
}
/**
 * Returns true whether the payload is null or undefined
 *
 * @param {*} payload
 * @returns {(payload is null | undefined)}
 */
var isNullOrUndefined = isOneOf(isNull, isUndefined);
function isOneOf(a, b, c, d, e) {
    return function (value) {
        return a(value) || b(value) || (!!c && c(value)) || (!!d && d(value)) || (!!e && e(value));
    };
}
/**
 * Does a generic check to check that the given payload is of a given type.
 * In cases like Number, it will return true for NaN as NaN is a Number (thanks javascript!);
 * It will, however, differentiate between object and null
 *
 * @template T
 * @param {*} payload
 * @param {T} type
 * @throws {TypeError} Will throw type error if type is an invalid type
 * @returns {payload is T}
 */
function isType(payload, type) {
    if (!(type instanceof Function)) {
        throw new TypeError('Type must be a function');
    }
    if (!Object.prototype.hasOwnProperty.call(type, 'prototype')) {
        throw new TypeError('Type is not a class');
    }
    // Classes usually have names (as functions usually have names)
    var name = type.name;
    return getType(payload) === name || Boolean(payload && payload.constructor === type);
}




/***/ }),

/***/ "2aa5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("6b1d");
var exec = __webpack_require__("42c5");

// `RegExp.prototype.exec` method
// https://tc39.es/ecma262/#sec-regexp.prototype.exec
$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
  exec: exec
});


/***/ }),

/***/ "2be6":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "2ce9":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ca22");
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("9869");
/* harmony import */ var _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("0fb0");
/* harmony import */ var _utils_slot_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("a4b3");




/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_1__["default"].extend({
  name: 'QPageContainer',
  mixins: [_mixins_listeners_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]],
  inject: {
    layout: {
      default() {
        console.error('QPageContainer needs to be child of QLayout');
      }

    }
  },
  provide: {
    pageContainer: true
  },
  computed: {
    style() {
      const css = {};

      if (this.layout.header.space === true) {
        css.paddingTop = `${this.layout.header.size}px`;
      }

      if (this.layout.right.space === true) {
        css[`padding${this.$q.lang.rtl === true ? 'Left' : 'Right'}`] = `${this.layout.right.size}px`;
      }

      if (this.layout.footer.space === true) {
        css.paddingBottom = `${this.layout.footer.size}px`;
      }

      if (this.layout.left.space === true) {
        css[`padding${this.$q.lang.rtl === true ? 'Right' : 'Left'}`] = `${this.layout.left.size}px`;
      }

      return css;
    }

  },

  render(h) {
    return h('div', {
      staticClass: 'q-page-container',
      style: this.style,
      on: _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.qListeners)
    }, Object(_utils_slot_js__WEBPACK_IMPORTED_MODULE_3__[/* slot */ "c"])(this, 'default'));
  }

}));

/***/ }),

/***/ "2dd1":
/***/ (function(module, exports) {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "2dd7":
/***/ (function(module, exports, __webpack_require__) {

var toPositiveInteger = __webpack_require__("e01a");

module.exports = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw RangeError('Wrong offset');
  return offset;
};


/***/ }),

/***/ "2df4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("6b1d");
var createIteratorConstructor = __webpack_require__("2e3f");
var getPrototypeOf = __webpack_require__("0e39");
var setPrototypeOf = __webpack_require__("c1a2");
var setToStringTag = __webpack_require__("fa46");
var createNonEnumerableProperty = __webpack_require__("5b12");
var redefine = __webpack_require__("b8ba");
var wellKnownSymbol = __webpack_require__("7d53");
var IS_PURE = __webpack_require__("0e93");
var Iterators = __webpack_require__("5bb7");
var IteratorsCore = __webpack_require__("ff89");

var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() { return nativeIterator.call(this); };
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
  }
  Iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};


/***/ }),

/***/ "2e3f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IteratorPrototype = __webpack_require__("ff89").IteratorPrototype;
var create = __webpack_require__("82e8");
var createPropertyDescriptor = __webpack_require__("9618");
var setToStringTag = __webpack_require__("fa46");
var Iterators = __webpack_require__("5bb7");

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ "2ef0":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@babel/runtime/helpers/objectSpread2.js
var objectSpread2 = __webpack_require__("ca22");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2);

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.string.replace.js
var es_string_replace = __webpack_require__("32f5");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue/dist/vue.runtime.esm.js
var vue_runtime_esm = __webpack_require__("9869");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/icon/QIcon.js
var QIcon = __webpack_require__("34ff");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/spinner/QSpinner.js + 1 modules
var QSpinner = __webpack_require__("9cbe");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.array.flat.js
var es_array_flat = __webpack_require__("ba53");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/align.js
var align = __webpack_require__("d23a");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/ripple.js + 1 modules
var ripple = __webpack_require__("b190");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/listeners.js
var listeners = __webpack_require__("0fb0");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/size.js
var size = __webpack_require__("d578");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/btn.js





const padding = {
  none: 0,
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32
};
/* harmony default export */ var btn = ({
  mixins: [listeners["a" /* default */], ripple["a" /* default */], align["a" /* default */], Object(size["b" /* getSizeMixin */])({
    xs: 8,
    sm: 10,
    md: 14,
    lg: 20,
    xl: 24
  })],
  props: {
    type: String,
    to: [Object, String],
    replace: Boolean,
    append: Boolean,
    label: [Number, String],
    icon: String,
    iconRight: String,
    round: Boolean,
    outline: Boolean,
    flat: Boolean,
    unelevated: Boolean,
    rounded: Boolean,
    push: Boolean,
    glossy: Boolean,
    size: String,
    fab: Boolean,
    fabMini: Boolean,
    padding: String,
    color: String,
    textColor: String,
    noCaps: Boolean,
    noWrap: Boolean,
    dense: Boolean,
    tabindex: [Number, String],
    align: {
      default: 'center'
    },
    stack: Boolean,
    stretch: Boolean,
    loading: {
      type: Boolean,
      default: null
    },
    disable: Boolean
  },
  computed: {
    style() {
      if (this.fab === false && this.fabMini === false) {
        return this.sizeStyle;
      }
    },

    isRounded() {
      return this.rounded === true || this.fab === true || this.fabMini === true;
    },

    isActionable() {
      return this.disable !== true && this.loading !== true;
    },

    computedTabIndex() {
      return this.isActionable === true ? this.tabindex || 0 : -1;
    },

    hasRouterLink() {
      return this.disable !== true && this.to !== void 0 && this.to !== null && this.to !== '';
    },

    isLink() {
      return this.type === 'a' || this.hasRouterLink === true;
    },

    design() {
      if (this.flat === true) return 'flat';
      if (this.outline === true) return 'outline';
      if (this.push === true) return 'push';
      if (this.unelevated === true) return 'unelevated';
      return 'standard';
    },

    currentLocation() {
      if (this.hasRouterLink === true) {
        // we protect from accessing this.$route without
        // actually needing it so that we won't trigger
        // unnecessary updates
        return this.append === true ? this.$router.resolve(this.to, this.$route, true) : this.$router.resolve(this.to);
      }
    },

    attrs() {
      const attrs = {
        tabindex: this.computedTabIndex
      };

      if (this.type !== 'a') {
        attrs.type = this.type || 'button';
      }

      if (this.hasRouterLink === true) {
        attrs.href = this.currentLocation.href;
        attrs.role = 'link';
      } else {
        attrs.role = this.type === 'a' ? 'link' : 'button';
      }

      if (this.loading === true && this.percentage !== void 0) {
        attrs.role = 'progressbar';
        attrs['aria-valuemin'] = 0;
        attrs['aria-valuemax'] = 100;
        attrs['aria-valuenow'] = this.percentage;
      }

      if (this.disable === true) {
        attrs.disabled = '';
        attrs['aria-disabled'] = 'true';
      }

      return attrs;
    },

    classes() {
      let colors;

      if (this.color !== void 0) {
        if (this.flat === true || this.outline === true) {
          colors = `text-${this.textColor || this.color}`;
        } else {
          colors = `bg-${this.color} text-${this.textColor || 'white'}`;
        }
      } else if (this.textColor) {
        colors = `text-${this.textColor}`;
      }

      return `q-btn--${this.design} ` + `q-btn--${this.round === true ? 'round' : `rectangle${this.isRounded === true ? ' q-btn--rounded' : ''}`}` + (colors !== void 0 ? ' ' + colors : '') + (this.isActionable === true ? ' q-btn--actionable q-focusable q-hoverable' : this.disable === true ? ' disabled' : '') + (this.fab === true ? ' q-btn--fab' : this.fabMini === true ? ' q-btn--fab-mini' : '') + (this.noCaps === true ? ' q-btn--no-uppercase' : '') + (this.noWrap === true ? '' : ' q-btn--wrap') + ( // this is for IE11
      this.dense === true ? ' q-btn--dense' : '') + (this.stretch === true ? ' no-border-radius self-stretch' : '') + (this.glossy === true ? ' glossy' : '');
    },

    innerClasses() {
      return this.alignClass + (this.stack === true ? ' column' : ' row') + (this.noWrap === true ? ' no-wrap text-no-wrap' : '') + (this.loading === true ? ' q-btn__content--hidden' : '');
    },

    wrapperStyle() {
      if (this.padding !== void 0) {
        return {
          padding: this.padding.split(/\s+/).map(v => v in padding ? padding[v] + 'px' : v).join(' '),
          minWidth: '0',
          minHeight: '0'
        };
      }
    }

  }
});
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/slot.js
var slot = __webpack_require__("a4b3");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("9ac9");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/touch.js
var touch = __webpack_require__("36df");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/key-composition.js
var key_composition = __webpack_require__("1b63");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/btn/QBtn.js










const {
  passiveCapture
} = utils_event["f" /* listenOpts */];
let touchTarget = void 0,
    keyboardTarget = void 0,
    mouseTarget = void 0;
const iconAttrs = {
  role: 'img',
  'aria-hidden': 'true'
};
/* harmony default export */ var QBtn = __webpack_exports__["a"] = (vue_runtime_esm["default"].extend({
  name: 'QBtn',
  mixins: [btn],
  props: {
    percentage: Number,
    darkPercentage: Boolean
  },
  computed: {
    hasLabel() {
      return this.label !== void 0 && this.label !== null && this.label !== '';
    },

    computedRipple() {
      return this.ripple === false ? false : objectSpread2_default()({
        keyCodes: this.isLink === true ? [13, 32] : [13]
      }, this.ripple === true ? {} : this.ripple);
    },

    percentageStyle() {
      const val = Math.max(0, Math.min(100, this.percentage));

      if (val > 0) {
        return {
          transition: 'transform 0.6s',
          transform: `translateX(${val - 100}%)`
        };
      }
    },

    onEvents() {
      if (this.loading === true) {
        return {
          mousedown: this.__onLoadingEvt,
          touchstart: this.__onLoadingEvt,
          click: this.__onLoadingEvt,
          keydown: this.__onLoadingEvt,
          keyup: this.__onLoadingEvt
        };
      } else if (this.isActionable === true) {
        const on = objectSpread2_default()(objectSpread2_default()({}, this.qListeners), {}, {
          click: this.click,
          keydown: this.__onKeydown,
          mousedown: this.__onMousedown
        });

        if (this.$q.platform.has.touch === true) {
          on.touchstart = this.__onTouchstart;
        }

        return on;
      }

      return {};
    },

    directives() {
      if (this.disable !== true && this.ripple !== false) {
        return [{
          name: 'ripple',
          value: this.computedRipple,
          modifiers: {
            center: this.round
          }
        }];
      }
    }

  },
  methods: {
    click(e) {
      if (e !== void 0) {
        if (e.defaultPrevented === true) {
          return;
        }

        const el = document.activeElement; // focus button if it came from ENTER on form
        // prevent the new submit (already done)

        if (this.type === 'submit' && (this.$q.platform.is.ie === true && (e.clientX < 0 || e.clientY < 0) || el !== document.body && this.$el.contains(el) === false && // required for iOS and desktop Safari
        el.contains(this.$el) === false)) {
          this.$el.focus();

          const onClickCleanup = () => {
            document.removeEventListener('keydown', utils_event["l" /* stopAndPrevent */], true);
            document.removeEventListener('keyup', onClickCleanup, passiveCapture);
            this.$el !== void 0 && this.$el.removeEventListener('blur', onClickCleanup, passiveCapture);
          };

          document.addEventListener('keydown', utils_event["l" /* stopAndPrevent */], true);
          document.addEventListener('keyup', onClickCleanup, passiveCapture);
          this.$el.addEventListener('blur', onClickCleanup, passiveCapture);
        }

        if (this.hasRouterLink === true) {
          if (e.ctrlKey === true || e.shiftKey === true || e.altKey === true || e.metaKey === true) {
            // if it has meta keys, let vue-router link
            // handle this by its own
            return;
          }

          Object(utils_event["l" /* stopAndPrevent */])(e);
        }
      }

      const go = () => {
        // vue-router now throwing error if navigating
        // to the same route that the user is currently at
        // https://github.com/vuejs/vue-router/issues/2872
        this.$router[this.replace === true ? 'replace' : 'push'](this.currentLocation.route, void 0, utils_event["g" /* noop */]);
      };

      this.$emit('click', e, go);
      this.hasRouterLink === true && e.navigate !== false && go();
    },

    __onKeydown(e) {
      if (Object(key_composition["a" /* isKeyCode */])(e, [13, 32]) === true) {
        Object(utils_event["l" /* stopAndPrevent */])(e);

        if (keyboardTarget !== this.$el) {
          keyboardTarget !== void 0 && this.__cleanup(); // focus external button if the focus helper was focused before

          this.$el.focus();
          keyboardTarget = this.$el;
          this.$el.classList.add('q-btn--active');
          document.addEventListener('keyup', this.__onPressEnd, true);
          this.$el.addEventListener('blur', this.__onPressEnd, passiveCapture);
        }
      }

      this.$emit('keydown', e);
    },

    __onTouchstart(e) {
      if (touchTarget !== this.$el) {
        touchTarget !== void 0 && this.__cleanup();
        touchTarget = this.$el;
        const target = this.touchTargetEl = Object(touch["b" /* getTouchTarget */])(e.target);
        target.addEventListener('touchcancel', this.__onPressEnd, passiveCapture);
        target.addEventListener('touchend', this.__onPressEnd, passiveCapture);
      } // avoid duplicated mousedown event
      // triggering another early ripple


      this.avoidMouseRipple = true;
      clearTimeout(this.mouseTimer);
      this.mouseTimer = setTimeout(() => {
        this.avoidMouseRipple = false;
      }, 200);
      this.$emit('touchstart', e);
    },

    __onMousedown(e) {
      if (mouseTarget !== this.$el) {
        mouseTarget !== void 0 && this.__cleanup();
        mouseTarget = this.$el;
        this.$el.classList.add('q-btn--active');
        document.addEventListener('mouseup', this.__onPressEnd, passiveCapture);
      }

      e.qSkipRipple = this.avoidMouseRipple === true;
      this.$emit('mousedown', e);
    },

    __onPressEnd(e) {
      // needed for IE (because it emits blur when focusing button from focus helper)
      if (e !== void 0 && e.type === 'blur' && document.activeElement === this.$el) {
        return;
      }

      if (e !== void 0 && e.type === 'keyup') {
        if (keyboardTarget === this.$el && Object(key_composition["a" /* isKeyCode */])(e, [13, 32]) === true) {
          // for click trigger
          const evt = new MouseEvent('click', e);
          evt.qKeyEvent = true;
          e.defaultPrevented === true && Object(utils_event["i" /* prevent */])(evt);
          e.cancelBubble === true && Object(utils_event["k" /* stop */])(evt);
          this.$el.dispatchEvent(evt);
          Object(utils_event["l" /* stopAndPrevent */])(e); // for ripple

          e.qKeyEvent = true;
        }

        this.$emit('keyup', e);
      }

      this.__cleanup();
    },

    __cleanup(destroying) {
      const blurTarget = this.$refs.blurTarget;

      if (destroying !== true && (touchTarget === this.$el || mouseTarget === this.$el) && blurTarget !== void 0 && blurTarget !== document.activeElement) {
        blurTarget.setAttribute('tabindex', -1);
        blurTarget.focus();
      }

      if (touchTarget === this.$el) {
        const target = this.touchTargetEl;
        target.removeEventListener('touchcancel', this.__onPressEnd, passiveCapture);
        target.removeEventListener('touchend', this.__onPressEnd, passiveCapture);
        touchTarget = this.touchTargetEl = void 0;
      }

      if (mouseTarget === this.$el) {
        document.removeEventListener('mouseup', this.__onPressEnd, passiveCapture);
        mouseTarget = void 0;
      }

      if (keyboardTarget === this.$el) {
        document.removeEventListener('keyup', this.__onPressEnd, true);
        this.$el !== void 0 && this.$el.removeEventListener('blur', this.__onPressEnd, passiveCapture);
        keyboardTarget = void 0;
      }

      this.$el !== void 0 && this.$el.classList.remove('q-btn--active');
    },

    __onLoadingEvt(evt) {
      Object(utils_event["l" /* stopAndPrevent */])(evt);
      evt.qSkipRipple = true;
    }

  },

  beforeDestroy() {
    this.__cleanup(true);
  },

  render(h) {
    let inner = [];
    this.icon !== void 0 && inner.push(h(QIcon["a" /* default */], {
      attrs: iconAttrs,
      props: {
        name: this.icon,
        left: this.stack === false && this.hasLabel === true
      }
    }));
    this.hasLabel === true && inner.push(h('span', {
      staticClass: 'block'
    }, [this.label]));
    inner = Object(slot["a" /* mergeSlot */])(inner, this, 'default');

    if (this.iconRight !== void 0 && this.round === false) {
      inner.push(h(QIcon["a" /* default */], {
        attrs: iconAttrs,
        props: {
          name: this.iconRight,
          right: this.stack === false && this.hasLabel === true
        }
      }));
    }

    const child = [h('span', {
      staticClass: 'q-focus-helper',
      ref: 'blurTarget'
    })];

    if (this.loading === true && this.percentage !== void 0) {
      child.push(h('span', {
        staticClass: 'q-btn__progress absolute-full overflow-hidden'
      }, [h('span', {
        staticClass: 'q-btn__progress-indicator fit block',
        class: this.darkPercentage === true ? 'q-btn__progress--dark' : '',
        style: this.percentageStyle
      })]));
    }

    child.push(h('span', {
      staticClass: 'q-btn__wrapper col row q-anchor--skip',
      style: this.wrapperStyle
    }, [h('span', {
      staticClass: 'q-btn__content text-center col items-center q-anchor--skip',
      class: this.innerClasses
    }, inner)]));
    this.loading !== null && child.push(h('transition', {
      props: {
        name: 'q-transition--fade'
      }
    }, this.loading === true ? [h('span', {
      key: 'loading',
      staticClass: 'absolute-full flex flex-center'
    }, this.$scopedSlots.loading !== void 0 ? this.$scopedSlots.loading() : [h(QSpinner["a" /* default */])])] : void 0));
    return h(this.isLink === true ? 'a' : 'button', {
      staticClass: 'q-btn q-btn-item non-selectable no-outline',
      class: this.classes,
      style: this.style,
      attrs: this.attrs,
      on: this.onEvents,
      directives: this.directives
    }, child);
  }

}));

/***/ }),

/***/ "2f6a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__("72df");

// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
// so we use an intermediate function.
function RE(s, f) {
  return RegExp(s, f);
}

exports.UNSUPPORTED_Y = fails(function () {
  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
  var re = RE('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});

exports.BROKEN_CARET = fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = RE('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});


/***/ }),

/***/ "31b4":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "31c3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("6b1d");
var global = __webpack_require__("f498");
var DESCRIPTORS = __webpack_require__("d4cb");
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__("d328");
var ArrayBufferViewCore = __webpack_require__("aaf2");
var ArrayBufferModule = __webpack_require__("cf50");
var anInstance = __webpack_require__("4cce");
var createPropertyDescriptor = __webpack_require__("9618");
var createNonEnumerableProperty = __webpack_require__("5b12");
var toLength = __webpack_require__("b495");
var toIndex = __webpack_require__("ff5c");
var toOffset = __webpack_require__("2dd7");
var toPrimitive = __webpack_require__("083f");
var has = __webpack_require__("f1a7");
var classof = __webpack_require__("da06");
var isObject = __webpack_require__("7526");
var create = __webpack_require__("82e8");
var setPrototypeOf = __webpack_require__("c1a2");
var getOwnPropertyNames = __webpack_require__("65d0").f;
var typedArrayFrom = __webpack_require__("7d23");
var forEach = __webpack_require__("d054").forEach;
var setSpecies = __webpack_require__("0a1e");
var definePropertyModule = __webpack_require__("abdf");
var getOwnPropertyDescriptorModule = __webpack_require__("185a");
var InternalStateModule = __webpack_require__("cdcd");
var inheritIfRequired = __webpack_require__("8fa9");

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var round = Math.round;
var RangeError = global.RangeError;
var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore.TypedArray;
var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var isTypedArray = ArrayBufferViewCore.isTypedArray;
var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
var WRONG_LENGTH = 'Wrong length';

var fromList = function (C, list) {
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
};

var addGetter = function (it, key) {
  nativeDefineProperty(it, key, { get: function () {
    return getInternalState(this)[key];
  } });
};

var isArrayBuffer = function (it) {
  var klass;
  return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
};

var isTypedArrayIndex = function (target, key) {
  return isTypedArray(target)
    && typeof key != 'symbol'
    && key in target
    && String(+key) == String(key);
};

var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
  return isTypedArrayIndex(target, key = toPrimitive(key, true))
    ? createPropertyDescriptor(2, target[key])
    : nativeGetOwnPropertyDescriptor(target, key);
};

var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
  if (isTypedArrayIndex(target, key = toPrimitive(key, true))
    && isObject(descriptor)
    && has(descriptor, 'value')
    && !has(descriptor, 'get')
    && !has(descriptor, 'set')
    // TODO: add validation descriptor w/o calling accessors
    && !descriptor.configurable
    && (!has(descriptor, 'writable') || descriptor.writable)
    && (!has(descriptor, 'enumerable') || descriptor.enumerable)
  ) {
    target[key] = descriptor.value;
    return target;
  } return nativeDefineProperty(target, key, descriptor);
};

if (DESCRIPTORS) {
  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
    definePropertyModule.f = wrappedDefineProperty;
    addGetter(TypedArrayPrototype, 'buffer');
    addGetter(TypedArrayPrototype, 'byteOffset');
    addGetter(TypedArrayPrototype, 'byteLength');
    addGetter(TypedArrayPrototype, 'length');
  }

  $({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
    defineProperty: wrappedDefineProperty
  });

  module.exports = function (TYPE, wrapper, CLAMPED) {
    var BYTES = TYPE.match(/\d+$/)[0] / 8;
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + TYPE;
    var SETTER = 'set' + TYPE;
    var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};

    var getter = function (that, index) {
      var data = getInternalState(that);
      return data.view[GETTER](index * BYTES + data.byteOffset, true);
    };

    var setter = function (that, index, value) {
      var data = getInternalState(that);
      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
    };

    var addElement = function (that, index) {
      nativeDefineProperty(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
        var index = 0;
        var byteOffset = 0;
        var buffer, byteLength, length;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new ArrayBuffer(byteLength);
        } else if (isArrayBuffer(data)) {
          buffer = data;
          byteOffset = toOffset(offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - byteOffset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (isTypedArray(data)) {
          return fromList(TypedArrayConstructor, data);
        } else {
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }
        setInternalState(that, {
          buffer: buffer,
          byteOffset: byteOffset,
          byteLength: byteLength,
          length: length,
          view: new DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
        anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
        return inheritIfRequired(function () {
          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
          if (isArrayBuffer(data)) return $length !== undefined
            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
            : typedArrayOffset !== undefined
              ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
              : new NativeTypedArrayConstructor(data);
          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }(), dummy, TypedArrayConstructor);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
        if (!(key in TypedArrayConstructor)) {
          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
        }
      });
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }

    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
    }

    if (TYPED_ARRAY_TAG) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
    }

    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

    $({
      global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS
    }, exported);

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
    }

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
    }

    setSpecies(CONSTRUCTOR_NAME);
  };
} else module.exports = function () { /* empty */ };


/***/ }),

/***/ "3211":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("7d53");

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ "3230":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export offset */
/* unused harmony export style */
/* unused harmony export height */
/* unused harmony export width */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return css; });
/* unused harmony export cssBatch */
/* unused harmony export ready */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return childHasFocus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getBodyFullscreenElement; });
function offset(el) {
  if (el === window) {
    return {
      top: 0,
      left: 0
    };
  }

  const {
    top,
    left
  } = el.getBoundingClientRect();
  return {
    top,
    left
  };
}
function style(el, property) {
  return window.getComputedStyle(el).getPropertyValue(property);
}
function height(el) {
  return el === window ? window.innerHeight : el.getBoundingClientRect().height;
}
function width(el) {
  return el === window ? window.innerWidth : el.getBoundingClientRect().width;
}
function css(element, css) {
  const style = element.style;
  Object.keys(css).forEach(prop => {
    style[prop] = css[prop];
  });
}
function cssBatch(elements, style) {
  elements.forEach(el => css(el, style));
}
function ready(fn) {
  if (typeof fn !== 'function') {
    return;
  }

  if (document.readyState !== 'loading') {
    return fn();
  }

  document.addEventListener('DOMContentLoaded', fn, false);
} // internal

function childHasFocus(el, focusedEl) {
  if (el === void 0 || el.contains(focusedEl) === true) {
    return true;
  }

  for (let next = el.nextElementSibling; next !== null; next = next.nextElementSibling) {
    if (next.contains(focusedEl)) {
      return true;
    }
  }

  return false;
} // internal

function getBodyFullscreenElement(isFullscreen, activeEl) {
  return isFullscreen === true ? // when a video tag enters fullscreen activeEl is null
  activeEl === document.documentElement || activeEl === null ? document.body : activeEl : document.body;
}
/* unused harmony default export */ var _unused_webpack_default_export = ({
  offset,
  style,
  height,
  width,
  css,
  cssBatch,
  ready
});

/***/ }),

/***/ "32f5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__("95b2");
var anObject = __webpack_require__("157c");
var toLength = __webpack_require__("b495");
var toInteger = __webpack_require__("8bb2");
var requireObjectCoercible = __webpack_require__("730c");
var advanceStringIndex = __webpack_require__("e3f6");
var getSubstitution = __webpack_require__("79b4");
var regExpExec = __webpack_require__("df8c");

var max = Math.max;
var min = Math.min;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = requireObjectCoercible(this);
      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
      return replacer !== undefined
        ? replacer.call(searchValue, O, replaceValue)
        : nativeReplace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      if (
        (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0) ||
        (typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)
      ) {
        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
        if (res.done) return res.value;
      }

      var rx = anObject(regexp);
      var S = String(this);

      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);

      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;

        results.push(result);
        if (!global) break;

        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];

        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];
});


/***/ }),

/***/ "332c":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("4cdd");
var uid = __webpack_require__("1d8a");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "34ff":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ca22");
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("918c");
/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("9869");
/* harmony import */ var _mixins_size_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("d578");
/* harmony import */ var _mixins_tag_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("5cad");
/* harmony import */ var _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("0fb0");
/* harmony import */ var _utils_slot_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("a4b3");







/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_2__["default"].extend({
  name: 'QIcon',
  mixins: [_mixins_listeners_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"], _mixins_size_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], _mixins_tag_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]],
  props: {
    tag: {
      default: 'i'
    },
    name: String,
    color: String,
    left: Boolean,
    right: Boolean
  },
  computed: {
    classes() {
      // "notranslate" class is for Google Translate
      // to avoid tampering with Material Icons ligature font
      return 'q-icon notranslate' + (this.left === true ? ' on-left' : '') + (this.right === true ? ' on-right' : '') + (this.color !== void 0 ? ` text-${this.color}` : '');
    },

    type() {
      let cls;
      let icon = this.name;

      if (!icon) {
        return {
          none: true,
          cls: this.classes
        };
      }

      if (this.$q.iconMapFn !== void 0) {
        const res = this.$q.iconMapFn(icon);

        if (res !== void 0) {
          if (res.icon !== void 0) {
            icon = res.icon;
          } else {
            return {
              cls: res.cls + ' ' + this.classes,
              content: res.content !== void 0 ? res.content : ' '
            };
          }
        }
      }

      if (icon.startsWith('M') === true) {
        const [def, viewBox] = icon.split('|');
        return {
          svg: true,
          cls: this.classes,
          nodes: def.split('&&').map(path => {
            const [d, style, transform] = path.split('@@');
            return this.$createElement('path', {
              attrs: {
                d,
                transform
              },
              style
            });
          }),
          viewBox: viewBox !== void 0 ? viewBox : '0 0 24 24'
        };
      }

      if (icon.startsWith('img:') === true) {
        return {
          img: true,
          cls: this.classes,
          src: icon.substring(4)
        };
      }

      if (icon.startsWith('svguse:') === true) {
        const [def, viewBox] = icon.split('|');
        return {
          svguse: true,
          cls: this.classes,
          src: def.substring(7),
          viewBox: viewBox !== void 0 ? viewBox : '0 0 24 24'
        };
      }

      let content = ' ';

      if (/^[l|f]a[s|r|l|b|d]{0,1} /.test(icon) || icon.startsWith('icon-') === true) {
        cls = icon;
      } else if (icon.startsWith('bt-') === true) {
        cls = `bt ${icon}`;
      } else if (icon.startsWith('eva-') === true) {
        cls = `eva ${icon}`;
      } else if (/^ion-(md|ios|logo)/.test(icon) === true) {
        cls = `ionicons ${icon}`;
      } else if (icon.startsWith('ion-') === true) {
        cls = `ionicons ion-${this.$q.platform.is.ios === true ? 'ios' : 'md'}${icon.substr(3)}`;
      } else if (icon.startsWith('mdi-') === true) {
        cls = `mdi ${icon}`;
      } else if (icon.startsWith('iconfont ') === true) {
        cls = `${icon}`;
      } else if (icon.startsWith('ti-') === true) {
        cls = `themify-icon ${icon}`;
      } else if (icon.startsWith('bi-') === true) {
        cls = `bootstrap-icons ${icon}`;
      } else {
        cls = 'material-icons';

        if (icon.startsWith('o_') === true) {
          icon = icon.substring(2);
          cls += '-outlined';
        } else if (icon.startsWith('r_') === true) {
          icon = icon.substring(2);
          cls += '-round';
        } else if (icon.startsWith('s_') === true) {
          icon = icon.substring(2);
          cls += '-sharp';
        }

        content = icon;
      }

      return {
        cls: cls + ' ' + this.classes,
        content
      };
    }

  },

  render(h) {
    const data = {
      class: this.type.cls,
      style: this.sizeStyle,
      on: _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.qListeners),
      attrs: {
        'aria-hidden': 'true',
        role: 'presentation'
      }
    };

    if (this.type.none === true) {
      return h(this.tag, data, Object(_utils_slot_js__WEBPACK_IMPORTED_MODULE_6__[/* slot */ "c"])(this, 'default'));
    }

    if (this.type.img === true) {
      data.attrs.src = this.type.src;
      return h('img', data);
    }

    if (this.type.svg === true) {
      data.attrs.focusable = 'false';
      /* needed for IE11 */

      data.attrs.viewBox = this.type.viewBox;
      return h('svg', data, Object(_utils_slot_js__WEBPACK_IMPORTED_MODULE_6__[/* mergeSlot */ "a"])(this.type.nodes, this, 'default'));
    }

    if (this.type.svguse === true) {
      data.attrs.focusable = 'false';
      /* needed for IE11 */

      data.attrs.viewBox = this.type.viewBox;
      return h('svg', data, [h('use', {
        attrs: {
          'xlink:href': this.type.src
        }
      }), Object(_utils_slot_js__WEBPACK_IMPORTED_MODULE_6__[/* mergeSlot */ "a"])(this.type.nodes, this, 'default')]);
    }

    return h(this.tag, data, Object(_utils_slot_js__WEBPACK_IMPORTED_MODULE_6__[/* mergeSlot */ "a"])([this.type.content], this, 'default'));
  }

}));

/***/ }),

/***/ "352f":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarInput_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("3979");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarInput_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarInput_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "36cb":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_CategoryPanel_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("cdee");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_CategoryPanel_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_CategoryPanel_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "36df":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getModifierDirections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getTouchTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return shouldStart; });
/* harmony import */ var _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5094");

const directions = ['left', 'right', 'up', 'down', 'horizontal', 'vertical'];
const modifiersAll = {
  left: true,
  right: true,
  up: true,
  down: true,
  horizontal: true,
  vertical: true,
  all: true
};
function getModifierDirections(mod) {
  const dir = {};
  directions.forEach(direction => {
    if (mod[direction]) {
      dir[direction] = true;
    }
  });

  if (Object.keys(dir).length === 0) {
    return modifiersAll;
  }

  if (dir.horizontal === true) {
    dir.left = dir.right = true;
  }

  if (dir.vertical === true) {
    dir.up = dir.down = true;
  }

  if (dir.left === true && dir.right === true) {
    dir.horizontal = true;
  }

  if (dir.up === true && dir.down === true) {
    dir.vertical = true;
  }

  if (dir.horizontal === true && dir.vertical === true) {
    dir.all = true;
  }

  return dir;
}
const getTouchTarget = _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__[/* isSSR */ "f"] === false && _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__[/* iosEmulated */ "e"] !== true && (_plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__[/* client */ "a"].is.ios === true || window.navigator.vendor.toLowerCase().indexOf('apple') > -1) ? () => document : target => target;
function shouldStart(evt, ctx) {
  return ctx.event === void 0 && evt.target !== void 0 && evt.target.draggable !== true && typeof ctx.handler === 'function' && evt.target.nodeName.toUpperCase() !== 'INPUT' && (evt.qClonedBy === void 0 || evt.qClonedBy.indexOf(ctx.uid) === -1);
}

/***/ }),

/***/ "378c":
/***/ (function(module, exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__("83a6");
var requireObjectCoercible = __webpack_require__("730c");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "37d1":
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__("730c");

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "3946":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@babel/runtime/helpers/objectSpread2.js
var objectSpread2 = __webpack_require__("ca22");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2);

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue/dist/vue.runtime.esm.js
var vue_runtime_esm = __webpack_require__("9869");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/field/QField.js + 2 modules
var QField = __webpack_require__("b693");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/icon/QIcon.js
var QIcon = __webpack_require__("34ff");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/dark.js
var dark = __webpack_require__("87b2");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/ripple.js + 1 modules
var ripple = __webpack_require__("b190");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/size.js
var size = __webpack_require__("d578");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("9ac9");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/slot.js
var slot = __webpack_require__("a4b3");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/cache.js
var cache = __webpack_require__("6459");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/chip/QChip.js








/* harmony default export */ var QChip = (vue_runtime_esm["default"].extend({
  name: 'QChip',
  mixins: [ripple["a" /* default */], dark["a" /* default */], Object(size["b" /* getSizeMixin */])({
    xs: 8,
    sm: 10,
    md: 14,
    lg: 20,
    xl: 24
  })],
  model: {
    event: 'remove'
  },
  props: {
    dense: Boolean,
    icon: String,
    iconRight: String,
    iconRemove: String,
    iconSelected: String,
    label: [String, Number],
    color: String,
    textColor: String,
    value: {
      type: Boolean,
      default: true
    },
    selected: {
      type: Boolean,
      default: null
    },
    square: Boolean,
    outline: Boolean,
    clickable: Boolean,
    removable: Boolean,
    tabindex: [String, Number],
    disable: Boolean
  },
  computed: {
    classes() {
      const text = this.outline === true ? this.color || this.textColor : this.textColor;
      return {
        [`bg-${this.color}`]: this.outline === false && this.color !== void 0,
        [`text-${text} q-chip--colored`]: text,
        disabled: this.disable,
        'q-chip--dense': this.dense,
        'q-chip--outline': this.outline,
        'q-chip--selected': this.selected,
        'q-chip--clickable cursor-pointer non-selectable q-hoverable': this.isClickable,
        'q-chip--square': this.square,
        'q-chip--dark q-dark': this.isDark
      };
    },

    hasLeftIcon() {
      return this.selected === true || this.icon !== void 0;
    },

    leftIcon() {
      return this.selected === true ? this.iconSelected || this.$q.iconSet.chip.selected : this.icon;
    },

    removeIcon() {
      return this.iconRemove || this.$q.iconSet.chip.remove;
    },

    isClickable() {
      return this.disable === false && (this.clickable === true || this.selected !== null);
    },

    attrs() {
      return this.disable === true ? {
        tabindex: -1,
        'aria-disabled': 'true'
      } : {
        tabindex: this.tabindex || 0
      };
    }

  },
  methods: {
    __onKeyup(e) {
      e.keyCode === 13
      /* ENTER */
      && this.__onClick(e);
    },

    __onClick(e) {
      if (!this.disable) {
        this.$emit('update:selected', !this.selected);
        this.$emit('click', e);
      }
    },

    __onRemove(e) {
      if (e.keyCode === void 0 || e.keyCode === 13) {
        Object(utils_event["l" /* stopAndPrevent */])(e);
        !this.disable && this.$emit('remove', false);
      }
    },

    __getContent(h) {
      const child = [];
      this.isClickable === true && child.push(h('div', {
        staticClass: 'q-focus-helper'
      }));
      this.hasLeftIcon === true && child.push(h(QIcon["a" /* default */], {
        staticClass: 'q-chip__icon q-chip__icon--left',
        props: {
          name: this.leftIcon
        }
      }));
      const label = this.label !== void 0 ? [h('div', {
        staticClass: 'ellipsis'
      }, [this.label])] : void 0;
      child.push(h('div', {
        staticClass: 'q-chip__content col row no-wrap items-center q-anchor--skip'
      }, Object(slot["b" /* mergeSlotSafely */])(label, this, 'default')));
      this.iconRight && child.push(h(QIcon["a" /* default */], {
        staticClass: 'q-chip__icon q-chip__icon--right',
        props: {
          name: this.iconRight
        }
      }));
      this.removable === true && child.push(h(QIcon["a" /* default */], {
        staticClass: 'q-chip__icon q-chip__icon--remove cursor-pointer',
        props: {
          name: this.removeIcon
        },
        attrs: this.attrs,
        on: Object(cache["b" /* default */])(this, 'non', {
          click: this.__onRemove,
          keyup: this.__onRemove
        })
      }));
      return child;
    }

  },

  render(h) {
    if (this.value === false) {
      return;
    }

    const data = {
      staticClass: 'q-chip row inline no-wrap items-center',
      class: this.classes,
      style: this.sizeStyle
    };
    this.isClickable === true && Object.assign(data, {
      attrs: this.attrs,
      on: Object(cache["b" /* default */])(this, 'click', {
        click: this.__onClick,
        keyup: this.__onKeyup
      }),
      directives: Object(cache["b" /* default */])(this, 'dir#' + this.ripple, [{
        name: 'ripple',
        value: this.ripple
      }])
    });
    return h('div', data, this.__getContent(h));
  }

}));
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/item/QItem.js + 1 modules
var QItem = __webpack_require__("ac9b");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/item/QItemSection.js
var QItemSection = __webpack_require__("66dc");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/listeners.js
var listeners = __webpack_require__("0fb0");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/item/QItemLabel.js




/* harmony default export */ var QItemLabel = (vue_runtime_esm["default"].extend({
  name: 'QItemLabel',
  mixins: [listeners["a" /* default */]],
  props: {
    overline: Boolean,
    caption: Boolean,
    header: Boolean,
    lines: [Number, String]
  },
  computed: {
    classes() {
      return {
        'q-item__label--overline text-overline': this.overline,
        'q-item__label--caption text-caption': this.caption,
        'q-item__label--header': this.header,
        'ellipsis': parseInt(this.lines, 10) === 1
      };
    },

    style() {
      if (this.lines !== void 0 && parseInt(this.lines, 10) > 1) {
        return {
          overflow: 'hidden',
          display: '-webkit-box',
          '-webkit-box-orient': 'vertical',
          '-webkit-line-clamp': this.lines
        };
      }
    }

  },

  render(h) {
    return h('div', {
      staticClass: 'q-item__label',
      style: this.style,
      class: this.classes,
      on: objectSpread2_default()({}, this.qListeners)
    }, Object(slot["c" /* slot */])(this, 'default'));
  }

}));
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/anchor.js
var mixins_anchor = __webpack_require__("0aa9");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/model-toggle.js
var model_toggle = __webpack_require__("56c6");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/portal.js
var portal = __webpack_require__("6769");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/transition.js
var transition = __webpack_require__("ee92");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/attrs.js
var attrs = __webpack_require__("ffad");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/plugins/Platform.js
var Platform = __webpack_require__("5094");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/vm.js
function getVmOfNode(el) {
  for (let node = el; node !== null; node = node.parentNode) {
    // node.__vue__ can be null if the instance was destroyed
    if (node.__vue__ === null) {
      return;
    }

    if (node.__vue__ !== void 0) {
      return node.__vue__;
    }
  }
}
function isVmChildOf(childVm, parentVm) {
  for (let vm = childVm; vm !== void 0; vm = vm.$parent) {
    if (vm === parentVm) {
      return true;
    }
  }

  return false;
}
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/menu/ClickOutside.js



let timer;
const {
  notPassiveCapture,
  passiveCapture
} = utils_event["f" /* listenOpts */],
      handlers = {
  click: [],
  focus: []
};

function hasModalsAbove(node) {
  while ((node = node.nextElementSibling) !== null) {
    if (node.classList.contains('q-dialog--modal')) {
      return true;
    }
  }

  return false;
}

function execHandlers(list, evt) {
  for (let i = list.length - 1; i >= 0; i--) {
    if (list[i](evt) === void 0) {
      return;
    }
  }
}

function globalHandler(evt) {
  clearTimeout(timer); // prevent autofocus on body resulting from blur

  if (evt.type === 'focusin' && (Platform["a" /* client */].is.ie === true && evt.target === document.body || evt.target.hasAttribute('tabindex') === true)) {
    timer = setTimeout(() => {
      execHandlers(handlers.focus, evt);
    }, Platform["a" /* client */].is.ie === true ? 500 : 200);
  } else {
    execHandlers(handlers.click, evt);
  }
}

/* harmony default export */ var ClickOutside = ({
  name: 'click-outside',

  bind(el, {
    value,
    arg
  }, vnode) {
    const vmEl = vnode.componentInstance || vnode.context;
    const ctx = {
      trigger: value,
      toggleEl: arg,

      handler(evt) {
        const target = evt.target;

        if (evt.qClickOutside !== true && target !== void 0 && target.nodeType !== 8 && // directives that prevent click by using pointer-events none generate click on html element
        target !== document.documentElement && target.classList.contains('no-pointer-events') === false && hasModalsAbove(el) !== true && (ctx.toggleEl === void 0 || ctx.toggleEl.contains(target) === false) && (target === document.body || isVmChildOf(getVmOfNode(target), vmEl) === false)) {
          // mark the event as being processed by clickOutside
          // used to prevent refocus after menu close
          evt.qClickOutside = true;
          return ctx.trigger(evt);
        }
      }

    };

    if (el.__qclickoutside) {
      el.__qclickoutside_old = el.__qclickoutside;
    }

    el.__qclickoutside = ctx;

    if (handlers.click.length === 0) {
      document.addEventListener('mousedown', globalHandler, notPassiveCapture);
      document.addEventListener('touchstart', globalHandler, notPassiveCapture);
      document.addEventListener('focusin', globalHandler, passiveCapture);
    }

    handlers.click.push(ctx.handler);
    ctx.timerFocusin = setTimeout(() => {
      handlers.focus.push(ctx.handler);
    }, 500);
  },

  update(el, {
    value,
    oldValue,
    arg
  }) {
    const ctx = el.__qclickoutside;

    if (value !== oldValue) {
      ctx.trigger = value;
    }

    if (arg !== ctx.arg) {
      ctx.toggleEl = arg;
    }
  },

  unbind(el) {
    const ctx = el.__qclickoutside_old || el.__qclickoutside;

    if (ctx !== void 0) {
      clearTimeout(ctx.timerFocusin);
      const indexClick = handlers.click.findIndex(h => h === ctx.handler),
            indexFocus = handlers.focus.findIndex(h => h === ctx.handler);
      indexClick > -1 && handlers.click.splice(indexClick, 1);
      indexFocus > -1 && handlers.focus.splice(indexFocus, 1);

      if (handlers.click.length === 0) {
        clearTimeout(timer);
        document.removeEventListener('mousedown', globalHandler, notPassiveCapture);
        document.removeEventListener('touchstart', globalHandler, notPassiveCapture);
        document.removeEventListener('focusin', globalHandler, passiveCapture);
      }

      delete el[el.__qclickoutside_old ? '__qclickoutside_old' : '__qclickoutside'];
    }
  }

});
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/scroll.js
var utils_scroll = __webpack_require__("8047");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/escape-key.js
var escape_key = __webpack_require__("072e");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/position-engine.js
var position_engine = __webpack_require__("e2a2");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/menu/QMenu.js














/* harmony default export */ var QMenu = (vue_runtime_esm["default"].extend({
  name: 'QMenu',
  mixins: [attrs["b" /* default */], dark["a" /* default */], mixins_anchor["a" /* default */], model_toggle["a" /* default */], portal["b" /* default */], transition["a" /* default */]],
  directives: {
    ClickOutside: ClickOutside
  },
  props: {
    persistent: Boolean,
    autoClose: Boolean,
    separateClosePopup: Boolean,
    noRouteDismiss: Boolean,
    noRefocus: Boolean,
    noFocus: Boolean,
    fit: Boolean,
    cover: Boolean,
    square: Boolean,
    anchor: {
      type: String,
      validator: position_engine["d" /* validatePosition */]
    },
    self: {
      type: String,
      validator: position_engine["d" /* validatePosition */]
    },
    offset: {
      type: Array,
      validator: position_engine["c" /* validateOffset */]
    },
    scrollTarget: {
      default: void 0
    },
    touchPosition: Boolean,
    maxHeight: {
      type: String,
      default: null
    },
    maxWidth: {
      type: String,
      default: null
    }
  },
  computed: {
    anchorOrigin() {
      return Object(position_engine["a" /* parsePosition */])(this.anchor || (this.cover === true ? 'center middle' : 'bottom start'), this.$q.lang.rtl);
    },

    selfOrigin() {
      return this.cover === true ? this.anchorOrigin : Object(position_engine["a" /* parsePosition */])(this.self || 'top start', this.$q.lang.rtl);
    },

    menuClass() {
      return (this.square === true ? ' q-menu--square' : '') + (this.isDark === true ? ' q-menu--dark q-dark' : '');
    },

    hideOnRouteChange() {
      return this.persistent !== true && this.noRouteDismiss !== true;
    },

    onEvents() {
      const on = objectSpread2_default()(objectSpread2_default()({}, this.qListeners), {}, {
        // stop propagating these events from children
        input: utils_event["k" /* stop */],
        'popup-show': utils_event["k" /* stop */],
        'popup-hide': utils_event["k" /* stop */]
      });

      if (this.autoClose === true) {
        on.click = this.__onAutoClose;
      }

      return on;
    },

    attrs() {
      return objectSpread2_default()({
        tabindex: -1
      }, this.qAttrs);
    }

  },
  methods: {
    focus() {
      let node = this.__portal !== void 0 && this.__portal.$refs !== void 0 ? this.__portal.$refs.inner : void 0;

      if (node !== void 0 && node.contains(document.activeElement) !== true) {
        node = node.querySelector('[autofocus], [data-autofocus]') || node;
        node.focus();
      }
    },

    __show(evt) {
      // IE can have null document.activeElement
      this.__refocusTarget = this.noRefocus === false && document.activeElement !== null ? document.activeElement : void 0;
      escape_key["a" /* default */].register(this, () => {
        if (this.persistent !== true) {
          this.$emit('escape-key');
          this.hide();
        }
      });

      this.__showPortal();

      this.__configureScrollTarget();

      this.absoluteOffset = void 0;

      if (evt !== void 0 && (this.touchPosition || this.contextMenu)) {
        const pos = Object(utils_event["h" /* position */])(evt);

        if (pos.left !== void 0) {
          const {
            top,
            left
          } = this.anchorEl.getBoundingClientRect();
          this.absoluteOffset = {
            left: pos.left - left,
            top: pos.top - top
          };
        }
      }

      if (this.unwatch === void 0) {
        this.unwatch = this.$watch(() => this.$q.screen.width + '|' + this.$q.screen.height + '|' + this.self + '|' + this.anchor + '|' + this.$q.lang.rtl, this.updatePosition);
      }

      this.$el.dispatchEvent(Object(utils_event["c" /* create */])('popup-show', {
        bubbles: true
      })); // IE can have null document.activeElement

      if (this.noFocus !== true && document.activeElement !== null) {
        document.activeElement.blur();
      }

      this.__nextTick(() => {
        this.updatePosition();
        this.noFocus !== true && this.focus();
      });

      this.__setTimeout(() => {
        // required in order to avoid the "double-tap needed" issue
        if (this.$q.platform.is.ios === true) {
          // if auto-close, then this click should
          // not close the menu
          this.__avoidAutoClose = this.autoClose;

          this.__portal.$el.click();
        }

        this.updatePosition();
        this.$emit('show', evt);
      }, 300);
    },

    __hide(evt) {
      this.__anchorCleanup(true); // check null for IE


      if (this.__refocusTarget !== void 0 && this.__refocusTarget !== null && ( // menu was hidden from code or ESC plugin
      evt === void 0 || // menu was not closed from a mouse or touch clickOutside
      evt.qClickOutside !== true)) {
        this.__refocusTarget.focus();
      }

      this.$el.dispatchEvent(Object(utils_event["c" /* create */])('popup-hide', {
        bubbles: true
      }));

      this.__setTimeout(() => {
        this.__hidePortal();

        this.$emit('hide', evt);
      }, 300);
    },

    __anchorCleanup(hiding) {
      this.absoluteOffset = void 0;

      if (this.unwatch !== void 0) {
        this.unwatch();
        this.unwatch = void 0;
      }

      if (hiding === true || this.showing === true) {
        escape_key["a" /* default */].pop(this);

        this.__unconfigureScrollTarget();
      }
    },

    __unconfigureScrollTarget() {
      if (this.__scrollTarget !== void 0) {
        this.__changeScrollEvent(this.__scrollTarget);

        this.__scrollTarget = void 0;
      }
    },

    __configureScrollTarget() {
      if (this.anchorEl !== void 0 || this.scrollTarget !== void 0) {
        this.__scrollTarget = Object(utils_scroll["d" /* getScrollTarget */])(this.anchorEl, this.scrollTarget);

        this.__changeScrollEvent(this.__scrollTarget, this.updatePosition);
      }
    },

    __onAutoClose(e) {
      // if auto-close, then the ios double-tap fix which
      // issues a click should not close the menu
      if (this.__avoidAutoClose !== true) {
        Object(portal["a" /* closePortalMenus */])(this, e);
        this.qListeners.click !== void 0 && this.$emit('click', e);
      } else {
        this.__avoidAutoClose = false;
      }
    },

    updatePosition() {
      if (this.anchorEl === void 0 || this.__portal === void 0) {
        return;
      }

      const el = this.__portal.$el;

      if (el.nodeType === 8) {
        // IE replaces the comment with delay
        setTimeout(this.updatePosition, 25);
        return;
      }

      Object(position_engine["b" /* setPosition */])({
        el,
        offset: this.offset,
        anchorEl: this.anchorEl,
        anchorOrigin: this.anchorOrigin,
        selfOrigin: this.selfOrigin,
        absoluteOffset: this.absoluteOffset,
        fit: this.fit,
        cover: this.cover,
        maxHeight: this.maxHeight,
        maxWidth: this.maxWidth
      });
    },

    __onClickOutside(e) {
      if (this.persistent !== true && this.showing === true) {
        const targetClassList = e.target.classList;
        Object(portal["a" /* closePortalMenus */])(this, e);

        if ( // always prevent touch event
        e.type === 'touchstart' || // prevent click if it's on a dialog backdrop
        targetClassList.contains('q-dialog__backdrop')) {
          Object(utils_event["m" /* stopAndPreventClick */])(e);
        }

        return true;
      }
    },

    __renderPortal(h) {
      return h('transition', {
        props: {
          name: this.transition
        }
      }, [this.showing === true ? h('div', {
        ref: 'inner',
        staticClass: 'q-menu q-position-engine scroll' + this.menuClass,
        class: this.contentClass,
        style: this.contentStyle,
        attrs: this.attrs,
        on: this.onEvents,
        directives: [{
          name: 'click-outside',
          value: this.__onClickOutside,
          arg: this.anchorEl
        }]
      }, Object(slot["c" /* slot */])(this, 'default')) : null]);
    }

  },

  mounted() {
    this.__processModelChange(this.value);
  },

  beforeDestroy() {
    // When the menu is destroyed while open we can only emit the event on anchorEl
    if (this.showing === true && this.anchorEl !== void 0) {
      this.anchorEl.dispatchEvent(Object(utils_event["c" /* create */])('popup-hide', {
        bubbles: true
      }));
    }
  }

}));
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/dialog/QDialog.js + 2 modules
var QDialog = __webpack_require__("e81c");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/web.dom-collections.iterator.js
var web_dom_collections_iterator = __webpack_require__("918c");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.array-buffer.constructor.js
var es_array_buffer_constructor = __webpack_require__("2169");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.array-buffer.slice.js
var es_array_buffer_slice = __webpack_require__("b257");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/is.js



const hasMap = typeof Map === 'function',
      hasSet = typeof Set === 'function',
      hasArrayBuffer = typeof ArrayBuffer === 'function';
function isDeepEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (a !== null && b !== null && typeof a === 'object' && typeof b === 'object') {
    if (a.constructor !== b.constructor) {
      return false;
    }

    let length, i;

    if (a.constructor === Array) {
      length = a.length;

      if (length !== b.length) {
        return false;
      }

      for (i = length; i-- !== 0;) {
        if (isDeepEqual(a[i], b[i]) !== true) {
          return false;
        }
      }

      return true;
    }

    if (hasMap === true && a.constructor === Map) {
      if (a.size !== b.size) {
        return false;
      }

      i = a.entries().next();

      while (i.done !== true) {
        if (b.has(i.value[0]) !== true) {
          return false;
        }

        i = i.next();
      }

      i = a.entries().next();

      while (i.done !== true) {
        if (isDeepEqual(i.value[1], b.get(i.value[0])) !== true) {
          return false;
        }

        i = i.next();
      }

      return true;
    }

    if (hasSet === true && a.constructor === Set) {
      if (a.size !== b.size) {
        return false;
      }

      i = a.entries().next();

      while (i.done !== true) {
        if (b.has(i.value[0]) !== true) {
          return false;
        }

        i = i.next();
      }

      return true;
    }

    if (hasArrayBuffer === true && a.buffer != null && a.buffer.constructor === ArrayBuffer) {
      length = a.length;

      if (length !== b.length) {
        return false;
      }

      for (i = length; i-- !== 0;) {
        if (a[i] !== b[i]) {
          return false;
        }
      }

      return true;
    }

    if (a.constructor === RegExp) {
      return a.source === b.source && a.flags === b.flags;
    }

    if (a.valueOf !== Object.prototype.valueOf) {
      return a.valueOf() === b.valueOf();
    }

    if (a.toString !== Object.prototype.toString) {
      return a.toString() === b.toString();
    }

    const keys = Object.keys(a);
    length = keys.length;

    if (length !== Object.keys(b).length) {
      return false;
    }

    for (i = length; i-- !== 0;) {
      const key = keys[i];

      if (isDeepEqual(a[key], b[key]) !== true) {
        return false;
      }
    }

    return true;
  } // true if both NaN, false otherwise


  return a !== a && b !== b; // eslint-disable-line no-self-compare
}
function isPrintableChar(v) {
  return v > 47 && v < 58 || // number keys
  v === 32 || v === 13 || // spacebar & return key(s) (if you want to allow carriage returns)
  v > 64 && v < 91 || // letter keys
  v > 95 && v < 112 || // numpad keys
  v > 185 && v < 193 || // ;=,-./` (in order)
  v > 218 && v < 223;
}
function isObject(v) {
  return Object(v) === v;
}
function isDate(v) {
  return Object.prototype.toString.call(v) === '[object Date]';
}
function isRegexp(v) {
  return Object.prototype.toString.call(v) === '[object RegExp]';
}
function isNumber(v) {
  return typeof v === 'number' && isFinite(v);
}
function isString(v) {
  return typeof v === 'string';
}
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/format.js
var format = __webpack_require__("a114");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/key-composition.js
var key_composition = __webpack_require__("1b63");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/form.js
var mixins_form = __webpack_require__("87c8");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.array.reduce.js
var es_array_reduce = __webpack_require__("28eb");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.string.replace.js
var es_string_replace = __webpack_require__("32f5");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/debounce.js
var debounce = __webpack_require__("9007");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/virtual-scroll.js




const aggBucketSize = 1000;
const scrollToEdges = ['start', 'center', 'end', 'start-force', 'center-force', 'end-force'];
const slice = Array.prototype.slice;
let buggyRTL = void 0; // mobile Chrome takes the crown for this

function detectBuggyRTL() {
  const scroller = document.createElement('div');
  const spacer = document.createElement('div');
  scroller.setAttribute('dir', 'rtl');
  scroller.style.width = '1px';
  scroller.style.height = '1px';
  scroller.style.overflow = 'auto';
  spacer.style.width = '1000px';
  spacer.style.height = '1px';
  document.body.appendChild(scroller);
  scroller.appendChild(spacer);
  scroller.scrollLeft = -1000;
  buggyRTL = scroller.scrollLeft >= 0;
  scroller.remove();
}

function sumFn(acc, h) {
  return acc + h;
}

function getScrollDetails(parent, child, beforeRef, afterRef, horizontal, rtl, stickyStart, stickyEnd) {
  const parentCalc = parent === window ? document.scrollingElement || document.documentElement : parent,
        propElSize = horizontal === true ? 'offsetWidth' : 'offsetHeight',
        details = {
    scrollStart: 0,
    scrollViewSize: -stickyStart - stickyEnd,
    scrollMaxSize: 0,
    offsetStart: -stickyStart,
    offsetEnd: -stickyEnd
  };

  if (horizontal === true) {
    if (parent === window) {
      details.scrollStart = window.pageXOffset || window.scrollX || document.body.scrollLeft || 0;
      details.scrollViewSize += window.innerWidth;
    } else {
      details.scrollStart = parentCalc.scrollLeft;
      details.scrollViewSize += parentCalc.clientWidth;
    }

    details.scrollMaxSize = parentCalc.scrollWidth;

    if (rtl === true) {
      details.scrollStart = (buggyRTL === true ? details.scrollMaxSize - details.scrollViewSize : 0) - details.scrollStart;
    }
  } else {
    if (parent === window) {
      details.scrollStart = window.pageYOffset || window.scrollY || document.body.scrollTop || 0;
      details.scrollViewSize += window.innerHeight;
    } else {
      details.scrollStart = parentCalc.scrollTop;
      details.scrollViewSize += parentCalc.clientHeight;
    }

    details.scrollMaxSize = parentCalc.scrollHeight;
  }

  if (beforeRef !== void 0) {
    for (let el = beforeRef.previousElementSibling; el !== null; el = el.previousElementSibling) {
      if (el.classList.contains('q-virtual-scroll--skip') === false) {
        details.offsetStart += el[propElSize];
      }
    }
  }

  if (afterRef !== void 0) {
    for (let el = afterRef.nextElementSibling; el !== null; el = el.nextElementSibling) {
      if (el.classList.contains('q-virtual-scroll--skip') === false) {
        details.offsetEnd += el[propElSize];
      }
    }
  }

  if (child !== parent) {
    const parentRect = parentCalc.getBoundingClientRect(),
          childRect = child.getBoundingClientRect();

    if (horizontal === true) {
      details.offsetStart += childRect.left - parentRect.left;
      details.offsetEnd -= childRect.width;
    } else {
      details.offsetStart += childRect.top - parentRect.top;
      details.offsetEnd -= childRect.height;
    }

    if (parent !== window) {
      details.offsetStart += details.scrollStart;
    }

    details.offsetEnd += details.scrollMaxSize - details.offsetStart;
  }

  return details;
}

function setScroll(parent, scroll, horizontal, rtl) {
  if (parent === window) {
    if (horizontal === true) {
      if (rtl === true) {
        scroll = (buggyRTL === true ? document.body.scrollWidth - window.innerWidth : 0) - scroll;
      }

      window.scrollTo(scroll, window.pageYOffset || window.scrollY || document.body.scrollTop || 0);
    } else {
      window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, scroll);
    }
  } else if (horizontal === true) {
    if (rtl === true) {
      scroll = (buggyRTL === true ? parent.scrollWidth - parent.offsetWidth : 0) - scroll;
    }

    parent.scrollLeft = scroll;
  } else {
    parent.scrollTop = scroll;
  }
}

function sumSize(sizeAgg, size, from, to) {
  if (from >= to) {
    return 0;
  }

  const lastTo = size.length,
        fromAgg = Math.floor(from / aggBucketSize),
        toAgg = Math.floor((to - 1) / aggBucketSize) + 1;
  let total = sizeAgg.slice(fromAgg, toAgg).reduce(sumFn, 0);

  if (from % aggBucketSize !== 0) {
    total -= size.slice(fromAgg * aggBucketSize, from).reduce(sumFn, 0);
  }

  if (to % aggBucketSize !== 0 && to !== lastTo) {
    total -= size.slice(to, toAgg * aggBucketSize).reduce(sumFn, 0);
  }

  return total;
}

const commonVirtScrollProps = {
  virtualScrollSliceSize: {
    type: [Number, String],
    default: null
  },
  virtualScrollSliceRatioBefore: {
    type: [Number, String],
    default: 1
  },
  virtualScrollSliceRatioAfter: {
    type: [Number, String],
    default: 1
  },
  virtualScrollItemSize: {
    type: [Number, String],
    default: 24
  },
  virtualScrollStickySizeStart: {
    type: [Number, String],
    default: 0
  },
  virtualScrollStickySizeEnd: {
    type: [Number, String],
    default: 0
  },
  tableColspan: [Number, String]
};
let id = 1;

function setOverflowAnchor(id, index) {
  if (setOverflowAnchor.isSupported === void 0) {
    setOverflowAnchor.isSupported = window.getComputedStyle(document.body).overflowAnchor !== void 0;
  }

  if (setOverflowAnchor.isSupported === false) {
    return;
  }

  const ssId = id + '_ss';
  let styleSheet = document.getElementById(ssId);

  if (styleSheet === null) {
    styleSheet = document.createElement('style');
    styleSheet.type = 'text/css';
    styleSheet.id = ssId;
    document.head.appendChild(styleSheet);
  }

  if (styleSheet.qChildIndex !== index) {
    styleSheet.qChildIndex = index;
    styleSheet.innerHTML = `#${id} > *:nth-child(${index}) { overflow-anchor: auto }`;
  }
}

const commonVirtPropsList = Object.keys(commonVirtScrollProps);
/* harmony default export */ var virtual_scroll = ({
  props: objectSpread2_default()({
    virtualScrollHorizontal: Boolean
  }, commonVirtScrollProps),

  data() {
    return {
      virtualScrollSliceRange: {
        from: 0,
        to: 0
      },
      id: 'qvs_' + id++
    };
  },

  watch: {
    needsSliceRecalc() {
      this.__setVirtualScrollSize();
    },

    needsReset() {
      this.reset();
    }

  },
  computed: {
    needsReset() {
      return ['virtualScrollItemSizeComputed', 'virtualScrollHorizontal'].map(p => this[p]).join(';');
    },

    needsSliceRecalc() {
      return this.needsReset + ';' + ['virtualScrollSliceRatioBefore', 'virtualScrollSliceRatioAfter'].map(p => this[p]).join(';');
    },

    colspanAttr() {
      return this.tableColspan !== void 0 ? {
        colspan: this.tableColspan
      } : {
        colspan: 100
      };
    },

    virtualScrollItemSizeComputed() {
      return this.virtualScrollItemSize;
    }

  },
  methods: {
    reset() {
      this.__resetVirtualScroll(this.prevToIndex, true);
    },

    refresh(toIndex) {
      this.__resetVirtualScroll(toIndex === void 0 ? this.prevToIndex : toIndex);
    },

    scrollTo(toIndex, edge) {
      const scrollEl = this.__getVirtualScrollTarget();

      if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {
        return;
      }

      const scrollDetails = getScrollDetails(scrollEl, this.__getVirtualScrollEl(), this.$refs.before, this.$refs.after, this.virtualScrollHorizontal, this.$q.lang.rtl, this.virtualScrollStickySizeStart, this.virtualScrollStickySizeEnd);
      this.__scrollViewSize !== scrollDetails.scrollViewSize && this.__setVirtualScrollSize(scrollDetails.scrollViewSize);

      this.__setVirtualScrollSliceRange(scrollEl, scrollDetails, Math.min(this.virtualScrollLength - 1, Math.max(0, parseInt(toIndex, 10) || 0)), 0, scrollToEdges.indexOf(edge) > -1 ? edge : this.prevToIndex > -1 && toIndex > this.prevToIndex ? 'end' : 'start');
    },

    __onVirtualScrollEvt() {
      const scrollEl = this.__getVirtualScrollTarget();

      if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {
        return;
      }

      const scrollDetails = getScrollDetails(scrollEl, this.__getVirtualScrollEl(), this.$refs.before, this.$refs.after, this.virtualScrollHorizontal, this.$q.lang.rtl, this.virtualScrollStickySizeStart, this.virtualScrollStickySizeEnd),
            listLastIndex = this.virtualScrollLength - 1,
            listEndOffset = scrollDetails.scrollMaxSize - scrollDetails.offsetStart - scrollDetails.offsetEnd - this.virtualScrollPaddingAfter;

      if (this.prevScrollStart === scrollDetails.scrollStart) {
        return;
      }

      if (scrollDetails.scrollMaxSize <= 0) {
        this.__setVirtualScrollSliceRange(scrollEl, scrollDetails, 0, 0);

        return;
      }

      this.__scrollViewSize !== scrollDetails.scrollViewSize && this.__setVirtualScrollSize(scrollDetails.scrollViewSize);

      this.__updateVirtualScrollSizes(this.virtualScrollSliceRange.from);

      const scrollMaxStart = Math.floor(scrollDetails.scrollMaxSize - Math.max(scrollDetails.scrollViewSize, scrollDetails.offsetEnd) - Math.min(this.virtualScrollSizes[listLastIndex], scrollDetails.scrollViewSize / 2));

      if (scrollMaxStart > 0 && Math.ceil(scrollDetails.scrollStart) >= scrollMaxStart) {
        this.__setVirtualScrollSliceRange(scrollEl, scrollDetails, listLastIndex, scrollDetails.scrollMaxSize - scrollDetails.offsetEnd - this.virtualScrollSizesAgg.reduce(sumFn, 0));

        return;
      }

      let toIndex = 0,
          listOffset = scrollDetails.scrollStart - scrollDetails.offsetStart,
          offset = listOffset;

      if (listOffset <= listEndOffset && listOffset + scrollDetails.scrollViewSize >= this.virtualScrollPaddingBefore) {
        listOffset -= this.virtualScrollPaddingBefore;
        toIndex = this.virtualScrollSliceRange.from;
        offset = listOffset;
      } else {
        for (let j = 0; listOffset >= this.virtualScrollSizesAgg[j] && toIndex < listLastIndex; j++) {
          listOffset -= this.virtualScrollSizesAgg[j];
          toIndex += aggBucketSize;
        }
      }

      while (listOffset > 0 && toIndex < listLastIndex) {
        listOffset -= this.virtualScrollSizes[toIndex];

        if (listOffset > -scrollDetails.scrollViewSize) {
          toIndex++;
          offset = listOffset;
        } else {
          offset = this.virtualScrollSizes[toIndex] + listOffset;
        }
      }

      this.__setVirtualScrollSliceRange(scrollEl, scrollDetails, toIndex, offset);
    },

    __setVirtualScrollSliceRange(scrollEl, scrollDetails, toIndex, offset, align) {
      const alignForce = typeof align === 'string' && align.indexOf('-force') > -1;
      const alignEnd = alignForce === true ? align.replace('-force', '') : align;
      const alignRange = alignEnd !== void 0 ? alignEnd : 'start';
      let from = Math.max(0, toIndex - this.virtualScrollSliceSizeComputed[alignRange]),
          to = from + this.virtualScrollSliceSizeComputed.total;

      if (to > this.virtualScrollLength) {
        to = this.virtualScrollLength;
        from = Math.max(0, to - this.virtualScrollSliceSizeComputed.total);
      }

      this.prevScrollStart = scrollDetails.scrollStart;
      const rangeChanged = from !== this.virtualScrollSliceRange.from || to !== this.virtualScrollSliceRange.to;

      if (rangeChanged === false && alignEnd === void 0) {
        this.__emitScroll(toIndex);

        return;
      }

      const {
        activeElement
      } = document;

      if (rangeChanged === true && this.$refs.content !== void 0 && this.$refs.content !== activeElement && this.$refs.content.contains(activeElement) === true) {
        const onBlurFn = () => {
          this.$refs.content.focus();
        };

        activeElement.addEventListener('blur', onBlurFn, true);
        requestAnimationFrame(() => {
          activeElement.removeEventListener('blur', onBlurFn, true);
        });
      }

      setOverflowAnchor(this.id, toIndex - from + 1);
      const sizeBefore = alignEnd !== void 0 ? this.virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0) : 0;

      if (rangeChanged === true) {
        // vue key matching algorithm works only if
        // the array of VNodes changes on only one of the ends
        // so we first change one end and then the other
        const tempTo = to >= this.virtualScrollSliceRange.from && from <= this.virtualScrollSliceRange.to ? this.virtualScrollSliceRange.to : to;
        this.virtualScrollSliceRange = {
          from,
          to: tempTo
        };
        this.virtualScrollPaddingBefore = sumSize(this.virtualScrollSizesAgg, this.virtualScrollSizes, 0, from);
        this.virtualScrollPaddingAfter = sumSize(this.virtualScrollSizesAgg, this.virtualScrollSizes, this.virtualScrollSliceRange.to, this.virtualScrollLength);
        requestAnimationFrame(() => {
          if (this.virtualScrollSliceRange.to !== to && this.prevScrollStart === scrollDetails.scrollStart) {
            this.virtualScrollSliceRange = {
              from: this.virtualScrollSliceRange.from,
              to
            };
            this.virtualScrollPaddingAfter = sumSize(this.virtualScrollSizesAgg, this.virtualScrollSizes, to, this.virtualScrollLength);
          }
        });
      }

      requestAnimationFrame(() => {
        // if the scroll was changed give up
        // (another call to __setVirtualScrollSliceRange before animation frame)
        if (this.prevScrollStart !== scrollDetails.scrollStart) {
          return;
        }

        if (rangeChanged === true) {
          this.__updateVirtualScrollSizes(from);
        }

        const sizeAfter = this.virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0),
              posStart = sizeAfter + scrollDetails.offsetStart + this.virtualScrollPaddingBefore,
              posEnd = posStart + this.virtualScrollSizes[toIndex];
        let scrollPosition = posStart + offset;

        if (alignEnd !== void 0) {
          const sizeDiff = sizeAfter - sizeBefore;
          const scrollStart = scrollDetails.scrollStart + sizeDiff;
          scrollPosition = alignForce !== true && scrollStart < posStart && posEnd < scrollStart + scrollDetails.scrollViewSize ? scrollStart : alignEnd === 'end' ? posEnd - scrollDetails.scrollViewSize : posStart - (alignEnd === 'start' ? 0 : Math.round((scrollDetails.scrollViewSize - this.virtualScrollSizes[toIndex]) / 2));
        }

        this.prevScrollStart = scrollPosition;
        setScroll(scrollEl, scrollPosition, this.virtualScrollHorizontal, this.$q.lang.rtl);

        this.__emitScroll(toIndex);
      });
    },

    __updateVirtualScrollSizes(from) {
      const contentEl = this.$refs.content;

      if (contentEl !== void 0) {
        const children = slice.call(contentEl.children).filter(el => el.classList.contains('q-virtual-scroll--skip') === false),
              childrenLength = children.length,
              sizeFn = this.virtualScrollHorizontal === true ? el => el.getBoundingClientRect().width : el => el.offsetHeight;
        let index = from,
            size,
            diff;

        for (let i = 0; i < childrenLength;) {
          size = sizeFn(children[i]);
          i++;

          while (i < childrenLength && children[i].classList.contains('q-virtual-scroll--with-prev') === true) {
            size += sizeFn(children[i]);
            i++;
          }

          diff = size - this.virtualScrollSizes[index];

          if (diff !== 0) {
            this.virtualScrollSizes[index] += diff;
            this.virtualScrollSizesAgg[Math.floor(index / aggBucketSize)] += diff;
          }

          index++;
        }
      }
    },

    __resetVirtualScroll(toIndex, fullReset) {
      const defaultSize = 1 * this.virtualScrollItemSizeComputed;

      if (fullReset === true || Array.isArray(this.virtualScrollSizes) === false) {
        this.virtualScrollSizes = [];
      }

      const oldVirtualScrollSizesLength = this.virtualScrollSizes.length;
      this.virtualScrollSizes.length = this.virtualScrollLength;

      for (let i = this.virtualScrollLength - 1; i >= oldVirtualScrollSizesLength; i--) {
        this.virtualScrollSizes[i] = defaultSize;
      }

      const jMax = Math.floor((this.virtualScrollLength - 1) / aggBucketSize);
      this.virtualScrollSizesAgg = [];

      for (let j = 0; j <= jMax; j++) {
        let size = 0;
        const iMax = Math.min((j + 1) * aggBucketSize, this.virtualScrollLength);

        for (let i = j * aggBucketSize; i < iMax; i++) {
          size += this.virtualScrollSizes[i];
        }

        this.virtualScrollSizesAgg.push(size);
      }

      this.prevToIndex = -1;
      this.prevScrollStart = void 0;

      if (toIndex >= 0) {
        this.__updateVirtualScrollSizes(this.virtualScrollSliceRange.from);

        this.$nextTick(() => {
          this.scrollTo(toIndex);
        });
      } else {
        this.virtualScrollPaddingBefore = sumSize(this.virtualScrollSizesAgg, this.virtualScrollSizes, 0, this.virtualScrollSliceRange.from);
        this.virtualScrollPaddingAfter = sumSize(this.virtualScrollSizesAgg, this.virtualScrollSizes, this.virtualScrollSliceRange.to, this.virtualScrollLength);

        this.__onVirtualScrollEvt();
      }
    },

    __setVirtualScrollSize(scrollViewSize) {
      if (scrollViewSize === void 0 && typeof window !== 'undefined') {
        const scrollEl = this.__getVirtualScrollTarget();

        if (scrollEl !== void 0 && scrollEl !== null && scrollEl.nodeType !== 8) {
          scrollViewSize = getScrollDetails(scrollEl, this.__getVirtualScrollEl(), this.$refs.before, this.$refs.after, this.virtualScrollHorizontal, this.$q.lang.rtl, this.virtualScrollStickySizeStart, this.virtualScrollStickySizeEnd).scrollViewSize;
        }
      }

      this.__scrollViewSize = scrollViewSize;
      const multiplier = 1 + this.virtualScrollSliceRatioBefore + this.virtualScrollSliceRatioAfter;
      const view = scrollViewSize === void 0 || scrollViewSize <= 0 ? 1 : Math.ceil(scrollViewSize / this.virtualScrollItemSizeComputed);
      const baseSize = Math.max(10, view, Math.ceil(this.virtualScrollSliceSize / multiplier));
      this.virtualScrollSliceSizeComputed = {
        total: Math.ceil(baseSize * multiplier),
        start: Math.ceil(baseSize * this.virtualScrollSliceRatioBefore),
        center: Math.ceil(baseSize * (0.5 + this.virtualScrollSliceRatioBefore)),
        end: Math.ceil(baseSize * (1 + this.virtualScrollSliceRatioBefore)),
        view
      };
    },

    __padVirtualScroll(h, tag, content) {
      const paddingSize = this.virtualScrollHorizontal === true ? 'width' : 'height';
      const style = {
        ['--q-virtual-scroll-item-' + paddingSize]: this.virtualScrollItemSizeComputed + 'px'
      };
      return [tag === 'tbody' ? h(tag, {
        staticClass: 'q-virtual-scroll__padding',
        key: 'before',
        ref: 'before'
      }, [h('tr', [h('td', {
        style: objectSpread2_default()({
          [paddingSize]: `${this.virtualScrollPaddingBefore}px`
        }, style),
        attrs: this.colspanAttr
      })])]) : h(tag, {
        staticClass: 'q-virtual-scroll__padding',
        key: 'before',
        ref: 'before',
        style: objectSpread2_default()({
          [paddingSize]: `${this.virtualScrollPaddingBefore}px`
        }, style)
      }), h(tag, {
        staticClass: 'q-virtual-scroll__content',
        key: 'content',
        ref: 'content',
        attrs: {
          id: this.id,
          tabindex: -1
        }
      }, content), tag === 'tbody' ? h(tag, {
        staticClass: 'q-virtual-scroll__padding',
        key: 'after',
        ref: 'after'
      }, [h('tr', [h('td', {
        style: objectSpread2_default()({
          [paddingSize]: `${this.virtualScrollPaddingAfter}px`
        }, style),
        attrs: this.colspanAttr
      })])]) : h(tag, {
        staticClass: 'q-virtual-scroll__padding',
        key: 'after',
        ref: 'after',
        style: objectSpread2_default()({
          [paddingSize]: `${this.virtualScrollPaddingAfter}px`
        }, style)
      })];
    },

    __emitScroll(index) {
      if (this.prevToIndex !== index) {
        this.qListeners['virtual-scroll'] !== void 0 && this.$emit('virtual-scroll', {
          index,
          from: this.virtualScrollSliceRange.from,
          to: this.virtualScrollSliceRange.to - 1,
          direction: index < this.prevToIndex ? 'decrease' : 'increase',
          ref: this
        });
        this.prevToIndex = index;
      }
    }

  },

  created() {
    this.__setVirtualScrollSize();
  },

  beforeMount() {
    buggyRTL === void 0 && detectBuggyRTL();
    this.__onVirtualScrollEvt = Object(debounce["a" /* default */])(this.__onVirtualScrollEvt, this.$q.platform.is.ios === true ? 120 : 35);

    this.__setVirtualScrollSize();
  },

  beforeDestroy() {
    const styleSheet = document.getElementById(this.id + '_ss');
    styleSheet !== null && styleSheet.remove();
  }

});
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/composition.js
var composition = __webpack_require__("c2ad");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/select/QSelect.js





















const validateNewValueMode = v => ['add', 'add-unique', 'toggle'].includes(v);

const reEscapeList = '.*+?^${}()|[]\\';
/* harmony default export */ var QSelect = __webpack_exports__["a"] = (vue_runtime_esm["default"].extend({
  name: 'QSelect',
  mixins: [QField["a" /* default */], virtual_scroll, composition["a" /* default */], mixins_form["a" /* FormFieldMixin */], listeners["a" /* default */]],
  props: {
    value: {
      required: true
    },
    multiple: Boolean,
    displayValue: [String, Number],
    displayValueSanitize: Boolean,
    dropdownIcon: String,
    options: {
      type: Array,
      default: () => []
    },
    optionValue: [Function, String],
    optionLabel: [Function, String],
    optionDisable: [Function, String],
    hideSelected: Boolean,
    hideDropdownIcon: Boolean,
    fillInput: Boolean,
    maxValues: [Number, String],
    optionsDense: Boolean,
    optionsDark: {
      type: Boolean,
      default: null
    },
    optionsSelectedClass: String,
    optionsSanitize: Boolean,
    optionsCover: Boolean,
    menuShrink: Boolean,
    menuAnchor: String,
    menuSelf: String,
    menuOffset: Array,
    popupContentClass: String,
    popupContentStyle: [String, Array, Object],
    useInput: Boolean,
    useChips: Boolean,
    newValueMode: {
      type: String,
      validator: validateNewValueMode
    },
    mapOptions: Boolean,
    emitValue: Boolean,
    inputDebounce: {
      type: [Number, String],
      default: 500
    },
    inputClass: [Array, String, Object],
    inputStyle: [Array, String, Object],
    tabindex: {
      type: [String, Number],
      default: 0
    },
    autocomplete: String,
    transitionShow: String,
    transitionHide: String,
    behavior: {
      type: String,
      validator: v => ['default', 'menu', 'dialog'].includes(v),
      default: 'default'
    },
    virtualScrollItemSize: {
      type: [Number, String],
      default: void 0
    }
  },

  data() {
    return {
      menu: false,
      dialog: false,
      optionIndex: -1,
      inputValue: '',
      dialogFieldFocused: false
    };
  },

  watch: {
    innerValue: {
      handler(val) {
        this.innerValueCache = val;

        if (this.useInput === true && this.fillInput === true && this.multiple !== true && // Prevent re-entering in filter while filtering
        // Also prevent clearing inputValue while filtering
        this.innerLoading !== true && (this.dialog !== true && this.menu !== true || this.hasValue !== true)) {
          this.userInputValue !== true && this.__resetInputValue();

          if (this.dialog === true || this.menu === true) {
            this.filter('');
          }
        }
      },

      immediate: true
    },

    fillInput() {
      this.__resetInputValue();
    },

    menu(show) {
      this.__updateMenu(show);
    }

  },
  computed: {
    isOptionsDark() {
      return this.optionsDark === null ? this.isDark : this.optionsDark;
    },

    virtualScrollLength() {
      return Array.isArray(this.options) ? this.options.length : 0;
    },

    fieldClass() {
      return `q-select q-field--auto-height q-select--with${this.useInput !== true ? 'out' : ''}-input` + ` q-select--with${this.useChips !== true ? 'out' : ''}-chips` + ` q-select--${this.multiple === true ? 'multiple' : 'single'}`;
    },

    computedInputClass() {
      if (this.hideSelected === true || this.innerValue.length === 0) {
        return this.inputClass;
      }

      return this.inputClass === void 0 ? 'q-field__input--padding' : [this.inputClass, 'q-field__input--padding'];
    },

    menuContentClass() {
      return (this.virtualScrollHorizontal === true ? 'q-virtual-scroll--horizontal' : '') + (this.popupContentClass ? ' ' + this.popupContentClass : '');
    },

    innerValue() {
      const mapNull = this.mapOptions === true && this.multiple !== true,
            val = this.value !== void 0 && (this.value !== null || mapNull === true) ? this.multiple === true && Array.isArray(this.value) ? this.value : [this.value] : [];

      if (this.mapOptions === true && Array.isArray(this.options) === true) {
        const cache = this.mapOptions === true && this.innerValueCache !== void 0 ? this.innerValueCache : [];
        const values = val.map(v => this.__getOption(v, cache));
        return this.value === null && mapNull === true ? values.filter(v => v !== null) : values;
      }

      return val;
    },

    noOptions() {
      return this.virtualScrollLength === 0;
    },

    selectedString() {
      return this.innerValue.map(opt => this.getOptionLabel(opt)).join(', ');
    },

    sanitizeFn() {
      return this.optionsSanitize === true ? () => true : opt => opt !== void 0 && opt !== null && opt.sanitize === true;
    },

    displayAsText() {
      return this.displayValueSanitize === true || this.displayValue === void 0 && (this.optionsSanitize === true || this.innerValue.some(this.sanitizeFn));
    },

    computedTabindex() {
      return this.focused === true ? this.tabindex : -1;
    },

    selectedScope() {
      return this.innerValue.map((opt, i) => ({
        index: i,
        opt,
        sanitize: this.sanitizeFn(opt),
        selected: true,
        removeAtIndex: this.__removeAtIndexAndFocus,
        toggleOption: this.toggleOption,
        tabindex: this.computedTabindex
      }));
    },

    optionScope() {
      if (this.virtualScrollLength === 0) {
        return [];
      }

      const {
        from,
        to
      } = this.virtualScrollSliceRange;
      const {
        options,
        optionEls
      } = this.__optionScopeCache;
      return this.options.slice(from, to).map((opt, i) => {
        const disable = this.isOptionDisabled(opt) === true;
        const index = from + i;
        const itemProps = {
          clickable: true,
          active: false,
          activeClass: this.computedOptionsSelectedClass,
          manualFocus: true,
          focused: false,
          disable,
          tabindex: -1,
          dense: this.optionsDense,
          dark: this.isOptionsDark
        };

        if (disable !== true) {
          this.isOptionSelected(opt) === true && (itemProps.active = true);
          this.optionIndex === index && (itemProps.focused = true);
        }

        const itemEvents = {
          click: () => {
            this.toggleOption(opt);
          }
        };

        if (this.$q.platform.is.desktop === true) {
          itemEvents.mousemove = () => {
            this.setOptionIndex(index);
          };
        }

        const option = {
          index,
          opt,
          sanitize: this.sanitizeFn(opt),
          selected: itemProps.active,
          focused: itemProps.focused,
          toggleOption: this.toggleOption,
          setOptionIndex: this.setOptionIndex,
          itemProps
        };

        if (options[i] === void 0 || isDeepEqual(option, options[i]) !== true) {
          options[i] = option;
          optionEls[i] = void 0;
        }

        return objectSpread2_default()(objectSpread2_default()({}, option), {}, {
          itemEvents
        });
      });
    },

    dropdownArrowIcon() {
      return this.dropdownIcon !== void 0 ? this.dropdownIcon : this.$q.iconSet.arrow.dropdown;
    },

    squaredMenu() {
      return this.optionsCover === false && this.outlined !== true && this.standout !== true && this.borderless !== true && this.rounded !== true;
    },

    computedOptionsSelectedClass() {
      return this.optionsSelectedClass !== void 0 ? this.optionsSelectedClass : this.color !== void 0 ? `text-${this.color}` : '';
    },

    innerOptionsValue() {
      return this.innerValue.map(opt => this.getOptionValue(opt));
    },

    // returns method to get value of an option;
    // takes into account 'option-value' prop
    getOptionValue() {
      return this.__getPropValueFn('optionValue', 'value');
    },

    // returns method to get label of an option;
    // takes into account 'option-label' prop
    getOptionLabel() {
      return this.__getPropValueFn('optionLabel', 'label');
    },

    // returns method to tell if an option is disabled;
    // takes into account 'option-disable' prop
    isOptionDisabled() {
      return this.__getPropValueFn('optionDisable', 'disable');
    },

    inputControlEvents() {
      const on = {
        input: this.__onInput,
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        change: this.__onChange,
        keydown: this.__onTargetKeydown,
        keyup: this.__onTargetAutocomplete,
        keypress: this.__onTargetKeypress,
        focus: this.__selectInputText,
        click: e => {
          this.hasDialog === true && Object(utils_event["k" /* stop */])(e);
        }
      };
      on.compositionstart = on.compositionupdate = on.compositionend = this.__onComposition;
      return on;
    },

    virtualScrollItemSizeComputed() {
      return this.virtualScrollItemSize === void 0 ? this.dense === true ? 24 : 48 : this.virtualScrollItemSize;
    }

  },
  methods: {
    getEmittingOptionValue(opt) {
      return this.emitValue === true ? this.getOptionValue(opt) : opt;
    },

    removeAtIndex(index) {
      if (index > -1 && index < this.innerValue.length) {
        if (this.multiple === true) {
          const model = this.value.slice();
          this.$emit('remove', {
            index,
            value: model.splice(index, 1)[0]
          });
          this.$emit('input', model);
        } else {
          this.$emit('input', null);
        }
      }
    },

    __removeAtIndexAndFocus(index) {
      this.removeAtIndex(index);

      this.__focus();
    },

    add(opt, unique) {
      const val = this.getEmittingOptionValue(opt);

      if (this.multiple !== true) {
        this.fillInput === true && this.updateInputValue(this.getOptionLabel(opt), true, true);
        this.$emit('input', val);
        return;
      }

      if (this.innerValue.length === 0) {
        this.$emit('add', {
          index: 0,
          value: val
        });
        this.$emit('input', this.multiple === true ? [val] : val);
        return;
      }

      if (unique === true && this.isOptionSelected(opt) === true) {
        return;
      }

      if (this.maxValues !== void 0 && this.value.length >= this.maxValues) {
        return;
      }

      const model = this.value.slice();
      this.$emit('add', {
        index: model.length,
        value: val
      });
      model.push(val);
      this.$emit('input', model);
    },

    toggleOption(opt, keepOpen) {
      if (this.editable !== true || opt === void 0 || this.isOptionDisabled(opt) === true) {
        return;
      }

      const optValue = this.getOptionValue(opt);

      if (this.multiple !== true) {
        if (keepOpen !== true) {
          this.updateInputValue(this.fillInput === true ? this.getOptionLabel(opt) : '', true, true);
          this.hidePopup();
        }

        this.$refs.target !== void 0 && this.$refs.target.focus();

        if (isDeepEqual(this.getOptionValue(this.innerValue[0]), optValue) !== true) {
          this.$emit('input', this.emitValue === true ? optValue : opt);
        }

        return;
      }

      (this.hasDialog !== true || this.dialogFieldFocused === true) && this.__focus();

      this.__selectInputText();

      if (this.innerValue.length === 0) {
        const val = this.emitValue === true ? optValue : opt;
        this.$emit('add', {
          index: 0,
          value: val
        });
        this.$emit('input', this.multiple === true ? [val] : val);
        return;
      }

      const model = this.value.slice(),
            index = this.innerOptionsValue.findIndex(v => isDeepEqual(v, optValue));

      if (index > -1) {
        this.$emit('remove', {
          index,
          value: model.splice(index, 1)[0]
        });
      } else {
        if (this.maxValues !== void 0 && model.length >= this.maxValues) {
          return;
        }

        const val = this.emitValue === true ? optValue : opt;
        this.$emit('add', {
          index: model.length,
          value: val
        });
        model.push(val);
      }

      this.$emit('input', model);
    },

    setOptionIndex(index) {
      if (this.$q.platform.is.desktop !== true) {
        return;
      }

      const val = index > -1 && index < this.virtualScrollLength ? index : -1;

      if (this.optionIndex !== val) {
        this.optionIndex = val;
      }
    },

    moveOptionSelection(offset = 1, skipInputValue) {
      if (this.menu === true) {
        let index = this.optionIndex;

        do {
          index = Object(format["b" /* normalizeToInterval */])(index + offset, -1, this.virtualScrollLength - 1);
        } while (index !== -1 && index !== this.optionIndex && this.isOptionDisabled(this.options[index]) === true);

        if (this.optionIndex !== index) {
          this.setOptionIndex(index);
          this.scrollTo(index);

          if (skipInputValue !== true && this.useInput === true && this.fillInput === true) {
            this.__setInputValue(index >= 0 ? this.getOptionLabel(this.options[index]) : this.defaultInputValue);
          }
        }
      }
    },

    __getOption(value, innerValueCache) {
      const fn = opt => isDeepEqual(this.getOptionValue(opt), value);

      return this.options.find(fn) || innerValueCache.find(fn) || value;
    },

    __getPropValueFn(propName, defaultVal) {
      const val = this[propName] !== void 0 ? this[propName] : defaultVal;
      return typeof val === 'function' ? val : opt => Object(opt) === opt && val in opt ? opt[val] : opt;
    },

    isOptionSelected(opt) {
      const val = this.getOptionValue(opt);
      return this.innerOptionsValue.find(v => isDeepEqual(v, val)) !== void 0;
    },

    __selectInputText() {
      if (this.useInput === true && this.$refs.target !== void 0) {
        this.$refs.target.select();
      }
    },

    __onTargetKeyup(e) {
      // if ESC and we have an opened menu
      // then stop propagation (might be caught by a QDialog
      // and so it will also close the QDialog, which is wrong)
      if (Object(key_composition["a" /* isKeyCode */])(e, 27) === true && this.menu === true) {
        Object(utils_event["k" /* stop */])(e); // on ESC we need to close the dialog also

        this.hidePopup();

        this.__resetInputValue();
      }

      this.$emit('keyup', e);
    },

    __onTargetAutocomplete(e) {
      const {
        value
      } = e.target;

      if (e.keyCode !== void 0) {
        this.__onTargetKeyup(e);

        return;
      }

      e.target.value = '';
      clearTimeout(this.inputTimer);

      this.__resetInputValue();

      if (typeof value === 'string' && value.length > 0) {
        const needle = value.toLocaleLowerCase();

        let fn = opt => this.getOptionValue(opt).toLocaleLowerCase() === needle;

        let option = this.options.find(fn);

        if (option !== void 0) {
          if (this.innerValue.indexOf(option) === -1) {
            this.toggleOption(option);
          } else {
            this.hidePopup();
          }
        } else {
          fn = opt => this.getOptionLabel(opt).toLocaleLowerCase() === needle;

          option = this.options.find(fn);

          if (option !== void 0) {
            if (this.innerValue.indexOf(option) === -1) {
              this.toggleOption(option);
            } else {
              this.hidePopup();
            }
          } else {
            this.filter(value, true);
          }
        }
      } else {
        this.__clearValue(e);
      }
    },

    __onTargetKeypress(e) {
      this.$emit('keypress', e);
    },

    __onTargetKeydown(e) {
      this.$emit('keydown', e);

      if (Object(key_composition["c" /* shouldIgnoreKey */])(e) === true) {
        return;
      }

      const newValueModeValid = this.inputValue.length > 0 && (this.newValueMode !== void 0 || this.qListeners['new-value'] !== void 0);
      const tabShouldSelect = e.shiftKey !== true && this.multiple !== true && (this.optionIndex > -1 || newValueModeValid === true); // escape

      if (e.keyCode === 27) {
        Object(utils_event["i" /* prevent */])(e); // prevent clearing the inputValue

        return;
      } // tab


      if (e.keyCode === 9 && tabShouldSelect === false) {
        this.__closeMenu();

        return;
      }

      if (e.target === void 0 || e.target.id !== this.targetUid) {
        return;
      } // down


      if (e.keyCode === 40 && this.innerLoading !== true && this.menu === false) {
        Object(utils_event["l" /* stopAndPrevent */])(e);
        this.showPopup();
        return;
      } // backspace


      if (e.keyCode === 8 && this.hideSelected !== true && this.inputValue.length === 0) {
        if (this.multiple === true && Array.isArray(this.value)) {
          this.removeAtIndex(this.value.length - 1);
        } else if (this.multiple !== true && this.value !== null) {
          this.$emit('input', null);
        }

        return;
      } // home, end - 36, 35


      if ((e.keyCode === 35 || e.keyCode === 36) && (typeof this.inputValue !== 'string' || this.inputValue.length === 0)) {
        Object(utils_event["l" /* stopAndPrevent */])(e);
        this.optionIndex = -1;
        this.moveOptionSelection(e.keyCode === 36 ? 1 : -1, this.multiple);
      } // pg up, pg down - 33, 34


      if ((e.keyCode === 33 || e.keyCode === 34) && this.virtualScrollSliceSizeComputed !== void 0) {
        Object(utils_event["l" /* stopAndPrevent */])(e);
        this.optionIndex = Math.max(-1, Math.min(this.virtualScrollLength, this.optionIndex + (e.keyCode === 33 ? -1 : 1) * this.virtualScrollSliceSizeComputed.view));
        this.moveOptionSelection(e.keyCode === 33 ? 1 : -1, this.multiple);
      } // up, down


      if (e.keyCode === 38 || e.keyCode === 40) {
        Object(utils_event["l" /* stopAndPrevent */])(e);
        this.moveOptionSelection(e.keyCode === 38 ? -1 : 1, this.multiple);
      }

      const optionsLength = this.virtualScrollLength; // clear search buffer if expired

      if (this.searchBuffer === void 0 || this.searchBufferExp < Date.now()) {
        this.searchBuffer = '';
      } // keyboard search when not having use-input


      if (optionsLength > 0 && this.useInput !== true && e.key !== void 0 && e.key.length === 1 && // printable char
      e.altKey === e.ctrlKey && ( // not kbd shortcut
      e.keyCode !== 32 || this.searchBuffer.length > 0) // space in middle of search
      ) {
          this.menu !== true && this.showPopup(e);
          const char = e.key.toLocaleLowerCase(),
                keyRepeat = this.searchBuffer.length === 1 && this.searchBuffer[0] === char;
          this.searchBufferExp = Date.now() + 1500;

          if (keyRepeat === false) {
            Object(utils_event["l" /* stopAndPrevent */])(e);
            this.searchBuffer += char;
          }

          const searchRe = new RegExp('^' + this.searchBuffer.split('').map(l => reEscapeList.indexOf(l) > -1 ? '\\' + l : l).join('.*'), 'i');
          let index = this.optionIndex;

          if (keyRepeat === true || index < 0 || searchRe.test(this.getOptionLabel(this.options[index])) !== true) {
            do {
              index = Object(format["b" /* normalizeToInterval */])(index + 1, -1, optionsLength - 1);
            } while (index !== this.optionIndex && (this.isOptionDisabled(this.options[index]) === true || searchRe.test(this.getOptionLabel(this.options[index])) !== true));
          }

          if (this.optionIndex !== index) {
            this.$nextTick(() => {
              this.setOptionIndex(index);
              this.scrollTo(index);

              if (index >= 0 && this.useInput === true && this.fillInput === true) {
                this.__setInputValue(this.getOptionLabel(this.options[index]));
              }
            });
          }

          return;
        } // enter, space (when not using use-input and not in search), or tab (when not using multiple and option selected)
      // same target is checked above


      if (e.keyCode !== 13 && (e.keyCode !== 32 || this.useInput === true || this.searchBuffer !== '') && (e.keyCode !== 9 || tabShouldSelect === false)) {
        return;
      }

      e.keyCode !== 9 && Object(utils_event["l" /* stopAndPrevent */])(e);

      if (this.optionIndex > -1 && this.optionIndex < optionsLength) {
        this.toggleOption(this.options[this.optionIndex]);
        return;
      }

      if (newValueModeValid === true) {
        const done = (val, mode) => {
          if (mode) {
            if (validateNewValueMode(mode) !== true) {
              return;
            }
          } else {
            mode = this.newValueMode;
          }

          if (val === void 0 || val === null) {
            return;
          }

          this.updateInputValue('', this.multiple !== true, true);
          this[mode === 'toggle' ? 'toggleOption' : 'add'](val, mode === 'add-unique');

          if (this.multiple !== true) {
            this.$refs.target !== void 0 && this.$refs.target.focus();
            this.hidePopup();
          }
        };

        if (this.qListeners['new-value'] !== void 0) {
          this.$emit('new-value', this.inputValue, done);
        } else {
          done(this.inputValue);
        }

        if (this.multiple !== true) {
          return;
        }
      }

      if (this.menu === true) {
        this.__closeMenu();
      } else if (this.innerLoading !== true) {
        this.showPopup();
      }
    },

    __getVirtualScrollEl() {
      return this.hasDialog === true ? this.$refs.menuContent : this.$refs.menu !== void 0 && this.$refs.menu.__portal !== void 0 ? this.$refs.menu.__portal.$el : void 0;
    },

    __getVirtualScrollTarget() {
      return this.__getVirtualScrollEl();
    },

    __getSelection(h) {
      if (this.hideSelected === true) {
        return [];
      }

      if (this.$scopedSlots['selected-item'] !== void 0) {
        return this.selectedScope.map(scope => this.$scopedSlots['selected-item'](scope)).slice();
      }

      if (this.$scopedSlots.selected !== void 0) {
        return this.$scopedSlots.selected().slice();
      }

      if (this.useChips === true) {
        return this.selectedScope.map((scope, i) => h(QChip, {
          key: 'option-' + i,
          props: {
            removable: this.editable === true && this.isOptionDisabled(scope.opt) !== true,
            dense: true,
            textColor: this.color,
            tabindex: this.computedTabindex
          },
          on: Object(cache["b" /* default */])(this, 'rem#' + i, {
            remove() {
              scope.removeAtIndex(i);
            }

          })
        }, [h('span', {
          staticClass: 'ellipsis',
          domProps: {
            [scope.sanitize === true ? 'textContent' : 'innerHTML']: this.getOptionLabel(scope.opt)
          }
        })]));
      }

      return [h('span', {
        domProps: {
          [this.displayAsText ? 'textContent' : 'innerHTML']: this.displayValue !== void 0 ? this.displayValue : this.selectedString
        }
      })];
    },

    __getControl(h, fromDialog) {
      const child = this.__getSelection(h);

      const isTarget = fromDialog === true || this.dialog !== true || this.hasDialog !== true;

      if (this.useInput === true) {
        child.push(this.__getInput(h, fromDialog, isTarget));
      } // there can be only one (when dialog is opened the control in dialog should be target)
      else if (this.editable === true && isTarget === true) {
          child.push(h('div', {
            ref: 'target',
            key: 'd_t',
            staticClass: 'no-outline',
            attrs: {
              id: this.targetUid,
              tabindex: this.tabindex
            },
            on: Object(cache["b" /* default */])(this, 'f-tget', {
              keydown: this.__onTargetKeydown,
              keyup: this.__onTargetKeyup,
              keypress: this.__onTargetKeypress
            })
          }));

          if (typeof this.autocomplete === 'string' && this.autocomplete.length > 0) {
            child.push(h('input', {
              staticClass: 'q-select__autocomplete-input no-outline',
              attrs: {
                autocomplete: this.autocomplete
              },
              on: Object(cache["b" /* default */])(this, 'autoinp', {
                keyup: this.__onTargetAutocomplete
              })
            }));
          }
        }

      if (this.nameProp !== void 0 && this.disable !== true && this.innerOptionsValue.length > 0) {
        const opts = this.innerOptionsValue.map(value => h('option', {
          attrs: {
            value,
            selected: true
          }
        }));
        child.push(h('select', {
          staticClass: 'hidden',
          attrs: {
            name: this.nameProp,
            multiple: this.multiple
          }
        }, opts));
      }

      return h('div', {
        staticClass: 'q-field__native row items-center',
        attrs: this.qAttrs
      }, child);
    },

    __getOptions(h) {
      if (this.menu !== true) {
        return void 0;
      }

      if (this.$scopedSlots.option !== void 0 && this.__optionScopeCache.optionSlot !== this.$scopedSlots.option) {
        this.__optionScopeCache.optionSlot = this.$scopedSlots.option;
        this.__optionScopeCache.optionEls = [];
      }

      const fn = this.$scopedSlots.option !== void 0 ? this.$scopedSlots.option : scope => h(QItem["a" /* default */], {
        key: scope.index,
        props: scope.itemProps,
        on: scope.itemEvents
      }, [h(QItemSection["a" /* default */], [h(QItemLabel, {
        domProps: {
          [scope.sanitize === true ? 'textContent' : 'innerHTML']: this.getOptionLabel(scope.opt)
        }
      })])]);
      const {
        optionEls
      } = this.__optionScopeCache;

      let options = this.__padVirtualScroll(h, 'div', this.optionScope.map((scope, i) => {
        if (optionEls[i] === void 0) {
          optionEls[i] = fn(scope);
        }

        return optionEls[i];
      }));

      if (this.$scopedSlots['before-options'] !== void 0) {
        options = this.$scopedSlots['before-options']().concat(options);
      }

      return Object(slot["a" /* mergeSlot */])(options, this, 'after-options');
    },

    __getInnerAppend(h) {
      return this.loading !== true && this.innerLoadingIndicator !== true && this.hideDropdownIcon !== true ? [h(QIcon["a" /* default */], {
        staticClass: 'q-select__dropdown-icon' + (this.menu === true ? ' rotate-180' : ''),
        props: {
          name: this.dropdownArrowIcon
        }
      })] : null;
    },

    __getInput(h, fromDialog, isTarget) {
      const options = {
        ref: isTarget === true ? 'target' : void 0,
        key: 'i_t',
        staticClass: 'q-field__input q-placeholder col',
        style: this.inputStyle,
        class: this.computedInputClass,
        domProps: {
          value: this.inputValue !== void 0 ? this.inputValue : ''
        },
        attrs: objectSpread2_default()(objectSpread2_default()({
          // required for Android in order to show ENTER key when in form
          type: 'search'
        }, this.qAttrs), {}, {
          id: this.targetUid,
          maxlength: this.maxlength,
          // this is converted to prop by QField
          tabindex: this.tabindex,
          autocomplete: this.autocomplete,
          'data-autofocus': fromDialog === true ? false : this.autofocus,
          disabled: this.disable === true,
          readonly: this.readonly === true
        }),
        on: this.inputControlEvents
      };

      if (fromDialog !== true && this.hasDialog === true) {
        options.staticClass += ' no-pointer-events';
      }

      return h('input', options);
    },

    __onChange(e) {
      this.__onComposition(e);
    },

    __onInput(e) {
      clearTimeout(this.inputTimer);

      if (e && e.target && e.target.composing === true) {
        return;
      }

      this.__setInputValue(e.target.value || ''); // mark it here as user input so that if updateInputValue is called
      // before filter is called the indicator is reset


      this.userInputValue = true;
      this.defaultInputValue = this.inputValue;

      if (this.focused !== true && (this.hasDialog !== true || this.dialogFieldFocused === true)) {
        this.__focus();
      }

      if (this.qListeners.filter !== void 0) {
        this.inputTimer = setTimeout(() => {
          this.filter(this.inputValue);
        }, this.inputDebounce);
      }
    },

    __setInputValue(inputValue) {
      if (this.inputValue !== inputValue) {
        this.inputValue = inputValue;
        this.$emit('input-value', inputValue);
      }
    },

    updateInputValue(val, noFiltering, internal) {
      this.userInputValue = internal !== true;

      if (this.useInput === true) {
        this.__setInputValue(val);

        if (noFiltering === true || internal !== true) {
          this.defaultInputValue = val;
        }

        noFiltering !== true && this.filter(val);
      }
    },

    filter(val, keepClosed) {
      if (this.qListeners.filter === void 0 || keepClosed !== true && this.focused !== true) {
        return;
      }

      if (this.innerLoading === true) {
        this.$emit('filter-abort');
      } else {
        this.innerLoading = true;
        this.innerLoadingIndicator = true;
      }

      if (val !== '' && this.multiple !== true && this.innerValue.length > 0 && this.userInputValue !== true && val === this.getOptionLabel(this.innerValue[0])) {
        val = '';
      }

      const filterId = setTimeout(() => {
        this.menu === true && (this.menu = false);
      }, 10);
      clearTimeout(this.filterId);
      this.filterId = filterId;
      this.$emit('filter', val, (fn, afterFn) => {
        if ((keepClosed === true || this.focused === true) && this.filterId === filterId) {
          clearTimeout(this.filterId);
          typeof fn === 'function' && fn(); // hide indicator to allow arrow to animate

          this.innerLoadingIndicator = false;
          this.$nextTick(() => {
            this.innerLoading = false;

            if (this.editable === true) {
              if (keepClosed === true) {
                this.menu === true && this.hidePopup();
              } else if (this.menu === true) {
                this.__updateMenu(true);
              } else {
                this.menu = true;
              }
            }

            typeof afterFn === 'function' && this.$nextTick(() => {
              afterFn(this);
            });
          });
        }
      }, () => {
        if (this.focused === true && this.filterId === filterId) {
          clearTimeout(this.filterId);
          this.innerLoading = false;
          this.innerLoadingIndicator = false;
        }

        this.menu === true && (this.menu = false);
      });
    },

    __getControlEvents() {
      const focusout = e => {
        this.__onControlFocusout(e, () => {
          this.__resetInputValue();

          this.__closeMenu();
        });
      };

      return {
        focusin: this.__onControlFocusin,
        focusout,
        'popup-show': this.__onControlPopupShow,
        'popup-hide': e => {
          e !== void 0 && Object(utils_event["k" /* stop */])(e);
          this.$emit('popup-hide', e);
          this.hasPopupOpen = false;
          focusout(e);
        },
        click: e => {
          if (this.hasDialog !== true) {
            // label from QField will propagate click on the input (except IE)
            Object(utils_event["i" /* prevent */])(e);

            if (this.menu === true) {
              this.__closeMenu();

              this.$refs.target !== void 0 && this.$refs.target.focus();
              return;
            }
          }

          this.showPopup(e);
        }
      };
    },

    __getControlChild(h) {
      if (this.editable !== false && (this.dialog === true || // dialog always has menu displayed, so need to render it
      this.noOptions !== true || this.$scopedSlots['no-option'] !== void 0)) {
        return this[`__get${this.hasDialog === true ? 'Dialog' : 'Menu'}`](h);
      }
    },

    __getMenu(h) {
      const child = this.noOptions === true ? this.$scopedSlots['no-option'] !== void 0 ? this.$scopedSlots['no-option']({
        inputValue: this.inputValue
      }) : null : this.__getOptions(h);
      return h(QMenu, {
        ref: 'menu',
        props: {
          value: this.menu,
          fit: this.menuShrink !== true,
          cover: this.optionsCover === true && this.noOptions !== true && this.useInput !== true,
          anchor: this.menuAnchor,
          self: this.menuSelf,
          offset: this.menuOffset,
          contentClass: this.menuContentClass,
          contentStyle: this.popupContentStyle,
          dark: this.isOptionsDark,
          noParentEvent: true,
          noRefocus: true,
          noFocus: true,
          square: this.squaredMenu,
          transitionShow: this.transitionShow,
          transitionHide: this.transitionHide,
          separateClosePopup: true
        },
        on: Object(cache["b" /* default */])(this, 'menu', {
          '&scroll': this.__onVirtualScrollEvt,
          'before-hide': this.__closeMenu,
          show: this.__onMenuShow
        })
      }, child);
    },

    __onMenuShow() {
      this.__setVirtualScrollSize();
    },

    __onDialogFieldFocus(e) {
      Object(utils_event["k" /* stop */])(e);
      this.$refs.target !== void 0 && this.$refs.target.focus();
      this.dialogFieldFocused = true;
      window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, 0);
    },

    __onDialogFieldBlur(e) {
      Object(utils_event["k" /* stop */])(e);
      this.$nextTick(() => {
        this.dialogFieldFocused = false;
      });
    },

    __getDialog(h) {
      const content = [h(QField["a" /* default */], {
        staticClass: `col-auto ${this.fieldClass}`,
        props: objectSpread2_default()(objectSpread2_default()({}, this.$props), {}, {
          for: this.targetUid,
          dark: this.isOptionsDark,
          square: true,
          filled: true,
          itemAligned: false,
          loading: this.innerLoadingIndicator,
          stackLabel: this.inputValue.length > 0
        }),
        on: objectSpread2_default()(objectSpread2_default()({}, this.qListeners), {}, {
          focus: this.__onDialogFieldFocus,
          blur: this.__onDialogFieldBlur
        }),
        scopedSlots: objectSpread2_default()(objectSpread2_default()({}, this.$scopedSlots), {}, {
          rawControl: () => this.__getControl(h, true),
          before: void 0,
          after: void 0
        })
      })];
      this.menu === true && content.push(h('div', {
        ref: 'menuContent',
        staticClass: 'scroll',
        class: this.menuContentClass,
        style: this.popupContentStyle,
        on: Object(cache["b" /* default */])(this, 'virtMenu', {
          click: utils_event["i" /* prevent */],
          '&scroll': this.__onVirtualScrollEvt
        })
      }, this.noOptions === true ? this.$scopedSlots['no-option'] !== void 0 ? this.$scopedSlots['no-option']({
        inputValue: this.inputValue
      }) : null : this.__getOptions(h)));
      return h(QDialog["a" /* default */], {
        ref: 'dialog',
        props: {
          value: this.dialog,
          dark: this.isOptionsDark,
          position: this.useInput === true ? 'top' : void 0,
          transitionShow: this.transitionShowComputed,
          transitionHide: this.transitionHide
        },
        on: Object(cache["b" /* default */])(this, 'dialog', {
          'before-hide': this.__onDialogBeforeHide,
          hide: this.__onDialogHide,
          show: this.__onDialogShow
        })
      }, [h('div', {
        staticClass: 'q-select__dialog' + (this.isOptionsDark === true ? ' q-select__dialog--dark q-dark' : '') + (this.dialogFieldFocused === true ? ' q-select__dialog--focused' : '')
      }, content)]);
    },

    __onDialogBeforeHide() {
      this.$refs.dialog.__refocusTarget = this.$el.querySelector('.q-field__native > [tabindex]:last-child');
      this.focused = false;
    },

    __onDialogHide(e) {
      this.hidePopup();
      this.focused === false && this.$emit('blur', e);

      this.__resetInputValue();
    },

    __onDialogShow() {
      const el = document.activeElement; // IE can have null document.activeElement

      if ((el === null || el.id !== this.targetUid) && this.$refs.target !== el && this.$refs.target !== void 0) {
        this.$refs.target.focus();
      }

      this.__setVirtualScrollSize();
    },

    __closeMenu() {
      if (this.__optionScopeCache !== void 0) {
        this.__optionScopeCache.optionEls = [];
      }

      if (this.dialog === true) {
        return;
      }

      this.optionIndex = -1;

      if (this.menu === true) {
        this.menu = false;
      }

      if (this.focused === false) {
        clearTimeout(this.filterId);
        this.filterId = void 0;

        if (this.innerLoading === true) {
          this.$emit('filter-abort');
          this.innerLoading = false;
          this.innerLoadingIndicator = false;
        }
      }
    },

    showPopup(e) {
      if (this.editable !== true) {
        return;
      }

      if (this.hasDialog === true) {
        this.__onControlFocusin(e);

        this.dialog = true;
        this.$nextTick(() => {
          this.__focus();
        });
      } else {
        this.__focus();
      }

      if (this.qListeners.filter !== void 0) {
        this.filter(this.inputValue);
      } else if (this.noOptions !== true || this.$scopedSlots['no-option'] !== void 0) {
        this.menu = true;
      }
    },

    hidePopup() {
      this.dialog = false;

      this.__closeMenu();
    },

    __resetInputValue() {
      this.useInput === true && this.updateInputValue(this.multiple !== true && this.fillInput === true && this.innerValue.length > 0 ? this.getOptionLabel(this.innerValue[0]) || '' : '', true, true);
    },

    __updateMenu(show) {
      let optionIndex = -1;

      if (show === true) {
        if (this.innerValue.length > 0) {
          const val = this.getOptionValue(this.innerValue[0]);
          optionIndex = this.options.findIndex(v => isDeepEqual(this.getOptionValue(v), val));
        }

        this.__resetVirtualScroll(optionIndex);
      }

      this.setOptionIndex(optionIndex);
    },

    __onPreRender() {
      this.hasDialog = this.$q.platform.is.mobile !== true && this.behavior !== 'dialog' ? false : this.behavior !== 'menu' && (this.useInput === true ? this.$scopedSlots['no-option'] !== void 0 || this.qListeners.filter !== void 0 || this.noOptions === false : true);
      this.transitionShowComputed = this.hasDialog === true && this.useInput === true && this.$q.platform.is.ios === true ? 'fade' : this.transitionShow;
    },

    __onPostRender() {
      if (this.dialog === false && this.$refs.menu !== void 0) {
        this.$refs.menu.updatePosition();
      }
    },

    updateMenuPosition() {
      this.__onPostRender();
    }

  },

  beforeMount() {
    this.__optionScopeCache = {
      optionSlot: this.$scopedSlots.option,
      options: [],
      optionEls: []
    };
  },

  beforeDestroy() {
    this.__optionScopeCache = void 0;
    clearTimeout(this.inputTimer);
  }

}));

/***/ }),

/***/ "3979":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "3aaf":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("9869");
/* harmony import */ var _mixins_anchor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("0aa9");
/* harmony import */ var _mixins_model_toggle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("56c6");
/* harmony import */ var _mixins_portal_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("6769");
/* harmony import */ var _mixins_transition_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("ee92");
/* harmony import */ var _utils_scroll_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("8047");
/* harmony import */ var _utils_touch_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("36df");
/* harmony import */ var _utils_event_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("9ac9");
/* harmony import */ var _utils_selection_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("004f");
/* harmony import */ var _utils_slot_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("a4b3");
/* harmony import */ var _utils_position_engine_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("e2a2");











/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
  name: 'QTooltip',
  mixins: [_mixins_anchor_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"], _mixins_model_toggle_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], _mixins_portal_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "b"], _mixins_transition_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]],
  props: {
    maxHeight: {
      type: String,
      default: null
    },
    maxWidth: {
      type: String,
      default: null
    },
    transitionShow: {
      default: 'jump-down'
    },
    transitionHide: {
      default: 'jump-up'
    },
    anchor: {
      type: String,
      default: 'bottom middle',
      validator: _utils_position_engine_js__WEBPACK_IMPORTED_MODULE_10__[/* validatePosition */ "d"]
    },
    self: {
      type: String,
      default: 'top middle',
      validator: _utils_position_engine_js__WEBPACK_IMPORTED_MODULE_10__[/* validatePosition */ "d"]
    },
    offset: {
      type: Array,
      default: () => [14, 14],
      validator: _utils_position_engine_js__WEBPACK_IMPORTED_MODULE_10__[/* validateOffset */ "c"]
    },
    scrollTarget: {
      default: void 0
    },
    delay: {
      type: Number,
      default: 0
    },
    hideDelay: {
      type: Number,
      default: 0
    }
  },
  computed: {
    anchorOrigin() {
      return Object(_utils_position_engine_js__WEBPACK_IMPORTED_MODULE_10__[/* parsePosition */ "a"])(this.anchor, this.$q.lang.rtl);
    },

    selfOrigin() {
      return Object(_utils_position_engine_js__WEBPACK_IMPORTED_MODULE_10__[/* parsePosition */ "a"])(this.self, this.$q.lang.rtl);
    },

    hideOnRouteChange() {
      return this.persistent !== true;
    }

  },
  methods: {
    __show(evt) {
      this.__showPortal();

      this.__nextTick(() => {
        this.observer = new MutationObserver(() => this.updatePosition());
        this.observer.observe(this.__portal.$el, {
          attributes: false,
          childList: true,
          characterData: true,
          subtree: true
        });
        this.updatePosition();

        this.__configureScrollTarget();
      });

      if (this.unwatch === void 0) {
        this.unwatch = this.$watch(() => this.$q.screen.width + '|' + this.$q.screen.height + '|' + this.self + '|' + this.anchor + '|' + this.$q.lang.rtl, this.updatePosition);
      }

      this.__setTimeout(() => {
        this.$emit('show', evt);
      }, 300);
    },

    __hide(evt) {
      this.__anchorCleanup();

      this.__setTimeout(() => {
        this.__hidePortal();

        this.$emit('hide', evt);
      }, 300);
    },

    __anchorCleanup() {
      if (this.observer !== void 0) {
        this.observer.disconnect();
        this.observer = void 0;
      }

      if (this.unwatch !== void 0) {
        this.unwatch();
        this.unwatch = void 0;
      }

      this.__unconfigureScrollTarget();

      Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_7__[/* cleanEvt */ "b"])(this, 'tooltipTemp');
    },

    updatePosition() {
      if (this.anchorEl === void 0 || this.__portal === void 0) {
        return;
      }

      const el = this.__portal.$el;

      if (el.nodeType === 8) {
        // IE replaces the comment with delay
        setTimeout(this.updatePosition, 25);
        return;
      }

      Object(_utils_position_engine_js__WEBPACK_IMPORTED_MODULE_10__[/* setPosition */ "b"])({
        el,
        offset: this.offset,
        anchorEl: this.anchorEl,
        anchorOrigin: this.anchorOrigin,
        selfOrigin: this.selfOrigin,
        maxHeight: this.maxHeight,
        maxWidth: this.maxWidth
      });
    },

    __delayShow(evt) {
      if (this.$q.platform.is.mobile === true) {
        Object(_utils_selection_js__WEBPACK_IMPORTED_MODULE_8__[/* clearSelection */ "a"])();
        document.body.classList.add('non-selectable');
        const target = Object(_utils_touch_js__WEBPACK_IMPORTED_MODULE_6__[/* getTouchTarget */ "b"])(this.anchorEl);
        const evts = ['touchmove', 'touchcancel', 'touchend', 'click'].map(e => [target, e, '__delayHide', 'passiveCapture']);
        Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_7__[/* addEvt */ "a"])(this, 'tooltipTemp', evts);
      }

      this.__setTimeout(() => {
        this.show(evt);
      }, this.delay);
    },

    __delayHide(evt) {
      this.__clearTimeout();

      if (this.$q.platform.is.mobile === true) {
        Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_7__[/* cleanEvt */ "b"])(this, 'tooltipTemp');
        Object(_utils_selection_js__WEBPACK_IMPORTED_MODULE_8__[/* clearSelection */ "a"])(); // delay needed otherwise selection still occurs

        setTimeout(() => {
          document.body.classList.remove('non-selectable');
        }, 10);
      }

      this.__setTimeout(() => {
        this.hide(evt);
      }, this.hideDelay);
    },

    __configureAnchorEl() {
      if (this.noParentEvent === true || this.anchorEl === void 0) {
        return;
      }

      const evts = this.$q.platform.is.mobile === true ? [[this.anchorEl, 'touchstart', '__delayShow', 'passive']] : [[this.anchorEl, 'mouseenter', '__delayShow', 'passive'], [this.anchorEl, 'mouseleave', '__delayHide', 'passive']];
      Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_7__[/* addEvt */ "a"])(this, 'anchor', evts);
    },

    __unconfigureScrollTarget() {
      if (this.__scrollTarget !== void 0) {
        this.__changeScrollEvent(this.__scrollTarget);

        this.__scrollTarget = void 0;
      }
    },

    __configureScrollTarget() {
      if (this.anchorEl !== void 0 || this.scrollTarget !== void 0) {
        this.__scrollTarget = Object(_utils_scroll_js__WEBPACK_IMPORTED_MODULE_5__[/* getScrollTarget */ "d"])(this.anchorEl, this.scrollTarget);
        const fn = this.noParentEvent === true ? this.updatePosition : this.hide;

        this.__changeScrollEvent(this.__scrollTarget, fn);
      }
    },

    __renderPortal(h) {
      return h('transition', {
        props: {
          name: this.transition
        }
      }, [this.showing === true ? h('div', {
        staticClass: 'q-tooltip q-tooltip--style q-position-engine no-pointer-events',
        class: this.contentClass,
        style: this.contentStyle,
        attrs: {
          role: 'complementary'
        }
      }, Object(_utils_slot_js__WEBPACK_IMPORTED_MODULE_9__[/* slot */ "c"])(this, 'default')) : null]);
    }

  },

  mounted() {
    this.__processModelChange(this.value);
  }

}));

/***/ }),

/***/ "3abb":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _dark_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("87b2");
/* harmony import */ var _utils_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("9ac9");
/* harmony import */ var _form_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("87c8");
/* harmony import */ var _option_size_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("1194");
/* harmony import */ var _refocus_target_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("6a94");
/* harmony import */ var _utils_slot_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("a4b3");
/* harmony import */ var _utils_cache_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("6459");







/* harmony default export */ __webpack_exports__["a"] = ({
  mixins: [_dark_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"], _option_size_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], _form_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "b"], _refocus_target_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]],
  props: {
    value: {
      required: true,
      default: null
    },
    val: {},
    trueValue: {
      default: true
    },
    falseValue: {
      default: false
    },
    indeterminateValue: {
      default: null
    },
    toggleOrder: {
      type: String,
      validator: v => v === 'tf' || v === 'ft'
    },
    toggleIndeterminate: Boolean,
    label: String,
    leftLabel: Boolean,
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    disable: Boolean,
    tabindex: [String, Number]
  },
  computed: {
    isTrue() {
      return this.modelIsArray === true ? this.index > -1 : this.value === this.trueValue;
    },

    isFalse() {
      return this.modelIsArray === true ? this.index === -1 : this.value === this.falseValue;
    },

    isIndeterminate() {
      return this.isTrue === false && this.isFalse === false;
    },

    index() {
      if (this.modelIsArray === true) {
        return this.value.indexOf(this.val);
      }
    },

    modelIsArray() {
      return this.val !== void 0 && Array.isArray(this.value);
    },

    computedTabindex() {
      return this.disable === true ? -1 : this.tabindex || 0;
    },

    classes() {
      return `q-${this.type} cursor-pointer no-outline row inline no-wrap items-center` + (this.disable === true ? ' disabled' : '') + (this.isDark === true ? ` q-${this.type}--dark` : '') + (this.dense === true ? ` q-${this.type}--dense` : '') + (this.leftLabel === true ? ' reverse' : '');
    },

    innerClass() {
      const state = this.isTrue === true ? 'truthy' : this.isFalse === true ? 'falsy' : 'indet';
      const color = this.color !== void 0 && (this.keepColor === true || (this.type === 'toggle' ? this.isTrue === true : this.isFalse !== true)) ? ` text-${this.color}` : '';
      return `q-${this.type}__inner--${state}${color}`;
    },

    formAttrs() {
      const prop = {
        type: 'checkbox'
      };
      this.name !== void 0 && Object.assign(prop, {
        checked: this.isTrue,
        name: this.name,
        value: this.modelIsArray === true ? this.val : this.trueValue
      });
      return prop;
    },

    attrs() {
      const attrs = {
        tabindex: this.computedTabindex,
        role: 'checkbox',
        'aria-label': this.label,
        'aria-checked': this.isIndeterminate === true ? 'mixed' : this.isTrue === true ? 'true' : 'false'
      };

      if (this.disable === true) {
        attrs['aria-disabled'] = 'true';
      }

      return attrs;
    }

  },
  methods: {
    toggle(e) {
      if (e !== void 0) {
        Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_1__[/* stopAndPrevent */ "l"])(e);

        this.__refocusTarget(e);
      }

      if (this.disable !== true) {
        this.$emit('input', this.__getNextValue(), e);
      }
    },

    __getNextValue() {
      if (this.modelIsArray === true) {
        if (this.isTrue === true) {
          const val = this.value.slice();
          val.splice(this.index, 1);
          return val;
        }

        return this.value.concat([this.val]);
      }

      if (this.isTrue === true) {
        if (this.toggleOrder !== 'ft' || this.toggleIndeterminate === false) {
          return this.falseValue;
        }
      } else if (this.isFalse === true) {
        if (this.toggleOrder === 'ft' || this.toggleIndeterminate === false) {
          return this.trueValue;
        }
      } else {
        return this.toggleOrder !== 'ft' ? this.trueValue : this.falseValue;
      }

      return this.indeterminateValue;
    },

    __onKeydown(e) {
      if (e.keyCode === 13 || e.keyCode === 32) {
        Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_1__[/* stopAndPrevent */ "l"])(e);
      }
    },

    __onKeyup(e) {
      if (e.keyCode === 13 || e.keyCode === 32) {
        this.toggle(e);
      }
    }

  },

  render(h) {
    const inner = this.__getInner(h);

    this.disable !== true && this.__injectFormInput(inner, 'unshift', `q-${this.type}__native absolute q-ma-none q-pa-none`);
    const child = [h('div', {
      staticClass: `q-${this.type}__inner relative-position non-selectable`,
      class: this.innerClass,
      style: this.sizeStyle
    }, inner)];

    if (this.__refocusTargetEl !== void 0) {
      child.push(this.__refocusTargetEl);
    }

    const label = this.label !== void 0 ? Object(_utils_slot_js__WEBPACK_IMPORTED_MODULE_5__[/* mergeSlot */ "a"])([this.label], this, 'default') : Object(_utils_slot_js__WEBPACK_IMPORTED_MODULE_5__[/* slot */ "c"])(this, 'default');
    label !== void 0 && child.push(h('div', {
      staticClass: `q-${this.type}__label q-anchor--skip`
    }, label));
    return h('div', {
      class: this.classes,
      attrs: this.attrs,
      on: Object(_utils_cache_js__WEBPACK_IMPORTED_MODULE_6__[/* default */ "b"])(this, 'inpExt', {
        click: this.toggle,
        keydown: this.__onKeydown,
        keyup: this.__onKeyup
      })
    }, child);
  }

});

/***/ }),

/***/ "3cec":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("7d53");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ "3cf3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ ComponentGallery; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ CodeBlock; });

// UNUSED EXPORTS: ApiCard, ApiComponentExample, PlanetarAnchor, PlanetarInput, PlanetarList, PlanetarSelect, PlanetarTabs, PlanetarToggle, ComponentExpose, ComponentPickerGrid, ComponentPickerCard, DocPage, TableOfContents, ExampleCard, ExampleSection, Markdown, MarkdownSection, CodeBlockSection

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/components/ApiCard.vue?vue&type=template&id=033691b6&scoped=true&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"planetar-api-card",attrs:{"id":_vm.kebabCase(_vm.fileName) + "-api"}},[_c('div',{staticClass:"_top"},[_c('div',{staticClass:"text-h4 mr-md"},[_vm._v(_vm._s(_vm.fileName)+" API")]),_c('PlanetarInput',{attrs:{"isSearch":true,"debounce":300},model:{value:(_vm.searchValue),callback:function ($$v) {_vm.searchValue=$$v},expression:"searchValue"}})],1),_c('div',{staticClass:"_bottom"},[_c('PlanetarList',{staticClass:"_tabs",attrs:{"items":_vm.categoryPlanetarListItems},model:{value:(_vm.activeTab),callback:function ($$v) {_vm.activeTab=$$v},expression:"activeTab"}}),_c('QTabPanels',{staticClass:"_tab-panels",attrs:{"animated":"","vertical":""},model:{value:(_vm.activeTab),callback:function ($$v) {_vm.activeTab=$$v},expression:"activeTab"}},_vm._l((_vm.categorySchemaMapFiltered),function(schema,category){return _c('QTabPanel',{key:category,staticClass:"_tab-panel",attrs:{"name":category}},[_c('CategoryPanel',{attrs:{"schema":schema,"mode":_vm.isPlainObject(_vm.value) ? 'edit' : 'view'},model:{value:(_vm.propsObject),callback:function ($$v) {_vm.propsObject=$$v},expression:"propsObject"}})],1)}),1)],1)])}
var staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/components/ApiCard.vue?vue&type=template&id=033691b6&scoped=true&

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/components/ApiCard.vue?vue&type=script&lang=js&
var ApiCardvue_type_script_lang_js_ = __webpack_require__("1515");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/components/ApiCard.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_ApiCardvue_type_script_lang_js_ = (ApiCardvue_type_script_lang_js_["a" /* default */]); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/components/ApiCard.vue?vue&type=style&index=0&id=033691b6&scoped=true&lang=css&
var ApiCardvue_type_style_index_0_id_033691b6_scoped_true_lang_css_ = __webpack_require__("d604");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__("2be6");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/color/QColor.js + 3 modules
var QColor = __webpack_require__("dfd0");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/runtime.auto-import.js
var runtime_auto_import = __webpack_require__("e279");
var runtime_auto_import_default = /*#__PURE__*/__webpack_require__.n(runtime_auto_import);

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/components/ApiCard.vue






/* normalize component */

var ApiCard_component = Object(componentNormalizer["a" /* default */])(
  components_ApiCardvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  "033691b6",
  null
  
)

/* harmony default export */ var ApiCard = (ApiCard_component.exports);


runtime_auto_import_default()(ApiCard_component, 'components', {QColor: QColor["a" /* default */]});

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/components/ApiComponentExample.vue?vue&type=template&id=5526b82d&scoped=true&
var ApiComponentExamplevue_type_template_id_5526b82d_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"planetar-api-component-example"},[_c('div',{staticClass:"text-h6 mb-lg _interactive-preview-title",on:{"click":_vm.togglePreviewStyle}},[_vm._v("\n    Interactive preview\n  ")]),(_vm.exampleComponent && _vm.apiCardMounted)?_c('div',{staticClass:"_interactive-preview-section",staticStyle:{"width":"100%"}},[_c(_vm.exampleComponent,_vm._b({tag:"component",model:{value:(_vm.model),callback:function ($$v) {_vm.model=$$v},expression:"model"}},'component',_vm.propsToBind,false)),(_vm.previewBg)?_c('div',{staticClass:"_bg",style:(("background: " + _vm.previewBg))}):_vm._e()],1):_vm._e(),_c('div',{staticClass:"text-h6 my-lg"},[_vm._v("Info card")]),_c('div',{staticClass:"px-xs",staticStyle:{"width":"100%"}},[_c('ApiCard',{attrs:{"filePath":_vm.filePath},on:{"mounted":_vm.onApiCardMounted},model:{value:(_vm.propsStringified),callback:function ($$v) {_vm.propsStringified=$$v},expression:"propsStringified"}})],1)])}
var ApiComponentExamplevue_type_template_id_5526b82d_scoped_true_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/components/ApiComponentExample.vue?vue&type=template&id=5526b82d&scoped=true&

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/utils/dist/index.js + 2 modules
var dist = __webpack_require__("4173");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/helpers/evaluateString.js
var evaluateString = __webpack_require__("8c14");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/components/ApiComponentExample.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ var ApiComponentExamplevue_type_script_lang_js_ = ({
  name: 'ApiComponentExample',
  components: {
    ApiCard: ApiCard
  },
  props: {
    /**
     * Relative from the `src` folder.
     * @example 'examples/MyBtn/Example1.vue'
     */
    filePath: {
      type: String,
      required: true
    },

    /**
     * Background color for the interactive preview section
     * @example 'black'
     */
    previewBg: {
      type: String
    }
  },
  created: function created() {
    var _this = this;

    var filePath = this.filePath;
    var extension = filePath.split('.').slice(-1)[0];
    Object(dist["a" /* dynamicImport */])(filePath, extension, 'component').then(function (componentExport) {
      _this.exampleComponent = componentExport.default;
    });
  },
  data: function data() {
    return {
      exampleComponent: null,
      propsStringified: {},
      model: undefined,
      previewStyle: '',
      apiCardMounted: false
    };
  },
  watch: {
    model: function model(newValue) {
      var newVal = JSON.stringify(newValue);
      if (this.propsStringified.value === newVal) return;
      this.$set(this.propsStringified, 'value', newVal);
    },
    propsToBind: function propsToBind(_ref) {
      var value = _ref.value;
      this.model = value;
    }
  },
  computed: {
    propsToBind: function propsToBind() {
      var propsStringified = this.propsStringified,
          previewStyle = this.previewStyle;
      var style = previewStyle;
      var propsEvaluated = Object(evaluateString["a" /* evaluateObject */])(propsStringified);
      return Object.assign({
        style: style
      }, propsEvaluated);
    }
  },
  methods: {
    onApiCardMounted: function onApiCardMounted() {
      this.apiCardMounted = true;
      this.$emit('mounted');
    },
    togglePreviewStyle: function togglePreviewStyle() {
      if (this.previewStyle === '') {
        this.previewStyle = 'width:100%';
      } else {
        this.previewStyle = '';
      }
    }
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/components/ApiComponentExample.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_ApiComponentExamplevue_type_script_lang_js_ = (ApiComponentExamplevue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/components/ApiComponentExample.vue?vue&type=style&index=0&id=5526b82d&scoped=true&lang=css&
var ApiComponentExamplevue_type_style_index_0_id_5526b82d_scoped_true_lang_css_ = __webpack_require__("be73");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/components/ApiComponentExample.vue






/* normalize component */

var ApiComponentExample_component = Object(componentNormalizer["a" /* default */])(
  components_ApiComponentExamplevue_type_script_lang_js_,
  ApiComponentExamplevue_type_template_id_5526b82d_scoped_true_render,
  ApiComponentExamplevue_type_template_id_5526b82d_scoped_true_staticRenderFns,
  false,
  null,
  "5526b82d",
  null
  
)

/* harmony default export */ var ApiComponentExample = (ApiComponentExample_component.exports);


runtime_auto_import_default()(ApiComponentExample_component, 'components', {QColor: QColor["a" /* default */]});

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/api-card/dist/index.js



/* harmony default export */ var api_card_dist = ({
  install: function install(Vue) {
    Vue.component(ApiCard.name, ApiCard);
    Vue.component(ApiComponentExample.name, ApiComponentExample);
  }
});
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/index.js + 32 modules
var atoms_dist = __webpack_require__("9d47");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentGallery.vue?vue&type=template&id=d25a87ce&scoped=true&
var ComponentGalleryvue_type_template_id_d25a87ce_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"component-gallery"},[(!_vm.filePath)?_c('ComponentPickerGrid',{attrs:{"componentFilesList":_vm.componentFilesList,"formElementPrefix":_vm.formElementPrefix,"include":_vm.include,"exclude":_vm.exclude}}):_vm._e(),(_vm.filePath)?_c('ComponentExpose',{attrs:{"interactivePreview":_vm.interactivePreviewForFilePath,"componentFilesList":_vm.componentFilesList,"previewBg":_vm.previewBgForFilePath}}):_vm._e()],1)}
var ComponentGalleryvue_type_template_id_d25a87ce_scoped_true_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentGallery.vue?vue&type=template&id=d25a87ce&scoped=true&

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.string.replace.js
var es_string_replace = __webpack_require__("32f5");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentPickerGrid.vue?vue&type=template&id=154aa186&scoped=true&
var ComponentPickerGridvue_type_template_id_154aa186_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"component-picker"},[_c('div',{staticClass:"text-h3 my-md"},[_vm._v("Atoms")]),(_vm.atomsFormElements.length)?_c('div',{staticClass:"text-h6"},[_vm._v("Form Elements")]):_vm._e(),(_vm.atomsFormElements.length)?_c('div',{staticClass:"_grid-md py-lg"},_vm._l((_vm.atomsFormElements),function(filePath){return _c('ComponentPickerCard',{key:filePath,attrs:{"filePath":filePath}})}),1):_vm._e(),(_vm.atomsFormElements.length && _vm.atomsOther.length)?_c('div',{staticClass:"text-h6"},[_vm._v("Other")]):_vm._e(),(_vm.atomsOther.length)?_c('div',{staticClass:"_grid-md py-lg"},_vm._l((_vm.atomsOther),function(filePath){return _c('ComponentPickerCard',{key:filePath,attrs:{"filePath":filePath}})}),1):_vm._e(),(!_vm.atomsOther.length && !_vm.atomsFormElements.length)?_c('div',{staticClass:"py-lg _no-components-yet"},[_c('div',{staticClass:"t-body1"},[_vm._v("No components yet! Start building!!")]),_c('h2',{staticStyle:{"margin":"16px"}},[_vm._v("")])]):_vm._e(),(_vm.molecules.length)?_c('div',{staticClass:"text-h3 my-md"},[_vm._v("Molecules")]):_vm._e(),(_vm.molecules.length)?_c('div',{staticClass:"_grid-md py-lg"},_vm._l((_vm.molecules),function(filePath){return _c('ComponentPickerCard',{key:filePath,attrs:{"filePath":filePath}})}),1):_vm._e()])}
var ComponentPickerGridvue_type_template_id_154aa186_scoped_true_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentPickerGrid.vue?vue&type=template&id=154aa186&scoped=true&

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/helpers/listOfComponents.js
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Returns an etry with the file category and the entry.
 *
 * @param {string} filePath
 * @returns {[undefined | 'atoms' | 'molecules' | 'atomExamples' | 'moleculeExamples', string]}
 */
function filePathToCategoryPathEntry(filePath) {
  var p = filePath.startsWith('./') ? filePath.slice(2) : filePath;
  if (p.startsWith('examples/molecules/') || p.includes('/examples/molecules/')) return ['moleculeExamples', p]; // prettier-ignore

  if (p.startsWith('examples/atoms/') || p.includes('/examples/atoms/')) return ['atomExamples', p];
  if (p.startsWith('molecules/') || p.includes('/molecules/')) return ['molecules', p];
  if (p.startsWith('atoms/') || p.includes('/atoms/')) return ['atoms', p];
  return [undefined, ''];
}
/**
 * @param {string[]} componentFilesList Example: `['./atoms/MyButton.vue']`
 * @returns {{
    atoms: string[],
    atomExamples: string[],
    molecules: string[],
    moleculeExamples: string[],
  }}
 */


function getComponentPaths(componentFilesList) {
  var base = {
    atoms: [],
    atomExamples: [],
    molecules: [],
    moleculeExamples: []
  };
  return componentFilesList.filter(function (filePath) {
    return !filePath.includes('index.js');
  }).reduce(function (carry, filePath) {
    var _filePathToCategoryPa = filePathToCategoryPathEntry(filePath),
        _filePathToCategoryPa2 = _slicedToArray(_filePathToCategoryPa, 2),
        category = _filePathToCategoryPa2[0],
        path = _filePathToCategoryPa2[1];

    if (!category) return carry;
    carry[category].push(path);
    return carry;
  }, base);
}
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentPickerCard.vue?vue&type=template&id=6818b8ed&scoped=true&
var ComponentPickerCardvue_type_template_id_6818b8ed_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"component-picker-card",attrs:{"clickable":true},on:{"click":function () { return _vm.$router.push({
        path: _vm.$router.currentRoute.path,
        query: { filePath: _vm.filePath },
      }); }}},[_c('div',{staticClass:"text-h6 text-wrap-all"},[_vm._v("\n    "+_vm._s(_vm.filePath.replace(/atoms\/|molecules\/|\.vue|\.jsx|\.tsx/g, ''))+"\n  ")])])}
var ComponentPickerCardvue_type_template_id_6818b8ed_scoped_true_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentPickerCard.vue?vue&type=template&id=6818b8ed&scoped=true&

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentPickerCard.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ var ComponentPickerCardvue_type_script_lang_js_ = ({
  name: 'ComponentPickerCard',
  props: {
    filePath: {
      type: String
    }
  },
  data: function data() {
    return {};
  },
  computed: {},
  methods: {}
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentPickerCard.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_ComponentPickerCardvue_type_script_lang_js_ = (ComponentPickerCardvue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentPickerCard.vue?vue&type=style&index=0&id=6818b8ed&scoped=true&lang=css&
var ComponentPickerCardvue_type_style_index_0_id_6818b8ed_scoped_true_lang_css_ = __webpack_require__("4be2");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentPickerCard.vue






/* normalize component */

var ComponentPickerCard_component = Object(componentNormalizer["a" /* default */])(
  components_ComponentPickerCardvue_type_script_lang_js_,
  ComponentPickerCardvue_type_template_id_6818b8ed_scoped_true_render,
  ComponentPickerCardvue_type_template_id_6818b8ed_scoped_true_staticRenderFns,
  false,
  null,
  "6818b8ed",
  null
  
)

/* harmony default export */ var ComponentPickerCard = (ComponentPickerCard_component.exports);
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentPickerGrid.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var ComponentPickerGridvue_type_script_lang_js_ = ({
  name: 'ComponentPicker',
  components: {
    ComponentPickerCard: ComponentPickerCard
  },
  props: {
    /**
     * You need to pass whatever is returned by `require.context('src/components', true, /^\.\/.*(\.vue)$/).keys()`
     * @type {string[]}
     * @example ['./atoms/MyButton.vue']
     * @example require.context('src/components', true, /^\.\/.*(\.vue)$/).keys()
     */
    componentFilesList: {
      type: Array,
      required: true
    },

    /**
     * If you want to separate form element atoms from others, you can pass a prefix like 'My' which will separate any component that starts with 'My', eg. 'MyButton', 'MyInput', etc.
     * @example 'My'
     */
    formElementPrefix: {
      type: String
    },

    /**
     * An array of strings to exclude certain components that partially match whatever you define. Eg. `['Button']` would exclude any component with `Button` in its name from the grid.
     * @type {string[]}
     * @example ['Button']
     */
    exclude: {
      type: Array
    },

    /**
     * An array of strings to include certain components that partially match whatever you define. Eg. `['Button']` would include ONLY components with `Button` in its name.
     * @type {string[]}
     * @example ['Button']
     */
    include: {
      type: Array
    }
  },
  data: function data() {
    var componentFilesList = this.componentFilesList,
        formElementPrefix = this.formElementPrefix,
        exclude = this.exclude,
        include = this.include;

    var _getComponentPaths = getComponentPaths(componentFilesList),
        atoms = _getComponentPaths.atoms,
        molecules = _getComponentPaths.molecules;

    function filePathIncluded() {
      var filePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      if (!include || !include.length) return true;
      return include.some(function (incl) {
        return filePath.includes(incl);
      });
    }

    function filePathExcluded() {
      var filePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      if (!exclude || !exclude.length) return false;
      return include.some(function (excl) {
        return filePath.includes(excl);
      });
    }

    function filePathOk() {
      var filePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      return filePathIncluded(filePath) && !filePathExcluded(filePath);
    }

    var _atoms = atoms.filter(filePathOk);

    var _molecules = molecules.filter(filePathOk);

    var atomsFormElements = !formElementPrefix ? [] : _atoms.filter(function (filePath) {
      return filePath.includes(formElementPrefix);
    });
    var atomsOther = !formElementPrefix ? _atoms : _atoms.filter(function (filePath) {
      return !filePath.includes(formElementPrefix);
    });
    return {
      atomsFormElements: atomsFormElements,
      atomsOther: atomsOther,
      molecules: _molecules
    };
  },
  methods: {},
  computed: {}
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentPickerGrid.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_ComponentPickerGridvue_type_script_lang_js_ = (ComponentPickerGridvue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentPickerGrid.vue?vue&type=style&index=0&id=154aa186&scoped=true&lang=css&
var ComponentPickerGridvue_type_style_index_0_id_154aa186_scoped_true_lang_css_ = __webpack_require__("1801");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentPickerGrid.vue






/* normalize component */

var ComponentPickerGrid_component = Object(componentNormalizer["a" /* default */])(
  components_ComponentPickerGridvue_type_script_lang_js_,
  ComponentPickerGridvue_type_template_id_154aa186_scoped_true_render,
  ComponentPickerGridvue_type_template_id_154aa186_scoped_true_staticRenderFns,
  false,
  null,
  "154aa186",
  null
  
)

/* harmony default export */ var ComponentPickerGrid = (ComponentPickerGrid_component.exports);
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentExpose.vue?vue&type=template&id=6c27d832&scoped=true&
var ComponentExposevue_type_template_id_6c27d832_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"component-expose"},[_c('router-link',{staticClass:"_back",attrs:{"to":_vm.$router.currentRoute.path}},[_c('svg',{staticClass:"feather feather-chevron-left",attrs:{"xmlns":"http://www.w3.org/2000/svg","width":"24","height":"24","viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"}},[_c('polyline',{attrs:{"points":"15 18 9 12 15 6"}})]),_vm._v("\n    back\n  ")]),_vm._l((_vm.exampleFilePaths),function(exampleFilePath){return _c('ExampleSection',{key:exampleFilePath,attrs:{"filePath":("components/examples/" + exampleFilePath)}})}),(_vm.interactivePreview)?_c('ApiComponentExample',{attrs:{"previewBg":_vm.previewBg,"filePath":("components/" + _vm.filePath)}}):_vm._e(),(!_vm.interactivePreview)?_c('ApiCard',{attrs:{"filePath":("components/" + _vm.filePath)}}):_vm._e()],2)}
var ComponentExposevue_type_template_id_6c27d832_scoped_true_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentExpose.vue?vue&type=template&id=6c27d832&scoped=true&

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.symbol.description.js
var es_symbol_description = __webpack_require__("8d0f");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/web.dom-collections.iterator.js
var web_dom_collections_iterator = __webpack_require__("918c");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/example-card/dist/components/ExampleCard.vue?vue&type=template&id=1da558e2&
var ExampleCardvue_type_template_id_1da558e2_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('PlanetarTabs',{class:("planetar-example-card planetar-example-card--" + _vm.activeTab),style:(_vm.iframeHeight && _vm.activeTab === 'example' ? ("height: " + _vm.iframeHeight) : ''),attrs:{"id":_vm.kebabCase(_vm.fileName) + "-example-card","tabLabels":_vm.tabLabels,"activeTab":_vm.activeTab},on:{"update:activeTab":function($event){_vm.activeTab=$event},"update:active-tab":function($event){_vm.activeTab=$event}},scopedSlots:_vm._u([_vm._l((_vm.tabLabels),function(tabLabel,index){return {key:index,fn:function(){return [(tabLabel === 'example' && _vm.exampleComponent)?_c('div',{key:tabLabel + index,staticClass:"pa-lg"},[_c(_vm.exampleComponent,{tag:"component"})],1):_vm._e(),(tabLabel === 'example' && _vm.iframe)?_c('iframe',{key:tabLabel + index,staticStyle:{"width":"100%","height":"100%"},attrs:{"src":_vm.iframe,"frameborder":"0"}}):(_vm.parts[tabLabel])?_c('CodeBlock',{key:tabLabel + index,staticClass:"t-body1",attrs:{"lang":"html","content":_vm.parts[tabLabel]}}):_vm._e()]},proxy:true}})],null,true)})}
var ExampleCardvue_type_template_id_1da558e2_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/example-card/dist/components/ExampleCard.vue?vue&type=template&id=1da558e2&

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/case-anything/dist/index.esm.js
var index_esm = __webpack_require__("9c21");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/Markdown.vue?vue&type=template&id=27ae2cbe&
var Markdownvue_type_template_id_27ae2cbe_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"markdown"},[_c('div',{domProps:{"innerHTML":_vm._s(_vm.mdAsString)}})])}
var Markdownvue_type_template_id_27ae2cbe_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/Markdown.vue?vue&type=template&id=27ae2cbe&

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.promise.js
var es_promise = __webpack_require__("26d3");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/node_modules/is-what/dist/index.esm.js
/**
 * Returns the object type of the given payload
 *
 * @param {*} payload
 * @returns {string}
 */
function getType(payload) {
    return Object.prototype.toString.call(payload).slice(8, -1);
}
/**
 * Returns whether the payload is undefined
 *
 * @param {*} payload
 * @returns {payload is undefined}
 */
function isUndefined(payload) {
    return getType(payload) === 'Undefined';
}
/**
 * Returns whether the payload is null
 *
 * @param {*} payload
 * @returns {payload is null}
 */
function isNull(payload) {
    return getType(payload) === 'Null';
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isPlainObject(payload) {
    if (getType(payload) !== 'Object')
        return false;
    return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isObject(payload) {
    return isPlainObject(payload);
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is { [K in any]: never }}
 */
function isEmptyObject(payload) {
    return isPlainObject(payload) && Object.keys(payload).length === 0;
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isFullObject(payload) {
    return isPlainObject(payload) && Object.keys(payload).length > 0;
}
/**
 * Returns whether the payload is an any kind of object (including special classes or objects with different prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isAnyObject(payload) {
    return getType(payload) === 'Object';
}
/**
 * Returns whether the payload is an object like a type passed in < >
 *
 * Usage: isObjectLike<{id: any}>(payload) // will make sure it's an object and has an `id` prop.
 *
 * @template T this must be passed in < >
 * @param {*} payload
 * @returns {payload is T}
 */
function isObjectLike(payload) {
    return isAnyObject(payload);
}
/**
 * Returns whether the payload is a function (regular or async)
 *
 * @param {*} payload
 * @returns {payload is AnyFunction}
 */
function isFunction(payload) {
    return typeof payload === 'function';
}
/**
 * Returns whether the payload is an array
 *
 * @param {any} payload
 * @returns {payload is any[]}
 */
function isArray(payload) {
    return getType(payload) === 'Array';
}
/**
 * Returns whether the payload is a an array with at least 1 item
 *
 * @param {*} payload
 * @returns {payload is any[]}
 */
function isFullArray(payload) {
    return isArray(payload) && payload.length > 0;
}
/**
 * Returns whether the payload is a an empty array
 *
 * @param {*} payload
 * @returns {payload is []}
 */
function isEmptyArray(payload) {
    return isArray(payload) && payload.length === 0;
}
/**
 * Returns whether the payload is a string
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isString(payload) {
    return getType(payload) === 'String';
}
/**
 * Returns whether the payload is a string, BUT returns false for ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isFullString(payload) {
    return isString(payload) && payload !== '';
}
/**
 * Returns whether the payload is ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isEmptyString(payload) {
    return payload === '';
}
/**
 * Returns whether the payload is a number (but not NaN)
 *
 * This will return `false` for `NaN`!!
 *
 * @param {*} payload
 * @returns {payload is number}
 */
function isNumber(payload) {
    return getType(payload) === 'Number' && !isNaN(payload);
}
/**
 * Returns whether the payload is a boolean
 *
 * @param {*} payload
 * @returns {payload is boolean}
 */
function isBoolean(payload) {
    return getType(payload) === 'Boolean';
}
/**
 * Returns whether the payload is a regular expression (RegExp)
 *
 * @param {*} payload
 * @returns {payload is RegExp}
 */
function isRegExp(payload) {
    return getType(payload) === 'RegExp';
}
/**
 * Returns whether the payload is a Map
 *
 * @param {*} payload
 * @returns {payload is Map<any, any>}
 */
function isMap(payload) {
    return getType(payload) === 'Map';
}
/**
 * Returns whether the payload is a WeakMap
 *
 * @param {*} payload
 * @returns {payload is WeakMap<any, any>}
 */
function isWeakMap(payload) {
    return getType(payload) === 'WeakMap';
}
/**
 * Returns whether the payload is a Set
 *
 * @param {*} payload
 * @returns {payload is Set<any>}
 */
function isSet(payload) {
    return getType(payload) === 'Set';
}
/**
 * Returns whether the payload is a WeakSet
 *
 * @param {*} payload
 * @returns {payload is WeakSet<any>}
 */
function isWeakSet(payload) {
    return getType(payload) === 'WeakSet';
}
/**
 * Returns whether the payload is a Symbol
 *
 * @param {*} payload
 * @returns {payload is symbol}
 */
function isSymbol(payload) {
    return getType(payload) === 'Symbol';
}
/**
 * Returns whether the payload is a Date, and that the date is valid
 *
 * @param {*} payload
 * @returns {payload is Date}
 */
function isDate(payload) {
    return getType(payload) === 'Date' && !isNaN(payload);
}
/**
 * Returns whether the payload is a Blob
 *
 * @param {*} payload
 * @returns {payload is Blob}
 */
function isBlob(payload) {
    return getType(payload) === 'Blob';
}
/**
 * Returns whether the payload is a File
 *
 * @param {*} payload
 * @returns {payload is File}
 */
function isFile(payload) {
    return getType(payload) === 'File';
}
/**
 * Returns whether the payload is a Promise
 *
 * @param {*} payload
 * @returns {payload is Promise<any>}
 */
function isPromise(payload) {
    return getType(payload) === 'Promise';
}
/**
 * Returns whether the payload is an Error
 *
 * @param {*} payload
 * @returns {payload is Error}
 */
function isError(payload) {
    return getType(payload) === 'Error';
}
/**
 * Returns whether the payload is literally the value `NaN` (it's `NaN` and also a `number`)
 *
 * @param {*} payload
 * @returns {payload is typeof NaN}
 */
function isNaNValue(payload) {
    return getType(payload) === 'Number' && isNaN(payload);
}
/**
 * Returns whether the payload is a primitive type (eg. Boolean | Null | Undefined | Number | String | Symbol)
 *
 * @param {*} payload
 * @returns {(payload is boolean | null | undefined | number | string | symbol)}
 */
function isPrimitive(payload) {
    return (isBoolean(payload) ||
        isNull(payload) ||
        isUndefined(payload) ||
        isNumber(payload) ||
        isString(payload) ||
        isSymbol(payload));
}
/**
 * Returns true whether the payload is null or undefined
 *
 * @param {*} payload
 * @returns {(payload is null | undefined)}
 */
var isNullOrUndefined = isOneOf(isNull, isUndefined);
function isOneOf(a, b, c, d, e) {
    return function (value) {
        return a(value) || b(value) || (!!c && c(value)) || (!!d && d(value)) || (!!e && e(value));
    };
}
/**
 * Does a generic check to check that the given payload is of a given type.
 * In cases like Number, it will return true for NaN as NaN is a Number (thanks javascript!);
 * It will, however, differentiate between object and null
 *
 * @template T
 * @param {*} payload
 * @param {T} type
 * @throws {TypeError} Will throw type error if type is an invalid type
 * @returns {payload is T}
 */
function isType(payload, type) {
    if (!(type instanceof Function)) {
        throw new TypeError('Type must be a function');
    }
    if (!Object.prototype.hasOwnProperty.call(type, 'prototype')) {
        throw new TypeError('Type is not a class');
    }
    // Classes usually have names (as functions usually have names)
    var name = type.name;
    return getType(payload) === name || Boolean(payload && payload.constructor === type);
}



// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/snarkdown/dist/snarkdown.es.js
var snarkdown_es = __webpack_require__("0471");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/prismjs/prism.js
var prism = __webpack_require__("9f9b");
var prism_default = /*#__PURE__*/__webpack_require__.n(prism);

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/helpers/htmlHelpers.js


function prismHighlight(str, lang) {
  if (!str || !lang || prism_default.a.languages[lang] === undefined) {
    console.error('something went wrong', str, lang);
    return '';
  }

  return prism_default.a.highlight(str, prism_default.a.languages[lang], lang);
}
function codeToHtml(str, lang) {
  if (lang === 'vue') lang = 'html';
  var highlightedCode = prismHighlight(str, lang);
  return "<pre class=\"language-".concat(lang, "\"><code class=\"language-").concat(lang, "\">").concat(highlightedCode, "</code></pre>");
}
function replacer(matchedString, lang, content) {
  content = content.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
  var htmlHighlighted = prismHighlight(content, lang);
  var recreatedBlock = "<pre class=\"language-".concat(lang, "\"><code class=\"language-").concat(lang, "\">").concat(htmlHighlighted, "</code></pre>");
  return recreatedBlock;
}
/**
 * @param {string} mdString
 * @returns {string | undefined}
 */

function mdToHtml(mdString) {
  if (!mdString) return undefined;
  var html = Object(snarkdown_es["a" /* default */])(mdString);
  var codeBlock = /<pre.+?><code.+?language-(\w+?)".*?>([\s\S]+?)<\/code><\/pre>/g;
  var htmlWithHighlighting = html.replace(/&quot;/g, '"').replace(codeBlock, replacer);
  return htmlWithHighlighting;
}
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/helpers/anchorHelpers.js

/**
 * Tells if an anchor link points to another domain or not
 * @param {HTMLAnchorElement} anchorEl
 * @returns {boolean}
 */

function isExternalLink(anchorEl) {
  var baseURI = anchorEl.baseURI;
  var target = baseURI.replace(/https|http/i, '');
  var current = document.baseURI.replace(/https|http/i, '');
  return target !== current;
}
/**
 * any anchor link starting with just `#` is treated as same page hash links
 * or any anchor link with the same pathname as the current page and a hash
 * @param {HTMLAnchorElement} anchorEl
 * @returns {boolean}
 */

function isSamePageHashLink(anchorEl) {
  if (isExternalLink(anchorEl) || !isFullString(anchorEl.href)) return false;
  var linkWithoutBaseURI = anchorEl.href.replace(document.baseURI, '');
  if (linkWithoutBaseURI[0] === '#') return true;
  var pathWithoutTrailingSlash = document.location.pathname.slice(1);
  var linkWithoutCurrentPath = linkWithoutBaseURI.replace(pathWithoutTrailingSlash, '');
  return linkWithoutCurrentPath[0] === '#'; // basically, if we remove the current path from the target link, and it still doesn't start with #
  // then it's a different page link or a same page non-hash link
}
/**
 * The passed anchorEl is a same site other page link
 * @param {HTMLAnchorElement} anchorEl
 * @returns {boolean}
 */

function isSameSiteOtherPageLink(anchorEl) {
  if (!isFullString(anchorEl.href)) return false;
  if (isExternalLink(anchorEl)) return false;
  if (isSamePageHashLink(anchorEl)) return false;
  return anchorEl.pathname !== document.location.pathname;
}
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/Markdown.vue?vue&type=script&lang=js&




//
//
//
//
//
//
function _await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}

function _empty() {}

function _invokeIgnored(body) {
  var result = body();

  if (result && result.then) {
    return result.then(_empty);
  }
}

function _async(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}

function Markdownvue_type_script_lang_js_slicedToArray(arr, i) {
  return Markdownvue_type_script_lang_js_arrayWithHoles(arr) || Markdownvue_type_script_lang_js_iterableToArrayLimit(arr, i) || Markdownvue_type_script_lang_js_unsupportedIterableToArray(arr, i) || Markdownvue_type_script_lang_js_nonIterableRest();
}

function Markdownvue_type_script_lang_js_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function Markdownvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return Markdownvue_type_script_lang_js_arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Markdownvue_type_script_lang_js_arrayLikeToArray(o, minLen);
}

function Markdownvue_type_script_lang_js_arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function Markdownvue_type_script_lang_js_iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function Markdownvue_type_script_lang_js_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}





/* harmony default export */ var Markdownvue_type_script_lang_js_ = ({
  name: 'Markdown',
  props: {
    /**
     * Your markdown content.
     * @example ## Hello
     */
    content: {
      type: String
    }
  },
  watch: {
    content: {
      immediate: true,
      handler: function handler(content) {
        var _this = this;

        this.$nextTick(function () {
          var el = _this.$el;
          if (!content || !el) return;
          var anchors = el.querySelectorAll('a');
          anchors.forEach(_this.parseAnchorEl);
        });
      }
    }
  },
  methods: {
    /**
     * @param {VNode[]} nodes
     * @returns {string}
     */
    getTextFromSlot: function getTextFromSlot(nodes) {
      if (!isArray(nodes)) return '';

      var _nodes = Markdownvue_type_script_lang_js_slicedToArray(nodes, 1),
          node = _nodes[0];

      return node && node.text || '';
    },

    /**
     * attaches custom scrolling behaviour to anchor elements that point to same site hash tags
     * @param {HTMLElement} el
     */
    parseAnchorEl: function parseAnchorEl(el) {
      var _this2 = this;

      if (isSamePageHashLink(el)) {
        var targetId = el.href.split('#')[1];
        el.addEventListener('click', function (e) {
          Object(dist["b" /* scrollToElId */])(targetId, _this2.$router, e);
        }); // todo: set route query

        return;
      }

      if (isSameSiteOtherPageLink(el)) {
        var _targetId = el.href.split('#')[1];
        var pathname = el.pathname;
        var router = this.$router;
        if (!router) return;
        el.addEventListener('click', _async(function (e) {
          e.preventDefault();
          e.stopPropagation();
          return _await(router.push(pathname), function () {
            // todo: set route query
            return _invokeIgnored(function () {
              if (_targetId) {
                return _await(new Promise(function (resolve) {
                  return setTimeout(resolve, 100);
                }), function () {
                  Object(dist["b" /* scrollToElId */])(_targetId, router, e);
                });
              }
            });
          });
        }));
        return;
      }

      if (!isExternalLink(el)) {
        // the anchor link does not point to the same page with hash
        // not to the same site other page
        // and not to another domain
        // so it's a same site same page non-hash link...
        // if Vue router exists, for now do nothing:
        var _router = this.$router;
        if (!_router) return;
        el.addEventListener('click', _async(function (e) {
          if (_router) {
            e.preventDefault();
            e.stopPropagation(); // todo: set route query
          }

          return _await();
        }));
      }
    }
  },
  computed: {
    mdAsString: function mdAsString() {
      var content = this.content,
          $slots = this.$slots,
          getTextFromDefaultSlot = this.getTextFromDefaultSlot,
          getTextFromSlot = this.getTextFromSlot;

      var _content = getTextFromSlot($slots.default) || content || '';

      return mdToHtml(_content);
    }
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/Markdown.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_Markdownvue_type_script_lang_js_ = (Markdownvue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/Markdown.vue?vue&type=style&index=0&lang=css&
var Markdownvue_type_style_index_0_lang_css_ = __webpack_require__("c29f");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/Markdown.vue






/* normalize component */

var Markdown_component = Object(componentNormalizer["a" /* default */])(
  components_Markdownvue_type_script_lang_js_,
  Markdownvue_type_template_id_27ae2cbe_render,
  Markdownvue_type_template_id_27ae2cbe_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var Markdown = (Markdown_component.exports);
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/MarkdownSection.vue?vue&type=template&id=111c2477&
var MarkdownSectionvue_type_template_id_111c2477_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('Markdown',{staticClass:"markdown-section",attrs:{"content":_vm.content}})}
var MarkdownSectionvue_type_template_id_111c2477_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/MarkdownSection.vue?vue&type=template&id=111c2477&

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/MarkdownSection.vue?vue&type=script&lang=js&
//
//
//
//


/* harmony default export */ var MarkdownSectionvue_type_script_lang_js_ = ({
  name: 'MarkdownSection',
  components: {
    Markdown: Markdown
  },
  props: {
    /**
     * Relative from the `src` folder.
     * @example 'examples/MyBtn/Example1.vue'
     */
    filePath: {
      type: String,
      required: true
    }
  },
  created: function created() {
    var _this = this;

    var filePath = this.filePath;
    var extension = filePath.split('.').slice(-1)[0];
    Object(dist["a" /* dynamicImport */])(filePath, extension, 'string').then(function (markdownContent) {
      _this.content = markdownContent;

      _this.$nextTick(function () {
        return _this.$emit('mounted');
      });
    });
  },
  data: function data() {
    return {
      content: ''
    };
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/MarkdownSection.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_MarkdownSectionvue_type_script_lang_js_ = (MarkdownSectionvue_type_script_lang_js_); 
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/MarkdownSection.vue





/* normalize component */

var MarkdownSection_component = Object(componentNormalizer["a" /* default */])(
  components_MarkdownSectionvue_type_script_lang_js_,
  MarkdownSectionvue_type_template_id_111c2477_render,
  MarkdownSectionvue_type_template_id_111c2477_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var MarkdownSection = (MarkdownSection_component.exports);
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/CodeBlock.vue?vue&type=template&id=03e52a0a&
var CodeBlockvue_type_template_id_03e52a0a_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"code-block",domProps:{"innerHTML":_vm._s(_vm.htmlAsString)}})}
var CodeBlockvue_type_template_id_03e52a0a_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/CodeBlock.vue?vue&type=template&id=03e52a0a&

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/CodeBlock.vue?vue&type=script&lang=js&
//
//
//
//

/* harmony default export */ var CodeBlockvue_type_script_lang_js_ = ({
  name: 'CodeBlock',
  props: {
    lang: String,

    /**
     * Because of how Vue parses strings, the forward slash in the closing script tag must be escaped
     * or the component will fail to compile.
     *
     * For more information, see these comments:
     * * https://github.com/vuejs/vue/issues/4625
     * * https://github.com/vuejs/vue-loader/issues/506
     * @example `<div>Hi</div>\n<br />\n<script>\nconst a = 1\n<\/script>`
     */
    content: String
  },
  computed: {
    htmlAsString: function htmlAsString() {
      var content = this.content,
          lang = this.lang;
      return codeToHtml(content, lang);
    }
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/CodeBlock.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_CodeBlockvue_type_script_lang_js_ = (CodeBlockvue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/CodeBlock.vue?vue&type=style&index=0&lang=css&
var CodeBlockvue_type_style_index_0_lang_css_ = __webpack_require__("bb7d");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/CodeBlock.vue






/* normalize component */

var CodeBlock_component = Object(componentNormalizer["a" /* default */])(
  components_CodeBlockvue_type_script_lang_js_,
  CodeBlockvue_type_template_id_03e52a0a_render,
  CodeBlockvue_type_template_id_03e52a0a_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var CodeBlock = (CodeBlock_component.exports);
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/CodeBlockSection.vue?vue&type=template&id=d37439c4&
var CodeBlockSectionvue_type_template_id_d37439c4_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('CodeBlock',{staticClass:"code-block-section",attrs:{"lang":_vm.lang,"content":_vm.content}})}
var CodeBlockSectionvue_type_template_id_d37439c4_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/CodeBlockSection.vue?vue&type=template&id=d37439c4&

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/CodeBlockSection.vue?vue&type=script&lang=js&
//
//
//
//


/* harmony default export */ var CodeBlockSectionvue_type_script_lang_js_ = ({
  name: 'CodeBlockSection',
  components: {
    CodeBlock: CodeBlock
  },
  props: {
    /**
     * Relative from the `src` folder.
     * @example 'examples/MyBtn/Example1.vue'
     */
    filePath: {
      type: String,
      required: true
    }
  },
  created: function created() {
    var _this = this;

    var filePath = this.filePath;
    var extension = filePath.split('.').slice(-1)[0];
    this.lang = extension;
    Object(dist["a" /* dynamicImport */])(filePath, extension, 'string').then(function (markdownContent) {
      _this.$nextTick(function () {
        return _this.$emit('mounted');
      });

      _this.content = markdownContent;
    });
  },
  data: function data() {
    return {
      content: '',
      lang: ''
    };
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/CodeBlockSection.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_CodeBlockSectionvue_type_script_lang_js_ = (CodeBlockSectionvue_type_script_lang_js_); 
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/components/CodeBlockSection.vue





/* normalize component */

var CodeBlockSection_component = Object(componentNormalizer["a" /* default */])(
  components_CodeBlockSectionvue_type_script_lang_js_,
  CodeBlockSectionvue_type_template_id_d37439c4_render,
  CodeBlockSectionvue_type_template_id_d37439c4_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var CodeBlockSection = (CodeBlockSection_component.exports);
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/markdown/dist/index.js





/* harmony default export */ var markdown_dist = ({
  install: function install(Vue) {
    Vue.component(Markdown.name, Markdown);
    Vue.component(MarkdownSection.name, MarkdownSection);
    Vue.component(CodeBlock.name, CodeBlock);
    Vue.component(CodeBlockSection.name, CodeBlockSection);
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/example-card/dist/helpers/regexp.js
/**
 * @param {string} tagName
 * @param {string} codeString
 * @returns {string}
 */
function getTagHtmlFromCodeString(tagName) {
  var codeString = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var tag = "(<".concat(tagName, "(.*?)>([\\w\\W]*?)<\\/").concat(tagName, ">)");
  var regex = new RegExp(tag, 'g');
  var parsed = regex.exec(codeString) || [];
  return parsed[1] || '';
}
var jsDocBlockNoIndentation = /\n\/\*\*([\s\S]*?)\n \*\//g;
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/example-card/dist/components/ExampleCard.vue?vue&type=script&lang=js&

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





/* harmony default export */ var ExampleCardvue_type_script_lang_js_ = ({
  name: 'ExampleCard',
  components: {
    PlanetarTabs: atoms_dist["e" /* PlanetarTabs */],
    CodeBlock: CodeBlock
  },
  props: {
    /**
     * Relative from the `src` folder.
     * @example 'examples/MyBtn/Example1.vue'
     */
    filePath: {
      type: String,
      required: true
    },

    /**
     * When `true` the JSDoc above the default export will be stripped from displayed source code in the script tab.
     */
    stripJSDocDescription: {
      type: Boolean,
      default: false
    },

    /**
     * If you want to host the actual example that's being rendered somewhere else and render it via iframe instead -- to be able to isolate all CSS -- you can do this by passing the iframe URL.
     */
    iframe: {
      type: String
    },

    /**
     * The height you want to pass to the iframe. If pixels it must include 'px'.
     * @example '800px'
     */
    iframeHeight: {
      type: String
    }
  },
  created: function created() {
    var _this = this;

    var parseComponent = this.parseComponent,
        filePath = this.filePath,
        iframe = this.iframe;
    var extension = filePath.split('.').slice(-1)[0];
    this.lang = extension;
    Object(dist["a" /* dynamicImport */])(filePath, extension, 'string').then(function (componentString) {
      parseComponent(componentString);
      _this.dynamicImports++;
    });
    if (iframe) return;
    Object(dist["a" /* dynamicImport */])(filePath, extension, 'component').then(function (componentExport) {
      _this.exampleComponent = componentExport.default;
      _this.dynamicImports++;
    });
  },
  watch: {
    dynamicImports: function dynamicImports(count) {
      var _this2 = this;

      var requiredImportsCount = this.iframe ? 1 : 2;
      if (count >= requiredImportsCount) this.$nextTick(function () {
        return _this2.$emit('mounted');
      });
    }
  },
  data: function data() {
    var propsSeparateTab = this.propsSeparateTab,
        filePath = this.filePath;
    var fileName = filePath.split('/').slice(-1)[0].replace(/\.vue|\.tsx|\.jsx/, '');
    return {
      dynamicImports: 0,
      fileName: fileName,
      activeTab: 'example',
      tabLabels: ['example'],
      lang: '',
      exampleComponent: null,
      parts: {
        template: '',
        script: '',
        style: ''
      }
    };
  },
  computed: {},
  methods: {
    kebabCase: index_esm["a" /* kebabCase */],
    parseComponent: function parseComponent(componentCodeString) {
      var stripJSDocDescription = this.stripJSDocDescription;
      var template = getTagHtmlFromCodeString('template', componentCodeString);
      var script = getTagHtmlFromCodeString('script', componentCodeString);
      var style = getTagHtmlFromCodeString('style', componentCodeString);
      var notAVueFile = !template && !script && !style;

      if (notAVueFile) {
        script = componentCodeString;

        if (stripJSDocDescription) {
          script = script.replace(jsDocBlockNoIndentation, '');
        }

        this.parts.script = script;
        this.tabLabels.push('script');
        return;
      }

      if (template) {
        this.parts.template = template;
        this.tabLabels.push('template');
      }

      if (script) {
        if (stripJSDocDescription) {
          script = script.replace(jsDocBlockNoIndentation, '');
        }

        this.parts.script = script;
        this.tabLabels.push('script');
      }

      if (style) {
        this.parts.style = style;
        this.tabLabels.push('style');
      }
    }
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/example-card/dist/components/ExampleCard.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_ExampleCardvue_type_script_lang_js_ = (ExampleCardvue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/example-card/dist/components/ExampleCard.vue?vue&type=style&index=0&lang=css&
var ExampleCardvue_type_style_index_0_lang_css_ = __webpack_require__("9b9f");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/example-card/dist/components/ExampleCard.vue






/* normalize component */

var ExampleCard_component = Object(componentNormalizer["a" /* default */])(
  components_ExampleCardvue_type_script_lang_js_,
  ExampleCardvue_type_template_id_1da558e2_render,
  ExampleCardvue_type_template_id_1da558e2_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var ExampleCard = (ExampleCard_component.exports);


runtime_auto_import_default()(ExampleCard_component, 'components', {QColor: QColor["a" /* default */]});

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/example-card/dist/components/ExampleSection.vue?vue&type=template&id=7e8d7638&
var ExampleSectionvue_type_template_id_7e8d7638_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{"id":_vm.kebabCase(_vm.exampleTitle) + "-example"}},[(!_vm.hideTitle && _vm.exampleTitle)?_c('div',{staticClass:"text-h6 mb-md"},[_vm._v(_vm._s(_vm.spaceCase(_vm.exampleTitle)))]):_vm._e(),(_vm.exampleDescription)?_c('Markdown',{staticClass:"mb-lg t-body1",attrs:{"content":_vm.exampleDescription}}):_vm._e(),_c('ExampleCard',{attrs:{"filePath":_vm.filePath,"stripJSDocDescription":true,"iframe":_vm.iframe,"iframeHeight":_vm.iframeHeight},on:{"mounted":function () { return _vm.dynamicImports++; }}})],1)}
var ExampleSectionvue_type_template_id_7e8d7638_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/example-card/dist/components/ExampleSection.vue?vue&type=template&id=7e8d7638&

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/example-card/dist/components/ExampleSection.vue?vue&type=script&lang=js&


//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ var ExampleSectionvue_type_script_lang_js_ = ({
  name: 'ExampleSection',
  components: {
    ExampleCard: ExampleCard,
    Markdown: Markdown
  },
  props: {
    /**
     * Relative from the `src` folder.
     * @example 'examples/MyBtn/Example1.vue'
     */
    filePath: {
      type: String,
      required: true
    },

    /**
     * By default the filename is shown as title above the example. Can be overwritten with the title prop.
     */
    title: {
      type: String
    },

    /**
     * By default a title is shown above the example. Can be hidden with hideTitle.
     */
    hideTitle: {
      type: Boolean
    },

    /**
     * If you want to host the actual example that's being rendered somewhere else and render it via iframe instead -- to be able to isolate all CSS -- you can do this by passing the iframe URL.
     */
    iframe: {
      type: String
    },

    /**
     * The height you want to pass to the iframe. If pixels it must include 'px'.
     * @example '800px'
     */
    iframeHeight: {
      type: String
    }
  },
  created: function created() {
    var _this = this;

    var parseComponent = this.parseComponent,
        filePath = this.filePath,
        parseDescription = this.parseDescription,
        iframe = this.iframe;
    var extension = filePath.split('.').slice(-1)[0];
    if (iframe) return;
    Object(dist["a" /* dynamicImport */])(filePath, extension, 'vue-docgen').then(function (vueDocgen) {
      _this.dynamicImports++;
      parseDescription(vueDocgen);
    });
  },
  watch: {
    dynamicImports: function dynamicImports(count) {
      var _this2 = this;

      var requiredImportsCount = this.iframe ? 1 : 2;
      if (count >= requiredImportsCount) this.$nextTick(function () {
        return _this2.$emit('mounted');
      });
    }
  },
  data: function data() {
    var filePath = this.filePath,
        title = this.title;
    var fileName = filePath.split('/').slice(-1)[0].replace('.vue', '').replace('.jsx', '').replace('.tsx', '');
    var exampleTitle = title || fileName;
    return {
      dynamicImports: 0,
      exampleTitle: exampleTitle,
      exampleDescription: ''
    };
  },
  computed: {},
  methods: {
    kebabCase: index_esm["a" /* kebabCase */],
    spaceCase: index_esm["b" /* spaceCase */],
    parseDescription: function parseDescription(vueDocgen) {
      var descriptionMd = vueDocgen.description;
      this.exampleDescription = descriptionMd;
    }
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/example-card/dist/components/ExampleSection.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_ExampleSectionvue_type_script_lang_js_ = (ExampleSectionvue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/example-card/dist/components/ExampleSection.vue?vue&type=style&index=0&lang=css&
var ExampleSectionvue_type_style_index_0_lang_css_ = __webpack_require__("df48");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/example-card/dist/components/ExampleSection.vue






/* normalize component */

var ExampleSection_component = Object(componentNormalizer["a" /* default */])(
  components_ExampleSectionvue_type_script_lang_js_,
  ExampleSectionvue_type_template_id_7e8d7638_render,
  ExampleSectionvue_type_template_id_7e8d7638_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var ExampleSection = (ExampleSection_component.exports);
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/example-card/dist/index.js



/* harmony default export */ var example_card_dist = ({
  install: function install(Vue) {
    Vue.component(ExampleCard.name, ExampleCard);
    Vue.component(ExampleSection.name, ExampleSection);
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentExpose.vue?vue&type=script&lang=js&




//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
function ComponentExposevue_type_script_lang_js_slicedToArray(arr, i) {
  return ComponentExposevue_type_script_lang_js_arrayWithHoles(arr) || ComponentExposevue_type_script_lang_js_iterableToArrayLimit(arr, i) || ComponentExposevue_type_script_lang_js_unsupportedIterableToArray(arr, i) || ComponentExposevue_type_script_lang_js_nonIterableRest();
}

function ComponentExposevue_type_script_lang_js_nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function ComponentExposevue_type_script_lang_js_unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return ComponentExposevue_type_script_lang_js_arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ComponentExposevue_type_script_lang_js_arrayLikeToArray(o, minLen);
}

function ComponentExposevue_type_script_lang_js_arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function ComponentExposevue_type_script_lang_js_iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function ComponentExposevue_type_script_lang_js_arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}




/* harmony default export */ var ComponentExposevue_type_script_lang_js_ = ({
  name: 'ComponentExpose',
  components: {
    ApiCard: ApiCard,
    ApiComponentExample: ApiComponentExample,
    ExampleSection: ExampleSection
  },
  props: {
    /**
     * You need to pass whatever is returned by `require.context('src/components', true, /^\.\/.*(\.vue)$/).keys()`
     * @type {string[]}
     * @example ['./atoms/MyButton.vue']
     * @example require.context('src/components', true, /^\.\/.*(\.vue)$/).keys()
     */
    componentFilesList: {
      type: Array,
      required: true
    },

    /**
     * If you don't want an interactive preview you can set this to false
     */
    interactivePreview: {
      type: Boolean,
      default: true
    },

    /**
     * Background color for the interactive preview section
     * @example 'black'
     */
    previewBg: {
      type: String
    }
  },
  computed: {
    filePath: function filePath() {
      var r = this.$route;
      return r.query.filePath;
    },
    exampleFilePaths: function exampleFilePaths() {
      var componentFilesList = this.componentFilesList,
          filePath = this.filePath;

      var _getComponentPaths = getComponentPaths(componentFilesList),
          atomExamples = _getComponentPaths.atomExamples,
          moleculeExamples = _getComponentPaths.moleculeExamples;

      var examplePaths = atomExamples.concat(moleculeExamples).map(function (p) {
        return p.replace('examples/', '');
      });
      var examplePathArrays = examplePaths.map(function (p) {
        return p.split('/');
      });
      var componentPathArray = filePath.split('/');

      var _componentPathArray = ComponentExposevue_type_script_lang_js_slicedToArray(componentPathArray, 2),
          folder = _componentPathArray[0],
          component = _componentPathArray[1];

      var componentExamples = examplePathArrays.filter(function (_ref) {
        var _ref2 = ComponentExposevue_type_script_lang_js_slicedToArray(_ref, 2),
            _folder = _ref2[0],
            _component = _ref2[1];

        return _folder === folder && _component.split('.')[0] === component.split('.')[0];
      }).map(function (pathArray) {
        return pathArray.join('/');
      });
      return componentExamples;
    }
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentExpose.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_ComponentExposevue_type_script_lang_js_ = (ComponentExposevue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentExpose.vue?vue&type=style&index=0&id=6c27d832&scoped=true&lang=css&
var ComponentExposevue_type_style_index_0_id_6c27d832_scoped_true_lang_css_ = __webpack_require__("e77a");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentExpose.vue






/* normalize component */

var ComponentExpose_component = Object(componentNormalizer["a" /* default */])(
  components_ComponentExposevue_type_script_lang_js_,
  ComponentExposevue_type_template_id_6c27d832_scoped_true_render,
  ComponentExposevue_type_template_id_6c27d832_scoped_true_staticRenderFns,
  false,
  null,
  "6c27d832",
  null
  
)

/* harmony default export */ var ComponentExpose = (ComponentExpose_component.exports);


runtime_auto_import_default()(ComponentExpose_component, 'components', {QColor: QColor["a" /* default */]});

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentGallery.vue?vue&type=script&lang=js&

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var ComponentGalleryvue_type_script_lang_js_ = ({
  name: 'ComponentGallery',
  components: {
    ComponentPickerGrid: ComponentPickerGrid,
    ComponentExpose: ComponentExpose
  },
  props: {
    /**
     * You need to pass whatever is returned by `require.context('src/components', true, /^\.\/.*(\.vue)$/).keys()`
     * @type {string[]}
     * @example ['./atoms/MyButton.vue']
     * @example require.context('src/components', true, /^\.\/.*(\.vue)$/).keys()
     */
    componentFilesList: {
      type: Array,
      required: true
    },

    /**
     * If you only want to include the interactive preview for certain components, you can pass an array of strings with the component names. Eg. `['Button']` would include the interactive preview ONLY for components with `Button` in its name.
     * @type {string[]}
     */
    interactivePreviewFor: {
      type: Array,
      default: function _default() {
        return [];
      }
    },

    /**
     * If you only want to exclude the interactive preview for certain components, you can pass an array of strings with the component names. Eg. `['Button']` would exclude the interactive preview for ALL components with `Button` in its name.
     * @type {string[]}
     */
    noInteractivePreviewFor: {
      type: Array,
      default: function _default() {
        return [];
      }
    },

    /**
     * You can give certain components a background for the "interactive preview" section, which will be applied like so: `style="background: ~~~"`
     * @type {{ [componentName: string]: string }}
     */
    componentNamePreviewBgMap: {
      type: Object,
      default: function _default() {
        return {};
      }
    },

    /**
     * If you want to separate form element atoms from others, you can pass a prefix like 'My' which will separate any component that starts with 'My', eg. 'MyButton', 'MyInput', etc.
     * @example 'My'
     */
    formElementPrefix: {
      type: String
    },

    /**
     * An array of strings to exclude certain components that partially match whatever you define. Eg. `['Button']` would exclude any component with `Button` in its name from the grid.
     * @type {string[]}
     * @example ['Button']
     */
    exclude: {
      type: Array
    },

    /**
     * An array of strings to include certain components that partially match whatever you define. Eg. `['Button']` would include ONLY components with `Button` in its name.
     * @type {string[]}
     * @example ['Button']
     */
    include: {
      type: Array
    }
  },
  computed: {
    filePath: function filePath() {
      var r = this.$route;
      return r.query.filePath;
    },
    interactivePreviewForFilePath: function interactivePreviewForFilePath() {
      var filePath = this.filePath,
          interactivePreviewFor = this.interactivePreviewFor,
          noInteractivePreviewFor = this.noInteractivePreviewFor;

      function previewIncluded() {
        var filePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        if (!interactivePreviewFor || !interactivePreviewFor.length) return true;
        return interactivePreviewFor.some(function (incl) {
          return filePath.includes(incl);
        });
      }

      function previewExcluded() {
        var filePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        if (!noInteractivePreviewFor || !noInteractivePreviewFor.length) return false;
        return noInteractivePreviewFor.some(function (excl) {
          return filePath.includes(excl);
        });
      }

      function filePathOk() {
        var filePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        return previewIncluded(filePath) && !previewExcluded(filePath);
      }

      return filePathOk(filePath);
    },
    previewBgForFilePath: function previewBgForFilePath() {
      var filePath = this.filePath,
          componentNamePreviewBgMap = this.componentNamePreviewBgMap;
      var componentName = (filePath.split('/').slice(-1)[0] || "").replace(/\.vue|\.jsx|\.tsx/, ''); // prettier-ignore

      return componentNamePreviewBgMap[componentName];
    }
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentGallery.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_ComponentGalleryvue_type_script_lang_js_ = (ComponentGalleryvue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentGallery.vue?vue&type=style&index=0&id=d25a87ce&scoped=true&lang=css&
var ComponentGalleryvue_type_style_index_0_id_d25a87ce_scoped_true_lang_css_ = __webpack_require__("a680");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/components/ComponentGallery.vue






/* normalize component */

var ComponentGallery_component = Object(componentNormalizer["a" /* default */])(
  components_ComponentGalleryvue_type_script_lang_js_,
  ComponentGalleryvue_type_template_id_d25a87ce_scoped_true_render,
  ComponentGalleryvue_type_template_id_d25a87ce_scoped_true_staticRenderFns,
  false,
  null,
  "d25a87ce",
  null
  
)

/* harmony default export */ var ComponentGallery = (ComponentGallery_component.exports);
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/component-gallery/dist/index.js





/* harmony default export */ var component_gallery_dist = ({
  install: function install(Vue) {
    Vue.component(ComponentGallery.name, ComponentGallery);
    Vue.component(ComponentExpose.name, ComponentExpose);
    Vue.component(ComponentPickerGrid.name, ComponentPickerGrid);
    Vue.component(ComponentPickerCard.name, ComponentPickerCard);
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/doc-builder/dist/components/DocPage.vue?vue&type=template&id=09837c02&scoped=true&
var DocPagevue_type_template_id_09837c02_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"doc-page"},[_vm._l((_vm.filesList),function(filePath,i){return [(filePath.endsWith('.vue'))?_c('ExampleSection',_vm._b({key:filePath + i,staticClass:"mb-xxxl",attrs:{"filePath":filePath,"hideTitle":true},on:{"mounted":function () { return _vm.mountCount++; }}},'ExampleSection',_vm.chapterOptions[filePath.replace(_vm.pathToChapterFiles, '')] || {},false)):_vm._e(),(filePath.endsWith('.md'))?_c('MarkdownSection',_vm._b({key:filePath + i,staticClass:"mb-xxxl",attrs:{"filePath":filePath},on:{"mounted":function () { return _vm.mountCount++; }}},'MarkdownSection',_vm.chapterOptions[filePath.replace(_vm.pathToChapterFiles, '')] || {},false)):_vm._e()]}),(_vm.pathsToApiCardSourceFile.length)?_c('div',{attrs:{"id":"api-card"}},_vm._l((_vm.pathsToApiCardSourceFile),function(path){return _c('ApiComponentExample',{key:path,staticClass:"mb-xxxl",attrs:{"filePath":path},on:{"mounted":function () { return _vm.mountCountApiCards++; }}})}),1):_vm._e()],2)}
var DocPagevue_type_template_id_09837c02_scoped_true_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/doc-builder/dist/components/DocPage.vue?vue&type=template&id=09837c02&scoped=true&

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.array.flat-map.js
var es_array_flat_map = __webpack_require__("9057");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.array.unscopables.flat-map.js
var es_array_unscopables_flat_map = __webpack_require__("a9dd");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/doc-builder/dist/helpers/domHelpers.js
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = domHelpers_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function domHelpers_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return domHelpers_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return domHelpers_arrayLikeToArray(o, minLen); }

function domHelpers_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


/**
 * @param {RegExp} regex
 * @param {HTMLElement} targetEl
 * @returns {HTMLElement[]}
 */

function DOMRegex(regex, targetEl) {
  var output = [];

  var _iterator = _createForOfIteratorHelper(targetEl.querySelectorAll('*')),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var el = _step.value;
      var classSelector = (el.getAttribute('class') || '').split(' ').map(function (c) {
        return ".".concat(c);
      }).join('');
      var querySelector = el.tagName + classSelector;
      if (regex.test(querySelector)) output.push(el);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return output;
}
/**
 * Creates a TOC based on "chapter title" elements like H1, H2, H3, ...
 * @param {HTMLElement} targetEl the target element where it should go find all "chapter title" elements like H1, H2, H3, ...
 * @param {string[]} pathsToApiCardSourceFile
 * @returns {{ text: string, id: string, tag: string }[]} An array of objects with info on the H1, H2, H3 tags found on this DocPage after mounting. Emitted when all elements are mounted; it will await any dynamic imports.
 */

function parseTitleEls(targetEl, pathsToApiCardSourceFile) {
  var titleEls = DOMRegex(/H1|H2|H3/, targetEl);
  var payloadTOC = titleEls.map(function (el) {
    var text = el.textContent;

    if (!el.id) {
      el.id = Object(index_esm["a" /* kebabCase */])(text);
    }

    var id = el.id;
    var tag = el.tagName;
    return {
      text: text,
      id: id,
      tag: tag
    };
  });
  var apiCardCount = pathsToApiCardSourceFile.length;

  if (apiCardCount) {
    payloadTOC.push({
      text: apiCardCount === 1 ? 'API Card' : 'API Cards',
      id: 'api-card',
      tag: 'H1'
    });
  }

  return payloadTOC;
}
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/doc-builder/dist/components/DocPage.vue?vue&type=script&lang=js&



//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





/* harmony default export */ var DocPagevue_type_script_lang_js_ = ({
  name: 'DocPage',
  components: {
    ExampleSection: ExampleSection,
    MarkdownSection: MarkdownSection,
    ApiComponentExample: ApiComponentExample
  },
  props: {
    /**
     * A path to a folder that will hold the files for this DocPage. It must be relative to the "src" folder.
     * @example 'pages/landing-page'
     */
    pathToChapterFiles: {
      type: String,
      required: true
    },

    /**
     * The file names (with extension) inside the "pathToChapterFiles". These files will become your rendered doc page.
     *
     * The files array can be a combination of .vue and .md files. Whenever it's a .vue file, it's rendered with <ExampleSection />. Whenever it's an .md file, it's rendered with <MarkdownSection />.
     * @type {string[]}
     */
    chapterOrder: {
      type: Array,
      required: true
    },

    /**
     * (optional) An array of paths to the Vue files to generate API Cards for at the bottom of the doc page.
     * @type {string[]}
     * @example ['components/atoms/MyButton.vue']
     */
    pathsToApiCardSourceFile: {
      type: Array,
      default: function _default() {
        return [];
      }
    },

    /**
     * (optional) If you want to pass extra props to either the `ExampleSection` or `MarkdownSection` you can do so with the filename from `chapterOrder` as key and the props as value.
     * @type {Record<string, Record<string, any>>}
     */
    chapterOptions: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  data: function data() {
    return {
      mountCount: 0,
      mountCountApiCards: 0
    };
  },
  watch: {
    mountCount: function mountCount(count) {
      var filesList = this.filesList,
          pathsToApiCardSourceFile = this.pathsToApiCardSourceFile,
          mountCountApiCards = this.mountCountApiCards,
          scrollToHashInUrl = this.scrollToHashInUrl;
      var allChaptersMounted = count >= filesList.length;

      if (allChaptersMounted) {
        var payloadTOC = parseTitleEls(this.$el, pathsToApiCardSourceFile);
        this.$emit('TOC', payloadTOC);
      }

      var allApiCardsMounted = mountCountApiCards >= pathsToApiCardSourceFile.length;
      if (allChaptersMounted && allApiCardsMounted) scrollToHashInUrl();
    },
    mountCountApiCards: function mountCountApiCards(count) {
      var filesList = this.filesList,
          mountCount = this.mountCount,
          pathsToApiCardSourceFile = this.pathsToApiCardSourceFile,
          scrollToHashInUrl = this.scrollToHashInUrl;
      var allChaptersMounted = mountCount >= filesList.length;
      var allApiCardsMounted = count >= pathsToApiCardSourceFile.length;
      if (allChaptersMounted && allApiCardsMounted) scrollToHashInUrl();
    }
  },
  computed: {
    /**
     * A list that combines `pathToChapterFiles` with each file in the `chapterOrder`.
     */
    filesList: function filesList() {
      var pathToChapterFiles = this.pathToChapterFiles,
          chapterOrder = this.chapterOrder;
      var parentPath = pathToChapterFiles.endsWith('/') ? pathToChapterFiles : "".concat(pathToChapterFiles, "/");
      return chapterOrder.flatMap(function (chapter) {
        if (!chapter.endsWith('.md') && !chapter.endsWith('.vue')) return [];
        var filename = chapter[0] === '/' ? chapter.slice(1) : chapter;
        return parentPath + filename;
      });
    }
  },
  methods: {
    scrollToHashInUrl: function scrollToHashInUrl() {
      var _this = this;

      var hash = document.location.hash.replace('#', '');
      if (hash) this.$nextTick(function () {
        return Object(dist["b" /* scrollToElId */])(hash, _this.$router);
      }); // to make sure this is only called once, let's replace it with an empty function

      this.scrollToHashInUrl = function () {};
    }
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/doc-builder/dist/components/DocPage.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_DocPagevue_type_script_lang_js_ = (DocPagevue_type_script_lang_js_); 
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/doc-builder/dist/components/DocPage.vue





/* normalize component */

var DocPage_component = Object(componentNormalizer["a" /* default */])(
  components_DocPagevue_type_script_lang_js_,
  DocPagevue_type_template_id_09837c02_scoped_true_render,
  DocPagevue_type_template_id_09837c02_scoped_true_staticRenderFns,
  false,
  null,
  "09837c02",
  null
  
)

/* harmony default export */ var DocPage = (DocPage_component.exports);
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/doc-builder/dist/components/TableOfContents.vue?vue&type=template&id=315e9983&scoped=true&
var TableOfContentsvue_type_template_id_315e9983_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"table-of-contents"},[_c('scrollactive',{staticClass:"_toc-wrapper",attrs:{"offset":80,"duration":_vm.SCROLL_DURATION,"scrollOnStart":false,"modifyUrl":false},on:{"itemchanged":_vm.tocItemChanged}},_vm._l((_vm.computedTOC),function(tocItem,i){return _c('PlanetarAnchor',{key:i,class:[
        'scrollactive-item',
        '_toc-item',
        tocItem.tag,
        {
          '_has-active-child': _vm.tocIdHasActiveChildDic[tocItem.id],
          '_has-active-parent': _vm.tocIdHasActiveParentDic[tocItem.id],
          '_has-active-sibling': _vm.tocIdHasActiveSiblingDic[tocItem.id],
        } ],attrs:{"content":tocItem.text,"href":("#" + (tocItem.id))},on:{"click":_vm.setUrlHash}})}),1)],1)}
var TableOfContentsvue_type_template_id_315e9983_scoped_true_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/doc-builder/dist/components/TableOfContents.vue?vue&type=template&id=315e9983&scoped=true&

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.array.reduce.js
var es_array_reduce = __webpack_require__("28eb");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.array.reverse.js
var es_array_reverse = __webpack_require__("c053");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-scrollactive/dist/vue-scrollactive.min.js
var vue_scrollactive_min = __webpack_require__("56f4");
var vue_scrollactive_min_default = /*#__PURE__*/__webpack_require__.n(vue_scrollactive_min);

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue/dist/vue.runtime.esm.js
var vue_runtime_esm = __webpack_require__("9869");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/map-anything/dist/index.esm.js
var dist_index_esm = __webpack_require__("9ed5");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/doc-builder/dist/components/TableOfContents.vue?vue&type=script&lang=js&






//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || TableOfContentsvue_type_script_lang_js_unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function TableOfContentsvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return TableOfContentsvue_type_script_lang_js_arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TableOfContentsvue_type_script_lang_js_arrayLikeToArray(o, minLen);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return TableOfContentsvue_type_script_lang_js_arrayLikeToArray(arr);
}

function TableOfContentsvue_type_script_lang_js_arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}





vue_runtime_esm["default"].use(vue_scrollactive_min_default.a);
var SCROLL_DURATION = 600;
/**
 * @type {{ text: string, id: string, tag: string }}
 * @returns {number | null}
 */

function tocItemToHNumber(tocItem) {
  return tocItem.tag.includes('H') ? Number(tocItem.tag.replace('H', '')) : null;
}

/* harmony default export */ var TableOfContentsvue_type_script_lang_js_ = ({
  name: 'TableOfContents',
  components: {
    PlanetarAnchor: atoms_dist["a" /* PlanetarAnchor */]
  },
  props: {
    /**
     * @type {{ text: string, id: string, tag: string }[]}
     */
    TOC: {
      type: Array,
      default: function _default() {
        return [];
      }
    }
  },
  data: function data() {
    return {
      SCROLL_DURATION: SCROLL_DURATION,
      activeTocId: null,
      willBecomeActiveTocId: null
    };
  },
  computed: {
    computedTOC: function computedTOC() {
      // check if H1 is the "biggest title", if not, adjust every title
      var hNumbers = this.TOC.filter(function (t) {
        return t.tag.includes('H') && t.id !== 'api-card';
      }).map(tocItemToHNumber);
      var topLevelTag = Math.min.apply(Math, _toConsumableArray(hNumbers));
      var adjustBy = 1 - topLevelTag;
      return this.TOC.map(function (tocItem) {
        // set api-card tag to the topLevelTag
        var item = tocItem.id === 'api-card' ? Object.assign({}, tocItem, {
          tag: "H".concat(topLevelTag)
        }) : tocItem; // don't worry if it's not using an H title

        if (!item.tag.includes('H')) return item; // adjust all other tags

        var hNumber = tocItemToHNumber(item) + adjustBy;
        return Object.assign({}, item, {
          tag: "H".concat(hNumber)
        });
      });
    },

    /**
     * @type {{ [tocId in string]: string }}[]}
     */
    tocIdParentIdDic: function tocIdParentIdDic() {
      var TOC = this.computedTOC;
      return TOC.reduce(function (dic, tocItem, currentIndex) {
        var TOCHead = TOC.slice(0, currentIndex);
        TOCHead.reverse();
        var parentIndex = TOCHead.findIndex(function (possibleParent) {
          return tocItemToHNumber(possibleParent) < tocItemToHNumber(tocItem);
        });
        var parentId = parentIndex === -1 ? '' : TOCHead[parentIndex].id;
        dic[tocItem.id] = parentId;
        return dic;
      }, {});
    },

    /**
     * @type {{ [tocId in string]: string[] }}[]}
     */
    tocIdChildrenIdsDic: function tocIdChildrenIdsDic() {
      var TOC = this.computedTOC;
      return TOC.reduce(function (dic, tocItem, currentIndex) {
        var TOCtail = TOC.slice(currentIndex + 1);
        var nextSiblingIndex = TOCtail.findIndex(function (possibleSibling) {
          return tocItem.tag === possibleSibling.tag;
        });
        var children = nextSiblingIndex === -1 ? TOCtail : TOCtail.slice(0, nextSiblingIndex);
        dic[tocItem.id] = children.map(function (c) {
          return c.id;
        });
        return dic;
      }, {});
    },

    /**
     * @type {{ [tocId in string]: string[] }}[]}
     */
    tocIdSiblingIdsDic: function tocIdSiblingIdsDic() {
      var TOC = this.computedTOC,
          tocIdParentIdDic = this.tocIdParentIdDic;
      return TOC.reduce(function (dic, tocItem, currentIndex) {
        var parentId = tocIdParentIdDic[tocItem.id];
        var parentIndex = !parentId ? 0 : TOC.findIndex(function (possibleParent) {
          return possibleParent.id === parentId;
        });
        var nextParentIndex = TOC.findIndex(function (possibleNextParent, index) {
          if (index <= currentIndex) return false;
          return tocItemToHNumber(possibleNextParent) < tocItemToHNumber(tocItem);
        });
        var siblingsAndChildren = nextParentIndex === -1 ? TOC.slice(parentIndex) : TOC.slice(parentIndex, nextParentIndex);
        var siblings = siblingsAndChildren.filter(function (s) {
          return s.tag === tocItem.tag;
        });
        dic[tocItem.id] = siblings.map(function (s) {
          return s.id;
        });
        return dic;
      }, {});
    },

    /**
     * @type {{ [tocId in string]: boolean }}[]}
     */
    tocIdHasActiveChildDic: function tocIdHasActiveChildDic() {
      var tocIdChildrenIdsDic = this.tocIdChildrenIdsDic,
          activeTocId = this.activeTocId,
          willBecomeActiveTocId = this.willBecomeActiveTocId;
      return Object(dist_index_esm["a" /* mapObject */])(tocIdChildrenIdsDic, function (childrenIds) {
        return childrenIds.includes(activeTocId) || childrenIds.includes(willBecomeActiveTocId);
      });
    },

    /**
     * @type {{ [tocId in string]: boolean }}[]}
     */
    tocIdHasActiveParentDic: function tocIdHasActiveParentDic() {
      var tocIdParentIdDic = this.tocIdParentIdDic,
          activeTocId = this.activeTocId,
          willBecomeActiveTocId = this.willBecomeActiveTocId;
      return Object(dist_index_esm["a" /* mapObject */])(tocIdParentIdDic, function (parentId) {
        return parentId === activeTocId || parentId === willBecomeActiveTocId;
      });
    },

    /**
     * @type {{ [tocId in string]: boolean }}[]}
     */
    tocIdHasActiveSiblingDic: function tocIdHasActiveSiblingDic() {
      var tocIdSiblingIdsDic = this.tocIdSiblingIdsDic,
          activeTocId = this.activeTocId,
          willBecomeActiveTocId = this.willBecomeActiveTocId;
      return Object(dist_index_esm["a" /* mapObject */])(tocIdSiblingIdsDic, function (siblingIds) {
        return siblingIds.includes(activeTocId) || siblingIds.includes(willBecomeActiveTocId);
      });
    }
  },
  methods: {
    /**
     * @param {MouseEvent} event
     */
    setUrlHash: function setUrlHash(event) {
      var activeTocHash = event.srcElement.getAttribute('href');
      var activeTocId = activeTocHash.replace('#', '');
      this.willBecomeActiveTocId = activeTocId;
      this.activeTocId = '';
      var router = this.$router;
      setTimeout(function () {
        if (router) {
          router.push({
            hash: "#".concat(activeTocId)
          });
        } else {
          location.hash = activeTocId;
        }
      }, SCROLL_DURATION);
    },

    /**
     * @param {ScrollEvent} event
     * @param {newActiveEl | null | undefined} HTMLElement
     * @param {lastActiveEl | null | undefined} HTMLElement
     */
    tocItemChanged: function tocItemChanged(event, newActiveEl, lastActiveEl) {
      if (!newActiveEl) return;
      var activeTocId = (newActiveEl.getAttribute('href') || '').replace('#', '');
      this.activeTocId = activeTocId;
      this.willBecomeActiveTocId = '';
    }
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/doc-builder/dist/components/TableOfContents.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_TableOfContentsvue_type_script_lang_js_ = (TableOfContentsvue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/doc-builder/dist/components/TableOfContents.vue?vue&type=style&index=0&id=315e9983&scoped=true&lang=css&
var TableOfContentsvue_type_style_index_0_id_315e9983_scoped_true_lang_css_ = __webpack_require__("1f75");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/doc-builder/dist/components/TableOfContents.vue






/* normalize component */

var TableOfContents_component = Object(componentNormalizer["a" /* default */])(
  components_TableOfContentsvue_type_script_lang_js_,
  TableOfContentsvue_type_template_id_315e9983_scoped_true_render,
  TableOfContentsvue_type_template_id_315e9983_scoped_true_staticRenderFns,
  false,
  null,
  "315e9983",
  null
  
)

/* harmony default export */ var TableOfContents = (TableOfContents_component.exports);


runtime_auto_import_default()(TableOfContents_component, 'components', {QColor: QColor["a" /* default */]});

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/doc-builder/dist/index.js



/* harmony default export */ var doc_builder_dist = ({
  install: function install(Vue) {
    Vue.component(DocPage.name, DocPage);
    Vue.component(TableOfContents.name, TableOfContents);
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/planetar/index.js














/* harmony default export */ var planetar = ({
  install(Vue) {
    Vue.use(api_card_dist)
    Vue.use(atoms_dist["g" /* default */])
    Vue.use(component_gallery_dist)
    Vue.use(doc_builder_dist)
    Vue.use(example_card_dist)
    Vue.use(markdown_dist)
  },
});


/***/ }),

/***/ "3d3c":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("9869");
/* harmony import */ var _icon_QIcon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("34ff");
/* harmony import */ var _mixins_checkbox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("3abb");



/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
  name: 'QToggle',
  mixins: [_mixins_checkbox_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]],
  props: {
    icon: String,
    checkedIcon: String,
    uncheckedIcon: String,
    indeterminateIcon: String,
    iconColor: String
  },
  computed: {
    computedIcon() {
      return (this.isTrue === true ? this.checkedIcon : this.isIndeterminate === true ? this.indeterminateIcon : this.uncheckedIcon) || this.icon;
    },

    computedIconColor() {
      if (this.isTrue === true) {
        return this.iconColor;
      }
    }

  },
  methods: {
    __getInner(h) {
      return [h('div', {
        staticClass: 'q-toggle__track'
      }), h('div', {
        staticClass: 'q-toggle__thumb absolute flex flex-center no-wrap'
      }, this.computedIcon !== void 0 ? [h(_icon_QIcon_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"], {
        props: {
          name: this.computedIcon,
          color: this.computedIconColor
        }
      })] : void 0)];
    }

  },

  created() {
    this.type = 'toggle';
  }

}));

/***/ }),

/***/ "3e34":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("f498");
var createNonEnumerableProperty = __webpack_require__("5b12");

module.exports = function (key, value) {
  try {
    createNonEnumerableProperty(global, key, value);
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "3e36":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("f498");

module.exports = global;


/***/ }),

/***/ "4173":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ dynamicImport; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ scrollToElId; });

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/utils/dist/importHelpers.js
/**
 * Dynamically import files as component; raw code as string; or Vue Docgen JSON.
 * Supports `.vue`, `.jsx` & `.tsx` files.
 *
 * @param {string} filePath Relative from the project's 'src' folder.
 * @param {'vue' | 'jsx' | 'tsx'} extension The extension without `.`, eg. `'vue'`
 * @param {'component' | 'string' | 'vue-docgen'} importType
 * @example dynamicImport('examples/MyBtn/Example1.vue', 'vue', 'component')
 *   .then(componentExport => doSomething(componentExport))
 * @example <component :is="importedComponent" />
 * @returns {Promise<any>}
 */
function dynamicImport(filePath, extension, importType) {
  if (extension === 'vue') {
    if (importType === 'vue-docgen') {
      return __webpack_require__("e6f4")(`./${filePath.replace('.vue', '')}.vue`)
    }
    if (importType === 'string') {
      return new Promise((resolve, reject) => {
        return __webpack_require__("62d0")(`./${filePath.replace('.vue', '')}.vue`)
          .then((raw) => resolve(raw.default))
          .catch(reject)
      })
    }
    return __webpack_require__("0d54")(`./${filePath.replace('.vue', '')}.vue`)
  }
  if (extension === 'jsx') {
    if (importType === 'vue-docgen') {
      return __webpack_require__("ae6a")(`./${filePath.replace('.jsx', '')}.jsx`)
    }
    if (importType === 'string') {
      return new Promise((resolve, reject) => {
        return __webpack_require__("85c8")(`./${filePath.replace('.jsx', '')}.jsx`)
          .then((raw) => resolve(raw.default))
          .catch(reject)
      })
    }
    return __webpack_require__("fdcc")(`./${filePath.replace('.jsx', '')}.jsx`)
  }
  if (extension === 'tsx') {
    if (importType === 'vue-docgen') {
      return __webpack_require__("9890")(`./${filePath.replace('.tsx', '')}.tsx`)
    }
    if (importType === 'string') {
      return new Promise((resolve, reject) => {
        return __webpack_require__("69a8")(`./${filePath.replace('.tsx', '')}.tsx`)
          .then((raw) => resolve(raw.default))
          .catch(reject)
      })
    }
    return __webpack_require__("4911")(`./${filePath.replace('.tsx', '')}.tsx`)
  }
  if (extension === 'md') {
    if (importType === 'string') {
      return new Promise((resolve, reject) => {
        return __webpack_require__("0e5e")(`./${filePath.replace('.md', '')}.md`)
          .then((raw) => resolve(raw.default))
          .catch(reject)
      })
    }
  }
  if (extension === 'js') {
    if (importType === 'string') {
      return new Promise((resolve, reject) => {
        return __webpack_require__("09a7")(`./${filePath.replace('.js', '')}.js`)
          .then((raw) => resolve(raw.default))
          .catch(reject)
      })
    }
  }
  if (extension === 'html') {
    if (importType === 'string') {
      return new Promise((resolve, reject) => {
        return __webpack_require__("2fb7")(`./${filePath.replace('.html', '')}.html`)
          .then((raw) => resolve(raw.default))
          .catch(reject)
      })
    }
  }
  if (extension === 'css') {
    if (importType === 'string') {
      return new Promise((resolve, reject) => {
        return __webpack_require__("3f2c")(`./${filePath.replace('.css', '')}.css`)
          .then((raw) => resolve(raw.default))
          .catch(reject)
      })
    }
  }
  throw new Error('incorrect filePath. Your filepath must end in .vue, .jsx, .md, or .tsx')
}

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/scroll.js
var utils_scroll = __webpack_require__("8047");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/utils/dist/scrollHelpers.js

const { getScrollTarget, setScrollPosition } = utils_scroll["a" /* default */]

/**
 * Pushes the given hash to the URL using primarily pushState if available to prevent the
 * scroll from jumping to the hash element. Uses window.location.hash as a fallback.
 *
 * @param {String} hash The hash value to be pushed
 */
function pushHashToUrl(hash) {
  if (window.history.pushState) {
    const pathname = window.location.pathname
    window.history.pushState(null, null, `${pathname}#${hash}`)
    return
  }
  window.location.hash = hash
}

/**
 * Finds an element by ID and scrolls to it.
 * @param {string} id the id of an element without `#`
 * @param {any} vueRouter the vue router instance eg. `this.$router`
 * @param {MouseEvent} mouseEvent if it involved a click event, pass the mouse event to preventDefault and stopPropagation
 * @returns {void}
 * @example scrollToElId('api-card')
 */
function scrollToElId(id = '', vueRouter = undefined, mouseEvent = undefined) {
  if (!id) return
  if (mouseEvent) {
    mouseEvent.preventDefault()
    mouseEvent.stopPropagation()
  }
  const el = document.getElementById(id)
  if (!el) return
  // for Vue router, need to push hash before scrolling to prevent jumping after scroll
  if (vueRouter) {
    vueRouter.push({ hash: `#${id}` })
  }
  const target = getScrollTarget(el)
  const offset = el.offsetTop
  const duration = 400
  setScrollPosition(target, offset, duration)
  // that's all for vueRouter!
  if (vueRouter) return
  // otherwise, let's attach `#` to the browser's URL. Should be called AFTER scrolling (to not mess with the scroll behaviour)
  setTimeout(() => {
    pushHashToUrl(id)
  }, duration + 1)
}

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/utils/dist/index.js




/***/ }),

/***/ "422d":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("f498");

module.exports = function (a, b) {
  var console = global.console;
  if (console && console.error) {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  }
};


/***/ }),

/***/ "429f":
/***/ (function(module) {

module.exports = JSON.parse("{\"a\":\"1.15.10\"}");

/***/ }),

/***/ "42ba":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};


/***/ }),

/***/ "42c5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var regexpFlags = __webpack_require__("abfd");
var stickyHelpers = __webpack_require__("2f6a");
var shared = __webpack_require__("4cdd");

var nativeExec = RegExp.prototype.exec;
var nativeReplace = shared('native-string-replace', String.prototype.replace);

var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
// eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = regexpFlags.call(re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = flags.replace('y', '');
      if (flags.indexOf('g') === -1) {
        flags += 'g';
      }

      strCopy = String(str).slice(re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = nativeExec.call(sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = match.input.slice(charsAdded);
        match[0] = match[0].slice(charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "433a":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("157c");
var aFunction = __webpack_require__("8697");
var wellKnownSymbol = __webpack_require__("7d53");

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
};


/***/ }),

/***/ "4776":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ca22");
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_array_sort_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("b506");
/* harmony import */ var core_js_modules_es_array_sort_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_sort_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_array_reduce_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("28eb");
/* harmony import */ var core_js_modules_es_array_reduce_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_reduce_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("9869");
/* harmony import */ var _icon_QIcon_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("34ff");
/* harmony import */ var _resize_observer_QResizeObserver_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("df4a");
/* harmony import */ var _mixins_timeout_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("9d01");
/* harmony import */ var _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("0fb0");
/* harmony import */ var _utils_event_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("9ac9");
/* harmony import */ var _utils_slot_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("a4b3");
/* harmony import */ var _utils_cache_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("6459");












function getIndicatorClass(color, top, vertical) {
  const pos = vertical === true ? ['left', 'right'] : ['top', 'bottom'];
  return `absolute-${top === true ? pos[0] : pos[1]}${color ? ` text-${color}` : ''}`;
}

function bufferPrioritySort(t1, t2) {
  if (t1.priorityMatched === t2.priorityMatched) {
    return t2.priorityHref - t1.priorityHref;
  }

  return t2.priorityMatched - t1.priorityMatched;
}

function bufferCleanSelected(t) {
  t.selected = false;
  return t;
}

const bufferFilters = [t => t.selected === true && t.exact === true && t.redirected !== true, t => t.selected === true && t.exact === true, t => t.selected === true && t.redirected !== true, t => t.selected === true, t => t.exact === true && t.redirected !== true, t => t.redirected !== true, t => t.exact === true, t => true],
      bufferFiltersLen = bufferFilters.length;
/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_3__["default"].extend({
  name: 'QTabs',
  mixins: [_mixins_timeout_js__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"], _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"]],

  provide() {
    return {
      tabs: this.tabs,
      __recalculateScroll: this.__recalculateScroll,
      __activateTab: this.__activateTab,
      __activateRoute: this.__activateRoute
    };
  },

  props: {
    value: [Number, String],
    align: {
      type: String,
      default: 'center',
      validator: v => ['left', 'center', 'right', 'justify'].includes(v)
    },
    breakpoint: {
      type: [String, Number],
      default: 600
    },
    vertical: Boolean,
    shrink: Boolean,
    stretch: Boolean,
    activeColor: String,
    activeBgColor: String,
    indicatorColor: String,
    leftIcon: String,
    rightIcon: String,
    outsideArrows: Boolean,
    mobileArrows: Boolean,
    switchIndicator: Boolean,
    narrowIndicator: Boolean,
    inlineLabel: Boolean,
    noCaps: Boolean,
    dense: Boolean,
    contentClass: String
  },

  data() {
    return {
      tabs: {
        current: this.value,
        activeColor: this.activeColor,
        activeBgColor: this.activeBgColor,
        indicatorClass: getIndicatorClass(this.indicatorColor, this.switchIndicator, this.vertical),
        narrowIndicator: this.narrowIndicator,
        inlineLabel: this.inlineLabel,
        noCaps: this.noCaps
      },
      scrollable: false,
      leftArrow: true,
      rightArrow: false,
      justify: false
    };
  },

  watch: {
    value(name) {
      this.__activateTab(name, true, true);
    },

    activeColor(v) {
      this.tabs.activeColor = v;
    },

    activeBgColor(v) {
      this.tabs.activeBgColor = v;
    },

    vertical(v) {
      this.tabs.indicatorClass = getIndicatorClass(this.indicatorColor, this.switchIndicator, v);
    },

    indicatorColor(v) {
      this.tabs.indicatorClass = getIndicatorClass(v, this.switchIndicator, this.vertical);
    },

    switchIndicator(v) {
      this.tabs.indicatorClass = getIndicatorClass(this.indicatorColor, v, this.vertical);
    },

    narrowIndicator(v) {
      this.tabs.narrowIndicator = v;
    },

    inlineLabel(v) {
      this.tabs.inlineLabel = v;
    },

    noCaps(v) {
      this.tabs.noCaps = v;
    },

    outsideArrows() {
      this.$nextTick(this.__recalculateScroll());
    },

    arrowsEnabled(v) {
      this.__updateArrows = v === true ? this.__updateArrowsFn : _utils_event_js__WEBPACK_IMPORTED_MODULE_8__[/* noop */ "g"];
      this.$nextTick(this.__recalculateScroll());
    }

  },
  computed: {
    arrowsEnabled() {
      return this.$q.platform.is.desktop === true || this.mobileArrows === true;
    },

    alignClass() {
      const align = this.scrollable === true ? 'left' : this.justify === true ? 'justify' : this.align;
      return `q-tabs__content--align-${align}`;
    },

    classes() {
      return `q-tabs--${this.scrollable === true ? '' : 'not-'}scrollable` + ` q-tabs--${this.vertical === true ? 'vertical' : 'horizontal'}` + ` q-tabs__arrows--${this.arrowsEnabled === true && this.outsideArrows === true ? 'outside' : 'inside'}` + (this.dense === true ? ' q-tabs--dense' : '') + (this.shrink === true ? ' col-shrink' : '') + (this.stretch === true ? ' self-stretch' : '');
    },

    innerClass() {
      return this.alignClass + (this.contentClass !== void 0 ? ` ${this.contentClass}` : '') + (this.$q.platform.is.mobile === true ? ' scroll' : '');
    },

    domProps() {
      return this.vertical === true ? {
        container: 'height',
        content: 'offsetHeight',
        scroll: 'scrollHeight'
      } : {
        container: 'width',
        content: 'offsetWidth',
        scroll: 'scrollWidth'
      };
    },

    onEvents() {
      return _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({
        input: _utils_event_js__WEBPACK_IMPORTED_MODULE_8__[/* stop */ "k"]
      }, this.qListeners);
    }

  },
  methods: {
    __activateTab(name, setCurrent, skipEmit) {
      if (this.tabs.current !== name) {
        skipEmit !== true && this.$emit('input', name);

        if (setCurrent === true || this.qListeners.input === void 0) {
          this.__animate(this.tabs.current, name);

          this.tabs.current = name;
        }
      }
    },

    __activateRoute(params) {
      if (this.bufferRoute !== this.$route && this.buffer.length > 0) {
        clearTimeout(this.bufferTimer);
        this.bufferTimer = void 0;
        this.buffer.length = 0;
      }

      this.bufferRoute = this.$route;

      if (params !== void 0) {
        if (params.remove === true) {
          this.buffer = this.buffer.filter(t => t.name !== params.name);
        } else {
          this.buffer.push(params);
        }
      }

      if (this.bufferTimer === void 0) {
        this.bufferTimer = setTimeout(() => {
          let tabs = [];

          for (let i = 0; i < bufferFiltersLen && tabs.length === 0; i++) {
            tabs = this.buffer.filter(bufferFilters[i]);
          }

          tabs.sort(bufferPrioritySort);

          this.__activateTab(tabs.length === 0 ? null : tabs[0].name, true);

          this.buffer = this.buffer.map(bufferCleanSelected);
          this.bufferTimer = void 0;
        }, 1);
      }
    },

    __recalculateScroll() {
      this.__nextTick(() => {
        this._isDestroyed !== true && this.__updateContainer({
          width: this.$el.offsetWidth,
          height: this.$el.offsetHeight
        });
      });

      this.__prepareTick();
    },

    __updateContainer(domSize) {
      const size = domSize[this.domProps.container],
            scrollSize = Math.min(this.$refs.content[this.domProps.scroll], Array.prototype.reduce.call(this.$refs.content.children, (acc, el) => acc + el[this.domProps.content], 0)),
            scroll = size > 0 && scrollSize > size; // when there is no tab, in Chrome, size === 0 and scrollSize === 1

      if (this.scrollable !== scroll) {
        this.scrollable = scroll;
      } // Arrows need to be updated even if the scroll status was already true


      scroll === true && this.$nextTick(() => this.__updateArrows());
      const justify = size < parseInt(this.breakpoint, 10);

      if (this.justify !== justify) {
        this.justify = justify;
      }
    },

    __animate(oldName, newName) {
      const oldTab = oldName !== void 0 && oldName !== null && oldName !== '' ? this.$children.find(tab => tab.name === oldName) : null,
            newTab = newName !== void 0 && newName !== null && newName !== '' ? this.$children.find(tab => tab.name === newName) : null;

      if (oldTab && newTab) {
        const oldEl = oldTab.$el.getElementsByClassName('q-tab__indicator')[0],
              newEl = newTab.$el.getElementsByClassName('q-tab__indicator')[0];
        clearTimeout(this.animateTimer);
        oldEl.style.transition = 'none';
        oldEl.style.transform = 'none';
        newEl.style.transition = 'none';
        newEl.style.transform = 'none';
        const oldPos = oldEl.getBoundingClientRect(),
              newPos = newEl.getBoundingClientRect();
        newEl.style.transform = this.vertical === true ? `translate3d(0,${oldPos.top - newPos.top}px,0) scale3d(1,${newPos.height ? oldPos.height / newPos.height : 1},1)` : `translate3d(${oldPos.left - newPos.left}px,0,0) scale3d(${newPos.width ? oldPos.width / newPos.width : 1},1,1)`; // allow scope updates to kick in (QRouteTab needs more time)

        this.$nextTick(() => {
          this.animateTimer = setTimeout(() => {
            newEl.style.transition = 'transform .25s cubic-bezier(.4, 0, .2, 1)';
            newEl.style.transform = 'none';
          }, 70);
        });
      }

      if (newTab && this.scrollable === true) {
        const {
          left,
          width,
          top,
          height
        } = this.$refs.content.getBoundingClientRect(),
              newPos = newTab.$el.getBoundingClientRect();
        let offset = this.vertical === true ? newPos.top - top : newPos.left - left;

        if (offset < 0) {
          this.$refs.content[this.vertical === true ? 'scrollTop' : 'scrollLeft'] += Math.floor(offset);

          this.__updateArrows();

          return;
        }

        offset += this.vertical === true ? newPos.height - height : newPos.width - width;

        if (offset > 0) {
          this.$refs.content[this.vertical === true ? 'scrollTop' : 'scrollLeft'] += Math.ceil(offset);

          this.__updateArrows();
        }
      }
    },

    __updateArrowsFn() {
      const content = this.$refs.content,
            rect = content.getBoundingClientRect(),
            pos = this.vertical === true ? content.scrollTop : content.scrollLeft;
      this.leftArrow = pos > 0;
      this.rightArrow = this.vertical === true ? Math.ceil(pos + rect.height) < content.scrollHeight : Math.ceil(pos + rect.width) < content.scrollWidth;
    },

    __animScrollTo(value) {
      this.__stopAnimScroll();

      this.__scrollTowards(value);

      this.scrollTimer = setInterval(() => {
        if (this.__scrollTowards(value)) {
          this.__stopAnimScroll();
        }
      }, 5);
    },

    __scrollToStart() {
      this.__animScrollTo(0);
    },

    __scrollToEnd() {
      this.__animScrollTo(9999);
    },

    __stopAnimScroll() {
      clearInterval(this.scrollTimer);
    },

    __scrollTowards(value) {
      const content = this.$refs.content;
      let pos = this.vertical === true ? content.scrollTop : content.scrollLeft,
          done = false;
      const direction = value < pos ? -1 : 1;
      pos += direction * 5;

      if (pos < 0) {
        done = true;
        pos = 0;
      } else if (direction === -1 && pos <= value || direction === 1 && pos >= value) {
        done = true;
        pos = value;
      }

      content[this.vertical === true ? 'scrollTop' : 'scrollLeft'] = pos;

      this.__updateArrows();

      return done;
    }

  },

  activated() {
    this.__recalculateScroll();
  },

  created() {
    this.buffer = [];
    this.__updateArrows = this.arrowsEnabled === true ? this.__updateArrowsFn : _utils_event_js__WEBPACK_IMPORTED_MODULE_8__[/* noop */ "g"];
  },

  beforeDestroy() {
    clearTimeout(this.bufferTimer);
    clearTimeout(this.animateTimer);
  },

  render(h) {
    const child = [h(_resize_observer_QResizeObserver_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"], {
      on: Object(_utils_cache_js__WEBPACK_IMPORTED_MODULE_10__[/* default */ "b"])(this, 'resize', {
        resize: this.__updateContainer
      })
    }), h('div', {
      ref: 'content',
      staticClass: 'q-tabs__content row no-wrap items-center self-stretch hide-scrollbar',
      class: this.innerClass,
      on: this.arrowsEnabled === true ? Object(_utils_cache_js__WEBPACK_IMPORTED_MODULE_10__[/* default */ "b"])(this, 'scroll', {
        scroll: this.__updateArrowsFn
      }) : void 0
    }, Object(_utils_slot_js__WEBPACK_IMPORTED_MODULE_9__[/* slot */ "c"])(this, 'default'))];
    this.arrowsEnabled === true && child.push(h(_icon_QIcon_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"], {
      staticClass: 'q-tabs__arrow q-tabs__arrow--left absolute q-tab__icon',
      class: this.leftArrow === true ? '' : 'q-tabs__arrow--faded',
      props: {
        name: this.leftIcon || (this.vertical === true ? this.$q.iconSet.tabs.up : this.$q.iconSet.tabs.left)
      },
      on: Object(_utils_cache_js__WEBPACK_IMPORTED_MODULE_10__[/* default */ "b"])(this, 'onL', {
        mousedown: this.__scrollToStart,
        touchstart: this.__scrollToStart,
        mouseup: this.__stopAnimScroll,
        mouseleave: this.__stopAnimScroll,
        touchend: this.__stopAnimScroll
      })
    }), h(_icon_QIcon_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"], {
      staticClass: 'q-tabs__arrow q-tabs__arrow--right absolute q-tab__icon',
      class: this.rightArrow === true ? '' : 'q-tabs__arrow--faded',
      props: {
        name: this.rightIcon || (this.vertical === true ? this.$q.iconSet.tabs.down : this.$q.iconSet.tabs.right)
      },
      on: Object(_utils_cache_js__WEBPACK_IMPORTED_MODULE_10__[/* default */ "b"])(this, 'onR', {
        mousedown: this.__scrollToEnd,
        touchstart: this.__scrollToEnd,
        mouseup: this.__stopAnimScroll,
        mouseleave: this.__stopAnimScroll,
        touchend: this.__stopAnimScroll
      })
    }));
    return h('div', {
      staticClass: 'q-tabs row no-wrap items-center',
      class: this.classes,
      on: this.onEvents,
      attrs: {
        role: 'tablist'
      }
    }, child);
  }

}));

/***/ }),

/***/ "48c4":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarSelect_vue_vue_type_style_index_1_id_422ead2a_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("db2e");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarSelect_vue_vue_type_style_index_1_id_422ead2a_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarSelect_vue_vue_type_style_index_1_id_422ead2a_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "4919":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarTabs_vue_vue_type_style_index_1_id_49ae7236_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("d197");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarTabs_vue_vue_type_style_index_1_id_49ae7236_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarTabs_vue_vue_type_style_index_1_id_49ae7236_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "4be2":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ComponentPickerCard_vue_vue_type_style_index_0_id_6818b8ed_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("9fad");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ComponentPickerCard_vue_vue_type_style_index_0_id_6818b8ed_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ComponentPickerCard_vue_vue_type_style_index_0_id_6818b8ed_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "4c21":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarList_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("8c0b");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarList_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarList_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "4cce":
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  } return it;
};


/***/ }),

/***/ "4cdd":
/***/ (function(module, exports, __webpack_require__) {

var IS_PURE = __webpack_require__("0e93");
var store = __webpack_require__("c607");

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.10.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: ' 2021 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "4db4":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__("e7a0");

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ "4fed":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("f498");
var userAgent = __webpack_require__("64e4");

var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;


/***/ }),

/***/ "5027":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "502a":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ merge; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ mergeAndConcat; });

// UNUSED EXPORTS: concatArrays, mergeAndCompare

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/merge-anything/node_modules/is-what/dist/index.esm.js
/**
 * Returns the object type of the given payload
 *
 * @param {*} payload
 * @returns {string}
 */
function getType(payload) {
    return Object.prototype.toString.call(payload).slice(8, -1);
}
/**
 * Returns whether the payload is undefined
 *
 * @param {*} payload
 * @returns {payload is undefined}
 */
function isUndefined(payload) {
    return getType(payload) === 'Undefined';
}
/**
 * Returns whether the payload is null
 *
 * @param {*} payload
 * @returns {payload is null}
 */
function isNull(payload) {
    return getType(payload) === 'Null';
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isPlainObject(payload) {
    if (getType(payload) !== 'Object')
        return false;
    return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isObject(payload) {
    return isPlainObject(payload);
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is { [K in any]: never }}
 */
function isEmptyObject(payload) {
    return isPlainObject(payload) && Object.keys(payload).length === 0;
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isFullObject(payload) {
    return isPlainObject(payload) && Object.keys(payload).length > 0;
}
/**
 * Returns whether the payload is an any kind of object (including special classes or objects with different prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isAnyObject(payload) {
    return getType(payload) === 'Object';
}
/**
 * Returns whether the payload is an object like a type passed in < >
 *
 * Usage: isObjectLike<{id: any}>(payload) // will make sure it's an object and has an `id` prop.
 *
 * @template T this must be passed in < >
 * @param {*} payload
 * @returns {payload is T}
 */
function isObjectLike(payload) {
    return isAnyObject(payload);
}
/**
 * Returns whether the payload is a function (regular or async)
 *
 * @param {*} payload
 * @returns {payload is AnyFunction}
 */
function isFunction(payload) {
    return typeof payload === 'function';
}
/**
 * Returns whether the payload is an array
 *
 * @param {any} payload
 * @returns {payload is any[]}
 */
function isArray(payload) {
    return getType(payload) === 'Array';
}
/**
 * Returns whether the payload is a an array with at least 1 item
 *
 * @param {*} payload
 * @returns {payload is any[]}
 */
function isFullArray(payload) {
    return isArray(payload) && payload.length > 0;
}
/**
 * Returns whether the payload is a an empty array
 *
 * @param {*} payload
 * @returns {payload is []}
 */
function isEmptyArray(payload) {
    return isArray(payload) && payload.length === 0;
}
/**
 * Returns whether the payload is a string
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isString(payload) {
    return getType(payload) === 'String';
}
/**
 * Returns whether the payload is a string, BUT returns false for ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isFullString(payload) {
    return isString(payload) && payload !== '';
}
/**
 * Returns whether the payload is ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isEmptyString(payload) {
    return payload === '';
}
/**
 * Returns whether the payload is a number (but not NaN)
 *
 * This will return `false` for `NaN`!!
 *
 * @param {*} payload
 * @returns {payload is number}
 */
function isNumber(payload) {
    return getType(payload) === 'Number' && !isNaN(payload);
}
/**
 * Returns whether the payload is a boolean
 *
 * @param {*} payload
 * @returns {payload is boolean}
 */
function isBoolean(payload) {
    return getType(payload) === 'Boolean';
}
/**
 * Returns whether the payload is a regular expression (RegExp)
 *
 * @param {*} payload
 * @returns {payload is RegExp}
 */
function isRegExp(payload) {
    return getType(payload) === 'RegExp';
}
/**
 * Returns whether the payload is a Map
 *
 * @param {*} payload
 * @returns {payload is Map<any, any>}
 */
function isMap(payload) {
    return getType(payload) === 'Map';
}
/**
 * Returns whether the payload is a WeakMap
 *
 * @param {*} payload
 * @returns {payload is WeakMap<any, any>}
 */
function isWeakMap(payload) {
    return getType(payload) === 'WeakMap';
}
/**
 * Returns whether the payload is a Set
 *
 * @param {*} payload
 * @returns {payload is Set<any>}
 */
function isSet(payload) {
    return getType(payload) === 'Set';
}
/**
 * Returns whether the payload is a WeakSet
 *
 * @param {*} payload
 * @returns {payload is WeakSet<any>}
 */
function isWeakSet(payload) {
    return getType(payload) === 'WeakSet';
}
/**
 * Returns whether the payload is a Symbol
 *
 * @param {*} payload
 * @returns {payload is symbol}
 */
function isSymbol(payload) {
    return getType(payload) === 'Symbol';
}
/**
 * Returns whether the payload is a Date, and that the date is valid
 *
 * @param {*} payload
 * @returns {payload is Date}
 */
function isDate(payload) {
    return getType(payload) === 'Date' && !isNaN(payload);
}
/**
 * Returns whether the payload is a Blob
 *
 * @param {*} payload
 * @returns {payload is Blob}
 */
function isBlob(payload) {
    return getType(payload) === 'Blob';
}
/**
 * Returns whether the payload is a File
 *
 * @param {*} payload
 * @returns {payload is File}
 */
function isFile(payload) {
    return getType(payload) === 'File';
}
/**
 * Returns whether the payload is a Promise
 *
 * @param {*} payload
 * @returns {payload is Promise<any>}
 */
function isPromise(payload) {
    return getType(payload) === 'Promise';
}
/**
 * Returns whether the payload is an Error
 *
 * @param {*} payload
 * @returns {payload is Error}
 */
function isError(payload) {
    return getType(payload) === 'Error';
}
/**
 * Returns whether the payload is literally the value `NaN` (it's `NaN` and also a `number`)
 *
 * @param {*} payload
 * @returns {payload is typeof NaN}
 */
function isNaNValue(payload) {
    return getType(payload) === 'Number' && isNaN(payload);
}
/**
 * Returns whether the payload is a primitive type (eg. Boolean | Null | Undefined | Number | String | Symbol)
 *
 * @param {*} payload
 * @returns {(payload is boolean | null | undefined | number | string | symbol)}
 */
function isPrimitive(payload) {
    return (isBoolean(payload) ||
        isNull(payload) ||
        isUndefined(payload) ||
        isNumber(payload) ||
        isString(payload) ||
        isSymbol(payload));
}
/**
 * Returns true whether the payload is null or undefined
 *
 * @param {*} payload
 * @returns {(payload is null | undefined)}
 */
var isNullOrUndefined = isOneOf(isNull, isUndefined);
function isOneOf(a, b, c, d, e) {
    return function (value) {
        return a(value) || b(value) || (!!c && c(value)) || (!!d && d(value)) || (!!e && e(value));
    };
}
/**
 * Does a generic check to check that the given payload is of a given type.
 * In cases like Number, it will return true for NaN as NaN is a Number (thanks javascript!);
 * It will, however, differentiate between object and null
 *
 * @template T
 * @param {*} payload
 * @param {T} type
 * @throws {TypeError} Will throw type error if type is an invalid type
 * @returns {payload is T}
 */
function isType(payload, type) {
    if (!(type instanceof Function)) {
        throw new TypeError('Type must be a function');
    }
    if (!Object.prototype.hasOwnProperty.call(type, 'prototype')) {
        throw new TypeError('Type is not a class');
    }
    // Classes usually have names (as functions usually have names)
    var name = type.name;
    return getType(payload) === name || Boolean(payload && payload.constructor === type);
}



// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/merge-anything/dist/index.esm.js


/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __spreadArray(to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
}

/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
function concatArrays(originVal, newVal) {
    if (isArray(originVal) && isArray(newVal)) {
        // concat logic
        return originVal.concat(newVal);
    }
    return newVal; // always return newVal as fallback!!
}

function assignProp(carry, key, newVal, originalObject) {
    var propType = {}.propertyIsEnumerable.call(originalObject, key)
        ? 'enumerable'
        : 'nonenumerable';
    if (propType === 'enumerable')
        carry[key] = newVal;
    if (propType === 'nonenumerable') {
        Object.defineProperty(carry, key, {
            value: newVal,
            enumerable: false,
            writable: true,
            configurable: true,
        });
    }
}
function mergeRecursively(origin, newComer, compareFn) {
    // always return newComer if its not an object
    if (!isPlainObject(newComer))
        return newComer;
    // define newObject to merge all values upon
    var newObject = {};
    if (isPlainObject(origin)) {
        var props_1 = Object.getOwnPropertyNames(origin);
        var symbols_1 = Object.getOwnPropertySymbols(origin);
        newObject = __spreadArray(__spreadArray([], props_1), symbols_1).reduce(function (carry, key) {
            var targetVal = origin[key];
            if ((!isSymbol(key) && !Object.getOwnPropertyNames(newComer).includes(key)) ||
                (isSymbol(key) && !Object.getOwnPropertySymbols(newComer).includes(key))) {
                assignProp(carry, key, targetVal, origin);
            }
            return carry;
        }, {});
    }
    // newObject has all properties that newComer hasn't
    var props = Object.getOwnPropertyNames(newComer);
    var symbols = Object.getOwnPropertySymbols(newComer);
    var result = __spreadArray(__spreadArray([], props), symbols).reduce(function (carry, key) {
        // re-define the origin and newComer as targetVal and newVal
        var newVal = newComer[key];
        var targetVal = isPlainObject(origin) ? origin[key] : undefined;
        // When newVal is an object do the merge recursively
        if (targetVal !== undefined && isPlainObject(newVal)) {
            newVal = mergeRecursively(targetVal, newVal, compareFn);
        }
        var propToAssign = compareFn ? compareFn(targetVal, newVal, key) : newVal;
        assignProp(carry, key, propToAssign, newComer);
        return carry;
    }, newObject);
    return result;
}
/**
 * Merge anything recursively.
 * Objects get merged, special objects (classes etc.) are re-assigned "as is".
 * Basic types overwrite objects or other basic types.
 * @param object
 * @param otherObjects
 */
function merge(object) {
    var otherObjects = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        otherObjects[_i - 1] = arguments[_i];
    }
    return otherObjects.reduce(function (result, newComer) {
        return mergeRecursively(result, newComer);
    }, object);
}
function mergeAndCompare(compareFn, object) {
    var otherObjects = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        otherObjects[_i - 2] = arguments[_i];
    }
    return otherObjects.reduce(function (result, newComer) {
        return mergeRecursively(result, newComer, compareFn);
    }, object);
}
function mergeAndConcat(object) {
    var otherObjects = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        otherObjects[_i - 1] = arguments[_i];
    }
    return otherObjects.reduce(function (result, newComer) {
        return mergeRecursively(result, newComer, concatArrays);
    }, object);
}




/***/ }),

/***/ "5070":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "5094":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return isSSR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return fromSSR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return onSSR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return iosEmulated; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return iosCorrection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return client; });
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ca22");
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("9869");


/* eslint-disable no-useless-escape */

/* eslint-disable no-unused-expressions */

/* eslint-disable no-mixed-operators */

const isSSR = typeof window === 'undefined';
let fromSSR = false;
let onSSR = isSSR;
let iosEmulated = false;
let iosCorrection;

function getMatch(userAgent, platformMatch) {
  const match = /(edge|edga|edgios)\/([\w.]+)/.exec(userAgent) || /(opr)[\/]([\w.]+)/.exec(userAgent) || /(vivaldi)[\/]([\w.]+)/.exec(userAgent) || /(chrome|crios)[\/]([\w.]+)/.exec(userAgent) || /(iemobile)[\/]([\w.]+)/.exec(userAgent) || /(version)(applewebkit)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent) || /(webkit)[\/]([\w.]+).*(version)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent) || /(firefox|fxios)[\/]([\w.]+)/.exec(userAgent) || /(webkit)[\/]([\w.]+)/.exec(userAgent) || /(opera)(?:.*version|)[\/]([\w.]+)/.exec(userAgent) || /(msie) ([\w.]+)/.exec(userAgent) || userAgent.indexOf('trident') >= 0 && /(rv)(?::| )([\w.]+)/.exec(userAgent) || userAgent.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(userAgent) || [];
  return {
    browser: match[5] || match[3] || match[1] || '',
    version: match[2] || match[4] || '0',
    versionNumber: match[4] || match[2] || '0',
    platform: platformMatch[0] || ''
  };
}

function getPlatformMatch(userAgent) {
  return /(ipad)/.exec(userAgent) || /(ipod)/.exec(userAgent) || /(windows phone)/.exec(userAgent) || /(iphone)/.exec(userAgent) || /(kindle)/.exec(userAgent) || /(silk)/.exec(userAgent) || /(android)/.exec(userAgent) || /(win)/.exec(userAgent) || /(mac)/.exec(userAgent) || /(linux)/.exec(userAgent) || /(cros)/.exec(userAgent) || /(playbook)/.exec(userAgent) || /(bb)/.exec(userAgent) || /(blackberry)/.exec(userAgent) || [];
}

const hasTouch = isSSR === false ? 'ontouchstart' in window || window.navigator.maxTouchPoints > 0 : false;

function applyIosCorrection(is) {
  iosCorrection = {
    is: _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, is)
  };
  delete is.mac;
  delete is.desktop;
  const platform = Math.min(window.innerHeight, window.innerWidth) > 414 ? 'ipad' : 'iphone';
  Object.assign(is, {
    mobile: true,
    ios: true,
    platform,
    [platform]: true
  });
}

function getPlatform(UA) {
  const userAgent = UA.toLowerCase(),
        platformMatch = getPlatformMatch(userAgent),
        matched = getMatch(userAgent, platformMatch),
        browser = {};

  if (matched.browser) {
    browser[matched.browser] = true;
    browser.version = matched.version;
    browser.versionNumber = parseInt(matched.versionNumber, 10);
  }

  if (matched.platform) {
    browser[matched.platform] = true;
  }

  const knownMobiles = browser.android || browser.ios || browser.bb || browser.blackberry || browser.ipad || browser.iphone || browser.ipod || browser.kindle || browser.playbook || browser.silk || browser['windows phone']; // These are all considered mobile platforms, meaning they run a mobile browser

  if (knownMobiles === true || userAgent.indexOf('mobile') > -1) {
    browser.mobile = true;

    if (browser.edga || browser.edgios) {
      browser.edge = true;
      matched.browser = 'edge';
    } else if (browser.crios) {
      browser.chrome = true;
      matched.browser = 'chrome';
    } else if (browser.fxios) {
      browser.firefox = true;
      matched.browser = 'firefox';
    }
  } // If it's not mobile we should consider it's desktop platform, meaning it runs a desktop browser
  // It's a workaround for anonymized user agents
  // (browser.cros || browser.mac || browser.linux || browser.win)
  else {
      browser.desktop = true;
    } // Set iOS if on iPod, iPad or iPhone


  if (browser.ipod || browser.ipad || browser.iphone) {
    browser.ios = true;
  }

  if (browser['windows phone']) {
    browser.winphone = true;
    delete browser['windows phone'];
  } // Chrome, Opera 15+, Vivaldi and Safari are webkit based browsers


  if (browser.chrome || browser.opr || browser.safari || browser.vivaldi || // we expect unknown, non iOS mobile browsers to be webkit based
  browser.mobile === true && browser.ios !== true && knownMobiles !== true) {
    browser.webkit = true;
  } // IE11 has a new token so we will assign it msie to avoid breaking changes


  if (browser.rv || browser.iemobile) {
    matched.browser = 'ie';
    browser.ie = true;
  } // Blackberry browsers are marked as Safari on BlackBerry


  if (browser.safari && browser.blackberry || browser.bb) {
    matched.browser = 'blackberry';
    browser.blackberry = true;
  } // Playbook browsers are marked as Safari on Playbook


  if (browser.safari && browser.playbook) {
    matched.browser = 'playbook';
    browser.playbook = true;
  } // Opera 15+ are identified as opr


  if (browser.opr) {
    matched.browser = 'opera';
    browser.opera = true;
  } // Stock Android browsers are marked as Safari on Android.


  if (browser.safari && browser.android) {
    matched.browser = 'android';
    browser.android = true;
  } // Kindle browsers are marked as Safari on Kindle


  if (browser.safari && browser.kindle) {
    matched.browser = 'kindle';
    browser.kindle = true;
  } // Kindle Silk browsers are marked as Safari on Kindle


  if (browser.safari && browser.silk) {
    matched.browser = 'silk';
    browser.silk = true;
  }

  if (browser.vivaldi) {
    matched.browser = 'vivaldi';
    browser.vivaldi = true;
  } // Assign the name and platform variable


  browser.name = matched.browser;
  browser.platform = matched.platform;

  if (isSSR === false) {
    if (userAgent.indexOf('electron') > -1) {
      browser.electron = true;
    } else if (document.location.href.indexOf('-extension://') > -1) {
      browser.bex = true;
    } else {
      if (window.Capacitor !== void 0) {
        browser.capacitor = true;
        browser.nativeMobile = true;
        browser.nativeMobileWrapper = 'capacitor';
      } else if (window._cordovaNative !== void 0 || window.cordova !== void 0) {
        browser.cordova = true;
        browser.nativeMobile = true;
        browser.nativeMobileWrapper = 'cordova';
      }

      if (hasTouch === true && browser.mac === true && (browser.desktop === true && browser.safari === true || browser.nativeMobile === true && browser.android !== true && browser.ios !== true && browser.ipad !== true)) {
        /*
        * Correction needed for iOS since the default
        * setting on iPad is to request desktop view; if we have
        * touch support and the user agent says it's a
        * desktop, we infer that it's an iPhone/iPad with desktop view
        * so we must fix the false positives
        */
        applyIosCorrection(browser);
      }
    }

    fromSSR = browser.nativeMobile === void 0 && browser.electron === void 0 && document.querySelector('[data-server-rendered]') !== null;

    if (fromSSR === true) {
      onSSR = true;
    }
  }

  return browser;
}

const userAgent = isSSR !== true ? navigator.userAgent || navigator.vendor || window.opera : '';
const ssrClient = {
  has: {
    touch: false,
    webStorage: false
  },
  within: {
    iframe: false
  }
}; // We export "client" for hydration error-free parts,
// like touch directives who do not (and must NOT) wait
// for the client takeover;
// Do NOT import this directly in your app, unless you really know
// what you are doing.

const client = isSSR === false ? {
  userAgent,
  is: getPlatform(userAgent),
  has: {
    touch: hasTouch,
    webStorage: (() => {
      try {
        if (window.localStorage) {
          return true;
        }
      } catch (e) {}

      return false;
    })()
  },
  within: {
    iframe: window.self !== window.top
  }
} : ssrClient;
const Platform = {
  install($q, queues) {
    if (isSSR === true) {
      // we're on server-side, so we push
      // to the server queue instead of
      // applying directly
      queues.server.push((q, ctx) => {
        q.platform = this.parseSSR(ctx.ssr);
      });
    } else if (fromSSR === true) {
      // must match with server-side before
      // client taking over in order to prevent
      // hydration errors
      Object.assign(this, client, iosCorrection, ssrClient); // takeover should increase accuracy for
      // the rest of the props; we also avoid
      // hydration errors

      queues.takeover.push(q => {
        onSSR = fromSSR = false;
        Object.assign(q.platform, client);
        iosCorrection = void 0;
      }); // we need to make platform reactive
      // for the takeover phase

      vue__WEBPACK_IMPORTED_MODULE_1__["default"].util.defineReactive($q, 'platform', this);
    } else {
      // we don't have any business with SSR, so
      // directly applying...
      Object.assign(this, client);
      $q.platform = this;
    }
  }

};

if (isSSR === true) {
  Platform.parseSSR =
  /* ssrContext */
  ssr => {
    const userAgent = ssr.req.headers['user-agent'] || ssr.req.headers['User-Agent'] || '';
    return _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, client), {}, {
      userAgent,
      is: getPlatform(userAgent)
    });
  };
} else {
  iosEmulated = client.is.ios === true && window.navigator.vendor.toLowerCase().indexOf('apple') === -1;
}

/* harmony default export */ __webpack_exports__["b"] = (Platform);

/***/ }),

/***/ "5428":
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__("3e36");
var global = __webpack_require__("f498");

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "56b5":
/***/ (function(module, exports) {

// Functions in this file are no-op,
//  they just take a callback function and return it
// They're used to apply typings to the callback
//  parameters and return value when using Quasar with TypeScript
// We need these in `ui` folder to make `quasar/wrapper` import work,
//  but they are useful only for Quasar CLI projects
// They are typed via module augmentation by `@quasar/app`
module.exports.boot = function (callback) {
  return callback;
};

module.exports.configure = function (callback) {
  return callback;
};

module.exports.preFetch = function (callback) {
  return callback;
};

module.exports.route = function (callback) {
  return callback;
};

module.exports.store = function (callback) {
  return callback;
};

/***/ }),

/***/ "56c6":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5094");
/* harmony import */ var _timeout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("9d01");
/* harmony import */ var _listeners_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("0fb0");



/* harmony default export */ __webpack_exports__["a"] = ({
  mixins: [_timeout_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"], _listeners_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]],
  props: {
    value: {
      type: Boolean,
      default: void 0
    }
  },

  data() {
    return {
      showing: false
    };
  },

  watch: {
    value(val) {
      this.__processModelChange(val);
    },

    $route() {
      this.hideOnRouteChange === true && this.showing === true && this.hide();
    }

  },
  methods: {
    toggle(evt) {
      this[this.showing === true ? 'hide' : 'show'](evt);
    },

    show(evt) {
      if (this.disable === true || this.__showCondition !== void 0 && this.__showCondition(evt) !== true) {
        return;
      }

      if (this.qListeners.input !== void 0 && _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__[/* isSSR */ "f"] === false) {
        this.$emit('input', true);
        this.payload = evt;
        this.$nextTick(() => {
          if (this.payload === evt) {
            this.payload = void 0;
          }
        });
      }

      if (this.value === void 0 || this.qListeners.input === void 0 || _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__[/* isSSR */ "f"] === true) {
        this.__processShow(evt);
      }
    },

    __processShow(evt) {
      if (this.showing === true) {
        return;
      } // need to call it before setting showing to true
      // in order to not ruin the animation


      this.__preparePortal !== void 0 && this.__preparePortal();
      this.showing = true;
      this.$emit('before-show', evt);

      if (this.__show !== void 0) {
        this.__clearTick();

        this.__show(evt);

        this.__prepareTick();
      } else {
        this.$emit('show', evt);
      }
    },

    hide(evt) {
      if (this.disable === true) {
        return;
      }

      if (this.qListeners.input !== void 0 && _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__[/* isSSR */ "f"] === false) {
        this.$emit('input', false);
        this.payload = evt;
        this.$nextTick(() => {
          if (this.payload === evt) {
            this.payload = void 0;
          }
        });
      }

      if (this.value === void 0 || this.qListeners.input === void 0 || _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__[/* isSSR */ "f"] === true) {
        this.__processHide(evt);
      }
    },

    __processHide(evt) {
      if (this.showing === false) {
        return;
      }

      this.showing = false;
      this.$emit('before-hide', evt);

      if (this.__hide !== void 0) {
        this.__clearTick();

        this.__hide(evt);

        this.__prepareTick();
      } else {
        this.$emit('hide', evt);
      }
    },

    __processModelChange(val) {
      if (this.disable === true && val === true) {
        this.qListeners.input !== void 0 && this.$emit('input', false);
      } else if (val === true !== this.showing) {
        this[`__process${val === true ? 'Show' : 'Hide'}`](this.payload);
      }
    }

  }
});

/***/ }),

/***/ "56f4":
/***/ (function(module, exports, __webpack_require__) {

!(function (t, e) {
   true
    ? (module.exports = e())
    : undefined;
})('undefined' != typeof self ? self : this, function () {
  return (function (t) {
    var e = {};
    function r(n) {
      if (e[n]) return e[n].exports;
      var o = (e[n] = { i: n, l: !1, exports: {} });
      return t[n].call(o.exports, o, o.exports, r), (o.l = !0), o.exports;
    }
    return (
      (r.m = t),
      (r.c = e),
      (r.d = function (t, e, n) {
        r.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n });
      }),
      (r.r = function (t) {
        'undefined' != typeof Symbol &&
          Symbol.toStringTag &&
          Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }),
          Object.defineProperty(t, '__esModule', { value: !0 });
      }),
      (r.t = function (t, e) {
        if ((1 & e && (t = r(t)), 8 & e)) return t;
        if (4 & e && 'object' == typeof t && t && t.__esModule) return t;
        var n = Object.create(null);
        if (
          (r.r(n),
          Object.defineProperty(n, 'default', { enumerable: !0, value: t }),
          2 & e && 'string' != typeof t)
        )
          for (var o in t)
            r.d(
              n,
              o,
              function (e) {
                return t[e];
              }.bind(null, o)
            );
        return n;
      }),
      (r.n = function (t) {
        var e =
          t && t.__esModule
            ? function () {
                return t.default;
              }
            : function () {
                return t;
              };
        return r.d(e, 'a', e), e;
      }),
      (r.o = function (t, e) {
        return Object.prototype.hasOwnProperty.call(t, e);
      }),
      (r.p = '/dist/'),
      r((r.s = 1))
    );
  })([
    function (t, e) {
      var r = 'function' == typeof Float32Array;
      function n(t, e) {
        return 1 - 3 * e + 3 * t;
      }
      function o(t, e) {
        return 3 * e - 6 * t;
      }
      function i(t) {
        return 3 * t;
      }
      function s(t, e, r) {
        return ((n(e, r) * t + o(e, r)) * t + i(e)) * t;
      }
      function l(t, e, r) {
        return 3 * n(e, r) * t * t + 2 * o(e, r) * t + i(e);
      }
      function a(t) {
        return t;
      }
      t.exports = function (t, e, n, o) {
        if (!(0 <= t && t <= 1 && 0 <= n && n <= 1))
          throw new Error('bezier x values must be in [0, 1] range');
        if (t === e && n === o) return a;
        for (var i = r ? new Float32Array(11) : new Array(11), c = 0; c < 11; ++c)
          i[c] = s(0.1 * c, t, n);
        function u(e) {
          for (var r = 0, o = 1; 10 !== o && i[o] <= e; ++o) r += 0.1;
          --o;
          var a = r + 0.1 * ((e - i[o]) / (i[o + 1] - i[o])),
            c = l(a, t, n);
          return c >= 0.001
            ? (function (t, e, r, n) {
                for (var o = 0; o < 4; ++o) {
                  var i = l(e, r, n);
                  if (0 === i) return e;
                  e -= (s(e, r, n) - t) / i;
                }
                return e;
              })(e, a, t, n)
            : 0 === c
            ? a
            : (function (t, e, r, n, o) {
                var i,
                  l,
                  a = 0;
                do {
                  (i = s((l = e + (r - e) / 2), n, o) - t) > 0 ? (r = l) : (e = l);
                } while (Math.abs(i) > 1e-7 && ++a < 10);
                return l;
              })(e, r, r + 0.1, t, n);
        }
        return function (t) {
          return 0 === t ? 0 : 1 === t ? 1 : s(u(t), e, o);
        };
      };
    },
    function (t, e, r) {
      'use strict';
      r.r(e);
      var n = function () {
        var t = this.$createElement;
        return (this._self._c || t)(
          this.tag,
          { ref: 'scrollactive-nav-wrapper', tag: 'component', staticClass: 'scrollactive-nav' },
          [this._t('default')],
          2
        );
      };
      n._withStripped = !0;
      var o = r(0),
        i = r.n(o);
      function s(t) {
        return (
          (function (t) {
            if (Array.isArray(t)) return l(t);
          })(t) ||
          (function (t) {
            if ('undefined' != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t);
          })(t) ||
          (function (t, e) {
            if (!t) return;
            if ('string' == typeof t) return l(t, e);
            var r = Object.prototype.toString.call(t).slice(8, -1);
            'Object' === r && t.constructor && (r = t.constructor.name);
            if ('Map' === r || 'Set' === r) return Array.from(t);
            if ('Arguments' === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
              return l(t, e);
          })(t) ||
          (function () {
            throw new TypeError(
              'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
            );
          })()
        );
      }
      function l(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
        return n;
      }
      var a = (function (t, e, r, n, o, i, s, l) {
        var a,
          c = 'function' == typeof t ? t.options : t;
        if (
          (e && ((c.render = e), (c.staticRenderFns = r), (c._compiled = !0)),
          n && (c.functional = !0),
          i && (c._scopeId = 'data-v-' + i),
          s
            ? ((a = function (t) {
                (t =
                  t ||
                  (this.$vnode && this.$vnode.ssrContext) ||
                  (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext)) ||
                  'undefined' == typeof __VUE_SSR_CONTEXT__ ||
                  (t = __VUE_SSR_CONTEXT__),
                  o && o.call(this, t),
                  t && t._registeredComponents && t._registeredComponents.add(s);
              }),
              (c._ssrRegister = a))
            : o &&
              (a = l
                ? function () {
                    o.call(this, (c.functional ? this.parent : this).$root.$options.shadowRoot);
                  }
                : o),
          a)
        )
          if (c.functional) {
            c._injectStyles = a;
            var u = c.render;
            c.render = function (t, e) {
              return a.call(e), u(t, e);
            };
          } else {
            var f = c.beforeCreate;
            c.beforeCreate = f ? [].concat(f, a) : [a];
          }
        return { exports: t, options: c };
      })(
        {
          props: {
            activeClass: { type: String, default: 'is-active' },
            offset: { type: Number, default: 20 },
            scrollOffset: { type: Number, default: null },
            scrollContainerSelector: { type: String, default: '' },
            clickToScroll: { type: Boolean, default: !0 },
            duration: { type: Number, default: 600 },
            alwaysTrack: { type: Boolean, default: !1 },
            bezierEasingValue: { type: String, default: '.5,0,.35,1' },
            modifyUrl: { type: Boolean, default: !0 },
            exact: { type: Boolean, default: !1 },
            highlightFirstItem: { type: Boolean, default: !1 },
            tag: { type: String, default: 'nav' },
            scrollOnStart: { type: Boolean, default: !0 },
          },
          data: function () {
            return {
              observer: null,
              items: [],
              currentItem: null,
              lastActiveItem: null,
              scrollAnimationFrame: null,
              bezierEasing: i.a,
            };
          },
          computed: {
            cubicBezierArray: function () {
              return this.bezierEasingValue.split(',');
            },
            scrollContainer: function () {
              var t = window;
              return (
                this.scrollContainerSelector &&
                  (t = document.querySelector(this.scrollContainerSelector) || window),
                t
              );
            },
          },
          mounted: function () {
            var t = window.MutationObserver || window.WebKitMutationObserver;
            this.observer ||
              ((this.observer = new t(this.initScrollactiveItems)),
              this.observer.observe(this.$refs['scrollactive-nav-wrapper'], {
                childList: !0,
                subtree: !0,
              })),
              this.initScrollactiveItems(),
              this.removeActiveClass(),
              (this.currentItem = this.getItemInsideWindow()),
              this.currentItem && this.currentItem.classList.add(this.activeClass),
              this.scrollOnStart && this.scrollToHashElement(),
              this.scrollContainer.addEventListener('scroll', this.onScroll);
          },
          updated: function () {
            this.initScrollactiveItems();
          },
          beforeDestroy: function () {
            this.scrollContainer.removeEventListener('scroll', this.onScroll),
              window.cancelAnimationFrame(this.scrollAnimationFrame);
          },
          methods: {
            onScroll: function (t) {
              (this.currentItem = this.getItemInsideWindow()),
                this.currentItem !== this.lastActiveItem &&
                  (this.removeActiveClass(),
                  this.$emit('itemchanged', t, this.currentItem, this.lastActiveItem),
                  (this.lastActiveItem = this.currentItem)),
                this.currentItem && this.currentItem.classList.add(this.activeClass);
            },
            getItemInsideWindow: function () {
              var t,
                e = this;
              return (
                [].forEach.call(this.items, function (r) {
                  var n = r === e.items[0],
                    o = document.getElementById(decodeURI(r.hash.substr(1)));
                  if (o) {
                    var i = e.scrollContainer.scrollTop || window.pageYOffset,
                      s = i >= e.getOffsetTop(o) - e.offset,
                      l = i < e.getOffsetTop(o) - e.offset + o.offsetHeight;
                    n && e.highlightFirstItem && l && (t = r),
                      e.exact && s && l && (t = r),
                      !e.exact && s && (t = r);
                  }
                }),
                t
              );
            },
            initScrollactiveItems: function () {
              var t = this;
              (this.items = this.$el.querySelectorAll('.scrollactive-item')),
                this.clickToScroll
                  ? [].forEach.call(this.items, function (e) {
                      e.addEventListener('click', t.handleClick);
                    })
                  : [].forEach.call(this.items, function (e) {
                      e.removeEventListener('click', t.handleClick);
                    });
            },
            setScrollactiveItems: function () {
              this.initScrollactiveItems();
            },
            handleClick: function (t) {
              var e = this;
              t.preventDefault();
              var r = t.currentTarget.hash,
                n = document.getElementById(decodeURI(r.substr(1)));
              n
                ? (this.alwaysTrack ||
                    (this.scrollContainer.removeEventListener('scroll', this.onScroll),
                    window.cancelAnimationFrame(this.scrollAnimationFrame),
                    this.removeActiveClass(),
                    t.currentTarget.classList.add(this.activeClass)),
                  this.scrollTo(n).then(function () {
                    if (!e.alwaysTrack) {
                      e.scrollContainer.addEventListener('scroll', e.onScroll);
                      (e.currentItem = [].find.call(e.items, function (t) {
                        return decodeURI(t.hash.substr(1)) === n.id;
                      })),
                        e.currentItem !== e.lastActiveItem &&
                          (e.$emit('itemchanged', null, e.currentItem, e.lastActiveItem),
                          (e.lastActiveItem = e.currentItem));
                    }
                    e.modifyUrl && e.pushHashToUrl(r);
                  }))
                : console.warn(
                    "[vue-scrollactive] Element '".concat(
                      r,
                      "' was not found. Make sure it is set in the DOM."
                    )
                  );
            },
            scrollTo: function (t) {
              var e = this;
              return new Promise(function (r) {
                var n = e.getOffsetTop(t),
                  o = e.scrollContainer.scrollTop || window.pageYOffset,
                  i = n - o,
                  l = e.bezierEasing.apply(e, s(e.cubicBezierArray)),
                  a = null;
                window.requestAnimationFrame(function t(n) {
                  a || (a = n);
                  var s = n - a,
                    c = s / e.duration;
                  s >= e.duration && (s = e.duration), c >= 1 && (c = 1);
                  var u = e.scrollOffset || e.offset,
                    f = o + l(c) * (i - u);
                  e.scrollContainer.scrollTo(0, f),
                    s < e.duration
                      ? (e.scrollAnimationFrame = window.requestAnimationFrame(t))
                      : r();
                });
              });
            },
            getOffsetTop: function (t) {
              for (var e = 0, r = t; r; ) (e += r.offsetTop), (r = r.offsetParent);
              return this.scrollContainer.offsetTop && (e -= this.scrollContainer.offsetTop), e;
            },
            removeActiveClass: function () {
              var t = this;
              [].forEach.call(this.items, function (e) {
                e.classList.remove(t.activeClass);
              });
            },
            scrollToHashElement: function () {
              var t = this,
                e = window.location.hash;
              if (e) {
                var r = document.querySelector(decodeURI(e));
                r &&
                  ((window.location.hash = ''),
                  setTimeout(function () {
                    var n = r.offsetTop - t.offset;
                    t.scrollContainer.scrollTo(0, n), t.pushHashToUrl(e);
                  }, 0));
              }
            },
            pushHashToUrl: function (t) {
              window.history.pushState
                ? window.history.pushState(null, null, t)
                : (window.location.hash = t);
            },
          },
        },
        n,
        [],
        !1,
        null,
        null,
        null
      );
      a.options.__file = 'src/scrollactive.vue';
      var c = a.exports,
        u = {
          install: function (t) {
            u.install.installed || t.component('scrollactive', c);
          },
        };
      'undefined' != typeof window && window.Vue && u.install(window.Vue);
      e.default = u;
    },
  ]);
});


/***/ }),

/***/ "5736":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "57bf":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ca22");
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("9869");
/* harmony import */ var _spinner_QSpinner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("9cbe");
/* harmony import */ var _mixins_transition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("ee92");
/* harmony import */ var _mixins_dark_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("87b2");
/* harmony import */ var _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("0fb0");






/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_1__["default"].extend({
  name: 'QInnerLoading',
  mixins: [_mixins_listeners_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"], _mixins_dark_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"], _mixins_transition_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]],
  props: {
    showing: Boolean,
    color: String,
    size: {
      type: [String, Number],
      default: 42
    }
  },

  render(h) {
    const child = this.showing === true ? [h('div', {
      staticClass: 'q-inner-loading absolute-full column flex-center',
      class: this.isDark === true ? 'q-inner-loading--dark' : null,
      on: _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.qListeners)
    }, this.$scopedSlots.default !== void 0 ? this.$scopedSlots.default() : [h(_spinner_QSpinner_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], {
      props: {
        size: this.size,
        color: this.color
      }
    })])] : void 0;
    return h('transition', {
      props: {
        name: this.transition,
        appear: true
      }
    }, child);
  }

}));

/***/ }),

/***/ "5a6a":
/***/ (function(module, exports, __webpack_require__) {

var createTypedArrayConstructor = __webpack_require__("31c3");

// `Uint8Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint8', function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "5b12":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("d4cb");
var definePropertyModule = __webpack_require__("abdf");
var createPropertyDescriptor = __webpack_require__("9618");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "5bb7":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "5cad":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  props: {
    tag: {
      type: String,
      default: 'div'
    }
  }
});

/***/ }),

/***/ "5f2b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/*!
  * vue-router v3.2.0
  * (c) 2020 Evan You
  * @license MIT
  */
/*  */

function assert (condition, message) {
  if (!condition) {
    throw new Error(("[vue-router] " + message))
  }
}

function warn (condition, message) {
  if (false) {}
}

function isError (err) {
  return Object.prototype.toString.call(err).indexOf('Error') > -1
}

function isExtendedError (constructor, err) {
  return (
    err instanceof constructor ||
    // _name is to support IE9 too
    (err && (err.name === constructor.name || err._name === constructor._name))
  )
}

function extend (a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a
}

var View = {
  name: 'RouterView',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render (_, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    // used by devtools to display a router-view badge
    data.routerView = true;

    // directly use parent context's createElement() function
    // so that components rendered by router-view can resolve named slots
    var h = parent.$createElement;
    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent && parent._routerRoot !== parent) {
      var vnodeData = parent.$vnode ? parent.$vnode.data : {};
      if (vnodeData.routerView) {
        depth++;
      }
      if (vnodeData.keepAlive && parent._directInactive && parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      var cachedData = cache[name];
      var cachedComponent = cachedData && cachedData.component;
      if (cachedComponent) {
        // #2301
        // pass props
        if (cachedData.configProps) {
          fillPropsinData(cachedComponent, data, cachedData.route, cachedData.configProps);
        }
        return h(cachedComponent, data, children)
      } else {
        // render previous empty view
        return h()
      }
    }

    var matched = route.matched[depth];
    var component = matched && matched.components[name];

    // render empty node if no matched route or no config component
    if (!matched || !component) {
      cache[name] = null;
      return h()
    }

    // cache component
    cache[name] = { component: component };

    // attach instance registration hook
    // this will be called in the instance's injected lifecycle hooks
    data.registerRouteInstance = function (vm, val) {
      // val could be undefined for unregistration
      var current = matched.instances[name];
      if (
        (val && current !== vm) ||
        (!val && current === vm)
      ) {
        matched.instances[name] = val;
      }
    }

    // also register instance in prepatch hook
    // in case the same component instance is reused across different routes
    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {
      matched.instances[name] = vnode.componentInstance;
    };

    // register instance in init hook
    // in case kept-alive component be actived when routes changed
    data.hook.init = function (vnode) {
      if (vnode.data.keepAlive &&
        vnode.componentInstance &&
        vnode.componentInstance !== matched.instances[name]
      ) {
        matched.instances[name] = vnode.componentInstance;
      }
    };

    var configProps = matched.props && matched.props[name];
    // save route and configProps in cachce
    if (configProps) {
      extend(cache[name], {
        route: route,
        configProps: configProps
      });
      fillPropsinData(component, data, route, configProps);
    }

    return h(component, data, children)
  }
};

function fillPropsinData (component, data, route, configProps) {
  // resolve props
  var propsToPass = data.props = resolveProps(route, configProps);
  if (propsToPass) {
    // clone to prevent mutation
    propsToPass = data.props = extend({}, propsToPass);
    // pass non-declared props as attrs
    var attrs = data.attrs = data.attrs || {};
    for (var key in propsToPass) {
      if (!component.props || !(key in component.props)) {
        attrs[key] = propsToPass[key];
        delete propsToPass[key];
      }
    }
  }
}

function resolveProps (route, config) {
  switch (typeof config) {
    case 'undefined':
      return
    case 'object':
      return config
    case 'function':
      return config(route)
    case 'boolean':
      return config ? route.params : undefined
    default:
      if (false) {}
  }
}

/*  */

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function (str) { return encodeURIComponent(str)
  .replace(encodeReserveRE, encodeReserveReplacer)
  .replace(commaRE, ','); };

var decode = decodeURIComponent;

function resolveQuery (
  query,
  extraQuery,
  _parseQuery
) {
  if ( extraQuery === void 0 ) extraQuery = {};

  var parse = _parseQuery || parseQuery;
  var parsedQuery;
  try {
    parsedQuery = parse(query || '');
  } catch (e) {
     false && false;
    parsedQuery = {};
  }
  for (var key in extraQuery) {
    parsedQuery[key] = extraQuery[key];
  }
  return parsedQuery
}

function parseQuery (query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0
      ? decode(parts.join('='))
      : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res
}

function stringifyQuery (obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return ''
    }

    if (val === null) {
      return encode(key)
    }

    if (Array.isArray(val)) {
      var result = [];
      val.forEach(function (val2) {
        if (val2 === undefined) {
          return
        }
        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&')
    }

    return encode(key) + '=' + encode(val)
  }).filter(function (x) { return x.length > 0; }).join('&') : null;
  return res ? ("?" + res) : ''
}

/*  */

var trailingSlashRE = /\/?$/;

function createRoute (
  record,
  location,
  redirectedFrom,
  router
) {
  var stringifyQuery = router && router.options.stringifyQuery;

  var query = location.query || {};
  try {
    query = clone(query);
  } catch (e) {}

  var route = {
    name: location.name || (record && record.name),
    meta: (record && record.meta) || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: query,
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery);
  }
  return Object.freeze(route)
}

function clone (value) {
  if (Array.isArray(value)) {
    return value.map(clone)
  } else if (value && typeof value === 'object') {
    var res = {};
    for (var key in value) {
      res[key] = clone(value[key]);
    }
    return res
  } else {
    return value
  }
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: '/'
});

function formatMatch (record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res
}

function getFullPath (
  ref,
  _stringifyQuery
) {
  var path = ref.path;
  var query = ref.query; if ( query === void 0 ) query = {};
  var hash = ref.hash; if ( hash === void 0 ) hash = '';

  var stringify = _stringifyQuery || stringifyQuery;
  return (path || '/') + stringify(query) + hash
}

function isSameRoute (a, b) {
  if (b === START) {
    return a === b
  } else if (!b) {
    return false
  } else if (a.path && b.path) {
    return (
      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&
      a.hash === b.hash &&
      isObjectEqual(a.query, b.query)
    )
  } else if (a.name && b.name) {
    return (
      a.name === b.name &&
      a.hash === b.hash &&
      isObjectEqual(a.query, b.query) &&
      isObjectEqual(a.params, b.params)
    )
  } else {
    return false
  }
}

function isObjectEqual (a, b) {
  if ( a === void 0 ) a = {};
  if ( b === void 0 ) b = {};

  // handle null value #1566
  if (!a || !b) { return a === b }
  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false
  }
  return aKeys.every(function (key) {
    var aVal = a[key];
    var bVal = b[key];
    // check nested equality
    if (typeof aVal === 'object' && typeof bVal === 'object') {
      return isObjectEqual(aVal, bVal)
    }
    return String(aVal) === String(bVal)
  })
}

function isIncludedRoute (current, target) {
  return (
    current.path.replace(trailingSlashRE, '/').indexOf(
      target.path.replace(trailingSlashRE, '/')
    ) === 0 &&
    (!target.hash || current.hash === target.hash) &&
    queryIncludes(current.query, target.query)
  )
}

function queryIncludes (current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false
    }
  }
  return true
}

/*  */

function resolvePath (
  relative,
  base,
  append
) {
  var firstChar = relative.charAt(0);
  if (firstChar === '/') {
    return relative
  }

  if (firstChar === '?' || firstChar === '#') {
    return base + relative
  }

  var stack = base.split('/');

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, '').split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === '..') {
      stack.pop();
    } else if (segment !== '.') {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/')
}

function parsePath (path) {
  var hash = '';
  var query = '';

  var hashIndex = path.indexOf('#');
  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');
  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  }
}

function cleanPath (path) {
  return path.replace(/\/\//g, '/')
}

var isarray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/**
 * Expose `pathToRegexp`.
 */
var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options), options)
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens, options) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment;
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options && options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}
pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

/*  */

// $flow-disable-line
var regexpCompileCache = Object.create(null);

function fillParams (
  path,
  params,
  routeMsg
) {
  params = params || {};
  try {
    var filler =
      regexpCompileCache[path] ||
      (regexpCompileCache[path] = pathToRegexp_1.compile(path));

    // Fix #2505 resolving asterisk routes { name: 'not-found', params: { pathMatch: '/not-found' }}
    // and fix #3106 so that you can work with location descriptor object having params.pathMatch equal to empty string
    if (typeof params.pathMatch === 'string') { params[0] = params.pathMatch; }

    return filler(params, { pretty: true })
  } catch (e) {
    if (false) {}
    return ''
  } finally {
    // delete the 0 if it was added
    delete params[0];
  }
}

/*  */

function normalizeLocation (
  raw,
  current,
  append,
  router
) {
  var next = typeof raw === 'string' ? { path: raw } : raw;
  // named target
  if (next._normalized) {
    return next
  } else if (next.name) {
    next = extend({}, raw);
    var params = next.params;
    if (params && typeof params === 'object') {
      next.params = extend({}, params);
    }
    return next
  }

  // relative params
  if (!next.path && next.params && current) {
    next = extend({}, next);
    next._normalized = true;
    var params$1 = extend(extend({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params$1;
    } else if (current.matched.length) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params$1, ("path " + (current.path)));
    } else if (false) {}
    return next
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = (current && current.path) || '/';
  var path = parsedPath.path
    ? resolvePath(parsedPath.path, basePath, append || next.append)
    : basePath;

  var query = resolveQuery(
    parsedPath.query,
    next.query,
    router && router.options.parseQuery
  );

  var hash = next.hash || parsedPath.hash;
  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  }
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var noop = function () {};

var Link = {
  name: 'RouterLink',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    ariaCurrentValue: {
      type: String,
      default: 'page'
    },
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render (h) {
    var this$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(
      this.to,
      current,
      this.append
    );
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;

    var classes = {};
    var globalActiveClass = router.options.linkActiveClass;
    var globalExactActiveClass = router.options.linkExactActiveClass;
    // Support global empty active class
    var activeClassFallback =
      globalActiveClass == null ? 'router-link-active' : globalActiveClass;
    var exactActiveClassFallback =
      globalExactActiveClass == null
        ? 'router-link-exact-active'
        : globalExactActiveClass;
    var activeClass =
      this.activeClass == null ? activeClassFallback : this.activeClass;
    var exactActiveClass =
      this.exactActiveClass == null
        ? exactActiveClassFallback
        : this.exactActiveClass;

    var compareTarget = route.redirectedFrom
      ? createRoute(null, normalizeLocation(route.redirectedFrom), null, router)
      : route;

    classes[exactActiveClass] = isSameRoute(current, compareTarget);
    classes[activeClass] = this.exact
      ? classes[exactActiveClass]
      : isIncludedRoute(current, compareTarget);

    var ariaCurrentValue = classes[exactActiveClass] ? this.ariaCurrentValue : null;

    var handler = function (e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location, noop);
        } else {
          router.push(location, noop);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) {
        on[e] = handler;
      });
    } else {
      on[this.event] = handler;
    }

    var data = { class: classes };

    var scopedSlot =
      !this.$scopedSlots.$hasNormal &&
      this.$scopedSlots.default &&
      this.$scopedSlots.default({
        href: href,
        route: route,
        navigate: handler,
        isActive: classes[activeClass],
        isExactActive: classes[exactActiveClass]
      });

    if (scopedSlot) {
      if (scopedSlot.length === 1) {
        return scopedSlot[0]
      } else if (scopedSlot.length > 1 || !scopedSlot.length) {
        if (false) {}
        return scopedSlot.length === 0 ? h() : h('span', {}, scopedSlot)
      }
    }

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = { href: href, 'aria-current': ariaCurrentValue };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var aData = (a.data = extend({}, a.data));
        aData.on = aData.on || {};
        // transform existing events in both objects into arrays so we can push later
        for (var event in aData.on) {
          var handler$1 = aData.on[event];
          if (event in on) {
            aData.on[event] = Array.isArray(handler$1) ? handler$1 : [handler$1];
          }
        }
        // append new listeners for router-link
        for (var event$1 in on) {
          if (event$1 in aData.on) {
            // on[event] is always a function
            aData.on[event$1].push(on[event$1]);
          } else {
            aData.on[event$1] = handler;
          }
        }

        var aAttrs = (a.data.attrs = extend({}, a.data.attrs));
        aAttrs.href = href;
        aAttrs['aria-current'] = ariaCurrentValue;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default)
  }
};

function guardEvent (e) {
  // don't redirect with control keys
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) { return }
  // don't redirect when preventDefault called
  if (e.defaultPrevented) { return }
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) { return }
  // don't redirect if `target="_blank"`
  if (e.currentTarget && e.currentTarget.getAttribute) {
    var target = e.currentTarget.getAttribute('target');
    if (/\b_blank\b/i.test(target)) { return }
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true
}

function findAnchor (children) {
  if (children) {
    var child;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.tag === 'a') {
        return child
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child
      }
    }
  }
}

var _Vue;

function install (Vue) {
  if (install.installed && _Vue === Vue) { return }
  install.installed = true;

  _Vue = Vue;

  var isDef = function (v) { return v !== undefined; };

  var registerInstance = function (vm, callVal) {
    var i = vm.$options._parentVnode;
    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
      i(vm, callVal);
    }
  };

  Vue.mixin({
    beforeCreate: function beforeCreate () {
      if (isDef(this.$options.router)) {
        this._routerRoot = this;
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      } else {
        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;
      }
      registerInstance(this, this);
    },
    destroyed: function destroyed () {
      registerInstance(this);
    }
  });

  Object.defineProperty(Vue.prototype, '$router', {
    get: function get () { return this._routerRoot._router }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get: function get () { return this._routerRoot._route }
  });

  Vue.component('RouterView', View);
  Vue.component('RouterLink', Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;
}

/*  */

var inBrowser = typeof window !== 'undefined';

/*  */

function createRouteMap (
  routes,
  oldPathList,
  oldPathMap,
  oldNameMap
) {
  // the path list is used to control path matching priority
  var pathList = oldPathList || [];
  // $flow-disable-line
  var pathMap = oldPathMap || Object.create(null);
  // $flow-disable-line
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathList, pathMap, nameMap, route);
  });

  // ensure wildcard routes are always at the end
  for (var i = 0, l = pathList.length; i < l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0]);
      l--;
      i--;
    }
  }

  if (false) { var pathNames, found; }

  return {
    pathList: pathList,
    pathMap: pathMap,
    nameMap: nameMap
  }
}

function addRouteRecord (
  pathList,
  pathMap,
  nameMap,
  route,
  parent,
  matchAs
) {
  var path = route.path;
  var name = route.name;
  if (false) {}

  var pathToRegexpOptions =
    route.pathToRegexpOptions || {};
  var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);

  if (typeof route.caseSensitive === 'boolean') {
    pathToRegexpOptions.sensitive = route.caseSensitive;
  }

  var record = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || { default: route.component },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props:
      route.props == null
        ? {}
        : route.components
          ? route.props
          : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named, does not redirect and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (false) {}
    route.children.forEach(function (child) {
      var childMatchAs = matchAs
        ? cleanPath((matchAs + "/" + (child.path)))
        : undefined;
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (!pathMap[record.path]) {
    pathList.push(record.path);
    pathMap[record.path] = record;
  }

  if (route.alias !== undefined) {
    var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];
    for (var i = 0; i < aliases.length; ++i) {
      var alias = aliases[i];
      if (false) {}

      var aliasRoute = {
        path: alias,
        children: route.children
      };
      addRouteRecord(
        pathList,
        pathMap,
        nameMap,
        aliasRoute,
        parent,
        record.path || '/' // matchAs
      );
    }
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if (false) {}
  }
}

function compileRouteRegex (
  path,
  pathToRegexpOptions
) {
  var regex = pathToRegexp_1(path, [], pathToRegexpOptions);
  if (false) { var keys; }
  return regex
}

function normalizePath (
  path,
  parent,
  strict
) {
  if (!strict) { path = path.replace(/\/$/, ''); }
  if (path[0] === '/') { return path }
  if (parent == null) { return path }
  return cleanPath(((parent.path) + "/" + path))
}

/*  */



function createMatcher (
  routes,
  router
) {
  var ref = createRouteMap(routes);
  var pathList = ref.pathList;
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes (routes) {
    createRouteMap(routes, pathList, pathMap, nameMap);
  }

  function match (
    raw,
    currentRoute,
    redirectedFrom
  ) {
    var location = normalizeLocation(raw, currentRoute, false, router);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if (false) {}
      if (!record) { return _createRoute(null, location) }
      var paramNames = record.regex.keys
        .filter(function (key) { return !key.optional; })
        .map(function (key) { return key.name; });

      if (typeof location.params !== 'object') {
        location.params = {};
      }

      if (currentRoute && typeof currentRoute.params === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      location.path = fillParams(record.path, location.params, ("named route \"" + name + "\""));
      return _createRoute(record, location, redirectedFrom)
    } else if (location.path) {
      location.params = {};
      for (var i = 0; i < pathList.length; i++) {
        var path = pathList[i];
        var record$1 = pathMap[path];
        if (matchRoute(record$1.regex, location.path, location.params)) {
          return _createRoute(record$1, location, redirectedFrom)
        }
      }
    }
    // no match
    return _createRoute(null, location)
  }

  function redirect (
    record,
    location
  ) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function'
      ? originalRedirect(createRoute(record, location, null, router))
      : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = { path: redirect };
    }

    if (!redirect || typeof redirect !== 'object') {
      if (false) {}
      return _createRoute(null, location)
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if (false) {}
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location)
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, ("redirect route with path \"" + rawPath + "\""));
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location)
    } else {
      if (false) {}
      return _createRoute(null, location)
    }
  }

  function alias (
    record,
    location,
    matchAs
  ) {
    var aliasedPath = fillParams(matchAs, location.params, ("aliased route with path \"" + matchAs + "\""));
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location)
    }
    return _createRoute(null, location)
  }

  function _createRoute (
    record,
    location,
    redirectedFrom
  ) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location)
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs)
    }
    return createRoute(record, location, redirectedFrom, router)
  }

  return {
    match: match,
    addRoutes: addRoutes
  }
}

function matchRoute (
  regex,
  path,
  params
) {
  var m = path.match(regex);

  if (!m) {
    return false
  } else if (!params) {
    return true
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = regex.keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
    if (key) {
      // Fix #1994: using * with props: true generates a param named 0
      params[key.name || 'pathMatch'] = val;
    }
  }

  return true
}

function resolveRecordPath (path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true)
}

/*  */

// use User Timing api (if present) for more accurate key precision
var Time =
  inBrowser && window.performance && window.performance.now
    ? window.performance
    : Date;

function genStateKey () {
  return Time.now().toFixed(3)
}

var _key = genStateKey();

function getStateKey () {
  return _key
}

function setStateKey (key) {
  return (_key = key)
}

/*  */

var positionStore = Object.create(null);

function setupScroll () {
  // Prevent browser scroll behavior on History popstate
  if ('scrollRestoration' in window.history) {
    window.history.scrollRestoration = 'manual';
  }
  // Fix for #1585 for Firefox
  // Fix for #2195 Add optional third attribute to workaround a bug in safari https://bugs.webkit.org/show_bug.cgi?id=182678
  // Fix for #2774 Support for apps loaded from Windows file shares not mapped to network drives: replaced location.origin with
  // window.location.protocol + '//' + window.location.host
  // location.host contains the port and location.hostname doesn't
  var protocolAndPath = window.location.protocol + '//' + window.location.host;
  var absolutePath = window.location.href.replace(protocolAndPath, '');
  // preserve existing history state as it could be overriden by the user
  var stateCopy = extend({}, window.history.state);
  stateCopy.key = getStateKey();
  window.history.replaceState(stateCopy, '', absolutePath);
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();
    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll (
  router,
  to,
  from,
  isPop
) {
  if (!router.app) {
    return
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return
  }

  if (false) {}

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior.call(
      router,
      to,
      from,
      isPop ? position : null
    );

    if (!shouldScroll) {
      return
    }

    if (typeof shouldScroll.then === 'function') {
      shouldScroll
        .then(function (shouldScroll) {
          scrollToPosition((shouldScroll), position);
        })
        .catch(function (err) {
          if (false) {}
        });
    } else {
      scrollToPosition(shouldScroll, position);
    }
  });
}

function saveScrollPosition () {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition () {
  var key = getStateKey();
  if (key) {
    return positionStore[key]
  }
}

function getElementPosition (el, offset) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left - offset.x,
    y: elRect.top - docRect.top - offset.y
  }
}

function isValidPosition (obj) {
  return isNumber(obj.x) || isNumber(obj.y)
}

function normalizePosition (obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  }
}

function normalizeOffset (obj) {
  return {
    x: isNumber(obj.x) ? obj.x : 0,
    y: isNumber(obj.y) ? obj.y : 0
  }
}

function isNumber (v) {
  return typeof v === 'number'
}

var hashStartsWithNumberRE = /^#\d/;

function scrollToPosition (shouldScroll, position) {
  var isObject = typeof shouldScroll === 'object';
  if (isObject && typeof shouldScroll.selector === 'string') {
    // getElementById would still fail if the selector contains a more complicated query like #main[data-attr]
    // but at the same time, it doesn't make much sense to select an element with an id and an extra selector
    var el = hashStartsWithNumberRE.test(shouldScroll.selector) // $flow-disable-line
      ? document.getElementById(shouldScroll.selector.slice(1)) // $flow-disable-line
      : document.querySelector(shouldScroll.selector);

    if (el) {
      var offset =
        shouldScroll.offset && typeof shouldScroll.offset === 'object'
          ? shouldScroll.offset
          : {};
      offset = normalizeOffset(offset);
      position = getElementPosition(el, offset);
    } else if (isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }
  } else if (isObject && isValidPosition(shouldScroll)) {
    position = normalizePosition(shouldScroll);
  }

  if (position) {
    window.scrollTo(position.x, position.y);
  }
}

/*  */

var supportsPushState =
  inBrowser &&
  (function () {
    var ua = window.navigator.userAgent;

    if (
      (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&
      ua.indexOf('Mobile Safari') !== -1 &&
      ua.indexOf('Chrome') === -1 &&
      ua.indexOf('Windows Phone') === -1
    ) {
      return false
    }

    return window.history && typeof window.history.pushState === 'function'
  })();

function pushState (url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      // preserve existing history state as it could be overriden by the user
      var stateCopy = extend({}, history.state);
      stateCopy.key = getStateKey();
      history.replaceState(stateCopy, '', url);
    } else {
      history.pushState({ key: setStateKey(genStateKey()) }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState (url) {
  pushState(url, true);
}

/*  */

function runQueue (queue, fn, cb) {
  var step = function (index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */

function resolveAsyncComponents (matched) {
  return function (to, from, next) {
    var hasAsync = false;
    var pending = 0;
    var error = null;

    flatMapComponents(matched, function (def, _, match, key) {
      // if it's a function and doesn't have cid attached,
      // assume it's an async component resolve function.
      // we are not using Vue's default async resolving mechanism because
      // we want to halt the navigation until the incoming component has been
      // resolved.
      if (typeof def === 'function' && def.cid === undefined) {
        hasAsync = true;
        pending++;

        var resolve = once(function (resolvedDef) {
          if (isESModule(resolvedDef)) {
            resolvedDef = resolvedDef.default;
          }
          // save resolved on async factory in case it's used elsewhere
          def.resolved = typeof resolvedDef === 'function'
            ? resolvedDef
            : _Vue.extend(resolvedDef);
          match.components[key] = resolvedDef;
          pending--;
          if (pending <= 0) {
            next();
          }
        });

        var reject = once(function (reason) {
          var msg = "Failed to resolve async component " + key + ": " + reason;
           false && false;
          if (!error) {
            error = isError(reason)
              ? reason
              : new Error(msg);
            next(error);
          }
        });

        var res;
        try {
          res = def(resolve, reject);
        } catch (e) {
          reject(e);
        }
        if (res) {
          if (typeof res.then === 'function') {
            res.then(resolve, reject);
          } else {
            // new syntax in Vue 2.3
            var comp = res.component;
            if (comp && typeof comp.then === 'function') {
              comp.then(resolve, reject);
            }
          }
        }
      }
    });

    if (!hasAsync) { next(); }
  }
}

function flatMapComponents (
  matched,
  fn
) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) { return fn(
      m.components[key],
      m.instances[key],
      m, key
    ); })
  }))
}

function flatten (arr) {
  return Array.prototype.concat.apply([], arr)
}

var hasSymbol =
  typeof Symbol === 'function' &&
  typeof Symbol.toStringTag === 'symbol';

function isESModule (obj) {
  return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module')
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once (fn) {
  var called = false;
  return function () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    if (called) { return }
    called = true;
    return fn.apply(this, args)
  }
}

var NavigationDuplicated = /*@__PURE__*/(function (Error) {
  function NavigationDuplicated (normalizedLocation) {
    Error.call(this);
    this.name = this._name = 'NavigationDuplicated';
    // passing the message to super() doesn't seem to work in the transpiled version
    this.message = "Navigating to current location (\"" + (normalizedLocation.fullPath) + "\") is not allowed";
    // add a stack property so services like Sentry can correctly display it
    Object.defineProperty(this, 'stack', {
      value: new Error().stack,
      writable: true,
      configurable: true
    });
    // we could also have used
    // Error.captureStackTrace(this, this.constructor)
    // but it only exists on node and chrome
  }

  if ( Error ) NavigationDuplicated.__proto__ = Error;
  NavigationDuplicated.prototype = Object.create( Error && Error.prototype );
  NavigationDuplicated.prototype.constructor = NavigationDuplicated;

  return NavigationDuplicated;
}(Error));

// support IE9
NavigationDuplicated._name = 'NavigationDuplicated';

/*  */

var History = function History (router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for "nowhere"
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
  this.readyErrorCbs = [];
  this.errorCbs = [];
};

History.prototype.listen = function listen (cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady (cb, errorCb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
    if (errorCb) {
      this.readyErrorCbs.push(errorCb);
    }
  }
};

History.prototype.onError = function onError (errorCb) {
  this.errorCbs.push(errorCb);
};

History.prototype.transitionTo = function transitionTo (
  location,
  onComplete,
  onAbort
) {
    var this$1 = this;

  var route = this.router.match(location, this.current);
  this.confirmTransition(
    route,
    function () {
      this$1.updateRoute(route);
      onComplete && onComplete(route);
      this$1.ensureURL();

      // fire ready cbs once
      if (!this$1.ready) {
        this$1.ready = true;
        this$1.readyCbs.forEach(function (cb) {
          cb(route);
        });
      }
    },
    function (err) {
      if (onAbort) {
        onAbort(err);
      }
      if (err && !this$1.ready) {
        this$1.ready = true;
        this$1.readyErrorCbs.forEach(function (cb) {
          cb(err);
        });
      }
    }
  );
};

History.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {
    var this$1 = this;

  var current = this.current;
  var abort = function (err) {
    // after merging https://github.com/vuejs/vue-router/pull/2771 we
    // When the user navigates through history through back/forward buttons
    // we do not want to throw the error. We only throw it if directly calling
    // push/replace. That's why it's not included in isError
    if (!isExtendedError(NavigationDuplicated, err) && isError(err)) {
      if (this$1.errorCbs.length) {
        this$1.errorCbs.forEach(function (cb) {
          cb(err);
        });
      } else {
        warn(false, 'uncaught error during route navigation:');
        console.error(err);
      }
    }
    onAbort && onAbort(err);
  };
  if (
    isSameRoute(route, current) &&
    // in the case the route map has been dynamically appended to
    route.matched.length === current.matched.length
  ) {
    this.ensureURL();
    return abort(new NavigationDuplicated(route))
  }

  var ref = resolveQueue(
    this.current.matched,
    route.matched
  );
    var updated = ref.updated;
    var deactivated = ref.deactivated;
    var activated = ref.activated;

  var queue = [].concat(
    // in-component leave guards
    extractLeaveGuards(deactivated),
    // global before hooks
    this.router.beforeHooks,
    // in-component update hooks
    extractUpdateHooks(updated),
    // in-config enter guards
    activated.map(function (m) { return m.beforeEnter; }),
    // async components
    resolveAsyncComponents(activated)
  );

  this.pending = route;
  var iterator = function (hook, next) {
    if (this$1.pending !== route) {
      return abort()
    }
    try {
      hook(route, current, function (to) {
        if (to === false || isError(to)) {
          // next(false) -> abort navigation, ensure current URL
          this$1.ensureURL(true);
          abort(to);
        } else if (
          typeof to === 'string' ||
          (typeof to === 'object' &&
            (typeof to.path === 'string' || typeof to.name === 'string'))
        ) {
          // next('/') or next({ path: '/' }) -> redirect
          abort();
          if (typeof to === 'object' && to.replace) {
            this$1.replace(to);
          } else {
            this$1.push(to);
          }
        } else {
          // confirm transition and pass on the value
          next(to);
        }
      });
    } catch (e) {
      abort(e);
    }
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];
    var isValid = function () { return this$1.current === route; };
    // wait until async components are resolved before
    // extracting in-component enter guards
    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    var queue = enterGuards.concat(this$1.router.resolveHooks);
    runQueue(queue, iterator, function () {
      if (this$1.pending !== route) {
        return abort()
      }
      this$1.pending = null;
      onComplete(route);
      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) {
            cb();
          });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute (route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase (base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = (baseEl && baseEl.getAttribute('href')) || '/';
      // strip full URL origin
      base = base.replace(/^https?:\/\/[^\/]+/, '');
    } else {
      base = '/';
    }
  }
  // make sure there's the starting slash
  if (base.charAt(0) !== '/') {
    base = '/' + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, '')
}

function resolveQueue (
  current,
  next
) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  }
}

function extractGuards (
  records,
  name,
  bind,
  reverse
) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard)
        ? guard.map(function (guard) { return bind(guard, instance, match, key); })
        : bind(guard, instance, match, key)
    }
  });
  return flatten(reverse ? guards.reverse() : guards)
}

function extractGuard (
  def,
  key
) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key]
}

function extractLeaveGuards (deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)
}

function extractUpdateHooks (updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)
}

function bindGuard (guard, instance) {
  if (instance) {
    return function boundRouteGuard () {
      return guard.apply(instance, arguments)
    }
  }
}

function extractEnterGuards (
  activated,
  cbs,
  isValid
) {
  return extractGuards(
    activated,
    'beforeRouteEnter',
    function (guard, _, match, key) {
      return bindEnterGuard(guard, match, key, cbs, isValid)
    }
  )
}

function bindEnterGuard (
  guard,
  match,
  key,
  cbs,
  isValid
) {
  return function routeEnterGuard (to, from, next) {
    return guard(to, from, function (cb) {
      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
      next(cb);
    })
  }
}

function poll (
  cb, // somehow flow cannot infer this is a function
  instances,
  key,
  isValid
) {
  if (
    instances[key] &&
    !instances[key]._isBeingDestroyed // do not reuse being destroyed instance
  ) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}

/*  */

var HTML5History = /*@__PURE__*/(function (History) {
  function HTML5History (router, base) {
    var this$1 = this;

    History.call(this, router, base);

    var expectScroll = router.options.scrollBehavior;
    var supportsScroll = supportsPushState && expectScroll;

    if (supportsScroll) {
      setupScroll();
    }

    var initLocation = getLocation(this.base);
    window.addEventListener('popstate', function (e) {
      var current = this$1.current;

      // Avoiding first `popstate` event dispatched in some browsers but first
      // history route not updated since async guard at the same time.
      var location = getLocation(this$1.base);
      if (this$1.current === START && location === initLocation) {
        return
      }

      this$1.transitionTo(location, function (route) {
        if (supportsScroll) {
          handleScroll(router, route, current, true);
        }
      });
    });
  }

  if ( History ) HTML5History.__proto__ = History;
  HTML5History.prototype = Object.create( History && History.prototype );
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go (n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL (push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {
    return getLocation(this.base)
  };

  return HTML5History;
}(History));

function getLocation (base) {
  var path = decodeURI(window.location.pathname);
  if (base && path.toLowerCase().indexOf(base.toLowerCase()) === 0) {
    path = path.slice(base.length);
  }
  return (path || '/') + window.location.search + window.location.hash
}

/*  */

var HashHistory = /*@__PURE__*/(function (History) {
  function HashHistory (router, base, fallback) {
    History.call(this, router, base);
    // check history fallback deeplinking
    if (fallback && checkFallback(this.base)) {
      return
    }
    ensureSlash();
  }

  if ( History ) HashHistory.__proto__ = History;
  HashHistory.prototype = Object.create( History && History.prototype );
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners () {
    var this$1 = this;

    var router = this.router;
    var expectScroll = router.options.scrollBehavior;
    var supportsScroll = supportsPushState && expectScroll;

    if (supportsScroll) {
      setupScroll();
    }

    window.addEventListener(
      supportsPushState ? 'popstate' : 'hashchange',
      function () {
        var current = this$1.current;
        if (!ensureSlash()) {
          return
        }
        this$1.transitionTo(getHash(), function (route) {
          if (supportsScroll) {
            handleScroll(this$1.router, route, current, true);
          }
          if (!supportsPushState) {
            replaceHash(route.fullPath);
          }
        });
      }
    );
  };

  HashHistory.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(
      location,
      function (route) {
        pushHash(route.fullPath);
        handleScroll(this$1.router, route, fromRoute, false);
        onComplete && onComplete(route);
      },
      onAbort
    );
  };

  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(
      location,
      function (route) {
        replaceHash(route.fullPath);
        handleScroll(this$1.router, route, fromRoute, false);
        onComplete && onComplete(route);
      },
      onAbort
    );
  };

  HashHistory.prototype.go = function go (n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL (push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {
    return getHash()
  };

  return HashHistory;
}(History));

function checkFallback (base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(cleanPath(base + '/#' + location));
    return true
  }
}

function ensureSlash () {
  var path = getHash();
  if (path.charAt(0) === '/') {
    return true
  }
  replaceHash('/' + path);
  return false
}

function getHash () {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  // empty path
  if (index < 0) { return '' }

  href = href.slice(index + 1);
  // decode the hash but not the search or hash
  // as search(query) is already decoded
  // https://github.com/vuejs/vue-router/issues/2708
  var searchIndex = href.indexOf('?');
  if (searchIndex < 0) {
    var hashIndex = href.indexOf('#');
    if (hashIndex > -1) {
      href = decodeURI(href.slice(0, hashIndex)) + href.slice(hashIndex);
    } else { href = decodeURI(href); }
  } else {
    href = decodeURI(href.slice(0, searchIndex)) + href.slice(searchIndex);
  }

  return href
}

function getUrl (path) {
  var href = window.location.href;
  var i = href.indexOf('#');
  var base = i >= 0 ? href.slice(0, i) : href;
  return (base + "#" + path)
}

function pushHash (path) {
  if (supportsPushState) {
    pushState(getUrl(path));
  } else {
    window.location.hash = path;
  }
}

function replaceHash (path) {
  if (supportsPushState) {
    replaceState(getUrl(path));
  } else {
    window.location.replace(getUrl(path));
  }
}

/*  */

var AbstractHistory = /*@__PURE__*/(function (History) {
  function AbstractHistory (router, base) {
    History.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if ( History ) AbstractHistory.__proto__ = History;
  AbstractHistory.prototype = Object.create( History && History.prototype );
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(
      location,
      function (route) {
        this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
        this$1.index++;
        onComplete && onComplete(route);
      },
      onAbort
    );
  };

  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(
      location,
      function (route) {
        this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
        onComplete && onComplete(route);
      },
      onAbort
    );
  };

  AbstractHistory.prototype.go = function go (n) {
    var this$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(
      route,
      function () {
        this$1.index = targetIndex;
        this$1.updateRoute(route);
      },
      function (err) {
        if (isExtendedError(NavigationDuplicated, err)) {
          this$1.index = targetIndex;
        }
      }
    );
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/'
  };

  AbstractHistory.prototype.ensureURL = function ensureURL () {
    // noop
  };

  return AbstractHistory;
}(History));

/*  */



var VueRouter = function VueRouter (options) {
  if ( options === void 0 ) options = {};

  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.resolveHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || [], this);

  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;
  if (this.fallback) {
    mode = 'hash';
  }
  if (!inBrowser) {
    mode = 'abstract';
  }
  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break
    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break
    default:
      if (false) {}
  }
};

var prototypeAccessors = { currentRoute: { configurable: true } };

VueRouter.prototype.match = function match (
  raw,
  current,
  redirectedFrom
) {
  return this.matcher.match(raw, current, redirectedFrom)
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current
};

VueRouter.prototype.init = function init (app /* Vue component instance */) {
    var this$1 = this;

   false && false;

  this.apps.push(app);

  // set up app destroyed handler
  // https://github.com/vuejs/vue-router/issues/2639
  app.$once('hook:destroyed', function () {
    // clean out app from this.apps array once destroyed
    var index = this$1.apps.indexOf(app);
    if (index > -1) { this$1.apps.splice(index, 1); }
    // ensure we still have a main app or null if no apps
    // we do not release the router so it can be reused
    if (this$1.app === app) { this$1.app = this$1.apps[0] || null; }
  });

  // main app previously initialized
  // return as we don't need to set up new history listener
  if (this.app) {
    return
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function () {
      history.setupListeners();
    };
    history.transitionTo(
      history.getCurrentLocation(),
      setupHashListener,
      setupHashListener
    );
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach (fn) {
  return registerHook(this.beforeHooks, fn)
};

VueRouter.prototype.beforeResolve = function beforeResolve (fn) {
  return registerHook(this.resolveHooks, fn)
};

VueRouter.prototype.afterEach = function afterEach (fn) {
  return registerHook(this.afterHooks, fn)
};

VueRouter.prototype.onReady = function onReady (cb, errorCb) {
  this.history.onReady(cb, errorCb);
};

VueRouter.prototype.onError = function onError (errorCb) {
  this.history.onError(errorCb);
};

VueRouter.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

  // $flow-disable-line
  if (!onComplete && !onAbort && typeof Promise !== 'undefined') {
    return new Promise(function (resolve, reject) {
      this$1.history.push(location, resolve, reject);
    })
  } else {
    this.history.push(location, onComplete, onAbort);
  }
};

VueRouter.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

  // $flow-disable-line
  if (!onComplete && !onAbort && typeof Promise !== 'undefined') {
    return new Promise(function (resolve, reject) {
      this$1.history.replace(location, resolve, reject);
    })
  } else {
    this.history.replace(location, onComplete, onAbort);
  }
};

VueRouter.prototype.go = function go (n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back () {
  this.go(-1);
};

VueRouter.prototype.forward = function forward () {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {
  var route = to
    ? to.matched
      ? to
      : this.resolve(to).route
    : this.currentRoute;
  if (!route) {
    return []
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key]
    })
  }))
};

VueRouter.prototype.resolve = function resolve (
  to,
  current,
  append
) {
  current = current || this.history.current;
  var location = normalizeLocation(
    to,
    current,
    append,
    this
  );
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  }
};

VueRouter.prototype.addRoutes = function addRoutes (routes) {
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties( VueRouter.prototype, prototypeAccessors );

function registerHook (list, fn) {
  list.push(fn);
  return function () {
    var i = list.indexOf(fn);
    if (i > -1) { list.splice(i, 1); }
  }
}

function createHref (base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path
}

VueRouter.install = install;
VueRouter.version = '3.2.0';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

/* harmony default export */ __webpack_exports__["a"] = (VueRouter);


/***/ }),

/***/ "61ad":
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__("730c");
var whitespaces = __webpack_require__("fbf7");

var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = String(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),

/***/ "632a":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarInput_vue_vue_type_style_index_1_id_5150ee5d_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("68c1");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarInput_vue_vue_type_style_index_1_id_5150ee5d_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarInput_vue_vue_type_style_index_1_id_5150ee5d_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "6459":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return cache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cacheWithFn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getPropCacheMixin; });
/* harmony import */ var _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5094");

function cache(vm, key, obj) {
  if (_plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__[/* isSSR */ "f"] === true) return obj;
  const k = `__qcache_${key}`;
  return vm[k] === void 0 ? vm[k] = obj : vm[k];
}
function cacheWithFn(vm, key, fn) {
  if (_plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__[/* isSSR */ "f"] === true) return fn();
  const k = `__qcache_${key}`;
  return vm[k] === void 0 ? vm[k] = fn() : vm[k];
}
function getPropCacheMixin(propName, proxyPropName) {
  return {
    data() {
      const target = {};
      const source = this[propName];

      for (const prop in source) {
        target[prop] = source[prop];
      }

      return {
        [proxyPropName]: target
      };
    },

    watch: {
      [propName](newObj, oldObj) {
        const target = this[proxyPropName];

        if (oldObj !== void 0) {
          // we first delete obsolete events
          for (const prop in oldObj) {
            if (newObj[prop] === void 0) {
              this.$delete(target, prop);
            }
          }
        }

        for (const prop in newObj) {
          // we then update changed events
          if (target[prop] !== newObj[prop]) {
            this.$set(target, prop, newObj[prop]);
          }
        }
      }

    }
  };
}

/***/ }),

/***/ "64e4":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("5428");

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ "65d0":
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__("c91c");
var enumBugKeys = __webpack_require__("b17e");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "66dc":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ca22");
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("9869");
/* harmony import */ var _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("0fb0");
/* harmony import */ var _utils_slot_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("a4b3");




/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_1__["default"].extend({
  name: 'QItemSection',
  mixins: [_mixins_listeners_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]],
  props: {
    avatar: Boolean,
    thumbnail: Boolean,
    side: Boolean,
    top: Boolean,
    noWrap: Boolean
  },
  computed: {
    classes() {
      const side = this.avatar || this.side || this.thumbnail;
      return {
        'q-item__section--top': this.top,
        'q-item__section--avatar': this.avatar,
        'q-item__section--thumbnail': this.thumbnail,
        'q-item__section--side': side,
        'q-item__section--nowrap': this.noWrap,
        'q-item__section--main': !side,
        [`justify-${this.top ? 'start' : 'center'}`]: true
      };
    }

  },

  render(h) {
    return h('div', {
      staticClass: 'q-item__section column',
      class: this.classes,
      on: _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.qListeners)
    }, Object(_utils_slot_js__WEBPACK_IMPORTED_MODULE_3__[/* slot */ "c"])(this, 'default'));
  }

}));

/***/ }),

/***/ "6769":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return closePortalMenus; });
/* unused harmony export closePortals */
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("9869");
/* harmony import */ var _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("5094");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("3230");



function closePortalMenus(vm, evt) {
  do {
    if (vm.$options.name === 'QMenu') {
      vm.hide(evt); // is this a point of separation?

      if (vm.separateClosePopup === true) {
        return vm.$parent;
      }
    } else if (vm.__renderPortal !== void 0) {
      // treat it as point of separation if parent is QPopupProxy
      // (so mobile matches desktop behavior)
      // and hide it too
      if (vm.$parent !== void 0 && vm.$parent.$options.name === 'QPopupProxy') {
        vm.hide(evt);
        return vm.$parent;
      } else {
        return vm;
      }
    }

    vm = vm.$parent;
  } while (vm !== void 0 && (vm.$el.contains === void 0 || // IE polyfill does not work on comments
  vm.$el.contains(evt.target) !== true));
}
function closePortals(vm, evt, depth) {
  while (depth !== 0 && vm !== void 0) {
    if (vm.__renderPortal !== void 0) {
      depth--;

      if (vm.$options.name === 'QMenu') {
        vm = closePortalMenus(vm, evt);
        continue;
      }

      vm.hide(evt);
    }

    vm = vm.$parent;
  }
}

function isOnGlobalDialog(vm) {
  while (vm !== void 0) {
    if (vm.$options.name === 'QGlobalDialog') {
      return true;
    }

    if (vm.$options.name === 'QDialog') {
      return false;
    }

    vm = vm.$parent;
  }

  return false;
}

const Portal = {
  inheritAttrs: false,
  props: {
    contentClass: [Array, String, Object],
    contentStyle: [Array, String, Object]
  },
  methods: {
    __showPortal() {
      if (this.$q.fullscreen !== void 0 && this.$q.fullscreen.isCapable === true) {
        const append = isFullscreen => {
          if (this.__portal === void 0) {
            return;
          }

          const newParent = Object(_utils_dom_js__WEBPACK_IMPORTED_MODULE_2__[/* getBodyFullscreenElement */ "c"])(isFullscreen, this.$q.fullscreen.activeEl);

          if (this.__portal.$el.parentElement !== newParent && newParent.contains(this.$el) === (this.__onGlobalDialog === false)) {
            newParent.appendChild(this.__portal.$el);
          }
        };

        this.unwatchFullscreen = this.$watch('$q.fullscreen.isActive', append);
        const isActive = this.$q.fullscreen.isActive;

        if (this.__onGlobalDialog === false || isActive === true) {
          append(isActive);
        }
      } else if (this.__portal !== void 0 && this.__onGlobalDialog === false) {
        document.body.appendChild(this.__portal.$el);
      }
    },

    __hidePortal() {
      if (this.__portal !== void 0) {
        if (this.unwatchFullscreen !== void 0) {
          this.unwatchFullscreen();
          this.unwatchFullscreen = void 0;
        }

        if (this.__onGlobalDialog === false) {
          this.__portal.$destroy();

          this.__portal.$el.remove();
        }

        this.__portal = void 0;
      }
    },

    __preparePortal() {
      if (this.__portal === void 0) {
        this.__portal = this.__onGlobalDialog === true ? {
          $el: this.$el,
          $refs: this.$refs
        } : new vue__WEBPACK_IMPORTED_MODULE_0__["default"]({
          name: 'QPortal',
          parent: this,
          inheritAttrs: false,
          render: h => this.__renderPortal(h),
          components: this.$options.components,
          directives: this.$options.directives
        }).$mount();
      }
    }

  },

  render(h) {
    if (this.__onGlobalDialog === true) {
      return this.__renderPortal(h);
    }

    if (this.__portal !== void 0) {
      this.__portal.$forceUpdate();
    }
  },

  beforeDestroy() {
    this.__hidePortal();
  }

};

if (_plugins_Platform_js__WEBPACK_IMPORTED_MODULE_1__[/* isSSR */ "f"] === false) {
  Portal.created = function () {
    this.__onGlobalDialog = isOnGlobalDialog(this.$parent);
  };
}

/* harmony default export */ __webpack_exports__["b"] = (Portal);

/***/ }),

/***/ "68c1":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "6a61":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "6a86":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("7526");
var isArray = __webpack_require__("c6de");
var wellKnownSymbol = __webpack_require__("7d53");

var SPECIES = wellKnownSymbol('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};


/***/ }),

/***/ "6a94":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  computed: {
    __refocusTargetEl() {
      if (this.disable !== true) {
        return this.$createElement('span', {
          ref: 'refocusTarget',
          staticClass: 'no-outline',
          attrs: {
            tabindex: -1
          }
        });
      }
    }

  },
  methods: {
    __refocusTarget(e) {
      if (e !== void 0 && e.type.indexOf('key') === 0) {
        if (document.activeElement !== this.$el && this.$el.contains(document.activeElement) === true) {
          this.$el.focus();
        }
      } else if ((e === void 0 || this.$el.contains(e.target) === true) && this.$refs.refocusTarget !== void 0) {
        this.$refs.refocusTarget.focus();
      }
    }

  }
});

/***/ }),

/***/ "6b1d":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("f498");
var getOwnPropertyDescriptor = __webpack_require__("185a").f;
var createNonEnumerableProperty = __webpack_require__("5b12");
var redefine = __webpack_require__("b8ba");
var setGlobal = __webpack_require__("3e34");
var copyConstructorProperties = __webpack_require__("b634");
var isForced = __webpack_require__("ebac");

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "703a":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "7297":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("f498");
var inspectSource = __webpack_require__("df6f");

var WeakMap = global.WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ "72df":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "730c":
/***/ (function(module, exports) {

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "7526":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "7535":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "7584":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarTabs_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7535");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarTabs_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarTabs_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "7747":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("918c");
/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("5094");
/* harmony import */ var _utils_event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("9ac9");




const getTrue = () => true;

function filterInvalidPath(path) {
  return typeof path === 'string' && path !== '' && path !== '/' && path !== '#/';
}

function normalizeExitPath(path) {
  path.startsWith('#') === true && (path = path.substr(1));
  path.startsWith('/') === false && (path = '/' + path);
  path.endsWith('/') === true && (path = path.substr(0, path.length - 1));
  return '#' + path;
}

function getShouldExitFn(cfg) {
  if (cfg.backButtonExit === false) {
    return () => false;
  }

  if (cfg.backButtonExit === '*') {
    return getTrue;
  } // Add default root path


  const exitPaths = ['#/']; // Add custom exit paths

  Array.isArray(cfg.backButtonExit) === true && exitPaths.push(...cfg.backButtonExit.filter(filterInvalidPath).map(normalizeExitPath));
  return () => exitPaths.includes(window.location.hash);
}

/* harmony default export */ __webpack_exports__["a"] = ({
  __history: [],
  add: _utils_event_js__WEBPACK_IMPORTED_MODULE_2__[/* noop */ "g"],
  remove: _utils_event_js__WEBPACK_IMPORTED_MODULE_2__[/* noop */ "g"],

  install(cfg) {
    if (_plugins_Platform_js__WEBPACK_IMPORTED_MODULE_1__[/* isSSR */ "f"] === true) {
      return;
    }

    const {
      cordova,
      capacitor
    } = _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_1__[/* client */ "a"].is;

    if (cordova !== true && capacitor !== true) {
      return;
    }

    const qConf = cfg[cordova === true ? 'cordova' : 'capacitor'];

    if (qConf !== void 0 && qConf.backButton === false) {
      return;
    } // if the '@capacitor/app' plugin is not installed
    // then we got nothing to do


    if ( // if we're on Capacitor mode
    capacitor === true // and it's also not in Capacitor's main instance
    && (window.Capacitor === void 0 || window.Capacitor.Plugins.App === void 0)) {
      return;
    }

    this.add = entry => {
      if (entry.condition === void 0) {
        entry.condition = getTrue;
      }

      this.__history.push(entry);
    };

    this.remove = entry => {
      const index = this.__history.indexOf(entry);

      if (index >= 0) {
        this.__history.splice(index, 1);
      }
    };

    const shouldExit = getShouldExitFn(Object.assign({
      backButtonExit: true
    }, qConf));

    const backHandler = () => {
      if (this.__history.length) {
        const entry = this.__history[this.__history.length - 1];

        if (entry.condition() === true) {
          this.__history.pop();

          entry.handler();
        }
      } else if (shouldExit() === true) {
        navigator.app.exitApp();
      } else {
        window.history.back();
      }
    };

    if (cordova === true) {
      document.addEventListener('deviceready', () => {
        document.addEventListener('backbutton', backHandler, false);
      });
    } else {
      window.Capacitor.Plugins.App.addListener('backButton', backHandler);
    }
  }

});

/***/ }),

/***/ "7850":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "79b4":
/***/ (function(module, exports, __webpack_require__) {

var toObject = __webpack_require__("37d1");

var floor = Math.floor;
var replace = ''.replace;
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

// https://tc39.es/ecma262/#sec-getsubstitution
module.exports = function (matched, str, position, captures, namedCaptures, replacement) {
  var tailPos = position + matched.length;
  var m = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== undefined) {
    namedCaptures = toObject(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace.call(replacement, symbols, function (match, ch) {
    var capture;
    switch (ch.charAt(0)) {
      case '$': return '$';
      case '&': return matched;
      case '`': return str.slice(0, position);
      case "'": return str.slice(tailPos);
      case '<':
        capture = namedCaptures[ch.slice(1, -1)];
        break;
      default: // \d\d?
        var n = +ch;
        if (n === 0) return match;
        if (n > m) {
          var f = floor(n / 10);
          if (f === 0) return match;
          if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
          return match;
        }
        capture = captures[n - 1];
    }
    return capture === undefined ? '' : capture;
  });
};


/***/ }),

/***/ "7b00":
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? module.exports = factory() :
	undefined;
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var _global = createCommonjsModule(function (module) {
	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	if (typeof __g == 'number') { __g = global; } // eslint-disable-line no-undef
	});

	var _core = createCommonjsModule(function (module) {
	var core = module.exports = { version: '2.6.5' };
	if (typeof __e == 'number') { __e = core; } // eslint-disable-line no-undef
	});
	var _core_1 = _core.version;

	var _isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	var _anObject = function (it) {
	  if (!_isObject(it)) { throw TypeError(it + ' is not an object!'); }
	  return it;
	};

	var _fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

	// Thank's IE8 for his funny defineProperty
	var _descriptors = !_fails(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});

	var document = _global.document;
	// typeof document.createElement is 'object' in old IE
	var is = _isObject(document) && _isObject(document.createElement);
	var _domCreate = function (it) {
	  return is ? document.createElement(it) : {};
	};

	var _ie8DomDefine = !_descriptors && !_fails(function () {
	  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
	});

	// 7.1.1 ToPrimitive(input [, PreferredType])

	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var _toPrimitive = function (it, S) {
	  if (!_isObject(it)) { return it; }
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) { return val; }
	  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) { return val; }
	  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) { return val; }
	  throw TypeError("Can't convert object to primitive value");
	};

	var dP = Object.defineProperty;

	var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  _anObject(O);
	  P = _toPrimitive(P, true);
	  _anObject(Attributes);
	  if (_ie8DomDefine) { try {
	    return dP(O, P, Attributes);
	  } catch (e) { /* empty */ } }
	  if ('get' in Attributes || 'set' in Attributes) { throw TypeError('Accessors not supported!'); }
	  if ('value' in Attributes) { O[P] = Attributes.value; }
	  return O;
	};

	var _objectDp = {
		f: f
	};

	var _propertyDesc = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var _hide = _descriptors ? function (object, key, value) {
	  return _objectDp.f(object, key, _propertyDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var hasOwnProperty = {}.hasOwnProperty;
	var _has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var id = 0;
	var px = Math.random();
	var _uid = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

	var _library = false;

	var _shared = createCommonjsModule(function (module) {
	var SHARED = '__core-js_shared__';
	var store = _global[SHARED] || (_global[SHARED] = {});

	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: _core.version,
	  mode: _library ? 'pure' : 'global',
	  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
	});
	});

	var _functionToString = _shared('native-function-to-string', Function.toString);

	var _redefine = createCommonjsModule(function (module) {
	var SRC = _uid('src');

	var TO_STRING = 'toString';
	var TPL = ('' + _functionToString).split(TO_STRING);

	_core.inspectSource = function (it) {
	  return _functionToString.call(it);
	};

	(module.exports = function (O, key, val, safe) {
	  var isFunction = typeof val == 'function';
	  if (isFunction) { _has(val, 'name') || _hide(val, 'name', key); }
	  if (O[key] === val) { return; }
	  if (isFunction) { _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key))); }
	  if (O === _global) {
	    O[key] = val;
	  } else if (!safe) {
	    delete O[key];
	    _hide(O, key, val);
	  } else if (O[key]) {
	    O[key] = val;
	  } else {
	    _hide(O, key, val);
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString() {
	  return typeof this == 'function' && this[SRC] || _functionToString.call(this);
	});
	});

	var _aFunction = function (it) {
	  if (typeof it != 'function') { throw TypeError(it + ' is not a function!'); }
	  return it;
	};

	// optional / simple context binding

	var _ctx = function (fn, that, length) {
	  _aFunction(fn);
	  if (that === undefined) { return fn; }
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var PROTOTYPE = 'prototype';

	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
	  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
	  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
	  var key, own, out, exp;
	  if (IS_GLOBAL) { source = name; }
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
	    // extend global
	    if (target) { _redefine(target, key, out, type & $export.U); }
	    // export
	    if (exports[key] != out) { _hide(exports, key, exp); }
	    if (IS_PROTO && expProto[key] != out) { expProto[key] = out; }
	  }
	};
	_global.core = _core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library`
	var _export = $export;

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	var _toInteger = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

	// 7.2.1 RequireObjectCoercible(argument)
	var _defined = function (it) {
	  if (it == undefined) { throw TypeError("Can't call method on  " + it); }
	  return it;
	};

	// true  -> String#at
	// false -> String#codePointAt
	var _stringAt = function (TO_STRING) {
	  return function (that, pos) {
	    var s = String(_defined(that));
	    var i = _toInteger(pos);
	    var l = s.length;
	    var a, b;
	    if (i < 0 || i >= l) { return TO_STRING ? '' : undefined; }
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

	var $at = _stringAt(false);
	_export(_export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos) {
	    return $at(this, pos);
	  }
	});

	var codePointAt = _core.String.codePointAt;

	var max = Math.max;
	var min = Math.min;
	var _toAbsoluteIndex = function (index, length) {
	  index = _toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

	var fromCharCode = String.fromCharCode;
	var $fromCodePoint = String.fromCodePoint;

	// length should be 1, old FF problem
	_export(_export.S + _export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x) {
	    var arguments$1 = arguments;
	 // eslint-disable-line no-unused-vars
	    var res = [];
	    var aLen = arguments.length;
	    var i = 0;
	    var code;
	    while (aLen > i) {
	      code = +arguments$1[i++];
	      if (_toAbsoluteIndex(code, 0x10ffff) !== code) { throw RangeError(code + ' is not a valid code point'); }
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});

	var fromCodePoint = _core.String.fromCodePoint;

	// This is a generated file. Do not edit.
	var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
	var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
	var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;

	var unicode = {
		Space_Separator: Space_Separator,
		ID_Start: ID_Start,
		ID_Continue: ID_Continue
	};

	var util = {
	    isSpaceSeparator: function isSpaceSeparator (c) {
	        return typeof c === 'string' && unicode.Space_Separator.test(c)
	    },

	    isIdStartChar: function isIdStartChar (c) {
	        return typeof c === 'string' && (
	            (c >= 'a' && c <= 'z') ||
	        (c >= 'A' && c <= 'Z') ||
	        (c === '$') || (c === '_') ||
	        unicode.ID_Start.test(c)
	        )
	    },

	    isIdContinueChar: function isIdContinueChar (c) {
	        return typeof c === 'string' && (
	            (c >= 'a' && c <= 'z') ||
	        (c >= 'A' && c <= 'Z') ||
	        (c >= '0' && c <= '9') ||
	        (c === '$') || (c === '_') ||
	        (c === '\u200C') || (c === '\u200D') ||
	        unicode.ID_Continue.test(c)
	        )
	    },

	    isDigit: function isDigit (c) {
	        return typeof c === 'string' && /[0-9]/.test(c)
	    },

	    isHexDigit: function isHexDigit (c) {
	        return typeof c === 'string' && /[0-9A-Fa-f]/.test(c)
	    },
	};

	var source;
	var parseState;
	var stack;
	var pos;
	var line;
	var column;
	var token;
	var key;
	var root;

	var parse = function parse (text, reviver) {
	    source = String(text);
	    parseState = 'start';
	    stack = [];
	    pos = 0;
	    line = 1;
	    column = 0;
	    token = undefined;
	    key = undefined;
	    root = undefined;

	    do {
	        token = lex();

	        // This code is unreachable.
	        // if (!parseStates[parseState]) {
	        //     throw invalidParseState()
	        // }

	        parseStates[parseState]();
	    } while (token.type !== 'eof')

	    if (typeof reviver === 'function') {
	        return internalize({'': root}, '', reviver)
	    }

	    return root
	};

	function internalize (holder, name, reviver) {
	    var value = holder[name];
	    if (value != null && typeof value === 'object') {
	        for (var key in value) {
	            var replacement = internalize(value, key, reviver);
	            if (replacement === undefined) {
	                delete value[key];
	            } else {
	                value[key] = replacement;
	            }
	        }
	    }

	    return reviver.call(holder, name, value)
	}

	var lexState;
	var buffer;
	var doubleQuote;
	var sign;
	var c;

	function lex () {
	    lexState = 'default';
	    buffer = '';
	    doubleQuote = false;
	    sign = 1;

	    for (;;) {
	        c = peek();

	        // This code is unreachable.
	        // if (!lexStates[lexState]) {
	        //     throw invalidLexState(lexState)
	        // }

	        var token = lexStates[lexState]();
	        if (token) {
	            return token
	        }
	    }
	}

	function peek () {
	    if (source[pos]) {
	        return String.fromCodePoint(source.codePointAt(pos))
	    }
	}

	function read () {
	    var c = peek();

	    if (c === '\n') {
	        line++;
	        column = 0;
	    } else if (c) {
	        column += c.length;
	    } else {
	        column++;
	    }

	    if (c) {
	        pos += c.length;
	    }

	    return c
	}

	var lexStates = {
	    default: function default$1 () {
	        switch (c) {
	        case '\t':
	        case '\v':
	        case '\f':
	        case ' ':
	        case '\u00A0':
	        case '\uFEFF':
	        case '\n':
	        case '\r':
	        case '\u2028':
	        case '\u2029':
	            read();
	            return

	        case '/':
	            read();
	            lexState = 'comment';
	            return

	        case undefined:
	            read();
	            return newToken('eof')
	        }

	        if (util.isSpaceSeparator(c)) {
	            read();
	            return
	        }

	        // This code is unreachable.
	        // if (!lexStates[parseState]) {
	        //     throw invalidLexState(parseState)
	        // }

	        return lexStates[parseState]()
	    },

	    comment: function comment () {
	        switch (c) {
	        case '*':
	            read();
	            lexState = 'multiLineComment';
	            return

	        case '/':
	            read();
	            lexState = 'singleLineComment';
	            return
	        }

	        throw invalidChar(read())
	    },

	    multiLineComment: function multiLineComment () {
	        switch (c) {
	        case '*':
	            read();
	            lexState = 'multiLineCommentAsterisk';
	            return

	        case undefined:
	            throw invalidChar(read())
	        }

	        read();
	    },

	    multiLineCommentAsterisk: function multiLineCommentAsterisk () {
	        switch (c) {
	        case '*':
	            read();
	            return

	        case '/':
	            read();
	            lexState = 'default';
	            return

	        case undefined:
	            throw invalidChar(read())
	        }

	        read();
	        lexState = 'multiLineComment';
	    },

	    singleLineComment: function singleLineComment () {
	        switch (c) {
	        case '\n':
	        case '\r':
	        case '\u2028':
	        case '\u2029':
	            read();
	            lexState = 'default';
	            return

	        case undefined:
	            read();
	            return newToken('eof')
	        }

	        read();
	    },

	    value: function value () {
	        switch (c) {
	        case '{':
	        case '[':
	            return newToken('punctuator', read())

	        case 'n':
	            read();
	            literal('ull');
	            return newToken('null', null)

	        case 't':
	            read();
	            literal('rue');
	            return newToken('boolean', true)

	        case 'f':
	            read();
	            literal('alse');
	            return newToken('boolean', false)

	        case '-':
	        case '+':
	            if (read() === '-') {
	                sign = -1;
	            }

	            lexState = 'sign';
	            return

	        case '.':
	            buffer = read();
	            lexState = 'decimalPointLeading';
	            return

	        case '0':
	            buffer = read();
	            lexState = 'zero';
	            return

	        case '1':
	        case '2':
	        case '3':
	        case '4':
	        case '5':
	        case '6':
	        case '7':
	        case '8':
	        case '9':
	            buffer = read();
	            lexState = 'decimalInteger';
	            return

	        case 'I':
	            read();
	            literal('nfinity');
	            return newToken('numeric', Infinity)

	        case 'N':
	            read();
	            literal('aN');
	            return newToken('numeric', NaN)

	        case '"':
	        case "'":
	            doubleQuote = (read() === '"');
	            buffer = '';
	            lexState = 'string';
	            return
	        }

	        throw invalidChar(read())
	    },

	    identifierNameStartEscape: function identifierNameStartEscape () {
	        if (c !== 'u') {
	            throw invalidChar(read())
	        }

	        read();
	        var u = unicodeEscape();
	        switch (u) {
	        case '$':
	        case '_':
	            break

	        default:
	            if (!util.isIdStartChar(u)) {
	                throw invalidIdentifier()
	            }

	            break
	        }

	        buffer += u;
	        lexState = 'identifierName';
	    },

	    identifierName: function identifierName () {
	        switch (c) {
	        case '$':
	        case '_':
	        case '\u200C':
	        case '\u200D':
	            buffer += read();
	            return

	        case '\\':
	            read();
	            lexState = 'identifierNameEscape';
	            return
	        }

	        if (util.isIdContinueChar(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('identifier', buffer)
	    },

	    identifierNameEscape: function identifierNameEscape () {
	        if (c !== 'u') {
	            throw invalidChar(read())
	        }

	        read();
	        var u = unicodeEscape();
	        switch (u) {
	        case '$':
	        case '_':
	        case '\u200C':
	        case '\u200D':
	            break

	        default:
	            if (!util.isIdContinueChar(u)) {
	                throw invalidIdentifier()
	            }

	            break
	        }

	        buffer += u;
	        lexState = 'identifierName';
	    },

	    sign: function sign$1 () {
	        switch (c) {
	        case '.':
	            buffer = read();
	            lexState = 'decimalPointLeading';
	            return

	        case '0':
	            buffer = read();
	            lexState = 'zero';
	            return

	        case '1':
	        case '2':
	        case '3':
	        case '4':
	        case '5':
	        case '6':
	        case '7':
	        case '8':
	        case '9':
	            buffer = read();
	            lexState = 'decimalInteger';
	            return

	        case 'I':
	            read();
	            literal('nfinity');
	            return newToken('numeric', sign * Infinity)

	        case 'N':
	            read();
	            literal('aN');
	            return newToken('numeric', NaN)
	        }

	        throw invalidChar(read())
	    },

	    zero: function zero () {
	        switch (c) {
	        case '.':
	            buffer += read();
	            lexState = 'decimalPoint';
	            return

	        case 'e':
	        case 'E':
	            buffer += read();
	            lexState = 'decimalExponent';
	            return

	        case 'x':
	        case 'X':
	            buffer += read();
	            lexState = 'hexadecimal';
	            return
	        }

	        return newToken('numeric', sign * 0)
	    },

	    decimalInteger: function decimalInteger () {
	        switch (c) {
	        case '.':
	            buffer += read();
	            lexState = 'decimalPoint';
	            return

	        case 'e':
	        case 'E':
	            buffer += read();
	            lexState = 'decimalExponent';
	            return
	        }

	        if (util.isDigit(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    decimalPointLeading: function decimalPointLeading () {
	        if (util.isDigit(c)) {
	            buffer += read();
	            lexState = 'decimalFraction';
	            return
	        }

	        throw invalidChar(read())
	    },

	    decimalPoint: function decimalPoint () {
	        switch (c) {
	        case 'e':
	        case 'E':
	            buffer += read();
	            lexState = 'decimalExponent';
	            return
	        }

	        if (util.isDigit(c)) {
	            buffer += read();
	            lexState = 'decimalFraction';
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    decimalFraction: function decimalFraction () {
	        switch (c) {
	        case 'e':
	        case 'E':
	            buffer += read();
	            lexState = 'decimalExponent';
	            return
	        }

	        if (util.isDigit(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    decimalExponent: function decimalExponent () {
	        switch (c) {
	        case '+':
	        case '-':
	            buffer += read();
	            lexState = 'decimalExponentSign';
	            return
	        }

	        if (util.isDigit(c)) {
	            buffer += read();
	            lexState = 'decimalExponentInteger';
	            return
	        }

	        throw invalidChar(read())
	    },

	    decimalExponentSign: function decimalExponentSign () {
	        if (util.isDigit(c)) {
	            buffer += read();
	            lexState = 'decimalExponentInteger';
	            return
	        }

	        throw invalidChar(read())
	    },

	    decimalExponentInteger: function decimalExponentInteger () {
	        if (util.isDigit(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    hexadecimal: function hexadecimal () {
	        if (util.isHexDigit(c)) {
	            buffer += read();
	            lexState = 'hexadecimalInteger';
	            return
	        }

	        throw invalidChar(read())
	    },

	    hexadecimalInteger: function hexadecimalInteger () {
	        if (util.isHexDigit(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    string: function string () {
	        switch (c) {
	        case '\\':
	            read();
	            buffer += escape();
	            return

	        case '"':
	            if (doubleQuote) {
	                read();
	                return newToken('string', buffer)
	            }

	            buffer += read();
	            return

	        case "'":
	            if (!doubleQuote) {
	                read();
	                return newToken('string', buffer)
	            }

	            buffer += read();
	            return

	        case '\n':
	        case '\r':
	            throw invalidChar(read())

	        case '\u2028':
	        case '\u2029':
	            separatorChar(c);
	            break

	        case undefined:
	            throw invalidChar(read())
	        }

	        buffer += read();
	    },

	    start: function start () {
	        switch (c) {
	        case '{':
	        case '[':
	            return newToken('punctuator', read())

	        // This code is unreachable since the default lexState handles eof.
	        // case undefined:
	        //     return newToken('eof')
	        }

	        lexState = 'value';
	    },

	    beforePropertyName: function beforePropertyName () {
	        switch (c) {
	        case '$':
	        case '_':
	            buffer = read();
	            lexState = 'identifierName';
	            return

	        case '\\':
	            read();
	            lexState = 'identifierNameStartEscape';
	            return

	        case '}':
	            return newToken('punctuator', read())

	        case '"':
	        case "'":
	            doubleQuote = (read() === '"');
	            lexState = 'string';
	            return
	        }

	        if (util.isIdStartChar(c)) {
	            buffer += read();
	            lexState = 'identifierName';
	            return
	        }

	        throw invalidChar(read())
	    },

	    afterPropertyName: function afterPropertyName () {
	        if (c === ':') {
	            return newToken('punctuator', read())
	        }

	        throw invalidChar(read())
	    },

	    beforePropertyValue: function beforePropertyValue () {
	        lexState = 'value';
	    },

	    afterPropertyValue: function afterPropertyValue () {
	        switch (c) {
	        case ',':
	        case '}':
	            return newToken('punctuator', read())
	        }

	        throw invalidChar(read())
	    },

	    beforeArrayValue: function beforeArrayValue () {
	        if (c === ']') {
	            return newToken('punctuator', read())
	        }

	        lexState = 'value';
	    },

	    afterArrayValue: function afterArrayValue () {
	        switch (c) {
	        case ',':
	        case ']':
	            return newToken('punctuator', read())
	        }

	        throw invalidChar(read())
	    },

	    end: function end () {
	        // This code is unreachable since it's handled by the default lexState.
	        // if (c === undefined) {
	        //     read()
	        //     return newToken('eof')
	        // }

	        throw invalidChar(read())
	    },
	};

	function newToken (type, value) {
	    return {
	        type: type,
	        value: value,
	        line: line,
	        column: column,
	    }
	}

	function literal (s) {
	    for (var i = 0, list = s; i < list.length; i += 1) {
	        var c = list[i];

	        var p = peek();

	        if (p !== c) {
	            throw invalidChar(read())
	        }

	        read();
	    }
	}

	function escape () {
	    var c = peek();
	    switch (c) {
	    case 'b':
	        read();
	        return '\b'

	    case 'f':
	        read();
	        return '\f'

	    case 'n':
	        read();
	        return '\n'

	    case 'r':
	        read();
	        return '\r'

	    case 't':
	        read();
	        return '\t'

	    case 'v':
	        read();
	        return '\v'

	    case '0':
	        read();
	        if (util.isDigit(peek())) {
	            throw invalidChar(read())
	        }

	        return '\0'

	    case 'x':
	        read();
	        return hexEscape()

	    case 'u':
	        read();
	        return unicodeEscape()

	    case '\n':
	    case '\u2028':
	    case '\u2029':
	        read();
	        return ''

	    case '\r':
	        read();
	        if (peek() === '\n') {
	            read();
	        }

	        return ''

	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	    case '8':
	    case '9':
	        throw invalidChar(read())

	    case undefined:
	        throw invalidChar(read())
	    }

	    return read()
	}

	function hexEscape () {
	    var buffer = '';
	    var c = peek();

	    if (!util.isHexDigit(c)) {
	        throw invalidChar(read())
	    }

	    buffer += read();

	    c = peek();
	    if (!util.isHexDigit(c)) {
	        throw invalidChar(read())
	    }

	    buffer += read();

	    return String.fromCodePoint(parseInt(buffer, 16))
	}

	function unicodeEscape () {
	    var buffer = '';
	    var count = 4;

	    while (count-- > 0) {
	        var c = peek();
	        if (!util.isHexDigit(c)) {
	            throw invalidChar(read())
	        }

	        buffer += read();
	    }

	    return String.fromCodePoint(parseInt(buffer, 16))
	}

	var parseStates = {
	    start: function start () {
	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        push();
	    },

	    beforePropertyName: function beforePropertyName () {
	        switch (token.type) {
	        case 'identifier':
	        case 'string':
	            key = token.value;
	            parseState = 'afterPropertyName';
	            return

	        case 'punctuator':
	            // This code is unreachable since it's handled by the lexState.
	            // if (token.value !== '}') {
	            //     throw invalidToken()
	            // }

	            pop();
	            return

	        case 'eof':
	            throw invalidEOF()
	        }

	        // This code is unreachable since it's handled by the lexState.
	        // throw invalidToken()
	    },

	    afterPropertyName: function afterPropertyName () {
	        // This code is unreachable since it's handled by the lexState.
	        // if (token.type !== 'punctuator' || token.value !== ':') {
	        //     throw invalidToken()
	        // }

	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        parseState = 'beforePropertyValue';
	    },

	    beforePropertyValue: function beforePropertyValue () {
	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        push();
	    },

	    beforeArrayValue: function beforeArrayValue () {
	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        if (token.type === 'punctuator' && token.value === ']') {
	            pop();
	            return
	        }

	        push();
	    },

	    afterPropertyValue: function afterPropertyValue () {
	        // This code is unreachable since it's handled by the lexState.
	        // if (token.type !== 'punctuator') {
	        //     throw invalidToken()
	        // }

	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        switch (token.value) {
	        case ',':
	            parseState = 'beforePropertyName';
	            return

	        case '}':
	            pop();
	        }

	        // This code is unreachable since it's handled by the lexState.
	        // throw invalidToken()
	    },

	    afterArrayValue: function afterArrayValue () {
	        // This code is unreachable since it's handled by the lexState.
	        // if (token.type !== 'punctuator') {
	        //     throw invalidToken()
	        // }

	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        switch (token.value) {
	        case ',':
	            parseState = 'beforeArrayValue';
	            return

	        case ']':
	            pop();
	        }

	        // This code is unreachable since it's handled by the lexState.
	        // throw invalidToken()
	    },

	    end: function end () {
	        // This code is unreachable since it's handled by the lexState.
	        // if (token.type !== 'eof') {
	        //     throw invalidToken()
	        // }
	    },
	};

	function push () {
	    var value;

	    switch (token.type) {
	    case 'punctuator':
	        switch (token.value) {
	        case '{':
	            value = {};
	            break

	        case '[':
	            value = [];
	            break
	        }

	        break

	    case 'null':
	    case 'boolean':
	    case 'numeric':
	    case 'string':
	        value = token.value;
	        break

	    // This code is unreachable.
	    // default:
	    //     throw invalidToken()
	    }

	    if (root === undefined) {
	        root = value;
	    } else {
	        var parent = stack[stack.length - 1];
	        if (Array.isArray(parent)) {
	            parent.push(value);
	        } else {
	            parent[key] = value;
	        }
	    }

	    if (value !== null && typeof value === 'object') {
	        stack.push(value);

	        if (Array.isArray(value)) {
	            parseState = 'beforeArrayValue';
	        } else {
	            parseState = 'beforePropertyName';
	        }
	    } else {
	        var current = stack[stack.length - 1];
	        if (current == null) {
	            parseState = 'end';
	        } else if (Array.isArray(current)) {
	            parseState = 'afterArrayValue';
	        } else {
	            parseState = 'afterPropertyValue';
	        }
	    }
	}

	function pop () {
	    stack.pop();

	    var current = stack[stack.length - 1];
	    if (current == null) {
	        parseState = 'end';
	    } else if (Array.isArray(current)) {
	        parseState = 'afterArrayValue';
	    } else {
	        parseState = 'afterPropertyValue';
	    }
	}

	// This code is unreachable.
	// function invalidParseState () {
	//     return new Error(`JSON5: invalid parse state '${parseState}'`)
	// }

	// This code is unreachable.
	// function invalidLexState (state) {
	//     return new Error(`JSON5: invalid lex state '${state}'`)
	// }

	function invalidChar (c) {
	    if (c === undefined) {
	        return syntaxError(("JSON5: invalid end of input at " + line + ":" + column))
	    }

	    return syntaxError(("JSON5: invalid character '" + (formatChar(c)) + "' at " + line + ":" + column))
	}

	function invalidEOF () {
	    return syntaxError(("JSON5: invalid end of input at " + line + ":" + column))
	}

	// This code is unreachable.
	// function invalidToken () {
	//     if (token.type === 'eof') {
	//         return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
	//     }

	//     const c = String.fromCodePoint(token.value.codePointAt(0))
	//     return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)
	// }

	function invalidIdentifier () {
	    column -= 5;
	    return syntaxError(("JSON5: invalid identifier character at " + line + ":" + column))
	}

	function separatorChar (c) {
	    console.warn(("JSON5: '" + (formatChar(c)) + "' in strings is not valid ECMAScript; consider escaping"));
	}

	function formatChar (c) {
	    var replacements = {
	        "'": "\\'",
	        '"': '\\"',
	        '\\': '\\\\',
	        '\b': '\\b',
	        '\f': '\\f',
	        '\n': '\\n',
	        '\r': '\\r',
	        '\t': '\\t',
	        '\v': '\\v',
	        '\0': '\\0',
	        '\u2028': '\\u2028',
	        '\u2029': '\\u2029',
	    };

	    if (replacements[c]) {
	        return replacements[c]
	    }

	    if (c < ' ') {
	        var hexString = c.charCodeAt(0).toString(16);
	        return '\\x' + ('00' + hexString).substring(hexString.length)
	    }

	    return c
	}

	function syntaxError (message) {
	    var err = new SyntaxError(message);
	    err.lineNumber = line;
	    err.columnNumber = column;
	    return err
	}

	var stringify = function stringify (value, replacer, space) {
	    var stack = [];
	    var indent = '';
	    var propertyList;
	    var replacerFunc;
	    var gap = '';
	    var quote;

	    if (
	        replacer != null &&
	        typeof replacer === 'object' &&
	        !Array.isArray(replacer)
	    ) {
	        space = replacer.space;
	        quote = replacer.quote;
	        replacer = replacer.replacer;
	    }

	    if (typeof replacer === 'function') {
	        replacerFunc = replacer;
	    } else if (Array.isArray(replacer)) {
	        propertyList = [];
	        for (var i = 0, list = replacer; i < list.length; i += 1) {
	            var v = list[i];

	            var item = (void 0);

	            if (typeof v === 'string') {
	                item = v;
	            } else if (
	                typeof v === 'number' ||
	                v instanceof String ||
	                v instanceof Number
	            ) {
	                item = String(v);
	            }

	            if (item !== undefined && propertyList.indexOf(item) < 0) {
	                propertyList.push(item);
	            }
	        }
	    }

	    if (space instanceof Number) {
	        space = Number(space);
	    } else if (space instanceof String) {
	        space = String(space);
	    }

	    if (typeof space === 'number') {
	        if (space > 0) {
	            space = Math.min(10, Math.floor(space));
	            gap = '          '.substr(0, space);
	        }
	    } else if (typeof space === 'string') {
	        gap = space.substr(0, 10);
	    }

	    return serializeProperty('', {'': value})

	    function serializeProperty (key, holder) {
	        var value = holder[key];
	        if (value != null) {
	            if (typeof value.toJSON5 === 'function') {
	                value = value.toJSON5(key);
	            } else if (typeof value.toJSON === 'function') {
	                value = value.toJSON(key);
	            }
	        }

	        if (replacerFunc) {
	            value = replacerFunc.call(holder, key, value);
	        }

	        if (value instanceof Number) {
	            value = Number(value);
	        } else if (value instanceof String) {
	            value = String(value);
	        } else if (value instanceof Boolean) {
	            value = value.valueOf();
	        }

	        switch (value) {
	        case null: return 'null'
	        case true: return 'true'
	        case false: return 'false'
	        }

	        if (typeof value === 'string') {
	            return quoteString(value, false)
	        }

	        if (typeof value === 'number') {
	            return String(value)
	        }

	        if (typeof value === 'object') {
	            return Array.isArray(value) ? serializeArray(value) : serializeObject(value)
	        }

	        return undefined
	    }

	    function quoteString (value) {
	        var quotes = {
	            "'": 0.1,
	            '"': 0.2,
	        };

	        var replacements = {
	            "'": "\\'",
	            '"': '\\"',
	            '\\': '\\\\',
	            '\b': '\\b',
	            '\f': '\\f',
	            '\n': '\\n',
	            '\r': '\\r',
	            '\t': '\\t',
	            '\v': '\\v',
	            '\0': '\\0',
	            '\u2028': '\\u2028',
	            '\u2029': '\\u2029',
	        };

	        var product = '';

	        for (var i = 0; i < value.length; i++) {
	            var c = value[i];
	            switch (c) {
	            case "'":
	            case '"':
	                quotes[c]++;
	                product += c;
	                continue

	            case '\0':
	                if (util.isDigit(value[i + 1])) {
	                    product += '\\x00';
	                    continue
	                }
	            }

	            if (replacements[c]) {
	                product += replacements[c];
	                continue
	            }

	            if (c < ' ') {
	                var hexString = c.charCodeAt(0).toString(16);
	                product += '\\x' + ('00' + hexString).substring(hexString.length);
	                continue
	            }

	            product += c;
	        }

	        var quoteChar = quote || Object.keys(quotes).reduce(function (a, b) { return (quotes[a] < quotes[b]) ? a : b; });

	        product = product.replace(new RegExp(quoteChar, 'g'), replacements[quoteChar]);

	        return quoteChar + product + quoteChar
	    }

	    function serializeObject (value) {
	        if (stack.indexOf(value) >= 0) {
	            throw TypeError('Converting circular structure to JSON5')
	        }

	        stack.push(value);

	        var stepback = indent;
	        indent = indent + gap;

	        var keys = propertyList || Object.keys(value);
	        var partial = [];
	        for (var i = 0, list = keys; i < list.length; i += 1) {
	            var key = list[i];

	            var propertyString = serializeProperty(key, value);
	            if (propertyString !== undefined) {
	                var member = serializeKey(key) + ':';
	                if (gap !== '') {
	                    member += ' ';
	                }
	                member += propertyString;
	                partial.push(member);
	            }
	        }

	        var final;
	        if (partial.length === 0) {
	            final = '{}';
	        } else {
	            var properties;
	            if (gap === '') {
	                properties = partial.join(',');
	                final = '{' + properties + '}';
	            } else {
	                var separator = ',\n' + indent;
	                properties = partial.join(separator);
	                final = '{\n' + indent + properties + ',\n' + stepback + '}';
	            }
	        }

	        stack.pop();
	        indent = stepback;
	        return final
	    }

	    function serializeKey (key) {
	        if (key.length === 0) {
	            return quoteString(key, true)
	        }

	        var firstChar = String.fromCodePoint(key.codePointAt(0));
	        if (!util.isIdStartChar(firstChar)) {
	            return quoteString(key, true)
	        }

	        for (var i = firstChar.length; i < key.length; i++) {
	            if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {
	                return quoteString(key, true)
	            }
	        }

	        return key
	    }

	    function serializeArray (value) {
	        if (stack.indexOf(value) >= 0) {
	            throw TypeError('Converting circular structure to JSON5')
	        }

	        stack.push(value);

	        var stepback = indent;
	        indent = indent + gap;

	        var partial = [];
	        for (var i = 0; i < value.length; i++) {
	            var propertyString = serializeProperty(String(i), value);
	            partial.push((propertyString !== undefined) ? propertyString : 'null');
	        }

	        var final;
	        if (partial.length === 0) {
	            final = '[]';
	        } else {
	            if (gap === '') {
	                var properties = partial.join(',');
	                final = '[' + properties + ']';
	            } else {
	                var separator = ',\n' + indent;
	                var properties$1 = partial.join(separator);
	                final = '[\n' + indent + properties$1 + ',\n' + stepback + ']';
	            }
	        }

	        stack.pop();
	        indent = stepback;
	        return final
	    }
	};

	var JSON5 = {
	    parse: parse,
	    stringify: stringify,
	};

	var lib = JSON5;

	var es5 = lib;

	return es5;

})));


/***/ }),

/***/ "7c3f":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("d4cb");
var fails = __webpack_require__("72df");
var createElement = __webpack_require__("f2bf");

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ "7cad":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ install_queues; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ install_$q; });

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/package.json
var quasar_package = __webpack_require__("429f");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/plugins/Platform.js
var Platform = __webpack_require__("5094");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue/dist/vue.runtime.esm.js
var vue_runtime_esm = __webpack_require__("9869");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("9ac9");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/debounce.js
var debounce = __webpack_require__("9007");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/plugins/Screen.js




const SIZE_LIST = ['sm', 'md', 'lg', 'xl'];
const {
  passive
} = utils_event["f" /* listenOpts */];
/* harmony default export */ var Screen = ({
  width: 0,
  height: 0,
  name: 'xs',
  sizes: {
    sm: 600,
    md: 1024,
    lg: 1440,
    xl: 1920
  },
  lt: {
    sm: true,
    md: true,
    lg: true,
    xl: true
  },
  gt: {
    xs: false,
    sm: false,
    md: false,
    lg: false
  },
  xs: true,
  sm: false,
  md: false,
  lg: false,
  xl: false,
  setSizes: utils_event["g" /* noop */],
  setDebounce: utils_event["g" /* noop */],

  install($q, queues, cfg) {
    if (Platform["f" /* isSSR */] === true) {
      $q.screen = this;
      return;
    }

    const classes = cfg.screen !== void 0 && cfg.screen.bodyClasses === true;

    const update = force => {
      const w = window.innerWidth,
            h = window.innerHeight;

      if (h !== this.height) {
        this.height = h;
      }

      if (w !== this.width) {
        this.width = w;
      } else if (force !== true) {
        return;
      }

      let s = this.sizes;
      this.gt.xs = w >= s.sm;
      this.gt.sm = w >= s.md;
      this.gt.md = w >= s.lg;
      this.gt.lg = w >= s.xl;
      this.lt.sm = w < s.sm;
      this.lt.md = w < s.md;
      this.lt.lg = w < s.lg;
      this.lt.xl = w < s.xl;
      this.xs = this.lt.sm;
      this.sm = this.gt.xs === true && this.lt.md === true;
      this.md = this.gt.sm === true && this.lt.lg === true;
      this.lg = this.gt.md === true && this.lt.xl === true;
      this.xl = this.gt.lg;
      s = this.xs === true && 'xs' || this.sm === true && 'sm' || this.md === true && 'md' || this.lg === true && 'lg' || 'xl';

      if (s !== this.name) {
        if (classes === true) {
          document.body.classList.remove(`screen--${this.name}`);
          document.body.classList.add(`screen--${s}`);
        }

        this.name = s;
      }
    };

    let updateEvt,
        updateSizes = {},
        updateDebounce = 16;

    this.setSizes = sizes => {
      SIZE_LIST.forEach(name => {
        if (sizes[name] !== void 0) {
          updateSizes[name] = sizes[name];
        }
      });
    };

    this.setDebounce = deb => {
      updateDebounce = deb;
    };

    const start = () => {
      const style = getComputedStyle(document.body),
            target = window.visualViewport !== void 0 ? window.visualViewport : window; // if css props available

      if (style.getPropertyValue('--q-size-sm')) {
        SIZE_LIST.forEach(name => {
          this.sizes[name] = parseInt(style.getPropertyValue(`--q-size-${name}`), 10);
        });
      }

      this.setSizes = sizes => {
        SIZE_LIST.forEach(name => {
          if (sizes[name]) {
            this.sizes[name] = sizes[name];
          }
        });
        update(true);
      };

      this.setDebounce = delay => {
        updateEvt !== void 0 && target.removeEventListener('resize', updateEvt, passive);
        updateEvt = delay > 0 ? Object(debounce["a" /* default */])(update, delay) : update;
        target.addEventListener('resize', updateEvt, passive);
      };

      this.setDebounce(updateDebounce);

      if (Object.keys(updateSizes).length > 0) {
        this.setSizes(updateSizes);
        updateSizes = void 0; // free up memory
      } else {
        update();
      } // due to optimizations, this would be left out otherwise


      classes === true && this.name === 'xs' && document.body.classList.add(`screen--xs`);
    };

    if (Platform["c" /* fromSSR */] === true) {
      queues.takeover.push(start);
    } else {
      start();
    }

    vue_runtime_esm["default"].util.defineReactive($q, 'screen', this);
  }

});
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.string.replace.js
var es_string_replace = __webpack_require__("32f5");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/plugins/Dark.js




const Dark = {
  isActive: false,
  mode: false,

  install($q, queues, {
    dark
  }) {
    this.isActive = dark === true;

    if (Platform["f" /* isSSR */] === true) {
      queues.server.push((q, ctx) => {
        q.dark = {
          isActive: false,
          mode: false,
          set: val => {
            ctx.ssr.Q_BODY_CLASSES = ctx.ssr.Q_BODY_CLASSES.replace(' body--light', '').replace(' body--dark', '') + ` body--${val === true ? 'dark' : 'light'}`;
            q.dark.isActive = val === true;
            q.dark.mode = val;
          },
          toggle: () => {
            q.dark.set(q.dark.isActive === false);
          }
        };
        q.dark.set(dark);
      });
      this.set = utils_event["g" /* noop */];
      return;
    }

    const initialVal = dark !== void 0 ? dark : false;

    if (Platform["c" /* fromSSR */] === true) {
      const ssrSet = val => {
        this.__fromSSR = val;
      };

      const originalSet = this.set;
      this.set = ssrSet;
      ssrSet(initialVal);
      queues.takeover.push(() => {
        this.set = originalSet;
        this.set(this.__fromSSR);
      });
    } else {
      this.set(initialVal);
    }

    vue_runtime_esm["default"].util.defineReactive(this, 'isActive', this.isActive);
    vue_runtime_esm["default"].util.defineReactive($q, 'dark', this);
  },

  set(val) {
    this.mode = val;

    if (val === 'auto') {
      if (this.__media === void 0) {
        this.__media = window.matchMedia('(prefers-color-scheme: dark)');

        this.__updateMedia = () => {
          this.set('auto');
        };

        this.__media.addListener(this.__updateMedia);
      }

      val = this.__media.matches;
    } else if (this.__media !== void 0) {
      this.__media.removeListener(this.__updateMedia);

      this.__media = void 0;
    }

    this.isActive = val === true;
    document.body.classList.remove(`body--${val === true ? 'light' : 'dark'}`);
    document.body.classList.add(`body--${val === true ? 'dark' : 'light'}`);
  },

  toggle() {
    Dark.set(Dark.isActive === false);
  },

  __media: void 0
};
/* harmony default export */ var plugins_Dark = (Dark);
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/history.js
var src_history = __webpack_require__("7747");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/lang.js
var lang = __webpack_require__("cfa7");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/colors.js
var colors = __webpack_require__("134d");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/key-composition.js
var key_composition = __webpack_require__("1b63");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/body.js






function getMobilePlatform(is) {
  if (is.ios === true) return 'ios';
  if (is.android === true) return 'android';
}

function getBodyClasses({
  is,
  has,
  within
}, cfg) {
  const cls = [is.desktop === true ? 'desktop' : 'mobile', `${has.touch === false ? 'no-' : ''}touch`];

  if (is.mobile === true) {
    const mobile = getMobilePlatform(is);
    mobile !== void 0 && cls.push('platform-' + mobile);
  }

  if (is.nativeMobile === true) {
    const type = is.nativeMobileWrapper;
    cls.push(type);
    cls.push('native-mobile');

    if (is.ios === true && (cfg[type] === void 0 || cfg[type].iosStatusBarPadding !== false)) {
      cls.push('q-ios-padding');
    }
  } else if (is.electron === true) {
    cls.push('electron');
  } else if (is.bex === true) {
    cls.push('bex');
  }

  within.iframe === true && cls.push('within-iframe');
  return cls;
} // SSR takeover corrections


function clientUpdate() {
  const classes = document.body.className;
  let newCls = classes;

  if (Platform["d" /* iosCorrection */] !== void 0) {
    newCls = newCls.replace('desktop', 'platform-ios mobile');
  }

  if (Platform["a" /* client */].has.touch === true) {
    newCls = newCls.replace('no-touch', 'touch');
  }

  if (Platform["a" /* client */].within.iframe === true) {
    newCls += ' within-iframe';
  }

  if (classes !== newCls) {
    document.body.className = newCls;
  }
}

function setColors(brand) {
  for (const color in brand) {
    Object(colors["h" /* setBrand */])(color, brand[color]);
  }
}

/* harmony default export */ var body = ({
  install(queues, cfg) {
    if (Platform["f" /* isSSR */] === true) {
      queues.server.push((q, ctx) => {
        const cls = getBodyClasses(q.platform, cfg),
              fn = ctx.ssr.setBodyClasses;

        if (cfg.screen !== void 0 && cfg.screen.bodyClass === true) {
          cls.push('screen--xs');
        }

        if (typeof fn === 'function') {
          fn(cls);
        } else {
          ctx.ssr.Q_BODY_CLASSES = cls.join(' ');
        }
      });
      return;
    }

    if (Platform["c" /* fromSSR */] === true) {
      clientUpdate();
    } else {
      const cls = getBodyClasses(Platform["a" /* client */], cfg);

      if (Platform["a" /* client */].is.ie === true && Platform["a" /* client */].is.versionNumber === 11) {
        cls.forEach(c => document.body.classList.add(c));
      } else {
        document.body.classList.add.apply(document.body.classList, cls);
      }
    }

    cfg.brand !== void 0 && setColors(cfg.brand);

    if (Platform["a" /* client */].is.ios === true) {
      // needed for iOS button active state
      document.body.addEventListener('touchstart', utils_event["g" /* noop */]);
    }

    window.addEventListener('keydown', key_composition["b" /* onKeyDownComposition */], true);
  }

});
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/icon-set.js
var icon_set = __webpack_require__("e57e");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/install.js








const autoInstalled = [Platform["b" /* default */], Screen, plugins_Dark];
const install_queues = {
  server: [],
  // on SSR update
  takeover: [] // on client takeover

};
const install_$q = {
  version: quasar_package["a" /* version */],
  config: {}
};
/* harmony default export */ var install = __webpack_exports__["b"] = (function (Vue, opts = {}) {
  if (this.__qInstalled === true) {
    return;
  }

  this.__qInstalled = true;
  const cfg = install_$q.config = Object.freeze(opts.config || {}); // required plugins

  Platform["b" /* default */].install(install_$q, install_queues);
  body.install(install_queues, cfg);
  plugins_Dark.install(install_$q, install_queues, cfg);
  Screen.install(install_$q, install_queues, cfg);
  src_history["a" /* default */].install(cfg);
  lang["a" /* default */].install(install_$q, install_queues, opts.lang);
  icon_set["a" /* default */].install(install_$q, install_queues, opts.iconSet);

  if (Platform["f" /* isSSR */] === true) {
    Vue.mixin({
      beforeCreate() {
        this.$q = this.$root.$options.$q;
      }

    });
  } else {
    Vue.prototype.$q = install_$q;
  }

  opts.components && Object.keys(opts.components).forEach(key => {
    const c = opts.components[key];

    if (typeof c === 'function') {
      Vue.component(c.options.name, c);
    }
  });
  opts.directives && Object.keys(opts.directives).forEach(key => {
    const d = opts.directives[key];

    if (d.name !== undefined && d.unbind !== void 0) {
      Vue.directive(d.name, d);
    }
  });

  if (opts.plugins) {
    const param = {
      $q: install_$q,
      queues: install_queues,
      cfg
    };
    Object.keys(opts.plugins).forEach(key => {
      const p = opts.plugins[key];

      if (typeof p.install === 'function' && autoInstalled.includes(p) === false) {
        p.install(param);
      }
    });
  }
});

/***/ }),

/***/ "7d15":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "7d23":
/***/ (function(module, exports, __webpack_require__) {

var toObject = __webpack_require__("37d1");
var toLength = __webpack_require__("b495");
var getIteratorMethod = __webpack_require__("0446");
var isArrayIteratorMethod = __webpack_require__("c965");
var bind = __webpack_require__("2117");
var aTypedArrayConstructor = __webpack_require__("aaf2").aTypedArrayConstructor;

module.exports = function from(source /* , mapfn, thisArg */) {
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, step, iterator, next;
  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    O = [];
    while (!(step = next.call(iterator)).done) {
      O.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = bind(mapfn, arguments[2], 2);
  }
  length = toLength(O.length);
  result = new (aTypedArrayConstructor(this))(length);
  for (i = 0; length > i; i++) {
    result[i] = mapping ? mapfn(O[i], i) : O[i];
  }
  return result;
};


/***/ }),

/***/ "7d53":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("f498");
var shared = __webpack_require__("4cdd");
var has = __webpack_require__("f1a7");
var uid = __webpack_require__("1d8a");
var NATIVE_SYMBOL = __webpack_require__("e7a0");
var USE_SYMBOL_AS_UID = __webpack_require__("4db4");

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    if (NATIVE_SYMBOL && has(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ "7dfd":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export getType */
/* unused harmony export isAnyObject */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isArray; });
/* unused harmony export isBlob */
/* unused harmony export isBoolean */
/* unused harmony export isDate */
/* unused harmony export isEmptyArray */
/* unused harmony export isEmptyObject */
/* unused harmony export isEmptyString */
/* unused harmony export isError */
/* unused harmony export isFile */
/* unused harmony export isFullArray */
/* unused harmony export isFullObject */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isFullString; });
/* unused harmony export isFunction */
/* unused harmony export isMap */
/* unused harmony export isNaNValue */
/* unused harmony export isNull */
/* unused harmony export isNullOrUndefined */
/* unused harmony export isNumber */
/* unused harmony export isObject */
/* unused harmony export isObjectLike */
/* unused harmony export isOneOf */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return isPlainObject; });
/* unused harmony export isPrimitive */
/* unused harmony export isPromise */
/* unused harmony export isRegExp */
/* unused harmony export isSet */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isString; });
/* unused harmony export isSymbol */
/* unused harmony export isType */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return isUndefined; });
/* unused harmony export isWeakMap */
/* unused harmony export isWeakSet */
/**
 * Returns the object type of the given payload
 *
 * @param {*} payload
 * @returns {string}
 */
function getType(payload) {
    return Object.prototype.toString.call(payload).slice(8, -1);
}
/**
 * Returns whether the payload is undefined
 *
 * @param {*} payload
 * @returns {payload is undefined}
 */
function isUndefined(payload) {
    return getType(payload) === 'Undefined';
}
/**
 * Returns whether the payload is null
 *
 * @param {*} payload
 * @returns {payload is null}
 */
function isNull(payload) {
    return getType(payload) === 'Null';
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isPlainObject(payload) {
    if (getType(payload) !== 'Object')
        return false;
    return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isObject(payload) {
    return isPlainObject(payload);
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is { [K in any]: never }}
 */
function isEmptyObject(payload) {
    return isPlainObject(payload) && Object.keys(payload).length === 0;
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isFullObject(payload) {
    return isPlainObject(payload) && Object.keys(payload).length > 0;
}
/**
 * Returns whether the payload is an any kind of object (including special classes or objects with different prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isAnyObject(payload) {
    return getType(payload) === 'Object';
}
/**
 * Returns whether the payload is an object like a type passed in < >
 *
 * Usage: isObjectLike<{id: any}>(payload) // will make sure it's an object and has an `id` prop.
 *
 * @template T this must be passed in < >
 * @param {*} payload
 * @returns {payload is T}
 */
function isObjectLike(payload) {
    return isAnyObject(payload);
}
/**
 * Returns whether the payload is a function (regular or async)
 *
 * @param {*} payload
 * @returns {payload is AnyFunction}
 */
function isFunction(payload) {
    return typeof payload === 'function';
}
/**
 * Returns whether the payload is an array
 *
 * @param {any} payload
 * @returns {payload is any[]}
 */
function isArray(payload) {
    return getType(payload) === 'Array';
}
/**
 * Returns whether the payload is a an array with at least 1 item
 *
 * @param {*} payload
 * @returns {payload is any[]}
 */
function isFullArray(payload) {
    return isArray(payload) && payload.length > 0;
}
/**
 * Returns whether the payload is a an empty array
 *
 * @param {*} payload
 * @returns {payload is []}
 */
function isEmptyArray(payload) {
    return isArray(payload) && payload.length === 0;
}
/**
 * Returns whether the payload is a string
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isString(payload) {
    return getType(payload) === 'String';
}
/**
 * Returns whether the payload is a string, BUT returns false for ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isFullString(payload) {
    return isString(payload) && payload !== '';
}
/**
 * Returns whether the payload is ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isEmptyString(payload) {
    return payload === '';
}
/**
 * Returns whether the payload is a number (but not NaN)
 *
 * This will return `false` for `NaN`!!
 *
 * @param {*} payload
 * @returns {payload is number}
 */
function isNumber(payload) {
    return getType(payload) === 'Number' && !isNaN(payload);
}
/**
 * Returns whether the payload is a boolean
 *
 * @param {*} payload
 * @returns {payload is boolean}
 */
function isBoolean(payload) {
    return getType(payload) === 'Boolean';
}
/**
 * Returns whether the payload is a regular expression (RegExp)
 *
 * @param {*} payload
 * @returns {payload is RegExp}
 */
function isRegExp(payload) {
    return getType(payload) === 'RegExp';
}
/**
 * Returns whether the payload is a Map
 *
 * @param {*} payload
 * @returns {payload is Map<any, any>}
 */
function isMap(payload) {
    return getType(payload) === 'Map';
}
/**
 * Returns whether the payload is a WeakMap
 *
 * @param {*} payload
 * @returns {payload is WeakMap<any, any>}
 */
function isWeakMap(payload) {
    return getType(payload) === 'WeakMap';
}
/**
 * Returns whether the payload is a Set
 *
 * @param {*} payload
 * @returns {payload is Set<any>}
 */
function isSet(payload) {
    return getType(payload) === 'Set';
}
/**
 * Returns whether the payload is a WeakSet
 *
 * @param {*} payload
 * @returns {payload is WeakSet<any>}
 */
function isWeakSet(payload) {
    return getType(payload) === 'WeakSet';
}
/**
 * Returns whether the payload is a Symbol
 *
 * @param {*} payload
 * @returns {payload is symbol}
 */
function isSymbol(payload) {
    return getType(payload) === 'Symbol';
}
/**
 * Returns whether the payload is a Date, and that the date is valid
 *
 * @param {*} payload
 * @returns {payload is Date}
 */
function isDate(payload) {
    return getType(payload) === 'Date' && !isNaN(payload);
}
/**
 * Returns whether the payload is a Blob
 *
 * @param {*} payload
 * @returns {payload is Blob}
 */
function isBlob(payload) {
    return getType(payload) === 'Blob';
}
/**
 * Returns whether the payload is a File
 *
 * @param {*} payload
 * @returns {payload is File}
 */
function isFile(payload) {
    return getType(payload) === 'File';
}
/**
 * Returns whether the payload is a Promise
 *
 * @param {*} payload
 * @returns {payload is Promise<any>}
 */
function isPromise(payload) {
    return getType(payload) === 'Promise';
}
/**
 * Returns whether the payload is an Error
 *
 * @param {*} payload
 * @returns {payload is Error}
 */
function isError(payload) {
    return getType(payload) === 'Error';
}
/**
 * Returns whether the payload is literally the value `NaN` (it's `NaN` and also a `number`)
 *
 * @param {*} payload
 * @returns {payload is typeof NaN}
 */
function isNaNValue(payload) {
    return getType(payload) === 'Number' && isNaN(payload);
}
/**
 * Returns whether the payload is a primitive type (eg. Boolean | Null | Undefined | Number | String | Symbol)
 *
 * @param {*} payload
 * @returns {(payload is boolean | null | undefined | number | string | symbol)}
 */
function isPrimitive(payload) {
    return (isBoolean(payload) ||
        isNull(payload) ||
        isUndefined(payload) ||
        isNumber(payload) ||
        isString(payload) ||
        isSymbol(payload));
}
/**
 * Returns true whether the payload is null or undefined
 *
 * @param {*} payload
 * @returns {(payload is null | undefined)}
 */
var isNullOrUndefined = isOneOf(isNull, isUndefined);
function isOneOf(a, b, c, d, e) {
    return function (value) {
        return a(value) || b(value) || (!!c && c(value)) || (!!d && d(value)) || (!!e && e(value));
    };
}
/**
 * Does a generic check to check that the given payload is of a given type.
 * In cases like Number, it will return true for NaN as NaN is a Number (thanks javascript!);
 * It will, however, differentiate between object and null
 *
 * @template T
 * @param {*} payload
 * @param {T} type
 * @throws {TypeError} Will throw type error if type is an invalid type
 * @returns {payload is T}
 */
function isType(payload, type) {
    if (!(type instanceof Function)) {
        throw new TypeError('Type must be a function');
    }
    if (!Object.prototype.hasOwnProperty.call(type, 'prototype')) {
        throw new TypeError('Type is not a class');
    }
    // Classes usually have names (as functions usually have names)
    var name = type.name;
    return getType(payload) === name || Boolean(payload && payload.constructor === type);
}




/***/ }),

/***/ "7f8a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__("72df");

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
    method.call(null, argument || function () { throw 1; }, 1);
  });
};


/***/ }),

/***/ "802e":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("72df");

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ "8047":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getScrollTarget; });
/* unused harmony export getScrollHeight */
/* unused harmony export getScrollWidth */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getScrollPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getHorizontalScrollPosition; });
/* unused harmony export animScrollTo */
/* unused harmony export animHorizontalScrollTo */
/* unused harmony export setScrollPosition */
/* unused harmony export setHorizontalScrollPosition */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return getScrollbarWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return hasScrollbar; });
/* harmony import */ var _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5094");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("3230");


const scrollTargets = _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__[/* isSSR */ "f"] === false ? [null, document, document.body, document.scrollingElement, document.documentElement] : [];
function getScrollTarget(el, target) {
  if (typeof target === 'string') {
    try {
      target = document.querySelector(target);
    } catch (err) {
      target = void 0;
    }
  }

  if (target === void 0 || target === null) {
    target = el.closest('.scroll,.scroll-y,.overflow-auto');
  } else if (target._isVue === true && target.$el !== void 0) {
    target = target.$el;
  }

  return scrollTargets.includes(target) ? window : target;
}
function getScrollHeight(el) {
  return (el === window ? document.body : el).scrollHeight;
}
function getScrollWidth(el) {
  return (el === window ? document.body : el).scrollWidth;
}
function getScrollPosition(scrollTarget) {
  if (scrollTarget === window) {
    return window.pageYOffset || window.scrollY || document.body.scrollTop || 0;
  }

  return scrollTarget.scrollTop;
}
function getHorizontalScrollPosition(scrollTarget) {
  if (scrollTarget === window) {
    return window.pageXOffset || window.scrollX || document.body.scrollLeft || 0;
  }

  return scrollTarget.scrollLeft;
}
function animScrollTo(el, to, duration = 0
/* , prevTime */
) {
  const prevTime = arguments[3] === void 0 ? performance.now() : arguments[3];
  const pos = getScrollPosition(el);

  if (duration <= 0) {
    if (pos !== to) {
      setScroll(el, to);
    }

    return;
  }

  requestAnimationFrame(nowTime => {
    const frameTime = nowTime - prevTime;
    const newPos = pos + (to - pos) / Math.max(frameTime, duration) * frameTime;
    setScroll(el, newPos);

    if (newPos !== to) {
      animScrollTo(el, to, duration - frameTime, nowTime);
    }
  });
}
function animHorizontalScrollTo(el, to, duration = 0
/* , prevTime */
) {
  const prevTime = arguments[3] === void 0 ? performance.now() : arguments[3];
  const pos = getHorizontalScrollPosition(el);

  if (duration <= 0) {
    if (pos !== to) {
      setHorizontalScroll(el, to);
    }

    return;
  }

  requestAnimationFrame(nowTime => {
    const frameTime = nowTime - prevTime;
    const newPos = pos + (to - pos) / Math.max(frameTime, duration) * frameTime;
    setHorizontalScroll(el, newPos);

    if (newPos !== to) {
      animHorizontalScrollTo(el, to, duration - frameTime, nowTime);
    }
  });
}

function setScroll(scrollTarget, offset) {
  if (scrollTarget === window) {
    window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, offset);
    return;
  }

  scrollTarget.scrollTop = offset;
}

function setHorizontalScroll(scrollTarget, offset) {
  if (scrollTarget === window) {
    window.scrollTo(offset, window.pageYOffset || window.scrollY || document.body.scrollTop || 0);
    return;
  }

  scrollTarget.scrollLeft = offset;
}

function setScrollPosition(scrollTarget, offset, duration) {
  if (duration) {
    animScrollTo(scrollTarget, offset, duration);
    return;
  }

  setScroll(scrollTarget, offset);
}
function setHorizontalScrollPosition(scrollTarget, offset, duration) {
  if (duration) {
    animHorizontalScrollTo(scrollTarget, offset, duration);
    return;
  }

  setHorizontalScroll(scrollTarget, offset);
}
let size;
function getScrollbarWidth() {
  if (size !== undefined) {
    return size;
  }

  const inner = document.createElement('p'),
        outer = document.createElement('div');
  Object(_dom_js__WEBPACK_IMPORTED_MODULE_1__[/* css */ "b"])(inner, {
    width: '100%',
    height: '200px'
  });
  Object(_dom_js__WEBPACK_IMPORTED_MODULE_1__[/* css */ "b"])(outer, {
    position: 'absolute',
    top: '0px',
    left: '0px',
    visibility: 'hidden',
    width: '200px',
    height: '150px',
    overflow: 'hidden'
  });
  outer.appendChild(inner);
  document.body.appendChild(outer);
  const w1 = inner.offsetWidth;
  outer.style.overflow = 'scroll';
  let w2 = inner.offsetWidth;

  if (w1 === w2) {
    w2 = outer.clientWidth;
  }

  outer.remove();
  size = w1 - w2;
  return size;
}
function hasScrollbar(el, onY = true) {
  if (!el || el.nodeType !== Node.ELEMENT_NODE) {
    return false;
  }

  return onY ? el.scrollHeight > el.clientHeight && (el.classList.contains('scroll') || el.classList.contains('overflow-auto') || ['auto', 'scroll'].includes(window.getComputedStyle(el)['overflow-y'])) : el.scrollWidth > el.clientWidth && (el.classList.contains('scroll') || el.classList.contains('overflow-auto') || ['auto', 'scroll'].includes(window.getComputedStyle(el)['overflow-x']));
}
/* harmony default export */ __webpack_exports__["a"] = ({
  getScrollTarget,
  getScrollHeight,
  getScrollWidth,
  getScrollPosition,
  getHorizontalScrollPosition,
  animScrollTo,
  animHorizontalScrollTo,
  setScrollPosition,
  setHorizontalScrollPosition,
  getScrollbarWidth,
  hasScrollbar
});

/***/ }),

/***/ "82e8":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("157c");
var defineProperties = __webpack_require__("b99b");
var enumBugKeys = __webpack_require__("b17e");
var hiddenKeys = __webpack_require__("d687");
var html = __webpack_require__("9324");
var documentCreateElement = __webpack_require__("f2bf");
var sharedKey = __webpack_require__("332c");

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    /* global ActiveXObject -- old IE */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : defineProperties(result, Properties);
};


/***/ }),

/***/ "83a6":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("72df");
var classof = __webpack_require__("6a61");

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),

/***/ "8548":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarSelect_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("fdad");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarSelect_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarSelect_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "8573":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("f498");
var getOwnPropertyDescriptor = __webpack_require__("185a").f;
var macrotask = __webpack_require__("2435").set;
var IS_IOS = __webpack_require__("e03e");
var IS_WEBOS_WEBKIT = __webpack_require__("1d2e");
var IS_NODE = __webpack_require__("f117");

var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var document = global.document;
var process = global.process;
var Promise = global.Promise;
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

var flush, head, last, notify, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify();
        else last = undefined;
        throw error;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
  if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true });
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    then = promise.then;
    notify = function () {
      then.call(promise, flush);
    };
  // Node.js without promises
  } else if (IS_NODE) {
    notify = function () {
      process.nextTick(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }
}

module.exports = queueMicrotask || function (fn) {
  var task = { fn: fn, next: undefined };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify();
  } last = task;
};


/***/ }),

/***/ "8697":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};


/***/ }),

/***/ "86a3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return testPattern; });
// file referenced from docs
const hex = /^#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?$/,
      hexa = /^#[0-9a-fA-F]{4}([0-9a-fA-F]{4})?$/,
      hexOrHexa = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/,
      rgb = /^rgb\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5])\)$/,
      rgba = /^rgba\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/;
const testPattern = {
  date: v => /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(v),
  time: v => /^([0-1]?\d|2[0-3]):[0-5]\d$/.test(v),
  fulltime: v => /^([0-1]?\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(v),
  timeOrFulltime: v => /^([0-1]?\d|2[0-3]):[0-5]\d(:[0-5]\d)?$/.test(v),
  hexColor: v => hex.test(v),
  hexaColor: v => hexa.test(v),
  hexOrHexaColor: v => hexOrHexa.test(v),
  rgbColor: v => rgb.test(v),
  rgbaColor: v => rgba.test(v),
  rgbOrRgbaColor: v => rgb.test(v) || rgba.test(v),
  hexOrRgbColor: v => hex.test(v) || rgb.test(v),
  hexaOrRgbaColor: v => hexa.test(v) || rgba.test(v),
  anyColor: v => hexOrHexa.test(v) || rgb.test(v) || rgba.test(v)
};
/* unused harmony default export */ var _unused_webpack_default_export = ({
  testPattern
});

/***/ }),

/***/ "87b2":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  props: {
    dark: {
      type: Boolean,
      default: null
    }
  },
  computed: {
    isDark() {
      return this.dark === null ? this.$q.dark.isActive : this.dark;
    }

  }
});

/***/ }),

/***/ "87c8":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FormFieldMixin; });
/* harmony default export */ __webpack_exports__["b"] = ({
  props: {
    name: String
  },
  computed: {
    formAttrs() {
      return {
        type: 'hidden',
        name: this.name,
        value: this.value
      };
    }

  },
  methods: {
    __injectFormInput(child, action, className) {
      child[action](this.$createElement('input', {
        staticClass: 'hidden',
        class: className,
        attrs: this.formAttrs,
        domProps: this.formDomProps
      }));
    }

  }
});
const FormFieldMixin = {
  props: {
    name: String
  },
  computed: {
    nameProp() {
      return this.name || this.for;
    }

  }
};

/***/ }),

/***/ "881c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__("8697");

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
};

// 25.4.1.5 NewPromiseCapability(C)
module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "8bb2":
/***/ (function(module, exports) {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.es/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),

/***/ "8bc7":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ACESFilmicToneMapping */
/* unused harmony export AddEquation */
/* unused harmony export AddOperation */
/* unused harmony export AdditiveAnimationBlendMode */
/* unused harmony export AdditiveBlending */
/* unused harmony export AlphaFormat */
/* unused harmony export AlwaysDepth */
/* unused harmony export AlwaysStencilFunc */
/* unused harmony export AmbientLight */
/* unused harmony export AmbientLightProbe */
/* unused harmony export AnimationClip */
/* unused harmony export AnimationLoader */
/* unused harmony export AnimationMixer */
/* unused harmony export AnimationObjectGroup */
/* unused harmony export AnimationUtils */
/* unused harmony export ArcCurve */
/* unused harmony export ArrayCamera */
/* unused harmony export ArrowHelper */
/* unused harmony export Audio */
/* unused harmony export AudioAnalyser */
/* unused harmony export AudioContext */
/* unused harmony export AudioListener */
/* unused harmony export AudioLoader */
/* unused harmony export AxesHelper */
/* unused harmony export AxisHelper */
/* unused harmony export BackSide */
/* unused harmony export BasicDepthPacking */
/* unused harmony export BasicShadowMap */
/* unused harmony export BinaryTextureLoader */
/* unused harmony export Bone */
/* unused harmony export BooleanKeyframeTrack */
/* unused harmony export BoundingBoxHelper */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Box2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Box3; });
/* unused harmony export Box3Helper */
/* unused harmony export BoxBufferGeometry */
/* unused harmony export BoxGeometry */
/* unused harmony export BoxHelper */
/* unused harmony export BufferAttribute */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return BufferGeometry; });
/* unused harmony export BufferGeometryLoader */
/* unused harmony export ByteType */
/* unused harmony export Cache */
/* unused harmony export Camera */
/* unused harmony export CameraHelper */
/* unused harmony export CanvasRenderer */
/* unused harmony export CanvasTexture */
/* unused harmony export CatmullRomCurve3 */
/* unused harmony export CineonToneMapping */
/* unused harmony export CircleBufferGeometry */
/* unused harmony export CircleGeometry */
/* unused harmony export ClampToEdgeWrapping */
/* unused harmony export Clock */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return Color; });
/* unused harmony export ColorKeyframeTrack */
/* unused harmony export CompressedTexture */
/* unused harmony export CompressedTextureLoader */
/* unused harmony export ConeBufferGeometry */
/* unused harmony export ConeGeometry */
/* unused harmony export CubeCamera */
/* unused harmony export CubeReflectionMapping */
/* unused harmony export CubeRefractionMapping */
/* unused harmony export CubeTexture */
/* unused harmony export CubeTextureLoader */
/* unused harmony export CubeUVReflectionMapping */
/* unused harmony export CubeUVRefractionMapping */
/* unused harmony export CubicBezierCurve */
/* unused harmony export CubicBezierCurve3 */
/* unused harmony export CubicInterpolant */
/* unused harmony export CullFaceBack */
/* unused harmony export CullFaceFront */
/* unused harmony export CullFaceFrontBack */
/* unused harmony export CullFaceNone */
/* unused harmony export Curve */
/* unused harmony export CurvePath */
/* unused harmony export CustomBlending */
/* unused harmony export CustomToneMapping */
/* unused harmony export CylinderBufferGeometry */
/* unused harmony export CylinderGeometry */
/* unused harmony export Cylindrical */
/* unused harmony export DataTexture */
/* unused harmony export DataTexture2DArray */
/* unused harmony export DataTexture3D */
/* unused harmony export DataTextureLoader */
/* unused harmony export DataUtils */
/* unused harmony export DecrementStencilOp */
/* unused harmony export DecrementWrapStencilOp */
/* unused harmony export DefaultLoadingManager */
/* unused harmony export DepthFormat */
/* unused harmony export DepthStencilFormat */
/* unused harmony export DepthTexture */
/* unused harmony export DirectionalLight */
/* unused harmony export DirectionalLightHelper */
/* unused harmony export DiscreteInterpolant */
/* unused harmony export DodecahedronBufferGeometry */
/* unused harmony export DodecahedronGeometry */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return DoubleSide; });
/* unused harmony export DstAlphaFactor */
/* unused harmony export DstColorFactor */
/* unused harmony export DynamicBufferAttribute */
/* unused harmony export DynamicCopyUsage */
/* unused harmony export DynamicDrawUsage */
/* unused harmony export DynamicReadUsage */
/* unused harmony export EdgesGeometry */
/* unused harmony export EdgesHelper */
/* unused harmony export EllipseCurve */
/* unused harmony export EqualDepth */
/* unused harmony export EqualStencilFunc */
/* unused harmony export EquirectangularReflectionMapping */
/* unused harmony export EquirectangularRefractionMapping */
/* unused harmony export Euler */
/* unused harmony export EventDispatcher */
/* unused harmony export ExtrudeBufferGeometry */
/* unused harmony export ExtrudeGeometry */
/* unused harmony export FaceColors */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return FileLoader; });
/* unused harmony export FlatShading */
/* unused harmony export Float16BufferAttribute */
/* unused harmony export Float32Attribute */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return Float32BufferAttribute; });
/* unused harmony export Float64Attribute */
/* unused harmony export Float64BufferAttribute */
/* unused harmony export FloatType */
/* unused harmony export Fog */
/* unused harmony export FogExp2 */
/* unused harmony export Font */
/* unused harmony export FontLoader */
/* unused harmony export FrontSide */
/* unused harmony export Frustum */
/* unused harmony export GLBufferAttribute */
/* unused harmony export GLSL1 */
/* unused harmony export GLSL3 */
/* unused harmony export GammaEncoding */
/* unused harmony export GreaterDepth */
/* unused harmony export GreaterEqualDepth */
/* unused harmony export GreaterEqualStencilFunc */
/* unused harmony export GreaterStencilFunc */
/* unused harmony export GridHelper */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return Group; });
/* unused harmony export HalfFloatType */
/* unused harmony export HemisphereLight */
/* unused harmony export HemisphereLightHelper */
/* unused harmony export HemisphereLightProbe */
/* unused harmony export IcosahedronBufferGeometry */
/* unused harmony export IcosahedronGeometry */
/* unused harmony export ImageBitmapLoader */
/* unused harmony export ImageLoader */
/* unused harmony export ImageUtils */
/* unused harmony export ImmediateRenderObject */
/* unused harmony export IncrementStencilOp */
/* unused harmony export IncrementWrapStencilOp */
/* unused harmony export InstancedBufferAttribute */
/* unused harmony export InstancedBufferGeometry */
/* unused harmony export InstancedInterleavedBuffer */
/* unused harmony export InstancedMesh */
/* unused harmony export Int16Attribute */
/* unused harmony export Int16BufferAttribute */
/* unused harmony export Int32Attribute */
/* unused harmony export Int32BufferAttribute */
/* unused harmony export Int8Attribute */
/* unused harmony export Int8BufferAttribute */
/* unused harmony export IntType */
/* unused harmony export InterleavedBuffer */
/* unused harmony export InterleavedBufferAttribute */
/* unused harmony export Interpolant */
/* unused harmony export InterpolateDiscrete */
/* unused harmony export InterpolateLinear */
/* unused harmony export InterpolateSmooth */
/* unused harmony export InvertStencilOp */
/* unused harmony export JSONLoader */
/* unused harmony export KeepStencilOp */
/* unused harmony export KeyframeTrack */
/* unused harmony export LOD */
/* unused harmony export LatheBufferGeometry */
/* unused harmony export LatheGeometry */
/* unused harmony export Layers */
/* unused harmony export LensFlare */
/* unused harmony export LessDepth */
/* unused harmony export LessEqualDepth */
/* unused harmony export LessEqualStencilFunc */
/* unused harmony export LessStencilFunc */
/* unused harmony export Light */
/* unused harmony export LightProbe */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return Line; });
/* unused harmony export Line3 */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return LineBasicMaterial; });
/* unused harmony export LineCurve */
/* unused harmony export LineCurve3 */
/* unused harmony export LineDashedMaterial */
/* unused harmony export LineLoop */
/* unused harmony export LinePieces */
/* unused harmony export LineSegments */
/* unused harmony export LineStrip */
/* unused harmony export LinearEncoding */
/* unused harmony export LinearFilter */
/* unused harmony export LinearInterpolant */
/* unused harmony export LinearMipMapLinearFilter */
/* unused harmony export LinearMipMapNearestFilter */
/* unused harmony export LinearMipmapLinearFilter */
/* unused harmony export LinearMipmapNearestFilter */
/* unused harmony export LinearToneMapping */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return Loader; });
/* unused harmony export LoaderUtils */
/* unused harmony export LoadingManager */
/* unused harmony export LogLuvEncoding */
/* unused harmony export LoopOnce */
/* unused harmony export LoopPingPong */
/* unused harmony export LoopRepeat */
/* unused harmony export LuminanceAlphaFormat */
/* unused harmony export LuminanceFormat */
/* unused harmony export MOUSE */
/* unused harmony export Material */
/* unused harmony export MaterialLoader */
/* unused harmony export Math */
/* unused harmony export MathUtils */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return Matrix3; });
/* unused harmony export Matrix4 */
/* unused harmony export MaxEquation */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return Mesh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return MeshBasicMaterial; });
/* unused harmony export MeshDepthMaterial */
/* unused harmony export MeshDistanceMaterial */
/* unused harmony export MeshFaceMaterial */
/* unused harmony export MeshLambertMaterial */
/* unused harmony export MeshMatcapMaterial */
/* unused harmony export MeshNormalMaterial */
/* unused harmony export MeshPhongMaterial */
/* unused harmony export MeshPhysicalMaterial */
/* unused harmony export MeshStandardMaterial */
/* unused harmony export MeshToonMaterial */
/* unused harmony export MinEquation */
/* unused harmony export MirroredRepeatWrapping */
/* unused harmony export MixOperation */
/* unused harmony export MultiMaterial */
/* unused harmony export MultiplyBlending */
/* unused harmony export MultiplyOperation */
/* unused harmony export NearestFilter */
/* unused harmony export NearestMipMapLinearFilter */
/* unused harmony export NearestMipMapNearestFilter */
/* unused harmony export NearestMipmapLinearFilter */
/* unused harmony export NearestMipmapNearestFilter */
/* unused harmony export NeverDepth */
/* unused harmony export NeverStencilFunc */
/* unused harmony export NoBlending */
/* unused harmony export NoColors */
/* unused harmony export NoToneMapping */
/* unused harmony export NormalAnimationBlendMode */
/* unused harmony export NormalBlending */
/* unused harmony export NotEqualDepth */
/* unused harmony export NotEqualStencilFunc */
/* unused harmony export NumberKeyframeTrack */
/* unused harmony export Object3D */
/* unused harmony export ObjectLoader */
/* unused harmony export ObjectSpaceNormalMap */
/* unused harmony export OctahedronBufferGeometry */
/* unused harmony export OctahedronGeometry */
/* unused harmony export OneFactor */
/* unused harmony export OneMinusDstAlphaFactor */
/* unused harmony export OneMinusDstColorFactor */
/* unused harmony export OneMinusSrcAlphaFactor */
/* unused harmony export OneMinusSrcColorFactor */
/* unused harmony export OrthographicCamera */
/* unused harmony export PCFShadowMap */
/* unused harmony export PCFSoftShadowMap */
/* unused harmony export PMREMGenerator */
/* unused harmony export ParametricBufferGeometry */
/* unused harmony export ParametricGeometry */
/* unused harmony export Particle */
/* unused harmony export ParticleBasicMaterial */
/* unused harmony export ParticleSystem */
/* unused harmony export ParticleSystemMaterial */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return PerspectiveCamera; });
/* unused harmony export Plane */
/* unused harmony export PlaneBufferGeometry */
/* unused harmony export PlaneGeometry */
/* unused harmony export PlaneHelper */
/* unused harmony export PointCloud */
/* unused harmony export PointCloudMaterial */
/* unused harmony export PointLight */
/* unused harmony export PointLightHelper */
/* unused harmony export Points */
/* unused harmony export PointsMaterial */
/* unused harmony export PolarGridHelper */
/* unused harmony export PolyhedronBufferGeometry */
/* unused harmony export PolyhedronGeometry */
/* unused harmony export PositionalAudio */
/* unused harmony export PropertyBinding */
/* unused harmony export PropertyMixer */
/* unused harmony export QuadraticBezierCurve */
/* unused harmony export QuadraticBezierCurve3 */
/* unused harmony export Quaternion */
/* unused harmony export QuaternionKeyframeTrack */
/* unused harmony export QuaternionLinearInterpolant */
/* unused harmony export REVISION */
/* unused harmony export RGBADepthPacking */
/* unused harmony export RGBAFormat */
/* unused harmony export RGBAIntegerFormat */
/* unused harmony export RGBA_ASTC_10x10_Format */
/* unused harmony export RGBA_ASTC_10x5_Format */
/* unused harmony export RGBA_ASTC_10x6_Format */
/* unused harmony export RGBA_ASTC_10x8_Format */
/* unused harmony export RGBA_ASTC_12x10_Format */
/* unused harmony export RGBA_ASTC_12x12_Format */
/* unused harmony export RGBA_ASTC_4x4_Format */
/* unused harmony export RGBA_ASTC_5x4_Format */
/* unused harmony export RGBA_ASTC_5x5_Format */
/* unused harmony export RGBA_ASTC_6x5_Format */
/* unused harmony export RGBA_ASTC_6x6_Format */
/* unused harmony export RGBA_ASTC_8x5_Format */
/* unused harmony export RGBA_ASTC_8x6_Format */
/* unused harmony export RGBA_ASTC_8x8_Format */
/* unused harmony export RGBA_BPTC_Format */
/* unused harmony export RGBA_ETC2_EAC_Format */
/* unused harmony export RGBA_PVRTC_2BPPV1_Format */
/* unused harmony export RGBA_PVRTC_4BPPV1_Format */
/* unused harmony export RGBA_S3TC_DXT1_Format */
/* unused harmony export RGBA_S3TC_DXT3_Format */
/* unused harmony export RGBA_S3TC_DXT5_Format */
/* unused harmony export RGBDEncoding */
/* unused harmony export RGBEEncoding */
/* unused harmony export RGBEFormat */
/* unused harmony export RGBFormat */
/* unused harmony export RGBIntegerFormat */
/* unused harmony export RGBM16Encoding */
/* unused harmony export RGBM7Encoding */
/* unused harmony export RGB_ETC1_Format */
/* unused harmony export RGB_ETC2_Format */
/* unused harmony export RGB_PVRTC_2BPPV1_Format */
/* unused harmony export RGB_PVRTC_4BPPV1_Format */
/* unused harmony export RGB_S3TC_DXT1_Format */
/* unused harmony export RGFormat */
/* unused harmony export RGIntegerFormat */
/* unused harmony export RawShaderMaterial */
/* unused harmony export Ray */
/* unused harmony export Raycaster */
/* unused harmony export RectAreaLight */
/* unused harmony export RedFormat */
/* unused harmony export RedIntegerFormat */
/* unused harmony export ReinhardToneMapping */
/* unused harmony export RepeatWrapping */
/* unused harmony export ReplaceStencilOp */
/* unused harmony export ReverseSubtractEquation */
/* unused harmony export RingBufferGeometry */
/* unused harmony export RingGeometry */
/* unused harmony export SRGB8_ALPHA8_ASTC_10x10_Format */
/* unused harmony export SRGB8_ALPHA8_ASTC_10x5_Format */
/* unused harmony export SRGB8_ALPHA8_ASTC_10x6_Format */
/* unused harmony export SRGB8_ALPHA8_ASTC_10x8_Format */
/* unused harmony export SRGB8_ALPHA8_ASTC_12x10_Format */
/* unused harmony export SRGB8_ALPHA8_ASTC_12x12_Format */
/* unused harmony export SRGB8_ALPHA8_ASTC_4x4_Format */
/* unused harmony export SRGB8_ALPHA8_ASTC_5x4_Format */
/* unused harmony export SRGB8_ALPHA8_ASTC_5x5_Format */
/* unused harmony export SRGB8_ALPHA8_ASTC_6x5_Format */
/* unused harmony export SRGB8_ALPHA8_ASTC_6x6_Format */
/* unused harmony export SRGB8_ALPHA8_ASTC_8x5_Format */
/* unused harmony export SRGB8_ALPHA8_ASTC_8x6_Format */
/* unused harmony export SRGB8_ALPHA8_ASTC_8x8_Format */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return Scene; });
/* unused harmony export SceneUtils */
/* unused harmony export ShaderChunk */
/* unused harmony export ShaderLib */
/* unused harmony export ShaderMaterial */
/* unused harmony export ShadowMaterial */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return Shape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return ShapeGeometry; });
/* unused harmony export ShapeGeometry */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return ShapePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return ShapeUtils; });
/* unused harmony export ShortType */
/* unused harmony export Skeleton */
/* unused harmony export SkeletonHelper */
/* unused harmony export SkinnedMesh */
/* unused harmony export SmoothShading */
/* unused harmony export Sphere */
/* unused harmony export SphereBufferGeometry */
/* unused harmony export SphereGeometry */
/* unused harmony export Spherical */
/* unused harmony export SphericalHarmonics3 */
/* unused harmony export SplineCurve */
/* unused harmony export SpotLight */
/* unused harmony export SpotLightHelper */
/* unused harmony export Sprite */
/* unused harmony export SpriteMaterial */
/* unused harmony export SrcAlphaFactor */
/* unused harmony export SrcAlphaSaturateFactor */
/* unused harmony export SrcColorFactor */
/* unused harmony export StaticCopyUsage */
/* unused harmony export StaticDrawUsage */
/* unused harmony export StaticReadUsage */
/* unused harmony export StereoCamera */
/* unused harmony export StreamCopyUsage */
/* unused harmony export StreamDrawUsage */
/* unused harmony export StreamReadUsage */
/* unused harmony export StringKeyframeTrack */
/* unused harmony export SubtractEquation */
/* unused harmony export SubtractiveBlending */
/* unused harmony export TOUCH */
/* unused harmony export TangentSpaceNormalMap */
/* unused harmony export TetrahedronBufferGeometry */
/* unused harmony export TetrahedronGeometry */
/* unused harmony export TextBufferGeometry */
/* unused harmony export TextGeometry */
/* unused harmony export Texture */
/* unused harmony export TextureLoader */
/* unused harmony export TorusBufferGeometry */
/* unused harmony export TorusGeometry */
/* unused harmony export TorusKnotBufferGeometry */
/* unused harmony export TorusKnotGeometry */
/* unused harmony export Triangle */
/* unused harmony export TriangleFanDrawMode */
/* unused harmony export TriangleStripDrawMode */
/* unused harmony export TrianglesDrawMode */
/* unused harmony export TubeBufferGeometry */
/* unused harmony export TubeGeometry */
/* unused harmony export UVMapping */
/* unused harmony export Uint16Attribute */
/* unused harmony export Uint16BufferAttribute */
/* unused harmony export Uint32Attribute */
/* unused harmony export Uint32BufferAttribute */
/* unused harmony export Uint8Attribute */
/* unused harmony export Uint8BufferAttribute */
/* unused harmony export Uint8ClampedAttribute */
/* unused harmony export Uint8ClampedBufferAttribute */
/* unused harmony export Uniform */
/* unused harmony export UniformsLib */
/* unused harmony export UniformsUtils */
/* unused harmony export UnsignedByteType */
/* unused harmony export UnsignedInt248Type */
/* unused harmony export UnsignedIntType */
/* unused harmony export UnsignedShort4444Type */
/* unused harmony export UnsignedShort5551Type */
/* unused harmony export UnsignedShort565Type */
/* unused harmony export UnsignedShortType */
/* unused harmony export VSMShadowMap */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return Vector2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return Vector3; });
/* unused harmony export Vector4 */
/* unused harmony export VectorKeyframeTrack */
/* unused harmony export Vertex */
/* unused harmony export VertexColors */
/* unused harmony export VideoTexture */
/* unused harmony export WebGL1Renderer */
/* unused harmony export WebGLCubeRenderTarget */
/* unused harmony export WebGLMultisampleRenderTarget */
/* unused harmony export WebGLRenderTarget */
/* unused harmony export WebGLRenderTargetCube */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return WebGLRenderer; });
/* unused harmony export WebGLUtils */
/* unused harmony export WireframeGeometry */
/* unused harmony export WireframeHelper */
/* unused harmony export WrapAroundEnding */
/* unused harmony export XHRLoader */
/* unused harmony export ZeroCurvatureEnding */
/* unused harmony export ZeroFactor */
/* unused harmony export ZeroSlopeEnding */
/* unused harmony export ZeroStencilOp */
/* unused harmony export sRGBEncoding */
/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = '127';
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const CullFaceFrontBack = 3;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const SmoothShading = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;

const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const CubeUVRefractionMapping = 307;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipMapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const NearestMipMapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipMapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedShort565Type = 1019;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const RGBEFormat = RGBAFormat;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBIntegerFormat = 1032;
const RGBAIntegerFormat = 1033;

const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3000;
const sRGBEncoding = 3001;
const GammaEncoding = 3007;
const RGBEEncoding = 3002;
const LogLuvEncoding = 3003;
const RGBM7Encoding = 3004;
const RGBM16Encoding = 3005;
const RGBDEncoding = 3006;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;

const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;

const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;

const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const StreamDrawUsage = 35040;
const StaticReadUsage = 35045;
const DynamicReadUsage = 35049;
const StreamReadUsage = 35041;
const StaticCopyUsage = 35046;
const DynamicCopyUsage = 35050;
const StreamCopyUsage = 35042;

const GLSL1 = '100';
const GLSL3 = '300 es';

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

function EventDispatcher() {}

Object.assign( EventDispatcher.prototype, {

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		const listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		const listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			const index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			// Make a copy, in case listeners are removed while iterating.
			const array = listenerArray.slice( 0 );

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

			event.target = null;

		}

	}

} );

const _lut = [];

for ( let i = 0; i < 256; i ++ ) {

	_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

}

let _seed = 1234567;

const MathUtils = {

	DEG2RAD: Math.PI / 180,
	RAD2DEG: 180 / Math.PI,

	generateUUID: function () {

		// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

		const d0 = Math.random() * 0xffffffff | 0;
		const d1 = Math.random() * 0xffffffff | 0;
		const d2 = Math.random() * 0xffffffff | 0;
		const d3 = Math.random() * 0xffffffff | 0;
		const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

		// .toUpperCase() here flattens concatenated strings to save heap memory space.
		return uuid.toUpperCase();

	},

	clamp: function ( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	},

	// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation

	euclideanModulo: function ( n, m ) {

		return ( ( n % m ) + m ) % m;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/

	inverseLerp: function ( x, y, value ) {

		if ( x !== y ) {

			return ( value - x ) / ( y - x );

		 } else {

			return 0;

		 }

	},

	// https://en.wikipedia.org/wiki/Linear_interpolation

	lerp: function ( x, y, t ) {

		return ( 1 - t ) * x + t * y;

	},

	// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/

	damp: function ( x, y, lambda, dt ) {

		return MathUtils.lerp( x, y, 1 - Math.exp( - lambda * dt ) );

	},

	// https://www.desmos.com/calculator/vcsjnyz7x4

	pingpong: function ( x, length = 1 ) {

		return length - Math.abs( MathUtils.euclideanModulo( x, length * 2 ) - length );

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	// Deterministic pseudo-random float in the interval [ 0, 1 ]

	seededRandom: function ( s ) {

		if ( s !== undefined ) _seed = s % 2147483647;

		// Park-Miller algorithm

		_seed = _seed * 16807 % 2147483647;

		return ( _seed - 1 ) / 2147483646;

	},

	degToRad: function ( degrees ) {

		return degrees * MathUtils.DEG2RAD;

	},

	radToDeg: function ( radians ) {

		return radians * MathUtils.RAD2DEG;

	},

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	},

	ceilPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

	},

	floorPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

	},

	setQuaternionFromProperEuler: function ( q, a, b, c, order ) {

		// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

		// rotations are applied to the axes in the order specified by 'order'
		// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
		// angles are in radians

		const cos = Math.cos;
		const sin = Math.sin;

		const c2 = cos( b / 2 );
		const s2 = sin( b / 2 );

		const c13 = cos( ( a + c ) / 2 );
		const s13 = sin( ( a + c ) / 2 );

		const c1_3 = cos( ( a - c ) / 2 );
		const s1_3 = sin( ( a - c ) / 2 );

		const c3_1 = cos( ( c - a ) / 2 );
		const s3_1 = sin( ( c - a ) / 2 );

		switch ( order ) {

			case 'XYX':
				q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
				break;

			case 'YZY':
				q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
				break;

			case 'ZXZ':
				q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
				break;

			case 'XZX':
				q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
				break;

			case 'YXY':
				q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
				break;

			case 'ZYZ':
				q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
				break;

			default:
				console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

		}

	}

};

class Vector2 {

	constructor( x = 0, y = 0 ) {

		this.x = x;
		this.y = y;

	}

	get width() {

		return this.x;

	}

	set width( value ) {

		this.x = value;

	}

	get height() {

		return this.y;

	}

	set height( value ) {

		this.y = value;

	}

	set( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y;

	}

	cross( v ) {

		return this.x * v.y - this.y * v.x;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	angle() {

		// computes the angle in radians with respect to the positive x-axis

		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		return angle;

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	}

	rotateAround( center, angle ) {

		const c = Math.cos( angle ), s = Math.sin( angle );

		const x = this.x - center.x;
		const y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();

		return this;

	}

}

Vector2.prototype.isVector2 = true;

class Matrix3 {

	constructor() {

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrix3Column( this, 0 );
		yAxis.setFromMatrix3Column( this, 1 );
		zAxis.setFromMatrix3Column( this, 2 );

		return this;

	}

	setFromMatrix4( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	}

	invert() {

		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	}

	transpose() {

		let tmp;
		const m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	}

	getNormalMatrix( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).invert().transpose();

	}

	transposeIntoArray( r ) {

		const m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	}

	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

		const c = Math.cos( rotation );
		const s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

		return this;

	}

	scale( sx, sy ) {

		const te = this.elements;

		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

		return this;

	}

	rotate( theta ) {

		const c = Math.cos( theta );
		const s = Math.sin( theta );

		const te = this.elements;

		const a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
		const a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

		te[ 0 ] = c * a11 + s * a21;
		te[ 3 ] = c * a12 + s * a22;
		te[ 6 ] = c * a13 + s * a23;

		te[ 1 ] = - s * a11 + c * a21;
		te[ 4 ] = - s * a12 + c * a22;
		te[ 7 ] = - s * a13 + c * a23;

		return this;

	}

	translate( tx, ty ) {

		const te = this.elements;

		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

	clone() {

		return new this.constructor().fromArray( this.elements );

	}

}

Matrix3.prototype.isMatrix3 = true;

let _canvas;

const ImageUtils = {

	getDataURL: function ( image ) {

		if ( /^data:/i.test( image.src ) ) {

			return image.src;

		}

		if ( typeof HTMLCanvasElement == 'undefined' ) {

			return image.src;

		}

		let canvas;

		if ( image instanceof HTMLCanvasElement ) {

			canvas = image;

		} else {

			if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

			_canvas.width = image.width;
			_canvas.height = image.height;

			const context = _canvas.getContext( '2d' );

			if ( image instanceof ImageData ) {

				context.putImageData( image, 0, 0 );

			} else {

				context.drawImage( image, 0, 0, image.width, image.height );

			}

			canvas = _canvas;

		}

		if ( canvas.width > 2048 || canvas.height > 2048 ) {

			console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

			return canvas.toDataURL( 'image/jpeg', 0.6 );

		} else {

			return canvas.toDataURL( 'image/png' );

		}

	}

};

let textureId = 0;

class Texture extends EventDispatcher {

	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding ) {

		super();

		Object.defineProperty( this, 'id', { value: textureId ++ } );

		this.uuid = MathUtils.generateUUID();

		this.name = '';

		this.image = image;
		this.mipmaps = [];

		this.mapping = mapping;

		this.wrapS = wrapS;
		this.wrapT = wrapT;

		this.magFilter = magFilter;
		this.minFilter = minFilter;

		this.anisotropy = anisotropy;

		this.format = format;
		this.internalFormat = null;
		this.type = type;

		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding;

		this.version = 0;
		this.onUpdate = null;

	}

	updateMatrix() {

		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.image = source.image;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );
		this.center.copy( source.center );
		this.rotation = source.rotation;

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy( source.matrix );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;

		return this;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		const output = {

			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,

			wrap: [ this.wrapS, this.wrapT ],

			format: this.format,
			type: this.type,
			encoding: this.encoding,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if ( this.image !== undefined ) {

			// TODO: Move to THREE.Image

			const image = this.image;

			if ( image.uuid === undefined ) {

				image.uuid = MathUtils.generateUUID(); // UGH

			}

			if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

				let url;

				if ( Array.isArray( image ) ) {

					// process array of images e.g. CubeTexture

					url = [];

					for ( let i = 0, l = image.length; i < l; i ++ ) {

						// check cube texture with data textures

						if ( image[ i ].isDataTexture ) {

							url.push( serializeImage( image[ i ].image ) );

						} else {

							url.push( serializeImage( image[ i ] ) );

						}

					}

				} else {

					// process single image

					url = serializeImage( image );

				}

				meta.images[ image.uuid ] = {
					uuid: image.uuid,
					url: url
				};

			}

			output.image = image.uuid;

		}

		if ( ! isRootObject ) {

			meta.textures[ this.uuid ] = output;

		}

		return output;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	transformUv( uv ) {

		if ( this.mapping !== UVMapping ) return uv;

		uv.applyMatrix3( this.matrix );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}

					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}

					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

		return uv;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

}

Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;

Texture.prototype.isTexture = true;

function serializeImage( image ) {

	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

		// default images

		return ImageUtils.getDataURL( image );

	} else {

		if ( image.data ) {

			// images of DataTexture

			return {
				data: Array.prototype.slice.call( image.data ),
				width: image.width,
				height: image.height,
				type: image.data.constructor.name
			};

		} else {

			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
			return {};

		}

	}

}

class Vector4 {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

	}

	get width() {

		return this.z;

	}

	set width( value ) {

		this.z = value;

	}

	get height() {

		return this.w;

	}

	set height( value ) {

		this.w = value;

	}

	set( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setW( w ) {

		this.w = w;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z, this.w );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		this.w *= v.w;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z, w = this.w;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	setAxisAngleFromQuaternion( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		const s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			this.x = 1;
			this.y = 0;
			this.z = 0;

		} else {

			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;

		}

		return this;

	}

	setAxisAngleFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		let angle, x, y, z; // variables for result
		const epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			const xx = ( m11 + 1 ) / 2;
			const yy = ( m22 + 1 ) / 2;
			const zz = ( m33 + 1 ) / 2;
			const xy = ( m12 + m21 ) / 4;
			const xz = ( m13 + m31 ) / 4;
			const yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			( m13 - m31 ) * ( m13 - m31 ) +
			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;
		this.w = v1.w + ( v2.w - v1.w ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();

		return this;

	}

}

Vector4.prototype.isVector4 = true;

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
class WebGLRenderTarget extends EventDispatcher {

	constructor( width, height, options ) {

		super();

		this.width = width;
		this.height = height;
		this.depth = 1;

		this.scissor = new Vector4( 0, 0, width, height );
		this.scissorTest = false;

		this.viewport = new Vector4( 0, 0, width, height );

		options = options || {};

		this.texture = new Texture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		this.texture.image = {};
		this.texture.image.width = width;
		this.texture.image.height = height;
		this.texture.image.depth = 1;

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

	}

	setTexture( texture ) {

		texture.image = {
			width: this.width,
			height: this.height,
			depth: this.depth
		};

		this.texture = texture;

	}

	setSize( width, height, depth = 1 ) {

		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

			this.width = width;
			this.height = height;
			this.depth = depth;

			this.texture.image.width = width;
			this.texture.image.height = height;
			this.texture.image.depth = depth;

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.width = source.width;
		this.height = source.height;
		this.depth = source.depth;

		this.viewport.copy( source.viewport );

		this.texture = source.texture.clone();

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		this.depthTexture = source.depthTexture;

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

WebGLRenderTarget.prototype.isWebGLRenderTarget = true;

class WebGLMultisampleRenderTarget extends WebGLRenderTarget {

	constructor( width, height, options ) {

		super( width, height, options );

		this.samples = 4;

	}

	copy( source ) {

		super.copy.call( this, source );

		this.samples = source.samples;

		return this;

	}

}

WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;

class Quaternion {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	static slerp( qa, qb, qm, t ) {

		console.warn( 'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.' );
		return qm.slerpQuaternions( qa, qb, t );

	}

	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( t === 0 ) {

			dst[ dstOffset + 0 ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
			return;

		}

		if ( t === 1 ) {

			dst[ dstOffset + 0 ] = x1;
			dst[ dstOffset + 1 ] = y1;
			dst[ dstOffset + 2 ] = z1;
			dst[ dstOffset + 3 ] = w1;
			return;

		}

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				const sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			const tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		const x0 = src0[ srcOffset0 ];
		const y0 = src0[ srcOffset0 + 1 ];
		const z0 = src0[ srcOffset0 + 2 ];
		const w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 ];
		const y1 = src1[ srcOffset1 + 1 ];
		const z1 = src1[ srcOffset1 + 2 ];
		const w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get w() {

		return this._w;

	}

	set w( value ) {

		this._w = value;
		this._onChangeCallback();

	}

	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}

	copy( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	}

	setFromEuler( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;

		const c1 = cos( x / 2 );
		const c2 = cos( y / 2 );
		const c3 = cos( z / 2 );

		const s1 = sin( x / 2 );
		const s2 = sin( y / 2 );
		const s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromAxisAngle( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		const halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			const s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	}

	setFromUnitVectors( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		let r = vFrom.dot( vTo ) + 1;

		if ( r < Number.EPSILON ) {

			// vFrom and vTo point in opposite directions

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	}

	angleTo( q ) {

		return 2 * Math.acos( Math.abs( MathUtils.clamp( this.dot( q ), - 1, 1 ) ) );

	}

	rotateTowards( q, step ) {

		const angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		const t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	}

	identity() {

		return this.set( 0, 0, 0, 1 );

	}

	invert() {

		// quaternion is assumed to have unit length

		return this.conjugate();

	}

	conjugate() {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	}

	dot( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	}

	lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}

	length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}

	normalize() {

		let l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	}

	multiply( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	}

	premultiply( q ) {

		return this.multiplyQuaternions( q, this );

	}

	multiplyQuaternions( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	}

	slerp( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		const x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	}

	slerpQuaternions( qa, qb, t ) {

		this.copy( qa ).slerp( qb, t );

	}

	equals( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	}

	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		return this;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

}

Quaternion.prototype.isQuaternion = true;

class Vector3 {

	constructor( x = 0, y = 0, z = 0 ) {

		this.x = x;
		this.y = y;
		this.z = z;

	}

	set( x, y, z ) {

		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	}

	multiply( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	}

	multiplyVectors( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	}

	applyEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

	}

	applyAxisAngle( axis, angle ) {

		return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	}

	applyNormalMatrix( m ) {

		return this.applyMatrix3( m ).normalize();

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	}

	applyQuaternion( q ) {

		const x = this.x, y = this.y, z = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		const ix = qw * x + qy * z - qz * y;
		const iy = qw * y + qz * x - qx * z;
		const iz = qw * z + qx * y - qy * x;
		const iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	}

	project( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	}

	unproject( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	}

	transformDirection( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	}

	// TODO lengthSquared?

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	}

	cross( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		return this.crossVectors( this, v );

	}

	crossVectors( a, b ) {

		const ax = a.x, ay = a.y, az = a.z;
		const bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	}

	projectOnVector( v ) {

		const denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		const scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	}

	projectOnPlane( planeNormal ) {

		_vector$c.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector$c );

	}

	reflect( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( MathUtils.clamp( theta, - 1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	}

	setFromSpherical( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	}

	setFromSphericalCoords( radius, phi, theta ) {

		const sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	}

	setFromCylindrical( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	}

	setFromCylindricalCoords( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	}

	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	}

	setFromMatrixScale( m ) {

		const sx = this.setFromMatrixColumn( m, 0 ).length();
		const sy = this.setFromMatrixColumn( m, 1 ).length();
		const sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	}

	setFromMatrixColumn( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	}

	setFromMatrix3Column( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

}

Vector3.prototype.isVector3 = true;

const _vector$c = /*@__PURE__*/ new Vector3();
const _quaternion$4 = /*@__PURE__*/ new Quaternion();

class Box3 {

	constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromArray( array ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = array.length; i < l; i += 3 ) {

			const x = array[ i ];
			const y = array[ i + 1 ];
			const z = array[ i + 2 ];

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromBufferAttribute( attribute ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = attribute.count; i < l; i ++ ) {

			const x = attribute.getX( i );
			const y = attribute.getY( i );
			const z = attribute.getZ( i );

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	setFromObject( object ) {

		this.makeEmpty();

		return this.expandByObject( object );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	}

	getCenter( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getCenter() target is now required' );
			target = new Vector3();

		}

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getSize() target is now required' );
			target = new Vector3();

		}

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	expandByObject( object ) {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix( false, false );

		const geometry = object.geometry;

		if ( geometry !== undefined ) {

			if ( geometry.boundingBox === null ) {

				geometry.computeBoundingBox();

			}

			_box$3.copy( geometry.boundingBox );
			_box$3.applyMatrix4( object.matrixWorld );

			this.union( _box$3 );

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			this.expandByObject( children[ i ] );

		}

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getParameter() target is now required' );
			target = new Vector3();

		}

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	}

	intersectsBox( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	}

	intersectsSphere( sphere ) {

		// Find the point on the AABB closest to the sphere center.
		this.clampPoint( sphere.center, _vector$b );

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	intersectsPlane( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		let min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= - plane.constant && max >= - plane.constant );

	}

	intersectsTriangle( triangle ) {

		if ( this.isEmpty() ) {

			return false;

		}

		// compute box center and extents
		this.getCenter( _center );
		_extents.subVectors( this.max, _center );

		// translate triangle to aabb origin
		_v0$2.subVectors( triangle.a, _center );
		_v1$7.subVectors( triangle.b, _center );
		_v2$3.subVectors( triangle.c, _center );

		// compute edge vectors for triangle
		_f0.subVectors( _v1$7, _v0$2 );
		_f1.subVectors( _v2$3, _v1$7 );
		_f2.subVectors( _v0$2, _v2$3 );

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		let axes = [
			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
		];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {

			return false;

		}

		// test 3 face normals from the aabb
		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {

			return false;

		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors( _f0, _f1 );
		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

		return satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents );

	}

	clampPoint( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .clampPoint() target is now required' );
			target = new Vector3();

		}

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		const clampedPoint = _vector$b.copy( point ).clamp( this.min, this.max );

		return clampedPoint.sub( point ).length();

	}

	getBoundingSphere( target ) {

		if ( target === undefined ) {

			console.error( 'THREE.Box3: .getBoundingSphere() target is now required' );
			//target = new Sphere(); // removed to avoid cyclic dependency

		}

		this.getCenter( target.center );

		target.radius = this.getSize( _vector$b ).length() * 0.5;

		return target;

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	applyMatrix4( matrix ) {

		// transform of empty box is an empty box.
		if ( this.isEmpty() ) return this;

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		this.setFromPoints( _points );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

Box3.prototype.isBox3 = true;

const _points = [
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3()
];

const _vector$b = /*@__PURE__*/ new Vector3();

const _box$3 = /*@__PURE__*/ new Box3();

// triangle centered vertices

const _v0$2 = /*@__PURE__*/ new Vector3();
const _v1$7 = /*@__PURE__*/ new Vector3();
const _v2$3 = /*@__PURE__*/ new Vector3();

// triangle edge vectors

const _f0 = /*@__PURE__*/ new Vector3();
const _f1 = /*@__PURE__*/ new Vector3();
const _f2 = /*@__PURE__*/ new Vector3();

const _center = /*@__PURE__*/ new Vector3();
const _extents = /*@__PURE__*/ new Vector3();
const _triangleNormal = /*@__PURE__*/ new Vector3();
const _testAxis = /*@__PURE__*/ new Vector3();

function satForAxes( axes, v0, v1, v2, extents ) {

	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

		_testAxis.fromArray( axes, i );
		// project the aabb onto the seperating axis
		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
		// project all 3 vertices of the triangle onto the seperating axis
		const p0 = v0.dot( _testAxis );
		const p1 = v1.dot( _testAxis );
		const p2 = v2.dot( _testAxis );
		// actual test, basically see if either of the most extreme of the triangle points intersects r
		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

			// points of the projected triangle are outside the projected half-length of the aabb
			// the axis is seperating and we can exit
			return false;

		}

	}

	return true;

}

const _box$2 = /*@__PURE__*/ new Box3();
const _v1$6 = /*@__PURE__*/ new Vector3();
const _toFarthestPoint = /*@__PURE__*/ new Vector3();
const _toPoint = /*@__PURE__*/ new Vector3();

class Sphere {

	constructor( center = new Vector3(), radius = - 1 ) {

		this.center = center;
		this.radius = radius;

	}

	set( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	}

	setFromPoints( points, optionalCenter ) {

		const center = this.center;

		if ( optionalCenter !== undefined ) {

			center.copy( optionalCenter );

		} else {

			_box$2.setFromPoints( points ).getCenter( center );

		}

		let maxRadiusSq = 0;

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		}

		this.radius = Math.sqrt( maxRadiusSq );

		return this;

	}

	copy( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	}

	isEmpty() {

		return ( this.radius < 0 );

	}

	makeEmpty() {

		this.center.set( 0, 0, 0 );
		this.radius = - 1;

		return this;

	}

	containsPoint( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	}

	distanceToPoint( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	}

	intersectsSphere( sphere ) {

		const radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	}

	intersectsBox( box ) {

		return box.intersectsSphere( this );

	}

	intersectsPlane( plane ) {

		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	}

	clampPoint( point, target ) {

		const deltaLengthSq = this.center.distanceToSquared( point );

		if ( target === undefined ) {

			console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
			target = new Vector3();

		}

		target.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );

		}

		return target;

	}

	getBoundingBox( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
			target = new Box3();

		}

		if ( this.isEmpty() ) {

			// Empty sphere produces empty bounding box
			target.makeEmpty();
			return target;

		}

		target.set( this.center, this.center );
		target.expandByScalar( this.radius );

		return target;

	}

	applyMatrix4( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	}

	translate( offset ) {

		this.center.add( offset );

		return this;

	}

	expandByPoint( point ) {

		// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671

		_toPoint.subVectors( point, this.center );

		const lengthSq = _toPoint.lengthSq();

		if ( lengthSq > ( this.radius * this.radius ) ) {

			const length = Math.sqrt( lengthSq );
			const missingRadiusHalf = ( length - this.radius ) * 0.5;

			// Nudge this sphere towards the target point. Add half the missing distance to radius,
			// and the other half to position. This gives a tighter enclosure, instead of if
			// the whole missing distance were just added to radius.

			this.center.add( _toPoint.multiplyScalar( missingRadiusHalf / length ) );
			this.radius += missingRadiusHalf;

		}

		return this;

	}

	union( sphere ) {

		// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769

		// To enclose another sphere into this sphere, we only need to enclose two points:
		// 1) Enclose the farthest point on the other sphere into this sphere.
		// 2) Enclose the opposite point of the farthest point into this sphere.

		_toFarthestPoint.subVectors( sphere.center, this.center ).normalize().multiplyScalar( sphere.radius );

		this.expandByPoint( _v1$6.copy( sphere.center ).add( _toFarthestPoint ) );
		this.expandByPoint( _v1$6.copy( sphere.center ).sub( _toFarthestPoint ) );

		return this;

	}

	equals( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$a = /*@__PURE__*/ new Vector3();
const _segCenter = /*@__PURE__*/ new Vector3();
const _segDir = /*@__PURE__*/ new Vector3();
const _diff = /*@__PURE__*/ new Vector3();

const _edge1 = /*@__PURE__*/ new Vector3();
const _edge2 = /*@__PURE__*/ new Vector3();
const _normal$1 = /*@__PURE__*/ new Vector3();

class Ray {

	constructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {

		this.origin = origin;
		this.direction = direction;

	}

	set( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	}

	copy( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	}

	at( t, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Ray: .at() target is now required' );
			target = new Vector3();

		}

		return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	}

	lookAt( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	}

	recast( t ) {

		this.origin.copy( this.at( t, _vector$a ) );

		return this;

	}

	closestPointToPoint( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
			target = new Vector3();

		}

		target.subVectors( point, this.origin );

		const directionDistance = target.dot( this.direction );

		if ( directionDistance < 0 ) {

			return target.copy( this.origin );

		}

		return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	}

	distanceToPoint( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	}

	distanceSqToPoint( point ) {

		const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

		// point behind the ray

		if ( directionDistance < 0 ) {

			return this.origin.distanceToSquared( point );

		}

		_vector$a.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		return _vector$a.distanceToSquared( point );

	}

	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		_segDir.copy( v1 ).sub( v0 ).normalize();
		_diff.copy( this.origin ).sub( _segCenter );

		const segExtent = v0.distanceTo( v1 ) * 0.5;
		const a01 = - this.direction.dot( _segDir );
		const b0 = _diff.dot( this.direction );
		const b1 = - _diff.dot( _segDir );
		const c = _diff.lengthSq();
		const det = Math.abs( 1 - a01 * a01 );
		let s0, s1, sqrDist, extDet;

		if ( det > 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						const invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

		}

		return sqrDist;

	}

	intersectSphere( sphere, target ) {

		_vector$a.subVectors( sphere.center, this.origin );
		const tca = _vector$a.dot( this.direction );
		const d2 = _vector$a.dot( _vector$a ) - tca * tca;
		const radius2 = sphere.radius * sphere.radius;

		if ( d2 > radius2 ) return null;

		const thc = Math.sqrt( radius2 - d2 );

		// t0 = first intersect point - entrance on front of sphere
		const t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		const t1 = tca + thc;

		// test to see if both t0 and t1 are behind the ray - if so, return null
		if ( t0 < 0 && t1 < 0 ) return null;

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if ( t0 < 0 ) return this.at( t1, target );

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at( t0, target );

	}

	intersectsSphere( sphere ) {

		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	distanceToPlane( plane ) {

		const denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;

	}

	intersectPlane( plane, target ) {

		const t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, target );

	}

	intersectsPlane( plane ) {

		// check if the ray lies on the plane first

		const distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		const denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	}

	intersectBox( box, target ) {

		let tmin, tmax, tymin, tymax, tzmin, tzmax;

		const invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		const origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, target );

	}

	intersectsBox( box ) {

		return this.intersectBox( box, _vector$a ) !== null;

	}

	intersectTriangle( a, b, c, backfaceCulling, target ) {

		// Compute the offset origin, edges, and normal.

		// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors( b, a );
		_edge2.subVectors( c, a );
		_normal$1.crossVectors( _edge1, _edge2 );

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		let DdN = this.direction.dot( _normal$1 );
		let sign;

		if ( DdN > 0 ) {

			if ( backfaceCulling ) return null;
			sign = 1;

		} else if ( DdN < 0 ) {

			sign = - 1;
			DdN = - DdN;

		} else {

			return null;

		}

		_diff.subVectors( this.origin, a );
		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

		// b1 < 0, no intersection
		if ( DdQxE2 < 0 ) {

			return null;

		}

		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

		// b2 < 0, no intersection
		if ( DdE1xQ < 0 ) {

			return null;

		}

		// b1+b2 > 1, no intersection
		if ( DdQxE2 + DdE1xQ > DdN ) {

			return null;

		}

		// Line intersects triangle, check if ray does.
		const QdN = - sign * _diff.dot( _normal$1 );

		// t < 0, no intersection
		if ( QdN < 0 ) {

			return null;

		}

		// Ray intersects triangle.
		return this.at( QdN / DdN, target );

	}

	applyMatrix4( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	}

	equals( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

class Matrix4 {

	constructor() {

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	clone() {

		return new Matrix4().fromArray( this.elements );

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	}

	copyPosition( m ) {

		const te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	}

	setFromMatrix3( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ], 0,
			me[ 1 ], me[ 4 ], me[ 7 ], 0,
			me[ 2 ], me[ 5 ], me[ 8 ], 0,
			0, 0, 0, 1

		);

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}

	makeBasis( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	}

	extractRotation( m ) {

		// this method does not support reflection matrices

		const te = this.elements;
		const me = m.elements;

		const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
		const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
		const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		const te = this.elements;

		const x = euler.x, y = euler.y, z = euler.z;
		const a = Math.cos( x ), b = Math.sin( x );
		const c = Math.cos( y ), d = Math.sin( y );
		const e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromQuaternion( q ) {

		return this.compose( _zero, q, _one );

	}

	lookAt( eye, target, up ) {

		const te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	}

	multiply( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	}

	transpose() {

		const te = this.elements;
		let tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	}

	setPosition( x, y, z ) {

		const te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	}

	invert() {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

	scale( v ) {

		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	}

	getMaxScaleOnAxis() {

		const te = this.elements;

		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	}

	makeTranslation( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationX( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationY( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	}

	makeRotationZ( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationAxis( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos( angle );
		const s = Math.sin( angle );
		const t = 1 - c;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeScale( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeShear( x, y, z ) {

		this.set(

			1, y, z, 0,
			x, 1, z, 0,
			x, y, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	compose( position, quaternion, scale ) {

		const te = this.elements;

		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x,	y2 = y + y, z2 = z + z;
		const xx = x * x2, xy = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;

		const sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	}

	decompose( position, quaternion, scale ) {

		const te = this.elements;

		let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1$2.copy( this );

		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;

		_m1$2.elements[ 0 ] *= invSX;
		_m1$2.elements[ 1 ] *= invSX;
		_m1$2.elements[ 2 ] *= invSX;

		_m1$2.elements[ 4 ] *= invSY;
		_m1$2.elements[ 5 ] *= invSY;
		_m1$2.elements[ 6 ] *= invSY;

		_m1$2.elements[ 8 ] *= invSZ;
		_m1$2.elements[ 9 ] *= invSZ;
		_m1$2.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1$2 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	}

	makePerspective( left, right, top, bottom, near, far ) {

		if ( far === undefined ) {

			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		}

		const te = this.elements;
		const x = 2 * near / ( right - left );
		const y = 2 * near / ( top - bottom );

		const a = ( right + left ) / ( right - left );
		const b = ( top + bottom ) / ( top - bottom );
		const c = - ( far + near ) / ( far - near );
		const d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	}

	makeOrthographic( left, right, top, bottom, near, far ) {

		const te = this.elements;
		const w = 1.0 / ( right - left );
		const h = 1.0 / ( top - bottom );
		const p = 1.0 / ( far - near );

		const x = ( right + left ) * w;
		const y = ( top + bottom ) * h;
		const z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

}

Matrix4.prototype.isMatrix4 = true;

const _v1$5 = /*@__PURE__*/ new Vector3();
const _m1$2 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
const _x = /*@__PURE__*/ new Vector3();
const _y = /*@__PURE__*/ new Vector3();
const _z = /*@__PURE__*/ new Vector3();

const _matrix$1 = /*@__PURE__*/ new Matrix4();
const _quaternion$3 = /*@__PURE__*/ new Quaternion();

class Euler {

	constructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get order() {

		return this._order;

	}

	set order( value ) {

		this._order = value;
		this._onChangeCallback();

	}

	set( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._order );

	}

	copy( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m, order, update ) {

		const clamp = MathUtils.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements;
		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromQuaternion( q, order, update ) {

		_matrix$1.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix$1, order, update );

	}

	setFromVector3( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	}

	reorder( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion$3.setFromEuler( this );

		return this.setFromQuaternion( _quaternion$3, newOrder );

	}

	equals( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	}

	fromArray( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	}

	toVector3( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new Vector3( this._x, this._y, this._z );

		}

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

}

Euler.prototype.isEuler = true;

Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

class Layers {

	constructor() {

		this.mask = 1 | 0;

	}

	set( channel ) {

		this.mask = 1 << channel | 0;

	}

	enable( channel ) {

		this.mask |= 1 << channel | 0;

	}

	enableAll() {

		this.mask = 0xffffffff | 0;

	}

	toggle( channel ) {

		this.mask ^= 1 << channel | 0;

	}

	disable( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	}

	disableAll() {

		this.mask = 0;

	}

	test( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

}

let _object3DId = 0;

const _v1$4 = new Vector3();
const _q1 = new Quaternion();
const _m1$1 = new Matrix4();
const _target = new Vector3();

const _position$3 = new Vector3();
const _scale$2 = new Vector3();
const _quaternion$2 = new Quaternion();

const _xAxis = new Vector3( 1, 0, 0 );
const _yAxis = new Vector3( 0, 1, 0 );
const _zAxis = new Vector3( 0, 0, 1 );

const _addedEvent = { type: 'added' };
const _removedEvent = { type: 'removed' };

function Object3D() {

	Object.defineProperty( this, 'id', { value: _object3DId ++ } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = null;
	this.children = [];

	this.up = Object3D.DefaultUp.clone();

	const position = new Vector3();
	const rotation = new Euler();
	const quaternion = new Quaternion();
	const scale = new Vector3( 1, 1, 1 );

	function onRotationChange() {

		quaternion.setFromEuler( rotation, false );

	}

	function onQuaternionChange() {

		rotation.setFromQuaternion( quaternion, undefined, false );

	}

	rotation._onChange( onRotationChange );
	quaternion._onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			configurable: true,
			enumerable: true,
			value: position
		},
		rotation: {
			configurable: true,
			enumerable: true,
			value: rotation
		},
		quaternion: {
			configurable: true,
			enumerable: true,
			value: quaternion
		},
		scale: {
			configurable: true,
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new Matrix4()
		},
		normalMatrix: {
			value: new Matrix3()
		}
	} );

	this.matrix = new Matrix4();
	this.matrixWorld = new Matrix4();

	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;

	this.layers = new Layers();
	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;
	this.renderOrder = 0;

	this.animations = [];

	this.userData = {};

}

Object3D.DefaultUp = new Vector3( 0, 1, 0 );
Object3D.DefaultMatrixAutoUpdate = true;

Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Object3D,

	isObject3D: true,

	onBeforeRender: function () {},
	onAfterRender: function () {},

	applyMatrix4: function ( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	applyQuaternion: function ( q ) {

		this.quaternion.premultiply( q );

		return this;

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function ( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	},

	rotateOnWorldAxis: function ( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	},

	rotateX: function ( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	},

	rotateY: function ( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	},

	rotateZ: function ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	},

	translateOnAxis: function ( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$4.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1$4.multiplyScalar( distance ) );

		return this;

	},

	translateX: function ( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	},

	translateY: function ( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	},

	translateZ: function ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	},

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function ( vector ) {

		return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

	},

	lookAt: function ( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		const parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position$3.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1$1.lookAt( _position$3, _target, this.up );

		} else {

			_m1$1.lookAt( _target, _position$3, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1$1 );

		if ( parent ) {

			_m1$1.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1$1 );
			this.quaternion.premultiply( _q1.invert() );

		}

	},

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
			return this;

		}

		if ( object && object.isObject3D ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

		} else {

			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		const index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

		}

		return this;

	},

	clear: function () {

		for ( let i = 0; i < this.children.length; i ++ ) {

			const object = this.children[ i ];

			object.parent = null;

			object.dispatchEvent( _removedEvent );

		}

		this.children.length = 0;

		return this;


	},

	attach: function ( object ) {

		// adds object as a child of this, while maintaining the object's world transform

		this.updateWorldMatrix( true, false );

		_m1$1.copy( this.matrixWorld ).invert();

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1$1.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix4( _m1$1 );

		this.add( object );

		object.updateWorldMatrix( false, true );

		return this;

	},

	getObjectById: function ( id ) {

		return this.getObjectByProperty( 'id', id );

	},

	getObjectByName: function ( name ) {

		return this.getObjectByProperty( 'name', name );

	},

	getObjectByProperty: function ( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			const child = this.children[ i ];
			const object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
			target = new Vector3();

		}

		this.updateWorldMatrix( true, false );

		return target.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
			target = new Quaternion();

		}

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, target, _scale$2 );

		return target;

	},

	getWorldScale: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
			target = new Vector3();

		}

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, _quaternion$2, target );

		return target;

	},

	getWorldDirection: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
			target = new Vector3();

		}

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	},

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	},

	traverseAncestors: function ( callback ) {

		const parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( force );

		}

	},

	updateWorldMatrix: function ( updateParents, updateChildren ) {

		const parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			this.matrixWorld.copy( this.matrix );

		} else {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		}

		// update children

		if ( updateChildren === true ) {

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateWorldMatrix( false, true );

			}

		}

	},

	toJSON: function ( meta ) {

		// meta is a string when called from JSON.stringify
		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		const output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {},
				skeletons: {},
				animations: {}
			};

			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		const object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( this.frustumCulled === false ) object.frustumCulled = false;
		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();

		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		// object specific properties

		if ( this.isInstancedMesh ) {

			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();
			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

		}

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			const parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				const shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

						const shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.isSkinnedMesh ) {

			object.bindMode = this.bindMode;
			object.bindMatrix = this.bindMatrix.toArray();

			if ( this.skeleton !== undefined ) {

				serialize( meta.skeletons, this.skeleton );

				object.skeleton = this.skeleton.uuid;

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				const uuids = [];

				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( let i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		//

		if ( this.animations.length > 0 ) {

			object.animations = [];

			for ( let i = 0; i < this.animations.length; i ++ ) {

				const animation = this.animations[ i ];

				object.animations.push( serialize( meta.animations, animation ) );

			}

		}

		if ( isRootObject ) {

			const geometries = extractFromCache( meta.geometries );
			const materials = extractFromCache( meta.materials );
			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const shapes = extractFromCache( meta.shapes );
			const skeletons = extractFromCache( meta.skeletons );
			const animations = extractFromCache( meta.animations );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
			if ( shapes.length > 0 ) output.shapes = shapes;
			if ( skeletons.length > 0 ) output.skeletons = skeletons;
			if ( animations.length > 0 ) output.animations = animations;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			const values = [];
			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

	},

	clone: function ( recursive ) {

		return new this.constructor().copy( this, recursive );

	},

	copy: function ( source, recursive = true ) {

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.rotation.order = source.rotation.order;
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( let i = 0; i < source.children.length; i ++ ) {

				const child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

} );

const _vector1 = /*@__PURE__*/ new Vector3();
const _vector2$1 = /*@__PURE__*/ new Vector3();
const _normalMatrix = /*@__PURE__*/ new Matrix3();

class Plane {

	constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

		// normal is assumed to be normalized

		this.normal = normal;
		this.constant = constant;

	}

	set( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	}

	setComponents( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	}

	setFromNormalAndCoplanarPoint( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );

		return this;

	}

	setFromCoplanarPoints( a, b, c ) {

		const normal = _vector1.subVectors( c, b ).cross( _vector2$1.subVectors( a, b ) ).normalize();

		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		this.setFromNormalAndCoplanarPoint( normal, a );

		return this;

	}

	copy( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	}

	normalize() {

		// Note: will lead to a divide by zero if the plane is invalid.

		const inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	}

	negate() {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	}

	distanceToPoint( point ) {

		return this.normal.dot( point ) + this.constant;

	}

	distanceToSphere( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	}

	projectPoint( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .projectPoint() target is now required' );
			target = new Vector3();

		}

		return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

	}

	intersectLine( line, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .intersectLine() target is now required' );
			target = new Vector3();

		}

		const direction = line.delta( _vector1 );

		const denominator = this.normal.dot( direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( this.distanceToPoint( line.start ) === 0 ) {

				return target.copy( line.start );

			}

			// Unsure if this is the correct method to handle this case.
			return null;

		}

		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

		if ( t < 0 || t > 1 ) {

			return null;

		}

		return target.copy( direction ).multiplyScalar( t ).add( line.start );

	}

	intersectsLine( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		const startSign = this.distanceToPoint( line.start );
		const endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	}

	intersectsBox( box ) {

		return box.intersectsPlane( this );

	}

	intersectsSphere( sphere ) {

		return sphere.intersectsPlane( this );

	}

	coplanarPoint( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
			target = new Vector3();

		}

		return target.copy( this.normal ).multiplyScalar( - this.constant );

	}

	applyMatrix4( matrix, optionalNormalMatrix ) {

		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

		this.constant = - referencePoint.dot( normal );

		return this;

	}

	translate( offset ) {

		this.constant -= offset.dot( this.normal );

		return this;

	}

	equals( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

Plane.prototype.isPlane = true;

const _v0$1 = /*@__PURE__*/ new Vector3();
const _v1$3 = /*@__PURE__*/ new Vector3();
const _v2$2 = /*@__PURE__*/ new Vector3();
const _v3$1 = /*@__PURE__*/ new Vector3();

const _vab = /*@__PURE__*/ new Vector3();
const _vac = /*@__PURE__*/ new Vector3();
const _vbc = /*@__PURE__*/ new Vector3();
const _vap = /*@__PURE__*/ new Vector3();
const _vbp = /*@__PURE__*/ new Vector3();
const _vcp = /*@__PURE__*/ new Vector3();

class Triangle {

	constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

		this.a = a;
		this.b = b;
		this.c = c;

	}

	static getNormal( a, b, c, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getNormal() target is now required' );
			target = new Vector3();

		}

		target.subVectors( c, b );
		_v0$1.subVectors( a, b );
		target.cross( _v0$1 );

		const targetLengthSq = target.lengthSq();
		if ( targetLengthSq > 0 ) {

			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		}

		return target.set( 0, 0, 0 );

	}

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	static getBarycoord( point, a, b, c, target ) {

		_v0$1.subVectors( c, a );
		_v1$3.subVectors( b, a );
		_v2$2.subVectors( point, a );

		const dot00 = _v0$1.dot( _v0$1 );
		const dot01 = _v0$1.dot( _v1$3 );
		const dot02 = _v0$1.dot( _v2$2 );
		const dot11 = _v1$3.dot( _v1$3 );
		const dot12 = _v1$3.dot( _v2$2 );

		const denom = ( dot00 * dot11 - dot01 * dot01 );

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
			target = new Vector3();

		}

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return target.set( - 2, - 1, - 1 );

		}

		const invDenom = 1 / denom;
		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set( 1 - u - v, v, u );

	}

	static containsPoint( point, a, b, c ) {

		this.getBarycoord( point, a, b, c, _v3$1 );

		return ( _v3$1.x >= 0 ) && ( _v3$1.y >= 0 ) && ( ( _v3$1.x + _v3$1.y ) <= 1 );

	}

	static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

		this.getBarycoord( point, p1, p2, p3, _v3$1 );

		target.set( 0, 0 );
		target.addScaledVector( uv1, _v3$1.x );
		target.addScaledVector( uv2, _v3$1.y );
		target.addScaledVector( uv3, _v3$1.z );

		return target;

	}

	static isFrontFacing( a, b, c, direction ) {

		_v0$1.subVectors( c, b );
		_v1$3.subVectors( a, b );

		// strictly front facing
		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

	}

	set( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	}

	setFromPointsAndIndices( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	}

	getArea() {

		_v0$1.subVectors( this.c, this.b );
		_v1$3.subVectors( this.a, this.b );

		return _v0$1.cross( _v1$3 ).length() * 0.5;

	}

	getMidpoint( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
			target = new Vector3();

		}

		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	}

	getNormal( target ) {

		return Triangle.getNormal( this.a, this.b, this.c, target );

	}

	getPlane( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getPlane() target is now required' );
			target = new Plane();

		}

		return target.setFromCoplanarPoints( this.a, this.b, this.c );

	}

	getBarycoord( point, target ) {

		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	}

	getUV( point, uv1, uv2, uv3, target ) {

		return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

	}

	containsPoint( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	}

	isFrontFacing( direction ) {

		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

	}

	intersectsBox( box ) {

		return box.intersectsTriangle( this );

	}

	closestPointToPoint( p, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
			target = new Vector3();

		}

		const a = this.a, b = this.b, c = this.c;
		let v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors( b, a );
		_vac.subVectors( c, a );
		_vap.subVectors( p, a );
		const d1 = _vab.dot( _vap );
		const d2 = _vac.dot( _vap );
		if ( d1 <= 0 && d2 <= 0 ) {

			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy( a );

		}

		_vbp.subVectors( p, b );
		const d3 = _vab.dot( _vbp );
		const d4 = _vac.dot( _vbp );
		if ( d3 >= 0 && d4 <= d3 ) {

			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy( b );

		}

		const vc = d1 * d4 - d3 * d2;
		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			v = d1 / ( d1 - d3 );
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy( a ).addScaledVector( _vab, v );

		}

		_vcp.subVectors( p, c );
		const d5 = _vab.dot( _vcp );
		const d6 = _vac.dot( _vcp );
		if ( d6 >= 0 && d5 <= d6 ) {

			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy( c );

		}

		const vb = d5 * d2 - d1 * d6;
		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			w = d2 / ( d2 - d6 );
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy( a ).addScaledVector( _vac, w );

		}

		const va = d3 * d6 - d5 * d4;
		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			_vbc.subVectors( c, b );
			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

		}

		// face region
		const denom = 1 / ( va + vb + vc );
		// u = va * denom
		v = vb * denom;
		w = vc * denom;

		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

	}

	equals( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

}

let materialId = 0;

function Material() {

	Object.defineProperty( this, 'id', { value: materialId ++ } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';
	this.type = 'Material';

	this.fog = true;

	this.blending = NormalBlending;
	this.side = FrontSide;
	this.vertexColors = false;

	this.opacity = 1;
	this.transparent = false;

	this.blendSrc = SrcAlphaFactor;
	this.blendDst = OneMinusSrcAlphaFactor;
	this.blendEquation = AddEquation;
	this.blendSrcAlpha = null;
	this.blendDstAlpha = null;
	this.blendEquationAlpha = null;

	this.depthFunc = LessEqualDepth;
	this.depthTest = true;
	this.depthWrite = true;

	this.stencilWriteMask = 0xff;
	this.stencilFunc = AlwaysStencilFunc;
	this.stencilRef = 0;
	this.stencilFuncMask = 0xff;
	this.stencilFail = KeepStencilOp;
	this.stencilZFail = KeepStencilOp;
	this.stencilZPass = KeepStencilOp;
	this.stencilWrite = false;

	this.clippingPlanes = null;
	this.clipIntersection = false;
	this.clipShadows = false;

	this.shadowSide = null;

	this.colorWrite = true;

	this.precision = null; // override the renderer's default precision for this material

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.dithering = false;

	this.alphaTest = 0;
	this.alphaToCoverage = false;
	this.premultipliedAlpha = false;

	this.visible = true;

	this.toneMapped = true;

	this.userData = {};

	this.version = 0;

}

Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Material,

	isMaterial: true,

	onBeforeCompile: function ( /* shaderobject, renderer */ ) {},

	customProgramCacheKey: function () {

		return this.onBeforeCompile.toString();

	},

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( const key in values ) {

			const newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
				continue;

			}

			// for backward compatability if shading is set in the constructor
			if ( key === 'shading' ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( newValue === FlatShading ) ? true : false;
				continue;

			}

			const currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( 'THREE.' + this.type + ': \'' + key + '\' is not a property of this material.' );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	},

	toJSON: function ( meta ) {

		const isRoot = ( meta === undefined || typeof meta === 'string' );

		if ( isRoot ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		const data = {
			metadata: {
				version: 4.5,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.sheen && this.sheen.isColor ) data.sheen = this.sheen.getHex();
		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

		}

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

		if ( this.lightMap && this.lightMap.isTexture ) {

			data.lightMap = this.lightMap.toJSON( meta ).uuid;
			data.lightMapIntensity = this.lightMapIntensity;

		}

		if ( this.aoMap && this.aoMap.isTexture ) {

			data.aoMap = this.aoMap.toJSON( meta ).uuid;
			data.aoMapIntensity = this.aoMapIntensity;

		}

		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}

		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();

		}

		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}

		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;
			data.reflectivity = this.reflectivity; // Scale behind envMap
			data.refractionRatio = this.refractionRatio;

			if ( this.combine !== undefined ) data.combine = this.combine;
			if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;

		}

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors ) data.vertexColors = true;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;

		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;
		data.colorWrite = this.colorWrite;

		data.stencilWrite = this.stencilWrite;
		data.stencilWriteMask = this.stencilWriteMask;
		data.stencilFunc = this.stencilFunc;
		data.stencilRef = this.stencilRef;
		data.stencilFuncMask = this.stencilFuncMask;
		data.stencilFail = this.stencilFail;
		data.stencilZFail = this.stencilZFail;
		data.stencilZPass = this.stencilZPass;

		// rotation (SpriteMaterial)
		if ( this.rotation && this.rotation !== 0 ) data.rotation = this.rotation;

		if ( this.polygonOffset === true ) data.polygonOffset = true;
		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

		if ( this.linewidth && this.linewidth !== 1 ) data.linewidth = this.linewidth;
		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		if ( this.scale !== undefined ) data.scale = this.scale;

		if ( this.dithering === true ) data.dithering = true;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		if ( this.morphTargets === true ) data.morphTargets = true;
		if ( this.morphNormals === true ) data.morphNormals = true;
		if ( this.skinning === true ) data.skinning = true;

		if ( this.flatShading === true ) data.flatShading = this.flatShading;

		if ( this.visible === false ) data.visible = false;

		if ( this.toneMapped === false ) data.toneMapped = false;

		if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRoot ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.fog = source.fog;

		this.blending = source.blending;
		this.side = source.side;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;

		const srcPlanes = source.clippingPlanes;
		let dstPlanes = null;

		if ( srcPlanes !== null ) {

			const n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( let i = 0; i !== n; ++ i ) {

				dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

		}

		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;

		this.shadowSide = source.shadowSide;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;
		this.alphaToCoverage = source.alphaToCoverage;
		this.premultipliedAlpha = source.premultipliedAlpha;

		this.visible = source.visible;

		this.toneMapped = source.toneMapped;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

Object.defineProperty( Material.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };

function hue2rgb( p, q, t ) {

	if ( t < 0 ) t += 1;
	if ( t > 1 ) t -= 1;
	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
	if ( t < 1 / 2 ) return q;
	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
	return p;

}

function SRGBToLinear( c ) {

	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

}

function LinearToSRGB( c ) {

	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

}

class Color {

	constructor( r, g, b ) {

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string
			return this.set( r );

		}

		return this.setRGB( r, g, b );

	}

	set( value ) {

		if ( value && value.isColor ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	}

	setScalar( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	}

	setHex( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	}

	setRGB( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	}

	setHSL( h, s, l ) {

		// h,s,l ranges are in 0.0 - 1.0
		h = MathUtils.euclideanModulo( h, 1 );
		s = MathUtils.clamp( s, 0, 1 );
		l = MathUtils.clamp( l, 0, 1 );

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			const q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		return this;

	}

	setStyle( style ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		let m;

		if ( m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			let color;
			const name = m[ 1 ];
			const components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						handleAlpha( color[ 4 ] );

						return this;

					}

					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						handleAlpha( color[ 4 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						const h = parseFloat( color[ 1 ] ) / 360;
						const s = parseInt( color[ 2 ], 10 ) / 100;
						const l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 4 ] );

						return this.setHSL( h, s, l );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

			// hex color

			const hex = m[ 1 ];
			const size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			return this.setColorName( style );

		}

		return this;

	}

	setColorName( style ) {

		// color keywords
		const hex = _colorKeywords[ style ];

		if ( hex !== undefined ) {

			// red
			this.setHex( hex );

		} else {

			// unknown color
			console.warn( 'THREE.Color: Unknown color ' + style );

		}

		return this;

	}

	clone() {

		return new this.constructor( this.r, this.g, this.b );

	}

	copy( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	}

	copyGammaToLinear( color, gammaFactor = 2.0 ) {

		this.r = Math.pow( color.r, gammaFactor );
		this.g = Math.pow( color.g, gammaFactor );
		this.b = Math.pow( color.b, gammaFactor );

		return this;

	}

	copyLinearToGamma( color, gammaFactor = 2.0 ) {

		const safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

		this.r = Math.pow( color.r, safeInverse );
		this.g = Math.pow( color.g, safeInverse );
		this.b = Math.pow( color.b, safeInverse );

		return this;

	}

	convertGammaToLinear( gammaFactor ) {

		this.copyGammaToLinear( this, gammaFactor );

		return this;

	}

	convertLinearToGamma( gammaFactor ) {

		this.copyLinearToGamma( this, gammaFactor );

		return this;

	}

	copySRGBToLinear( color ) {

		this.r = SRGBToLinear( color.r );
		this.g = SRGBToLinear( color.g );
		this.b = SRGBToLinear( color.b );

		return this;

	}

	copyLinearToSRGB( color ) {

		this.r = LinearToSRGB( color.r );
		this.g = LinearToSRGB( color.g );
		this.b = LinearToSRGB( color.b );

		return this;

	}

	convertSRGBToLinear() {

		this.copySRGBToLinear( this );

		return this;

	}

	convertLinearToSRGB() {

		this.copyLinearToSRGB( this );

		return this;

	}

	getHex() {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	}

	getHexString() {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	}

	getHSL( target ) {

		// h,s,l ranges are in 0.0 - 1.0

		if ( target === undefined ) {

			console.warn( 'THREE.Color: .getHSL() target is now required' );
			target = { h: 0, s: 0, l: 0 };

		}

		const r = this.r, g = this.g, b = this.b;

		const max = Math.max( r, g, b );
		const min = Math.min( r, g, b );

		let hue, saturation;
		const lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			const delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		target.h = hue;
		target.s = saturation;
		target.l = lightness;

		return target;

	}

	getStyle() {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	}

	offsetHSL( h, s, l ) {

		this.getHSL( _hslA );

		_hslA.h += h; _hslA.s += s; _hslA.l += l;

		this.setHSL( _hslA.h, _hslA.s, _hslA.l );

		return this;

	}

	add( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	}

	addColors( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	}

	addScalar( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	}

	sub( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	}

	multiply( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	}

	multiplyScalar( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	}

	lerp( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	}

	lerpColors( color1, color2, alpha ) {

		this.r = color1.r + ( color2.r - color1.r ) * alpha;
		this.g = color1.g + ( color2.g - color1.g ) * alpha;
		this.b = color1.b + ( color2.b - color1.b ) * alpha;

		return this;

	}

	lerpHSL( color, alpha ) {

		this.getHSL( _hslA );
		color.getHSL( _hslB );

		const h = MathUtils.lerp( _hslA.h, _hslB.h, alpha );
		const s = MathUtils.lerp( _hslA.s, _hslB.s, alpha );
		const l = MathUtils.lerp( _hslA.l, _hslB.l, alpha );

		this.setHSL( h, s, l );

		return this;

	}

	equals( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	}

	fromArray( array, offset = 0 ) {

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.r = attribute.getX( index );
		this.g = attribute.getY( index );
		this.b = attribute.getZ( index );

		if ( attribute.normalized === true ) {

			// assuming Uint8Array

			this.r /= 255;
			this.g /= 255;
			this.b /= 255;

		}

		return this;

	}

	toJSON() {

		return this.getHex();

	}

}

Color.NAMES = _colorKeywords;

Color.prototype.isColor = true;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */

class MeshBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshBasicMaterial';

		this.color = new Color( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		return this;

	}

}

MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

const _vector$9 = new Vector3();
const _vector2 = new Vector2();

function BufferAttribute( array, itemSize, normalized ) {

	if ( Array.isArray( array ) ) {

		throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

	}

	this.name = '';

	this.array = array;
	this.itemSize = itemSize;
	this.count = array !== undefined ? array.length / itemSize : 0;
	this.normalized = normalized === true;

	this.usage = StaticDrawUsage;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

}

Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

Object.assign( BufferAttribute.prototype, {

	isBufferAttribute: true,

	onUploadCallback: function () {},

	setUsage: function ( value ) {

		this.usage = value;

		return this;

	},

	copy: function ( source ) {

		this.name = source.name;
		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.usage = source.usage;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	copyArray: function ( array ) {

		this.array.set( array );

		return this;

	},

	copyColorsArray: function ( colors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = colors.length; i < l; i ++ ) {

			let color = colors[ i ];

			if ( color === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new Color();

			}

			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;

		}

		return this;

	},

	copyVector2sArray: function ( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new Vector2();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;

		}

		return this;

	},

	copyVector3sArray: function ( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new Vector3();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;

		}

		return this;

	},

	copyVector4sArray: function ( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new Vector4();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;

		}

		return this;

	},

	applyMatrix3: function ( m ) {

		if ( this.itemSize === 2 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector2.fromBufferAttribute( this, i );
				_vector2.applyMatrix3( m );

				this.setXY( i, _vector2.x, _vector2.y );

			}

		} else if ( this.itemSize === 3 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$9.fromBufferAttribute( this, i );
				_vector$9.applyMatrix3( m );

				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

			}

		}

		return this;

	},

	applyMatrix4: function ( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.x = this.getX( i );
			_vector$9.y = this.getY( i );
			_vector$9.z = this.getZ( i );

			_vector$9.applyMatrix4( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	},

	applyNormalMatrix: function ( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.x = this.getX( i );
			_vector$9.y = this.getY( i );
			_vector$9.z = this.getZ( i );

			_vector$9.applyNormalMatrix( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	},

	transformDirection: function ( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.x = this.getX( i );
			_vector$9.y = this.getY( i );
			_vector$9.z = this.getZ( i );

			_vector$9.transformDirection( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	},

	set: function ( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	},

	getX: function ( index ) {

		return this.array[ index * this.itemSize ];

	},

	setX: function ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	},

	getY: function ( index ) {

		return this.array[ index * this.itemSize + 1 ];

	},

	setY: function ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	},

	getZ: function ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	},

	setZ: function ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	},

	getW: function ( index ) {

		return this.array[ index * this.itemSize + 3 ];

	},

	setW: function ( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	},

	setXY: function ( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	},

	onUpload: function ( callback ) {

		this.onUploadCallback = callback;

		return this;

	},

	clone: function () {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	},

	toJSON: function () {

		const data = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.prototype.slice.call( this.array ),
			normalized: this.normalized
		};

		if ( this.name !== '' ) data.name = this.name;
		if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;
		if ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;

		return data;

	}

} );

//

function Int8BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

}

Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


function Uint8BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

}

Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

}

Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


function Int16BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

}

Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


function Uint16BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

}

Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


function Int32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

}

Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


function Uint32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

}

Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;

function Float16BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

}

Float16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float16BufferAttribute.prototype.constructor = Float16BufferAttribute;
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

function Float32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

}

Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


function Float64BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

}

Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

function arrayMax( array ) {

	if ( array.length === 0 ) return - Infinity;

	let max = array[ 0 ];

	for ( let i = 1, l = array.length; i < l; ++ i ) {

		if ( array[ i ] > max ) max = array[ i ];

	}

	return max;

}

const TYPED_ARRAYS = {
	Int8Array: Int8Array,
	Uint8Array: Uint8Array,
	Uint8ClampedArray: Uint8ClampedArray,
	Int16Array: Int16Array,
	Uint16Array: Uint16Array,
	Int32Array: Int32Array,
	Uint32Array: Uint32Array,
	Float32Array: Float32Array,
	Float64Array: Float64Array
};

function getTypedArray( type, buffer ) {

	return new TYPED_ARRAYS[ type ]( buffer );

}

let _id = 0;

const _m1 = new Matrix4();
const _obj = new Object3D();
const _offset = new Vector3();
const _box$1 = new Box3();
const _boxMorphTargets = new Box3();
const _vector$8 = new Vector3();

function BufferGeometry() {

	Object.defineProperty( this, 'id', { value: _id ++ } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';
	this.type = 'BufferGeometry';

	this.index = null;
	this.attributes = {};

	this.morphAttributes = {};
	this.morphTargetsRelative = false;

	this.groups = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.drawRange = { start: 0, count: Infinity };

	this.userData = {};

}

BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: BufferGeometry,

	isBufferGeometry: true,

	getIndex: function () {

		return this.index;

	},

	setIndex: function ( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		} else {

			this.index = index;

		}

		return this;

	},

	getAttribute: function ( name ) {

		return this.attributes[ name ];

	},

	setAttribute: function ( name, attribute ) {

		this.attributes[ name ] = attribute;

		return this;

	},

	deleteAttribute: function ( name ) {

		delete this.attributes[ name ];

		return this;

	},

	hasAttribute: function ( name ) {

		return this.attributes[ name ] !== undefined;

	},

	addGroup: function ( start, count, materialIndex = 0 ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex

		} );

	},

	clearGroups: function () {

		this.groups = [];

	},

	setDrawRange: function ( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	},

	applyMatrix4: function ( matrix ) {

		const position = this.attributes.position;

		if ( position !== undefined ) {

			position.applyMatrix4( matrix );

			position.needsUpdate = true;

		}

		const normal = this.attributes.normal;

		if ( normal !== undefined ) {

			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normal.applyNormalMatrix( normalMatrix );

			normal.needsUpdate = true;

		}

		const tangent = this.attributes.tangent;

		if ( tangent !== undefined ) {

			tangent.transformDirection( matrix );

			tangent.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	},

	rotateX: function ( angle ) {

		// rotate geometry around world x-axis

		_m1.makeRotationX( angle );

		this.applyMatrix4( _m1 );

		return this;

	},

	rotateY: function ( angle ) {

		// rotate geometry around world y-axis

		_m1.makeRotationY( angle );

		this.applyMatrix4( _m1 );

		return this;

	},

	rotateZ: function ( angle ) {

		// rotate geometry around world z-axis

		_m1.makeRotationZ( angle );

		this.applyMatrix4( _m1 );

		return this;

	},

	translate: function ( x, y, z ) {

		// translate geometry

		_m1.makeTranslation( x, y, z );

		this.applyMatrix4( _m1 );

		return this;

	},

	scale: function ( x, y, z ) {

		// scale geometry

		_m1.makeScale( x, y, z );

		this.applyMatrix4( _m1 );

		return this;

	},

	lookAt: function ( vector ) {

		_obj.lookAt( vector );

		_obj.updateMatrix();

		this.applyMatrix4( _obj.matrix );

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset ).negate();

		this.translate( _offset.x, _offset.y, _offset.z );

		return this;

	},

	setFromPoints: function ( points ) {

		const position = [];

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const point = points[ i ];
			position.push( point.x, point.y, point.z || 0 );

		}

		this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

		return this;

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingBox.set(
				new Vector3( - Infinity, - Infinity, - Infinity ),
				new Vector3( + Infinity, + Infinity, + Infinity )
			);

			return;

		}

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_box$1.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( this.boundingBox.min, _box$1.min );
						this.boundingBox.expandByPoint( _vector$8 );

						_vector$8.addVectors( this.boundingBox.max, _box$1.max );
						this.boundingBox.expandByPoint( _vector$8 );

					} else {

						this.boundingBox.expandByPoint( _box$1.min );
						this.boundingBox.expandByPoint( _box$1.max );

					}

				}

			}

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingSphere.set( new Vector3(), Infinity );

			return;

		}

		if ( position ) {

			// first, find the center of the bounding sphere

			const center = this.boundingSphere.center;

			_box$1.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( _box$1.min, _boxMorphTargets.min );
						_box$1.expandByPoint( _vector$8 );

						_vector$8.addVectors( _box$1.max, _boxMorphTargets.max );
						_box$1.expandByPoint( _vector$8 );

					} else {

						_box$1.expandByPoint( _boxMorphTargets.min );
						_box$1.expandByPoint( _boxMorphTargets.max );

					}

				}

			}

			_box$1.getCenter( center );

			// second, try to find a boundingSphere with a radius smaller than the
			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			let maxRadiusSq = 0;

			for ( let i = 0, il = position.count; i < il; i ++ ) {

				_vector$8.fromBufferAttribute( position, i );

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

			}

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					const morphTargetsRelative = this.morphTargetsRelative;

					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

						_vector$8.fromBufferAttribute( morphAttribute, j );

						if ( morphTargetsRelative ) {

							_offset.fromBufferAttribute( position, j );
							_vector$8.add( _offset );

						}

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

					}

				}

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

			}

		}

	},

	computeFaceNormals: function () {

		// backwards compatibility

	},

	computeTangents: function () {

		const index = this.index;
		const attributes = this.attributes;

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( index === null ||
			 attributes.position === undefined ||
			 attributes.normal === undefined ||
			 attributes.uv === undefined ) {

			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
			return;

		}

		const indices = index.array;
		const positions = attributes.position.array;
		const normals = attributes.normal.array;
		const uvs = attributes.uv.array;

		const nVertices = positions.length / 3;

		if ( attributes.tangent === undefined ) {

			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

		}

		const tangents = attributes.tangent.array;

		const tan1 = [], tan2 = [];

		for ( let i = 0; i < nVertices; i ++ ) {

			tan1[ i ] = new Vector3();
			tan2[ i ] = new Vector3();

		}

		const vA = new Vector3(),
			vB = new Vector3(),
			vC = new Vector3(),

			uvA = new Vector2(),
			uvB = new Vector2(),
			uvC = new Vector2(),

			sdir = new Vector3(),
			tdir = new Vector3();

		function handleTriangle( a, b, c ) {

			vA.fromArray( positions, a * 3 );
			vB.fromArray( positions, b * 3 );
			vC.fromArray( positions, c * 3 );

			uvA.fromArray( uvs, a * 2 );
			uvB.fromArray( uvs, b * 2 );
			uvC.fromArray( uvs, c * 2 );

			vB.sub( vA );
			vC.sub( vA );

			uvB.sub( uvA );
			uvC.sub( uvA );

			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

			// silently ignore degenerate uv triangles having coincident or colinear vertices

			if ( ! isFinite( r ) ) return;

			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		let groups = this.groups;

		if ( groups.length === 0 ) {

			groups = [ {
				start: 0,
				count: indices.length
			} ];

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleTriangle(
					indices[ j + 0 ],
					indices[ j + 1 ],
					indices[ j + 2 ]
				);

			}

		}

		const tmp = new Vector3(), tmp2 = new Vector3();
		const n = new Vector3(), n2 = new Vector3();

		function handleVertex( v ) {

			n.fromArray( normals, v * 3 );
			n2.copy( n );

			const t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			const test = tmp2.dot( tan2[ v ] );
			const w = ( test < 0.0 ) ? - 1.0 : 1.0;

			tangents[ v * 4 ] = tmp.x;
			tangents[ v * 4 + 1 ] = tmp.y;
			tangents[ v * 4 + 2 ] = tmp.z;
			tangents[ v * 4 + 3 ] = w;

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleVertex( indices[ j + 0 ] );
				handleVertex( indices[ j + 1 ] );
				handleVertex( indices[ j + 2 ] );

			}

		}

	},

	computeVertexNormals: function () {

		const index = this.index;
		const positionAttribute = this.getAttribute( 'position' );

		if ( positionAttribute !== undefined ) {

			let normalAttribute = this.getAttribute( 'normal' );

			if ( normalAttribute === undefined ) {

				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
				this.setAttribute( 'normal', normalAttribute );

			} else {

				// reset existing normals to zero

				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

					normalAttribute.setXYZ( i, 0, 0, 0 );

				}

			}

			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
			const cb = new Vector3(), ab = new Vector3();

			// indexed elements

			if ( index ) {

				for ( let i = 0, il = index.count; i < il; i += 3 ) {

					const vA = index.getX( i + 0 );
					const vB = index.getX( i + 1 );
					const vC = index.getX( i + 2 );

					pA.fromBufferAttribute( positionAttribute, vA );
					pB.fromBufferAttribute( positionAttribute, vB );
					pC.fromBufferAttribute( positionAttribute, vC );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					nA.fromBufferAttribute( normalAttribute, vA );
					nB.fromBufferAttribute( normalAttribute, vB );
					nC.fromBufferAttribute( normalAttribute, vC );

					nA.add( cb );
					nB.add( cb );
					nC.add( cb );

					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

					pA.fromBufferAttribute( positionAttribute, i + 0 );
					pB.fromBufferAttribute( positionAttribute, i + 1 );
					pC.fromBufferAttribute( positionAttribute, i + 2 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

				}

			}

			this.normalizeNormals();

			normalAttribute.needsUpdate = true;

		}

	},

	merge: function ( geometry, offset ) {

		if ( ! ( geometry && geometry.isBufferGeometry ) ) {

			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) {

			offset = 0;

			console.warn(
				'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
				+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
			);

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) continue;

			const attribute1 = attributes[ key ];
			const attributeArray1 = attribute1.array;

			const attribute2 = geometry.attributes[ key ];
			const attributeArray2 = attribute2.array;

			const attributeOffset = attribute2.itemSize * offset;
			const length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

			for ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	},

	normalizeNormals: function () {

		const normals = this.attributes.normal;

		for ( let i = 0, il = normals.count; i < il; i ++ ) {

			_vector$8.fromBufferAttribute( normals, i );

			_vector$8.normalize();

			normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

		}

	},

	toNonIndexed: function () {

		function convertBufferAttribute( attribute, indices ) {

			const array = attribute.array;
			const itemSize = attribute.itemSize;
			const normalized = attribute.normalized;

			const array2 = new array.constructor( indices.length * itemSize );

			let index = 0, index2 = 0;

			for ( let i = 0, l = indices.length; i < l; i ++ ) {

				index = indices[ i ] * itemSize;

				for ( let j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			return new BufferAttribute( array2, itemSize, normalized );

		}

		//

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
			return this;

		}

		const geometry2 = new BufferGeometry();

		const indices = this.index.array;
		const attributes = this.attributes;

		// attributes

		for ( const name in attributes ) {

			const attribute = attributes[ name ];

			const newAttribute = convertBufferAttribute( attribute, indices );

			geometry2.setAttribute( name, newAttribute );

		}

		// morph attributes

		const morphAttributes = this.morphAttributes;

		for ( const name in morphAttributes ) {

			const morphArray = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				const attribute = morphAttribute[ i ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				morphArray.push( newAttribute );

			}

			geometry2.morphAttributes[ name ] = morphArray;

		}

		geometry2.morphTargetsRelative = this.morphTargetsRelative;

		// groups

		const groups = this.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			geometry2.addGroup( group.start, group.count, group.materialIndex );

		}

		return geometry2;

	},

	toJSON: function () {

		const data = {
			metadata: {
				version: 4.5,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		if ( this.parameters !== undefined ) {

			const parameters = this.parameters;

			for ( const key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		// for simplicity the code assumes attributes are not shared across geometries, see #15811

		data.data = { attributes: {} };

		const index = this.index;

		if ( index !== null ) {

			data.data.index = {
				type: index.array.constructor.name,
				array: Array.prototype.slice.call( index.array )
			};

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			data.data.attributes[ key ] = attribute.toJSON( data.data );

		}

		const morphAttributes = {};
		let hasMorphAttributes = false;

		for ( const key in this.morphAttributes ) {

			const attributeArray = this.morphAttributes[ key ];

			const array = [];

			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

				const attribute = attributeArray[ i ];

				array.push( attribute.toJSON( data.data ) );

			}

			if ( array.length > 0 ) {

				morphAttributes[ key ] = array;

				hasMorphAttributes = true;

			}

		}

		if ( hasMorphAttributes ) {

			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;

		}

		const groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		const boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	},

	clone: function () {

		/*
		 // Handle primitives

		 const parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 const values = [];

		 for ( const key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 const geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */

		return new BufferGeometry().copy( this );

	},

	copy: function ( source ) {

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// used for storing cloned, shared data

		const data = {};

		// name

		this.name = source.name;

		// index

		const index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone( data ) );

		}

		// attributes

		const attributes = source.attributes;

		for ( const name in attributes ) {

			const attribute = attributes[ name ];
			this.setAttribute( name, attribute.clone( data ) );

		}

		// morph attributes

		const morphAttributes = source.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone( data ) );

			}

			this.morphAttributes[ name ] = array;

		}

		this.morphTargetsRelative = source.morphTargetsRelative;

		// groups

		const groups = source.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		const boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		const boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

const _inverseMatrix$2 = new Matrix4();
const _ray$2 = new Ray();
const _sphere$3 = new Sphere();

const _vA$1 = new Vector3();
const _vB$1 = new Vector3();
const _vC$1 = new Vector3();

const _tempA = new Vector3();
const _tempB = new Vector3();
const _tempC = new Vector3();

const _morphA = new Vector3();
const _morphB = new Vector3();
const _morphC = new Vector3();

const _uvA$1 = new Vector2();
const _uvB$1 = new Vector2();
const _uvC$1 = new Vector2();

const _intersectionPoint = new Vector3();
const _intersectionPointWorld = new Vector3();

function Mesh( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

	Object3D.call( this );

	this.type = 'Mesh';

	this.geometry = geometry;
	this.material = material;

	this.updateMorphTargets();

}

Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Mesh,

	isMesh: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		if ( source.morphTargetInfluences !== undefined ) {

			this.morphTargetInfluences = source.morphTargetInfluences.slice();

		}

		if ( source.morphTargetDictionary !== undefined ) {

			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		}

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	},

	updateMorphTargets: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			const morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	},

	raycast: function ( raycaster, intersects ) {

		const geometry = this.geometry;
		const material = this.material;
		const matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$3.copy( geometry.boundingSphere );
		_sphere$3.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;

		//

		_inverseMatrix$2.copy( matrixWorld ).invert();
		_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

		// Check boundingBox before continuing

		if ( geometry.boundingBox !== null ) {

			if ( _ray$2.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		let intersection;

		if ( geometry.isBufferGeometry ) {

			const index = geometry.index;
			const position = geometry.attributes.position;
			const morphPosition = geometry.morphAttributes.position;
			const morphTargetsRelative = geometry.morphTargetsRelative;
			const uv = geometry.attributes.uv;
			const uv2 = geometry.attributes.uv2;
			const groups = geometry.groups;
			const drawRange = geometry.drawRange;

			if ( index !== null ) {

				// indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = index.getX( j );
							const b = index.getX( j + 1 );
							const c = index.getX( j + 2 );

							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = index.getX( i );
						const b = index.getX( i + 1 );
						const c = index.getX( i + 2 );

						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			} else if ( position !== undefined ) {

				// non-indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = j;
							const b = j + 1;
							const c = j + 2;

							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = i;
						const b = i + 1;
						const c = i + 2;

						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

	}

} );

function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

	let intersect;

	if ( material.side === BackSide ) {

		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	} else {

		intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

	}

	if ( intersect === null ) return null;

	_intersectionPointWorld.copy( point );
	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

	if ( distance < raycaster.near || distance > raycaster.far ) return null;

	return {
		distance: distance,
		point: _intersectionPointWorld.clone(),
		object: object
	};

}

function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

	_vA$1.fromBufferAttribute( position, a );
	_vB$1.fromBufferAttribute( position, b );
	_vC$1.fromBufferAttribute( position, c );

	const morphInfluences = object.morphTargetInfluences;

	if ( material.morphTargets && morphPosition && morphInfluences ) {

		_morphA.set( 0, 0, 0 );
		_morphB.set( 0, 0, 0 );
		_morphC.set( 0, 0, 0 );

		for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

			const influence = morphInfluences[ i ];
			const morphAttribute = morphPosition[ i ];

			if ( influence === 0 ) continue;

			_tempA.fromBufferAttribute( morphAttribute, a );
			_tempB.fromBufferAttribute( morphAttribute, b );
			_tempC.fromBufferAttribute( morphAttribute, c );

			if ( morphTargetsRelative ) {

				_morphA.addScaledVector( _tempA, influence );
				_morphB.addScaledVector( _tempB, influence );
				_morphC.addScaledVector( _tempC, influence );

			} else {

				_morphA.addScaledVector( _tempA.sub( _vA$1 ), influence );
				_morphB.addScaledVector( _tempB.sub( _vB$1 ), influence );
				_morphC.addScaledVector( _tempC.sub( _vC$1 ), influence );

			}

		}

		_vA$1.add( _morphA );
		_vB$1.add( _morphB );
		_vC$1.add( _morphC );

	}

	if ( object.isSkinnedMesh && material.skinning ) {

		object.boneTransform( a, _vA$1 );
		object.boneTransform( b, _vB$1 );
		object.boneTransform( c, _vC$1 );

	}

	const intersection = checkIntersection( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

	if ( intersection ) {

		if ( uv ) {

			_uvA$1.fromBufferAttribute( uv, a );
			_uvB$1.fromBufferAttribute( uv, b );
			_uvC$1.fromBufferAttribute( uv, c );

			intersection.uv = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		}

		if ( uv2 ) {

			_uvA$1.fromBufferAttribute( uv2, a );
			_uvB$1.fromBufferAttribute( uv2, b );
			_uvC$1.fromBufferAttribute( uv2, c );

			intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		}

		const face = {
			a: a,
			b: b,
			c: c,
			normal: new Vector3(),
			materialIndex: 0
		};

		Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

		intersection.face = face;

	}

	return intersection;

}

class BoxGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

		super();

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		const scope = this;

		// segments

		widthSegments = Math.floor( widthSegments );
		heightSegments = Math.floor( heightSegments );
		depthSegments = Math.floor( depthSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let numberOfVertices = 0;
		let groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			const segmentWidth = width / gridX;
			const segmentHeight = height / gridY;

			const widthHalf = width / 2;
			const heightHalf = height / 2;
			const depthHalf = depth / 2;

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			let vertexCounter = 0;
			let groupCount = 0;

			const vector = new Vector3();

			// generate vertices, normals and uvs

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segmentHeight - heightHalf;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = numberOfVertices + ix + gridX1 * iy;
					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

}

/**
 * Uniform Utilities
 */

function cloneUniforms( src ) {

	const dst = {};

	for ( const u in src ) {

		dst[ u ] = {};

		for ( const p in src[ u ] ) {

			const property = src[ u ][ p ];

			if ( property && ( property.isColor ||
				property.isMatrix3 || property.isMatrix4 ||
				property.isVector2 || property.isVector3 || property.isVector4 ||
				property.isTexture || property.isQuaternion ) ) {

				dst[ u ][ p ] = property.clone();

			} else if ( Array.isArray( property ) ) {

				dst[ u ][ p ] = property.slice();

			} else {

				dst[ u ][ p ] = property;

			}

		}

	}

	return dst;

}

function mergeUniforms( uniforms ) {

	const merged = {};

	for ( let u = 0; u < uniforms.length; u ++ ) {

		const tmp = cloneUniforms( uniforms[ u ] );

		for ( const p in tmp ) {

			merged[ p ] = tmp[ p ];

		}

	}

	return merged;

}

// Legacy

const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

/**
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function ShaderMaterial( parameters ) {

	Material.call( this );

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};

	this.vertexShader = default_vertex;
	this.fragmentShader = default_fragment;

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog
	this.lights = false; // set to use scene lights
	this.clipping = false; // set to use user-defined clipping planes

	this.skinning = false; // set to use skinning attribute streams
	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	this.extensions = {
		derivatives: false, // set to use derivatives
		fragDepth: false, // set to use fragment depth values
		drawBuffers: false, // set to use draw buffers
		shaderTextureLOD: false // set to use shader texture LOD
	};

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};

	this.index0AttributeName = undefined;
	this.uniformsNeedUpdate = false;

	this.glslVersion = null;

	if ( parameters !== undefined ) {

		if ( parameters.attributes !== undefined ) {

			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

		}

		this.setValues( parameters );

	}

}

ShaderMaterial.prototype = Object.create( Material.prototype );
ShaderMaterial.prototype.constructor = ShaderMaterial;

ShaderMaterial.prototype.isShaderMaterial = true;

ShaderMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.fragmentShader = source.fragmentShader;
	this.vertexShader = source.vertexShader;

	this.uniforms = cloneUniforms( source.uniforms );

	this.defines = Object.assign( {}, source.defines );

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.lights = source.lights;
	this.clipping = source.clipping;

	this.skinning = source.skinning;

	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.extensions = Object.assign( {}, source.extensions );

	this.glslVersion = source.glslVersion;

	return this;

};

ShaderMaterial.prototype.toJSON = function ( meta ) {

	const data = Material.prototype.toJSON.call( this, meta );

	data.glslVersion = this.glslVersion;
	data.uniforms = {};

	for ( const name in this.uniforms ) {

		const uniform = this.uniforms[ name ];
		const value = uniform.value;

		if ( value && value.isTexture ) {

			data.uniforms[ name ] = {
				type: 't',
				value: value.toJSON( meta ).uuid
			};

		} else if ( value && value.isColor ) {

			data.uniforms[ name ] = {
				type: 'c',
				value: value.getHex()
			};

		} else if ( value && value.isVector2 ) {

			data.uniforms[ name ] = {
				type: 'v2',
				value: value.toArray()
			};

		} else if ( value && value.isVector3 ) {

			data.uniforms[ name ] = {
				type: 'v3',
				value: value.toArray()
			};

		} else if ( value && value.isVector4 ) {

			data.uniforms[ name ] = {
				type: 'v4',
				value: value.toArray()
			};

		} else if ( value && value.isMatrix3 ) {

			data.uniforms[ name ] = {
				type: 'm3',
				value: value.toArray()
			};

		} else if ( value && value.isMatrix4 ) {

			data.uniforms[ name ] = {
				type: 'm4',
				value: value.toArray()
			};

		} else {

			data.uniforms[ name ] = {
				value: value
			};

			// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

		}

	}

	if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

	data.vertexShader = this.vertexShader;
	data.fragmentShader = this.fragmentShader;

	const extensions = {};

	for ( const key in this.extensions ) {

		if ( this.extensions[ key ] === true ) extensions[ key ] = true;

	}

	if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

	return data;

};

function Camera() {

	Object3D.call( this );

	this.type = 'Camera';

	this.matrixWorldInverse = new Matrix4();

	this.projectionMatrix = new Matrix4();
	this.projectionMatrixInverse = new Matrix4();

}

Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Camera,

	isCamera: true,

	copy: function ( source, recursive ) {

		Object3D.prototype.copy.call( this, source, recursive );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );

		this.projectionMatrix.copy( source.projectionMatrix );
		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

		return this;

	},

	getWorldDirection: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
			target = new Vector3();

		}

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

	},

	updateMatrixWorld: function ( force ) {

		Object3D.prototype.updateMatrixWorld.call( this, force );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	},

	updateWorldMatrix: function ( updateParents, updateChildren ) {

		Object3D.prototype.updateWorldMatrix.call( this, updateParents, updateChildren );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

} );

function PerspectiveCamera( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

	Camera.call( this );

	this.type = 'PerspectiveCamera';

	this.fov = fov;
	this.zoom = 1;

	this.near = near;
	this.far = far;
	this.focus = 10;

	this.aspect = aspect;
	this.view = null;

	this.filmGauge = 35;	// width of the film (default in millimeters)
	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

	this.updateProjectionMatrix();

}

PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

	constructor: PerspectiveCamera,

	isPerspectiveCamera: true,

	copy: function ( source, recursive ) {

		Camera.prototype.copy.call( this, source, recursive );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	},

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength: function ( focalLength ) {

		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	},

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength: function () {

		const vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	},

	getEffectiveFOV: function () {

		return MathUtils.RAD2DEG * 2 * Math.atan(
			Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );

	},

	getFilmWidth: function () {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	},

	getFilmHeight: function () {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	},

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	},

	clearViewOffset: function () {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	},

	updateProjectionMatrix: function () {

		const near = this.near;
		let top = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom;
		let height = 2 * top;
		let width = this.aspect * height;
		let left = - 0.5 * width;
		const view = this.view;

		if ( this.view !== null && this.view.enabled ) {

			const fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		const skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	},

	toJSON: function ( meta ) {

		const data = Object3D.prototype.toJSON.call( this, meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

} );

const fov = 90, aspect = 1;

class CubeCamera extends Object3D {

	constructor( near, far, renderTarget ) {

		super();

		this.type = 'CubeCamera';

		if ( renderTarget.isWebGLCubeRenderTarget !== true ) {

			console.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );
			return;

		}

		this.renderTarget = renderTarget;

		const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.layers = this.layers;
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
		this.add( cameraPX );

		const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.layers = this.layers;
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );

		const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.layers = this.layers;
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
		this.add( cameraPY );

		const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.layers = this.layers;
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );

		const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.layers = this.layers;
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );

		const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.layers = this.layers;
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );

	}

	update( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		const renderTarget = this.renderTarget;

		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

		const currentXrEnabled = renderer.xr.enabled;
		const currentRenderTarget = renderer.getRenderTarget();

		renderer.xr.enabled = false;

		const generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderer.setRenderTarget( renderTarget, 0 );
		renderer.render( scene, cameraPX );

		renderer.setRenderTarget( renderTarget, 1 );
		renderer.render( scene, cameraNX );

		renderer.setRenderTarget( renderTarget, 2 );
		renderer.render( scene, cameraPY );

		renderer.setRenderTarget( renderTarget, 3 );
		renderer.render( scene, cameraNY );

		renderer.setRenderTarget( renderTarget, 4 );
		renderer.render( scene, cameraPZ );

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderer.setRenderTarget( renderTarget, 5 );
		renderer.render( scene, cameraNZ );

		renderer.setRenderTarget( currentRenderTarget );

		renderer.xr.enabled = currentXrEnabled;

	}

}

class CubeTexture extends Texture {

	constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
		format = format !== undefined ? format : RGBFormat;

		super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		// Why CubeTexture._needsFlipEnvMap is necessary:
		//
		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
		// and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)
		// when using WebGLCubeRenderTarget.texture as a cube texture.

		this._needsFlipEnvMap = true;

		this.flipY = false;

	}

	get images() {

		return this.image;

	}

	set images( value ) {

		this.image = value;

	}

}

CubeTexture.prototype.isCubeTexture = true;

class WebGLCubeRenderTarget extends WebGLRenderTarget {

	constructor( size, options, dummy ) {

		if ( Number.isInteger( options ) ) {

			console.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );

			options = dummy;

		}

		super( size, size, options );

		options = options || {};

		this.texture = new CubeTexture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		this.texture._needsFlipEnvMap = false;

	}

	fromEquirectangularTexture( renderer, texture ) {

		this.texture.type = texture.type;
		this.texture.format = RGBAFormat; // see #18859
		this.texture.encoding = texture.encoding;

		this.texture.generateMipmaps = texture.generateMipmaps;
		this.texture.minFilter = texture.minFilter;
		this.texture.magFilter = texture.magFilter;

		const shader = {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
		};

		const geometry = new BoxGeometry( 5, 5, 5 );

		const material = new ShaderMaterial( {

			name: 'CubemapFromEquirect',

			uniforms: cloneUniforms( shader.uniforms ),
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			side: BackSide,
			blending: NoBlending

		} );

		material.uniforms.tEquirect.value = texture;

		const mesh = new Mesh( geometry, material );

		const currentMinFilter = texture.minFilter;

		// Avoid blurred poles
		if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

		const camera = new CubeCamera( 1, 10, this );
		camera.update( renderer, mesh );

		texture.minFilter = currentMinFilter;

		mesh.geometry.dispose();
		mesh.material.dispose();

		return this;

	}

	clear( renderer, color, depth, stencil ) {

		const currentRenderTarget = renderer.getRenderTarget();

		for ( let i = 0; i < 6; i ++ ) {

			renderer.setRenderTarget( this, i );

			renderer.clear( color, depth, stencil );

		}

		renderer.setRenderTarget( currentRenderTarget );

	}

}

WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

class DataTexture extends Texture {

	constructor( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { data: data || null, width: width || 1, height: height || 1 };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

		this.needsUpdate = true;

	}

}

DataTexture.prototype.isDataTexture = true;

const _sphere$2 = /*@__PURE__*/ new Sphere();
const _vector$7 = /*@__PURE__*/ new Vector3();

class Frustum {

	constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

		this.planes = [ p0, p1, p2, p3, p4, p5 ];

	}

	set( p0, p1, p2, p3, p4, p5 ) {

		const planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	}

	copy( frustum ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	}

	setFromProjectionMatrix( m ) {

		const planes = this.planes;
		const me = m.elements;
		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	}

	intersectsObject( object ) {

		const geometry = object.geometry;

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$2.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

		return this.intersectsSphere( _sphere$2 );

	}

	intersectsSprite( sprite ) {

		_sphere$2.center.set( 0, 0, 0 );
		_sphere$2.radius = 0.7071067811865476;
		_sphere$2.applyMatrix4( sprite.matrixWorld );

		return this.intersectsSphere( _sphere$2 );

	}

	intersectsSphere( sphere ) {

		const planes = this.planes;
		const center = sphere.center;
		const negRadius = - sphere.radius;

		for ( let i = 0; i < 6; i ++ ) {

			const distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	}

	intersectsBox( box ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			const plane = planes[ i ];

			// corner at max distance

			_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

			if ( plane.distanceToPoint( _vector$7 ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	containsPoint( point ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

function WebGLAnimation() {

	let context = null;
	let isAnimating = false;
	let animationLoop = null;
	let requestId = null;

	function onAnimationFrame( time, frame ) {

		animationLoop( time, frame );

		requestId = context.requestAnimationFrame( onAnimationFrame );

	}

	return {

		start: function () {

			if ( isAnimating === true ) return;
			if ( animationLoop === null ) return;

			requestId = context.requestAnimationFrame( onAnimationFrame );

			isAnimating = true;

		},

		stop: function () {

			context.cancelAnimationFrame( requestId );

			isAnimating = false;

		},

		setAnimationLoop: function ( callback ) {

			animationLoop = callback;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

}

function WebGLAttributes( gl, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	const buffers = new WeakMap();

	function createBuffer( attribute, bufferType ) {

		const array = attribute.array;
		const usage = attribute.usage;

		const buffer = gl.createBuffer();

		gl.bindBuffer( bufferType, buffer );
		gl.bufferData( bufferType, array, usage );

		attribute.onUploadCallback();

		let type = 5126;

		if ( array instanceof Float32Array ) {

			type = 5126;

		} else if ( array instanceof Float64Array ) {

			console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

		} else if ( array instanceof Uint16Array ) {

			if ( attribute.isFloat16BufferAttribute ) {

				if ( isWebGL2 ) {

					type = 5131;

				} else {

					console.warn( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );

				}

			} else {

				type = 5123;

			}

		} else if ( array instanceof Int16Array ) {

			type = 5122;

		} else if ( array instanceof Uint32Array ) {

			type = 5125;

		} else if ( array instanceof Int32Array ) {

			type = 5124;

		} else if ( array instanceof Int8Array ) {

			type = 5120;

		} else if ( array instanceof Uint8Array ) {

			type = 5121;

		}

		return {
			buffer: buffer,
			type: type,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version
		};

	}

	function updateBuffer( buffer, attribute, bufferType ) {

		const array = attribute.array;
		const updateRange = attribute.updateRange;

		gl.bindBuffer( bufferType, buffer );

		if ( updateRange.count === - 1 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, array );

		} else {

			if ( isWebGL2 ) {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array, updateRange.offset, updateRange.count );

			} else {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

			}

			updateRange.count = - 1; // reset range

		}

	}

	//

	function get( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return buffers.get( attribute );

	}

	function remove( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data ) {

			gl.deleteBuffer( data.buffer );

			buffers.delete( attribute );

		}

	}

	function update( attribute, bufferType ) {

		if ( attribute.isGLBufferAttribute ) {

			const cached = buffers.get( attribute );

			if ( ! cached || cached.version < attribute.version ) {

				buffers.set( attribute, {
					buffer: attribute.buffer,
					type: attribute.type,
					bytesPerElement: attribute.elementSize,
					version: attribute.version
				} );

			}

			return;

		}

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data === undefined ) {

			buffers.set( attribute, createBuffer( attribute, bufferType ) );

		} else if ( data.version < attribute.version ) {

			updateBuffer( data.buffer, attribute, bufferType );

			data.version = attribute.version;

		}

	}

	return {

		get: get,
		remove: remove,
		update: update

	};

}

class PlaneGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

		super();
		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		const width_half = width / 2;
		const height_half = height / 2;

		const gridX = Math.floor( widthSegments );
		const gridY = Math.floor( heightSegments );

		const gridX1 = gridX + 1;
		const gridY1 = gridY + 1;

		const segment_width = width / gridX;
		const segment_height = height / gridY;

		//

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		for ( let iy = 0; iy < gridY1; iy ++ ) {

			const y = iy * segment_height - height_half;

			for ( let ix = 0; ix < gridX1; ix ++ ) {

				const x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		for ( let iy = 0; iy < gridY; iy ++ ) {

			for ( let ix = 0; ix < gridX; ix ++ ) {

				const a = ix + gridX1 * iy;
				const b = ix + gridX1 * ( iy + 1 );
				const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				const d = ( ix + 1 ) + gridX1 * iy;

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

}

var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

var begin_vertex = "vec3 transformed = vec3( position );";

var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";

var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif";

var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";

var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";

var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";

var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";

var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

var transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";

var transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif";

var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

const ShaderChunk = {
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	encodings_fragment: encodings_fragment,
	encodings_pars_fragment: encodings_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_common_pars_fragment: envmap_common_pars_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
	envmap_vertex: envmap_vertex,
	fog_vertex: fog_vertex,
	fog_pars_vertex: fog_pars_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_fragment: lightmap_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_vertex: lights_lambert_vertex,
	lights_pars_begin: lights_pars_begin,
	lights_toon_fragment: lights_toon_fragment,
	lights_toon_pars_fragment: lights_toon_pars_fragment,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_fragment_begin: lights_fragment_begin,
	lights_fragment_maps: lights_fragment_maps,
	lights_fragment_end: lights_fragment_end,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_fragment_begin: normal_fragment_begin,
	normal_fragment_maps: normal_fragment_maps,
	normalmap_pars_fragment: normalmap_pars_fragment,
	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
	clearcoat_pars_fragment: clearcoat_pars_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	dithering_fragment: dithering_fragment,
	dithering_pars_fragment: dithering_pars_fragment,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	transmissionmap_fragment: transmissionmap_fragment,
	transmissionmap_pars_fragment: transmissionmap_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	uv2_pars_fragment: uv2_pars_fragment,
	uv2_pars_vertex: uv2_pars_vertex,
	uv2_vertex: uv2_vertex,
	worldpos_vertex: worldpos_vertex,

	background_frag: background_frag,
	background_vert: background_vert,
	cube_frag: cube_frag,
	cube_vert: cube_vert,
	depth_frag: depth_frag,
	depth_vert: depth_vert,
	distanceRGBA_frag: distanceRGBA_frag,
	distanceRGBA_vert: distanceRGBA_vert,
	equirect_frag: equirect_frag,
	equirect_vert: equirect_vert,
	linedashed_frag: linedashed_frag,
	linedashed_vert: linedashed_vert,
	meshbasic_frag: meshbasic_frag,
	meshbasic_vert: meshbasic_vert,
	meshlambert_frag: meshlambert_frag,
	meshlambert_vert: meshlambert_vert,
	meshmatcap_frag: meshmatcap_frag,
	meshmatcap_vert: meshmatcap_vert,
	meshtoon_frag: meshtoon_frag,
	meshtoon_vert: meshtoon_vert,
	meshphong_frag: meshphong_frag,
	meshphong_vert: meshphong_vert,
	meshphysical_frag: meshphysical_frag,
	meshphysical_vert: meshphysical_vert,
	normal_frag: normal_frag,
	normal_vert: normal_vert,
	points_frag: points_frag,
	points_vert: points_vert,
	shadow_frag: shadow_frag,
	shadow_vert: shadow_vert,
	sprite_frag: sprite_frag,
	sprite_vert: sprite_vert
};

/**
 * Uniforms library for shared webgl shaders
 */

const UniformsLib = {

	common: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },

		map: { value: null },
		uvTransform: { value: new Matrix3() },
		uv2Transform: { value: new Matrix3() },

		alphaMap: { value: null },

	},

	specularmap: {

		specularMap: { value: null },

	},

	envmap: {

		envMap: { value: null },
		flipEnvMap: { value: - 1 },
		reflectivity: { value: 1.0 },
		refractionRatio: { value: 0.98 },
		maxMipLevel: { value: 0 }

	},

	aomap: {

		aoMap: { value: null },
		aoMapIntensity: { value: 1 }

	},

	lightmap: {

		lightMap: { value: null },
		lightMapIntensity: { value: 1 }

	},

	emissivemap: {

		emissiveMap: { value: null }

	},

	bumpmap: {

		bumpMap: { value: null },
		bumpScale: { value: 1 }

	},

	normalmap: {

		normalMap: { value: null },
		normalScale: { value: new Vector2( 1, 1 ) }

	},

	displacementmap: {

		displacementMap: { value: null },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }

	},

	roughnessmap: {

		roughnessMap: { value: null }

	},

	metalnessmap: {

		metalnessMap: { value: null }

	},

	gradientmap: {

		gradientMap: { value: null }

	},

	fog: {

		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: new Color( 0xffffff ) }

	},

	lights: {

		ambientLightColor: { value: [] },

		lightProbe: { value: [] },

		directionalLights: { value: [], properties: {
			direction: {},
			color: {}
		} },

		directionalLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },

		spotLights: { value: [], properties: {
			color: {},
			position: {},
			direction: {},
			distance: {},
			coneCos: {},
			penumbraCos: {},
			decay: {}
		} },

		spotLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		spotShadowMap: { value: [] },
		spotShadowMatrix: { value: [] },

		pointLights: { value: [], properties: {
			color: {},
			position: {},
			decay: {},
			distance: {}
		} },

		pointLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {},
			shadowCameraNear: {},
			shadowCameraFar: {}
		} },

		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },

		hemisphereLights: { value: [], properties: {
			direction: {},
			skyColor: {},
			groundColor: {}
		} },

		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		rectAreaLights: { value: [], properties: {
			color: {},
			position: {},
			width: {},
			height: {}
		} },

		ltc_1: { value: null },
		ltc_2: { value: null }

	},

	points: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		alphaMap: { value: null },
		uvTransform: { value: new Matrix3() }

	},

	sprite: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },
		center: { value: new Vector2( 0.5, 0.5 ) },
		rotation: { value: 0.0 },
		map: { value: null },
		alphaMap: { value: null },
		uvTransform: { value: new Matrix3() }

	}

};

const ShaderLib = {

	basic: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag

	},

	lambert: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag

	},

	phong: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				specular: { value: new Color( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag

	},

	standard: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.roughnessmap,
			UniformsLib.metalnessmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				roughness: { value: 1.0 },
				metalness: { value: 0.0 },
				envMapIntensity: { value: 1 } // temporary
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	},

	toon: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.gradientmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshtoon_vert,
		fragmentShader: ShaderChunk.meshtoon_frag

	},

	matcap: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			{
				matcap: { value: null }
			}
		] ),

		vertexShader: ShaderChunk.meshmatcap_vert,
		fragmentShader: ShaderChunk.meshmatcap_frag

	},

	points: {

		uniforms: mergeUniforms( [
			UniformsLib.points,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag

	},

	dashed: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		] ),

		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag

	},

	depth: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap
		] ),

		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag

	},

	normal: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.normal_vert,
		fragmentShader: ShaderChunk.normal_frag

	},

	sprite: {

		uniforms: mergeUniforms( [
			UniformsLib.sprite,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.sprite_vert,
		fragmentShader: ShaderChunk.sprite_frag

	},

	background: {

		uniforms: {
			uvTransform: { value: new Matrix3() },
			t2D: { value: null },
		},

		vertexShader: ShaderChunk.background_vert,
		fragmentShader: ShaderChunk.background_frag

	},
	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	cube: {

		uniforms: mergeUniforms( [
			UniformsLib.envmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag

	},

	equirect: {

		uniforms: {
			tEquirect: { value: null },
		},

		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag

	},

	distanceRGBA: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap,
			{
				referencePosition: { value: new Vector3() },
				nearDistance: { value: 1 },
				farDistance: { value: 1000 }
			}
		] ),

		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag

	},

	shadow: {

		uniforms: mergeUniforms( [
			UniformsLib.lights,
			UniformsLib.fog,
			{
				color: { value: new Color( 0x00000 ) },
				opacity: { value: 1.0 }
			},
		] ),

		vertexShader: ShaderChunk.shadow_vert,
		fragmentShader: ShaderChunk.shadow_frag

	}

};

ShaderLib.physical = {

	uniforms: mergeUniforms( [
		ShaderLib.standard.uniforms,
		{
			clearcoat: { value: 0 },
			clearcoatMap: { value: null },
			clearcoatRoughness: { value: 0 },
			clearcoatRoughnessMap: { value: null },
			clearcoatNormalScale: { value: new Vector2( 1, 1 ) },
			clearcoatNormalMap: { value: null },
			sheen: { value: new Color( 0x000000 ) },
			transmission: { value: 0 },
			transmissionMap: { value: null },
		}
	] ),

	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag

};

function WebGLBackground( renderer, cubemaps, state, objects, premultipliedAlpha ) {

	const clearColor = new Color( 0x000000 );
	let clearAlpha = 0;

	let planeMesh;
	let boxMesh;

	let currentBackground = null;
	let currentBackgroundVersion = 0;
	let currentTonemapping = null;

	function render( renderList, scene, camera, forceClear ) {

		let background = scene.isScene === true ? scene.background : null;

		if ( background && background.isTexture ) {

			background = cubemaps.get( background );

		}

		// Ignore background in AR
		// TODO: Reconsider this.

		const xr = renderer.xr;
		const session = xr.getSession && xr.getSession();

		if ( session && session.environmentBlendMode === 'additive' ) {

			background = null;

		}

		if ( background === null ) {

			setClear( clearColor, clearAlpha );

		} else if ( background && background.isColor ) {

			setClear( background, 1 );
			forceClear = true;

		}

		if ( renderer.autoClear || forceClear ) {

			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

		}

		if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {

			if ( boxMesh === undefined ) {

				boxMesh = new Mesh(
					new BoxGeometry( 1, 1, 1 ),
					new ShaderMaterial( {
						name: 'BackgroundCubeMaterial',
						uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
						vertexShader: ShaderLib.cube.vertexShader,
						fragmentShader: ShaderLib.cube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				boxMesh.geometry.deleteAttribute( 'normal' );
				boxMesh.geometry.deleteAttribute( 'uv' );

				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

					this.matrixWorld.copyPosition( camera.matrixWorld );

				};

				// enable code injection for non-built-in material
				Object.defineProperty( boxMesh.material, 'envMap', {

					get: function () {

						return this.uniforms.envMap.value;

					}

				} );

				objects.update( boxMesh );

			}

			boxMesh.material.uniforms.envMap.value = background;
			boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background._needsFlipEnvMap ) ? - 1 : 1;

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				boxMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}

			// push to the pre-sorted opaque render list
			renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

		} else if ( background && background.isTexture ) {

			if ( planeMesh === undefined ) {

				planeMesh = new Mesh(
					new PlaneGeometry( 2, 2 ),
					new ShaderMaterial( {
						name: 'BackgroundMaterial',
						uniforms: cloneUniforms( ShaderLib.background.uniforms ),
						vertexShader: ShaderLib.background.vertexShader,
						fragmentShader: ShaderLib.background.fragmentShader,
						side: FrontSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				planeMesh.geometry.deleteAttribute( 'normal' );

				// enable code injection for non-built-in material
				Object.defineProperty( planeMesh.material, 'map', {

					get: function () {

						return this.uniforms.t2D.value;

					}

				} );

				objects.update( planeMesh );

			}

			planeMesh.material.uniforms.t2D.value = background;

			if ( background.matrixAutoUpdate === true ) {

				background.updateMatrix();

			}

			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				planeMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}


			// push to the pre-sorted opaque render list
			renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

		}

	}

	function setClear( color, alpha ) {

		state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

	}

	return {

		getClearColor: function () {

			return clearColor;

		},
		setClearColor: function ( color, alpha = 1 ) {

			clearColor.set( color );
			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		getClearAlpha: function () {

			return clearAlpha;

		},
		setClearAlpha: function ( alpha ) {

			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		render: render

	};

}

function WebGLBindingStates( gl, extensions, attributes, capabilities ) {

	const maxVertexAttributes = gl.getParameter( 34921 );

	const extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
	const vaoAvailable = capabilities.isWebGL2 || extension !== null;

	const bindingStates = {};

	const defaultState = createBindingState( null );
	let currentState = defaultState;

	function setup( object, material, program, geometry, index ) {

		let updateBuffers = false;

		if ( vaoAvailable ) {

			const state = getBindingState( geometry, program, material );

			if ( currentState !== state ) {

				currentState = state;
				bindVertexArrayObject( currentState.object );

			}

			updateBuffers = needsUpdate( geometry, index );

			if ( updateBuffers ) saveCache( geometry, index );

		} else {

			const wireframe = ( material.wireframe === true );

			if ( currentState.geometry !== geometry.id ||
				currentState.program !== program.id ||
				currentState.wireframe !== wireframe ) {

				currentState.geometry = geometry.id;
				currentState.program = program.id;
				currentState.wireframe = wireframe;

				updateBuffers = true;

			}

		}

		if ( object.isInstancedMesh === true ) {

			updateBuffers = true;

		}

		if ( index !== null ) {

			attributes.update( index, 34963 );

		}

		if ( updateBuffers ) {

			setupVertexAttributes( object, material, program, geometry );

			if ( index !== null ) {

				gl.bindBuffer( 34963, attributes.get( index ).buffer );

			}

		}

	}

	function createVertexArrayObject() {

		if ( capabilities.isWebGL2 ) return gl.createVertexArray();

		return extension.createVertexArrayOES();

	}

	function bindVertexArrayObject( vao ) {

		if ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );

		return extension.bindVertexArrayOES( vao );

	}

	function deleteVertexArrayObject( vao ) {

		if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );

		return extension.deleteVertexArrayOES( vao );

	}

	function getBindingState( geometry, program, material ) {

		const wireframe = ( material.wireframe === true );

		let programMap = bindingStates[ geometry.id ];

		if ( programMap === undefined ) {

			programMap = {};
			bindingStates[ geometry.id ] = programMap;

		}

		let stateMap = programMap[ program.id ];

		if ( stateMap === undefined ) {

			stateMap = {};
			programMap[ program.id ] = stateMap;

		}

		let state = stateMap[ wireframe ];

		if ( state === undefined ) {

			state = createBindingState( createVertexArrayObject() );
			stateMap[ wireframe ] = state;

		}

		return state;

	}

	function createBindingState( vao ) {

		const newAttributes = [];
		const enabledAttributes = [];
		const attributeDivisors = [];

		for ( let i = 0; i < maxVertexAttributes; i ++ ) {

			newAttributes[ i ] = 0;
			enabledAttributes[ i ] = 0;
			attributeDivisors[ i ] = 0;

		}

		return {

			// for backward compatibility on non-VAO support browser
			geometry: null,
			program: null,
			wireframe: false,

			newAttributes: newAttributes,
			enabledAttributes: enabledAttributes,
			attributeDivisors: attributeDivisors,
			object: vao,
			attributes: {},
			index: null

		};

	}

	function needsUpdate( geometry, index ) {

		const cachedAttributes = currentState.attributes;
		const geometryAttributes = geometry.attributes;

		let attributesNum = 0;

		for ( const key in geometryAttributes ) {

			const cachedAttribute = cachedAttributes[ key ];
			const geometryAttribute = geometryAttributes[ key ];

			if ( cachedAttribute === undefined ) return true;

			if ( cachedAttribute.attribute !== geometryAttribute ) return true;

			if ( cachedAttribute.data !== geometryAttribute.data ) return true;

			attributesNum ++;

		}

		if ( currentState.attributesNum !== attributesNum ) return true;

		if ( currentState.index !== index ) return true;

		return false;

	}

	function saveCache( geometry, index ) {

		const cache = {};
		const attributes = geometry.attributes;
		let attributesNum = 0;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			const data = {};
			data.attribute = attribute;

			if ( attribute.data ) {

				data.data = attribute.data;

			}

			cache[ key ] = data;

			attributesNum ++;

		}

		currentState.attributes = cache;
		currentState.attributesNum = attributesNum;

		currentState.index = index;

	}

	function initAttributes() {

		const newAttributes = currentState.newAttributes;

		for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

			newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		enableAttributeAndDivisor( attribute, 0 );

	}

	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;
		const attributeDivisors = currentState.attributeDivisors;

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			const extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

			extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	}

	function disableUnusedAttributes() {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;

		for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	}

	function vertexAttribPointer( index, size, type, normalized, stride, offset ) {

		if ( capabilities.isWebGL2 === true && ( type === 5124 || type === 5125 ) ) {

			gl.vertexAttribIPointer( index, size, type, stride, offset );

		} else {

			gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

		}

	}

	function setupVertexAttributes( object, material, program, geometry ) {

		if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

			if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

		}

		initAttributes();

		const geometryAttributes = geometry.attributes;

		const programAttributes = program.getAttributes();

		const materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute >= 0 ) {

				const geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute !== undefined ) {

					const normalized = geometryAttribute.normalized;
					const size = geometryAttribute.itemSize;

					const attribute = attributes.get( geometryAttribute );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					const buffer = attribute.buffer;
					const type = attribute.type;
					const bytesPerElement = attribute.bytesPerElement;

					if ( geometryAttribute.isInterleavedBufferAttribute ) {

						const data = geometryAttribute.data;
						const stride = data.stride;
						const offset = geometryAttribute.offset;

						if ( data && data.isInstancedInterleavedBuffer ) {

							enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

							if ( geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = data.meshPerAttribute * data.count;

							}

						} else {

							enableAttribute( programAttribute );

						}

						gl.bindBuffer( 34962, buffer );
						vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

					} else {

						if ( geometryAttribute.isInstancedBufferAttribute ) {

							enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

							if ( geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							enableAttribute( programAttribute );

						}

						gl.bindBuffer( 34962, buffer );
						vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

					}

				} else if ( name === 'instanceMatrix' ) {

					const attribute = attributes.get( object.instanceMatrix );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					const buffer = attribute.buffer;
					const type = attribute.type;

					enableAttributeAndDivisor( programAttribute + 0, 1 );
					enableAttributeAndDivisor( programAttribute + 1, 1 );
					enableAttributeAndDivisor( programAttribute + 2, 1 );
					enableAttributeAndDivisor( programAttribute + 3, 1 );

					gl.bindBuffer( 34962, buffer );

					gl.vertexAttribPointer( programAttribute + 0, 4, type, false, 64, 0 );
					gl.vertexAttribPointer( programAttribute + 1, 4, type, false, 64, 16 );
					gl.vertexAttribPointer( programAttribute + 2, 4, type, false, 64, 32 );
					gl.vertexAttribPointer( programAttribute + 3, 4, type, false, 64, 48 );

				} else if ( name === 'instanceColor' ) {

					const attribute = attributes.get( object.instanceColor );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					const buffer = attribute.buffer;
					const type = attribute.type;

					enableAttributeAndDivisor( programAttribute, 1 );

					gl.bindBuffer( 34962, buffer );

					gl.vertexAttribPointer( programAttribute, 3, type, false, 12, 0 );

				} else if ( materialDefaultAttributeValues !== undefined ) {

					const value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								gl.vertexAttrib2fv( programAttribute, value );
								break;

							case 3:
								gl.vertexAttrib3fv( programAttribute, value );
								break;

							case 4:
								gl.vertexAttrib4fv( programAttribute, value );
								break;

							default:
								gl.vertexAttrib1fv( programAttribute, value );

						}

					}

				}

			}

		}

		disableUnusedAttributes();

	}

	function dispose() {

		reset();

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			for ( const programId in programMap ) {

				const stateMap = programMap[ programId ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ programId ];

			}

			delete bindingStates[ geometryId ];

		}

	}

	function releaseStatesOfGeometry( geometry ) {

		if ( bindingStates[ geometry.id ] === undefined ) return;

		const programMap = bindingStates[ geometry.id ];

		for ( const programId in programMap ) {

			const stateMap = programMap[ programId ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ programId ];

		}

		delete bindingStates[ geometry.id ];

	}

	function releaseStatesOfProgram( program ) {

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			if ( programMap[ program.id ] === undefined ) continue;

			const stateMap = programMap[ program.id ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ program.id ];

		}

	}

	function reset() {

		resetDefaultState();

		if ( currentState === defaultState ) return;

		currentState = defaultState;
		bindVertexArrayObject( currentState.object );

	}

	// for backward-compatilibity

	function resetDefaultState() {

		defaultState.geometry = null;
		defaultState.program = null;
		defaultState.wireframe = false;

	}

	return {

		setup: setup,
		reset: reset,
		resetDefaultState: resetDefaultState,
		dispose: dispose,
		releaseStatesOfGeometry: releaseStatesOfGeometry,
		releaseStatesOfProgram: releaseStatesOfProgram,

		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		disableUnusedAttributes: disableUnusedAttributes

	};

}

function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	let mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		gl.drawArrays( mode, start, count );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		let extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawArraysInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawArraysInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, start, count, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;

}

function WebGLCapabilities( gl, extensions, parameters ) {

	let maxAnisotropy;

	function getMaxAnisotropy() {

		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			maxAnisotropy = 0;

		}

		return maxAnisotropy;

	}

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
				gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
				gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	/* eslint-disable no-undef */
	const isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
		( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );
	/* eslint-enable no-undef */

	let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	const maxPrecision = getMaxPrecision( precision );

	if ( maxPrecision !== precision ) {

		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		precision = maxPrecision;

	}

	const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

	const maxTextures = gl.getParameter( 34930 );
	const maxVertexTextures = gl.getParameter( 35660 );
	const maxTextureSize = gl.getParameter( 3379 );
	const maxCubemapSize = gl.getParameter( 34076 );

	const maxAttributes = gl.getParameter( 34921 );
	const maxVertexUniforms = gl.getParameter( 36347 );
	const maxVaryings = gl.getParameter( 36348 );
	const maxFragmentUniforms = gl.getParameter( 36349 );

	const vertexTextures = maxVertexTextures > 0;
	const floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );
	const floatVertexTextures = vertexTextures && floatFragmentTextures;

	const maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

	return {

		isWebGL2: isWebGL2,

		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,

		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,

		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,

		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,

		vertexTextures: vertexTextures,
		floatFragmentTextures: floatFragmentTextures,
		floatVertexTextures: floatVertexTextures,

		maxSamples: maxSamples

	};

}

function WebGLClipping( properties ) {

	const scope = this;

	let globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false;

	const plane = new Plane(),
		viewNormalMatrix = new Matrix3(),

		uniform = { value: null, needsUpdate: false };

	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;

	this.init = function ( planes, enableLocalClipping, camera ) {

		const enabled =
			planes.length !== 0 ||
			enableLocalClipping ||
			// enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 ||
			localClippingEnabled;

		localClippingEnabled = enableLocalClipping;

		globalState = projectPlanes( planes, camera, 0 );
		numGlobalPlanes = planes.length;

		return enabled;

	};

	this.beginShadows = function () {

		renderingShadows = true;
		projectPlanes( null );

	};

	this.endShadows = function () {

		renderingShadows = false;
		resetGlobalState();

	};

	this.setState = function ( material, camera, useCache ) {

		const planes = material.clippingPlanes,
			clipIntersection = material.clipIntersection,
			clipShadows = material.clipShadows;

		const materialProperties = properties.get( material );

		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

			// there's no local clipping

			if ( renderingShadows ) {

				// there's no global clipping

				projectPlanes( null );

			} else {

				resetGlobalState();

			}

		} else {

			const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4;

			let dstArray = materialProperties.clippingState || null;

			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes( planes, camera, lGlobal, useCache );

			for ( let i = 0; i !== lGlobal; ++ i ) {

				dstArray[ i ] = globalState[ i ];

			}

			materialProperties.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;

		}


	};

	function resetGlobalState() {

		if ( uniform.value !== globalState ) {

			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;

		}

		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;

	}

	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		const nPlanes = planes !== null ? planes.length : 0;
		let dstArray = null;

		if ( nPlanes !== 0 ) {

			dstArray = uniform.value;

			if ( skipTransform !== true || dstArray === null ) {

				const flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;

				viewNormalMatrix.getNormalMatrix( viewMatrix );

				if ( dstArray === null || dstArray.length < flatSize ) {

					dstArray = new Float32Array( flatSize );

				}

				for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;

				}

			}

			uniform.value = dstArray;
			uniform.needsUpdate = true;

		}

		scope.numPlanes = nPlanes;
		scope.numIntersection = 0;

		return dstArray;

	}

}

function WebGLCubeMaps( renderer ) {

	let cubemaps = new WeakMap();

	function mapTextureMapping( texture, mapping ) {

		if ( mapping === EquirectangularReflectionMapping ) {

			texture.mapping = CubeReflectionMapping;

		} else if ( mapping === EquirectangularRefractionMapping ) {

			texture.mapping = CubeRefractionMapping;

		}

		return texture;

	}

	function get( texture ) {

		if ( texture && texture.isTexture ) {

			const mapping = texture.mapping;

			if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

				if ( cubemaps.has( texture ) ) {

					const cubemap = cubemaps.get( texture ).texture;
					return mapTextureMapping( cubemap, texture.mapping );

				} else {

					const image = texture.image;

					if ( image && image.height > 0 ) {

						const currentRenderTarget = renderer.getRenderTarget();

						const renderTarget = new WebGLCubeRenderTarget( image.height / 2 );
						renderTarget.fromEquirectangularTexture( renderer, texture );
						cubemaps.set( texture, renderTarget );

						renderer.setRenderTarget( currentRenderTarget );

						texture.addEventListener( 'dispose', onTextureDispose );

						return mapTextureMapping( renderTarget.texture, texture.mapping );

					} else {

						// image not yet ready. try the conversion next frame

						return null;

					}

				}

			}

		}

		return texture;

	}

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		const cubemap = cubemaps.get( texture );

		if ( cubemap !== undefined ) {

			cubemaps.delete( texture );
			cubemap.dispose();

		}

	}

	function dispose() {

		cubemaps = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

function WebGLExtensions( gl ) {

	const extensions = {};

	function getExtension( name ) {

		if ( extensions[ name ] !== undefined ) {

			return extensions[ name ];

		}

		let extension;

		switch ( name ) {

			case 'WEBGL_depth_texture':
				extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
				break;

			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				break;

			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				break;

			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				break;

			default:
				extension = gl.getExtension( name );

		}

		extensions[ name ] = extension;

		return extension;

	}

	return {

		has: function ( name ) {

			return getExtension( name ) !== null;

		},

		init: function ( capabilities ) {

			if ( capabilities.isWebGL2 ) {

				getExtension( 'EXT_color_buffer_float' );

			} else {

				getExtension( 'WEBGL_depth_texture' );
				getExtension( 'OES_texture_float' );
				getExtension( 'OES_texture_half_float' );
				getExtension( 'OES_texture_half_float_linear' );
				getExtension( 'OES_standard_derivatives' );
				getExtension( 'OES_element_index_uint' );
				getExtension( 'OES_vertex_array_object' );
				getExtension( 'ANGLE_instanced_arrays' );

			}

			getExtension( 'OES_texture_float_linear' );
			getExtension( 'EXT_color_buffer_half_float' );

		},

		get: function ( name ) {

			const extension = getExtension( name );

			if ( extension === null ) {

				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			return extension;

		}

	};

}

function WebGLGeometries( gl, attributes, info, bindingStates ) {

	const geometries = {};
	const wireframeAttributes = new WeakMap();

	function onGeometryDispose( event ) {

		const geometry = event.target;

		if ( geometry.index !== null ) {

			attributes.remove( geometry.index );

		}

		for ( const name in geometry.attributes ) {

			attributes.remove( geometry.attributes[ name ] );

		}

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		delete geometries[ geometry.id ];

		const attribute = wireframeAttributes.get( geometry );

		if ( attribute ) {

			attributes.remove( attribute );
			wireframeAttributes.delete( geometry );

		}

		bindingStates.releaseStatesOfGeometry( geometry );

		if ( geometry.isInstancedBufferGeometry === true ) {

			delete geometry._maxInstanceCount;

		}

		//

		info.memory.geometries --;

	}

	function get( object, geometry ) {

		if ( geometries[ geometry.id ] === true ) return geometry;

		geometry.addEventListener( 'dispose', onGeometryDispose );

		geometries[ geometry.id ] = true;

		info.memory.geometries ++;

		return geometry;

	}

	function update( geometry ) {

		const geometryAttributes = geometry.attributes;

		// Updating index buffer in VAO now. See WebGLBindingStates.

		for ( const name in geometryAttributes ) {

			attributes.update( geometryAttributes[ name ], 34962 );

		}

		// morph targets

		const morphAttributes = geometry.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = morphAttributes[ name ];

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				attributes.update( array[ i ], 34962 );

			}

		}

	}

	function updateWireframeAttribute( geometry ) {

		const indices = [];

		const geometryIndex = geometry.index;
		const geometryPosition = geometry.attributes.position;
		let version = 0;

		if ( geometryIndex !== null ) {

			const array = geometryIndex.array;
			version = geometryIndex.version;

			for ( let i = 0, l = array.length; i < l; i += 3 ) {

				const a = array[ i + 0 ];
				const b = array[ i + 1 ];
				const c = array[ i + 2 ];

				indices.push( a, b, b, c, c, a );

			}

		} else {

			const array = geometryPosition.array;
			version = geometryPosition.version;

			for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				const a = i + 0;
				const b = i + 1;
				const c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		const attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
		attribute.version = version;

		// Updating index buffer in VAO now. See WebGLBindingStates

		//

		const previousAttribute = wireframeAttributes.get( geometry );

		if ( previousAttribute ) attributes.remove( previousAttribute );

		//

		wireframeAttributes.set( geometry, attribute );

	}

	function getWireframeAttribute( geometry ) {

		const currentAttribute = wireframeAttributes.get( geometry );

		if ( currentAttribute ) {

			const geometryIndex = geometry.index;

			if ( geometryIndex !== null ) {

				// if the attribute is obsolete, create a new one

				if ( currentAttribute.version < geometryIndex.version ) {

					updateWireframeAttribute( geometry );

				}

			}

		} else {

			updateWireframeAttribute( geometry );

		}

		return wireframeAttributes.get( geometry );

	}

	return {

		get: get,
		update: update,

		getWireframeAttribute: getWireframeAttribute

	};

}

function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	let mode;

	function setMode( value ) {

		mode = value;

	}

	let type, bytesPerElement;

	function setIndex( value ) {

		type = value.type;
		bytesPerElement = value.bytesPerElement;

	}

	function render( start, count ) {

		gl.drawElements( mode, count, type, start * bytesPerElement );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		let extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawElementsInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawElementsInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;

}

function WebGLInfo( gl ) {

	const memory = {
		geometries: 0,
		textures: 0
	};

	const render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};

	function update( count, mode, instanceCount ) {

		render.calls ++;

		switch ( mode ) {

			case 4:
				render.triangles += instanceCount * ( count / 3 );
				break;

			case 1:
				render.lines += instanceCount * ( count / 2 );
				break;

			case 3:
				render.lines += instanceCount * ( count - 1 );
				break;

			case 2:
				render.lines += instanceCount * count;
				break;

			case 0:
				render.points += instanceCount * count;
				break;

			default:
				console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
				break;

		}

	}

	function reset() {

		render.frame ++;
		render.calls = 0;
		render.triangles = 0;
		render.points = 0;
		render.lines = 0;

	}

	return {
		memory: memory,
		render: render,
		programs: null,
		autoReset: true,
		reset: reset,
		update: update
	};

}

function numericalSort( a, b ) {

	return a[ 0 ] - b[ 0 ];

}

function absNumericalSort( a, b ) {

	return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

}

function WebGLMorphtargets( gl ) {

	const influencesList = {};
	const morphInfluences = new Float32Array( 8 );

	const workInfluences = [];

	for ( let i = 0; i < 8; i ++ ) {

		workInfluences[ i ] = [ i, 0 ];

	}

	function update( object, geometry, material, program ) {

		const objectInfluences = object.morphTargetInfluences;

		// When object doesn't have morph target influences defined, we treat it as a 0-length array
		// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

		const length = objectInfluences === undefined ? 0 : objectInfluences.length;

		let influences = influencesList[ geometry.id ];

		if ( influences === undefined ) {

			// initialise list

			influences = [];

			for ( let i = 0; i < length; i ++ ) {

				influences[ i ] = [ i, 0 ];

			}

			influencesList[ geometry.id ] = influences;

		}

		// Collect influences

		for ( let i = 0; i < length; i ++ ) {

			const influence = influences[ i ];

			influence[ 0 ] = i;
			influence[ 1 ] = objectInfluences[ i ];

		}

		influences.sort( absNumericalSort );

		for ( let i = 0; i < 8; i ++ ) {

			if ( i < length && influences[ i ][ 1 ] ) {

				workInfluences[ i ][ 0 ] = influences[ i ][ 0 ];
				workInfluences[ i ][ 1 ] = influences[ i ][ 1 ];

			} else {

				workInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;
				workInfluences[ i ][ 1 ] = 0;

			}

		}

		workInfluences.sort( numericalSort );

		const morphTargets = material.morphTargets && geometry.morphAttributes.position;
		const morphNormals = material.morphNormals && geometry.morphAttributes.normal;

		let morphInfluencesSum = 0;

		for ( let i = 0; i < 8; i ++ ) {

			const influence = workInfluences[ i ];
			const index = influence[ 0 ];
			const value = influence[ 1 ];

			if ( index !== Number.MAX_SAFE_INTEGER && value ) {

				if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {

					geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );

				}

				if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {

					geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

				}

				morphInfluences[ i ] = value;
				morphInfluencesSum += value;

			} else {

				if ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {

					geometry.deleteAttribute( 'morphTarget' + i );

				}

				if ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {

					geometry.deleteAttribute( 'morphNormal' + i );

				}

				morphInfluences[ i ] = 0;

			}

		}

		// GLSL shader uses formula baseinfluence * base + sum(target * influence)
		// This allows us to switch between absolute morphs and relative morphs without changing shader code
		// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
		const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

		program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
		program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

	}

	return {

		update: update

	};

}

function WebGLObjects( gl, geometries, attributes, info ) {

	let updateMap = new WeakMap();

	function update( object ) {

		const frame = info.render.frame;

		const geometry = object.geometry;
		const buffergeometry = geometries.get( object, geometry );

		// Update once per frame

		if ( updateMap.get( buffergeometry ) !== frame ) {

			geometries.update( buffergeometry );

			updateMap.set( buffergeometry, frame );

		}

		if ( object.isInstancedMesh ) {

			if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

				object.addEventListener( 'dispose', onInstancedMeshDispose );

			}

			attributes.update( object.instanceMatrix, 34962 );

			if ( object.instanceColor !== null ) {

				attributes.update( object.instanceColor, 34962 );

			}

		}

		return buffergeometry;

	}

	function dispose() {

		updateMap = new WeakMap();

	}

	function onInstancedMeshDispose( event ) {

		const instancedMesh = event.target;

		instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

		attributes.remove( instancedMesh.instanceMatrix );

		if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

	}

	return {

		update: update,
		dispose: dispose

	};

}

class DataTexture2DArray extends Texture {

	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		super( null );

		this.image = { data, width, height, depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;

		this.needsUpdate = true;

	}

}

DataTexture2DArray.prototype.isDataTexture2DArray = true;

class DataTexture3D extends Texture {

	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in DataTexture3D directly.
		//
		//	const texture = new THREE.DataTexture3D( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839

		super( null );

		this.image = { data, width, height, depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;

		this.needsUpdate = true;

	}

}

DataTexture3D.prototype.isDataTexture3D = true;

/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

const emptyTexture = new Texture();
const emptyTexture2dArray = new DataTexture2DArray();
const emptyTexture3d = new DataTexture3D();
const emptyCubeTexture = new CubeTexture();

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

const arrayCacheF32 = [];
const arrayCacheI32 = [];

// Float32Array caches used for uploading Matrix uniforms

const mat4array = new Float32Array( 16 );
const mat3array = new Float32Array( 9 );
const mat2array = new Float32Array( 4 );

// Flattening for arrays of vectors and matrices

function flatten( array, nBlocks, blockSize ) {

	const firstElem = array[ 0 ];

	if ( firstElem <= 0 || firstElem > 0 ) return array;
	// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983

	const n = nBlocks * blockSize;
	let r = arrayCacheF32[ n ];

	if ( r === undefined ) {

		r = new Float32Array( n );
		arrayCacheF32[ n ] = r;

	}

	if ( nBlocks !== 0 ) {

		firstElem.toArray( r, 0 );

		for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

			offset += blockSize;
			array[ i ].toArray( r, offset );

		}

	}

	return r;

}

function arraysEqual( a, b ) {

	if ( a.length !== b.length ) return false;

	for ( let i = 0, l = a.length; i < l; i ++ ) {

		if ( a[ i ] !== b[ i ] ) return false;

	}

	return true;

}

function copyArray( a, b ) {

	for ( let i = 0, l = b.length; i < l; i ++ ) {

		a[ i ] = b[ i ];

	}

}

// Texture unit allocation

function allocTexUnits( textures, n ) {

	let r = arrayCacheI32[ n ];

	if ( r === undefined ) {

		r = new Int32Array( n );
		arrayCacheI32[ n ] = r;

	}

	for ( let i = 0; i !== n; ++ i ) {

		r[ i ] = textures.allocateTextureUnit();

	}

	return r;

}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValueV1f( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1f( this.addr, v );

	cache[ 0 ] = v;

}

// Single float vector (from flat array or THREE.VectorN)

function setValueV2f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2f( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3f( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else if ( v.r !== undefined ) {

		if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

			gl.uniform3f( this.addr, v.r, v.g, v.b );

			cache[ 0 ] = v.r;
			cache[ 1 ] = v.g;
			cache[ 2 ] = v.b;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4fv( this.addr, v );

		copyArray( cache, v );

	}

}

// Single matrix (from flat array or THREE.MatrixN)

function setValueM2( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix2fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat2array.set( elements );

		gl.uniformMatrix2fv( this.addr, false, mat2array );

		copyArray( cache, elements );

	}

}

function setValueM3( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix3fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat3array.set( elements );

		gl.uniformMatrix3fv( this.addr, false, mat3array );

		copyArray( cache, elements );

	}

}

function setValueM4( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix4fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat4array.set( elements );

		gl.uniformMatrix4fv( this.addr, false, mat4array );

		copyArray( cache, elements );

	}

}

// Single integer / boolean

function setValueV1i( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1i( this.addr, v );

	cache[ 0 ] = v;

}

// Single integer / boolean vector (from flat array)

function setValueV2i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform2iv( this.addr, v );

	copyArray( cache, v );

}

function setValueV3i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform3iv( this.addr, v );

	copyArray( cache, v );

}

function setValueV4i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform4iv( this.addr, v );

	copyArray( cache, v );

}

// Single unsigned integer

function setValueV1ui( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1ui( this.addr, v );

	cache[ 0 ] = v;

}

// Single unsigned integer vector (from flat array)

function setValueV2ui( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform2uiv( this.addr, v );

	copyArray( cache, v );

}

function setValueV3ui( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform3uiv( this.addr, v );

	copyArray( cache, v );

}

function setValueV4ui( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform4uiv( this.addr, v );

	copyArray( cache, v );

}


// Single texture (2D / Cube)

function setValueT1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.safeSetTexture2D( v || emptyTexture, unit );

}

function setValueT3D1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture3D( v || emptyTexture3d, unit );

}

function setValueT6( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.safeSetTextureCube( v || emptyCubeTexture, unit );

}

function setValueT2DArray1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture2DArray( v || emptyTexture2dArray, unit );

}

// Helper to pick the right setter for the singular case

function getSingularSetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1f; // FLOAT
		case 0x8b50: return setValueV2f; // _VEC2
		case 0x8b51: return setValueV3f; // _VEC3
		case 0x8b52: return setValueV4f; // _VEC4

		case 0x8b5a: return setValueM2; // _MAT2
		case 0x8b5b: return setValueM3; // _MAT3
		case 0x8b5c: return setValueM4; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

		case 0x1405: return setValueV1ui; // UINT
		case 0x8dc6: return setValueV2ui; // _VEC2
		case 0x8dc7: return setValueV3ui; // _VEC3
		case 0x8dc8: return setValueV4ui; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1;

		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			return setValueT3D1;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6;

		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArray1;

	}

}


// Array of scalars

function setValueV1fArray( gl, v ) {

	gl.uniform1fv( this.addr, v );

}

// Array of vectors (from flat array or array of THREE.VectorN)

function setValueV2fArray( gl, v ) {

	const data = flatten( v, this.size, 2 );

	gl.uniform2fv( this.addr, data );

}

function setValueV3fArray( gl, v ) {

	const data = flatten( v, this.size, 3 );

	gl.uniform3fv( this.addr, data );

}

function setValueV4fArray( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniform4fv( this.addr, data );

}

// Array of matrices (from flat array or array of THREE.MatrixN)

function setValueM2Array( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniformMatrix2fv( this.addr, false, data );

}

function setValueM3Array( gl, v ) {

	const data = flatten( v, this.size, 9 );

	gl.uniformMatrix3fv( this.addr, false, data );

}

function setValueM4Array( gl, v ) {

	const data = flatten( v, this.size, 16 );

	gl.uniformMatrix4fv( this.addr, false, data );

}

// Array of integer / boolean

function setValueV1iArray( gl, v ) {

	gl.uniform1iv( this.addr, v );

}

// Array of integer / boolean vectors (from flat array)

function setValueV2iArray( gl, v ) {

	gl.uniform2iv( this.addr, v );

}

function setValueV3iArray( gl, v ) {

	gl.uniform3iv( this.addr, v );

}

function setValueV4iArray( gl, v ) {

	gl.uniform4iv( this.addr, v );

}

// Array of unsigned integer

function setValueV1uiArray( gl, v ) {

	gl.uniform1uiv( this.addr, v );

}

// Array of unsigned integer vectors (from flat array)

function setValueV2uiArray( gl, v ) {

	gl.uniform2uiv( this.addr, v );

}

function setValueV3uiArray( gl, v ) {

	gl.uniform3uiv( this.addr, v );

}

function setValueV4uiArray( gl, v ) {

	gl.uniform4uiv( this.addr, v );

}


// Array of textures (2D / Cube)

function setValueT1Array( gl, v, textures ) {

	const n = v.length;

	const units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( let i = 0; i !== n; ++ i ) {

		textures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );

	}

}

function setValueT6Array( gl, v, textures ) {

	const n = v.length;

	const units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( let i = 0; i !== n; ++ i ) {

		textures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

	}

}

// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1fArray; // FLOAT
		case 0x8b50: return setValueV2fArray; // _VEC2
		case 0x8b51: return setValueV3fArray; // _VEC3
		case 0x8b52: return setValueV4fArray; // _VEC4

		case 0x8b5a: return setValueM2Array; // _MAT2
		case 0x8b5b: return setValueM3Array; // _MAT3
		case 0x8b5c: return setValueM4Array; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

		case 0x1405: return setValueV1uiArray; // UINT
		case 0x8dc6: return setValueV2uiArray; // _VEC2
		case 0x8dc7: return setValueV3uiArray; // _VEC3
		case 0x8dc8: return setValueV4uiArray; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1Array;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6Array;

	}

}

// --- Uniform Classes ---

function SingleUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.setValue = getSingularSetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

function PureArrayUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.size = activeInfo.size;
	this.setValue = getPureArraySetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

PureArrayUniform.prototype.updateCache = function ( data ) {

	const cache = this.cache;

	if ( data instanceof Float32Array && cache.length !== data.length ) {

		this.cache = new Float32Array( data.length );

	}

	copyArray( cache, data );

};

function StructuredUniform( id ) {

	this.id = id;

	this.seq = [];
	this.map = {};

}

StructuredUniform.prototype.setValue = function ( gl, value, textures ) {

	const seq = this.seq;

	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		const u = seq[ i ];
		u.setValue( gl, value[ u.id ], textures );

	}

};

// --- Top-level ---

// Parser - builds up the property tree from the path strings

const RePathPart = /(\w+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform( container, uniformObject ) {

	container.seq.push( uniformObject );
	container.map[ uniformObject.id ] = uniformObject;

}

function parseUniform( activeInfo, addr, container ) {

	const path = activeInfo.name,
		pathLength = path.length;

	// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex = 0;

	while ( true ) {

		const match = RePathPart.exec( path ),
			matchEnd = RePathPart.lastIndex;

		let id = match[ 1 ];
		const idIsIndex = match[ 2 ] === ']',
			subscript = match[ 3 ];

		if ( idIsIndex ) id = id | 0; // convert to integer

		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

			// bare name or "pure" bottom-level array "[0]" suffix

			addUniform( container, subscript === undefined ?
				new SingleUniform( id, activeInfo, addr ) :
				new PureArrayUniform( id, activeInfo, addr ) );

			break;

		} else {

			// step into inner node / create it in case it doesn't exist

			const map = container.map;
			let next = map[ id ];

			if ( next === undefined ) {

				next = new StructuredUniform( id );
				addUniform( container, next );

			}

			container = next;

		}

	}

}

// Root Container

function WebGLUniforms( gl, program ) {

	this.seq = [];
	this.map = {};

	const n = gl.getProgramParameter( program, 35718 );

	for ( let i = 0; i < n; ++ i ) {

		const info = gl.getActiveUniform( program, i ),
			addr = gl.getUniformLocation( program, info.name );

		parseUniform( info, addr, this );

	}

}

WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {

	const u = this.map[ name ];

	if ( u !== undefined ) u.setValue( gl, value, textures );

};

WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

	const v = object[ name ];

	if ( v !== undefined ) this.setValue( gl, name, v );

};


// Static interface

WebGLUniforms.upload = function ( gl, seq, values, textures ) {

	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		const u = seq[ i ],
			v = values[ u.id ];

		if ( v.needsUpdate !== false ) {

			// note: always updating when .needsUpdate is undefined
			u.setValue( gl, v.value, textures );

		}

	}

};

WebGLUniforms.seqWithValue = function ( seq, values ) {

	const r = [];

	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		const u = seq[ i ];
		if ( u.id in values ) r.push( u );

	}

	return r;

};

function WebGLShader( gl, type, string ) {

	const shader = gl.createShader( type );

	gl.shaderSource( shader, string );
	gl.compileShader( shader );

	return shader;

}

let programIdCount = 0;

function addLineNumbers( string ) {

	const lines = string.split( '\n' );

	for ( let i = 0; i < lines.length; i ++ ) {

		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

	}

	return lines.join( '\n' );

}

function getEncodingComponents( encoding ) {

	switch ( encoding ) {

		case LinearEncoding:
			return [ 'Linear', '( value )' ];
		case sRGBEncoding:
			return [ 'sRGB', '( value )' ];
		case RGBEEncoding:
			return [ 'RGBE', '( value )' ];
		case RGBM7Encoding:
			return [ 'RGBM', '( value, 7.0 )' ];
		case RGBM16Encoding:
			return [ 'RGBM', '( value, 16.0 )' ];
		case RGBDEncoding:
			return [ 'RGBD', '( value, 256.0 )' ];
		case GammaEncoding:
			return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
		case LogLuvEncoding:
			return [ 'LogLuv', '( value )' ];
		default:
			console.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );
			return [ 'Linear', '( value )' ];

	}

}

function getShaderErrors( gl, shader, type ) {

	const status = gl.getShaderParameter( shader, 35713 );
	const log = gl.getShaderInfoLog( shader ).trim();

	if ( status && log === '' ) return '';

	// --enable-privileged-webgl-extension
	// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

	const source = gl.getShaderSource( shader );

	return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers( source );

}

function getTexelDecodingFunction( functionName, encoding ) {

	const components = getEncodingComponents( encoding );
	return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

}

function getTexelEncodingFunction( functionName, encoding ) {

	const components = getEncodingComponents( encoding );
	return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

}

function getToneMappingFunction( functionName, toneMapping ) {

	let toneMappingName;

	switch ( toneMapping ) {

		case LinearToneMapping:
			toneMappingName = 'Linear';
			break;

		case ReinhardToneMapping:
			toneMappingName = 'Reinhard';
			break;

		case CineonToneMapping:
			toneMappingName = 'OptimizedCineon';
			break;

		case ACESFilmicToneMapping:
			toneMappingName = 'ACESFilmic';
			break;

		case CustomToneMapping:
			toneMappingName = 'Custom';
			break;

		default:
			console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
			toneMappingName = 'Linear';

	}

	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

}

function generateExtensions( parameters ) {

	const chunks = [
		( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
		( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
		( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
		( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
	];

	return chunks.filter( filterEmptyLine ).join( '\n' );

}

function generateDefines( defines ) {

	const chunks = [];

	for ( const name in defines ) {

		const value = defines[ name ];

		if ( value === false ) continue;

		chunks.push( '#define ' + name + ' ' + value );

	}

	return chunks.join( '\n' );

}

function fetchAttributeLocations( gl, program ) {

	const attributes = {};

	const n = gl.getProgramParameter( program, 35721 );

	for ( let i = 0; i < n; i ++ ) {

		const info = gl.getActiveAttrib( program, i );
		const name = info.name;

		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

		attributes[ name ] = gl.getAttribLocation( program, name );

	}

	return attributes;

}

function filterEmptyLine( string ) {

	return string !== '';

}

function replaceLightNums( string, parameters ) {

	return string
		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
		.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
		.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
		.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

}

function replaceClippingPlaneNums( string, parameters ) {

	return string
		.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
		.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

}

// Resolve Includes

const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes( string ) {

	return string.replace( includePattern, includeReplacer );

}

function includeReplacer( match, include ) {

	const string = ShaderChunk[ include ];

	if ( string === undefined ) {

		throw new Error( 'Can not resolve #include <' + include + '>' );

	}

	return resolveIncludes( string );

}

// Unroll Loops

const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function unrollLoops( string ) {

	return string
		.replace( unrollLoopPattern, loopReplacer )
		.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );

}

function deprecatedLoopReplacer( match, start, end, snippet ) {

	console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );
	return loopReplacer( match, start, end, snippet );

}

function loopReplacer( match, start, end, snippet ) {

	let string = '';

	for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

		string += snippet
			.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
			.replace( /UNROLLED_LOOP_INDEX/g, i );

	}

	return string;

}

//

function generatePrecision( parameters ) {

	let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

	if ( parameters.precision === 'highp' ) {

		precisionstring += '\n#define HIGH_PRECISION';

	} else if ( parameters.precision === 'mediump' ) {

		precisionstring += '\n#define MEDIUM_PRECISION';

	} else if ( parameters.precision === 'lowp' ) {

		precisionstring += '\n#define LOW_PRECISION';

	}

	return precisionstring;

}

function generateShadowMapTypeDefine( parameters ) {

	let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	if ( parameters.shadowMapType === PCFShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

	} else if ( parameters.shadowMapType === VSMShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

	}

	return shadowMapTypeDefine;

}

function generateEnvMapTypeDefine( parameters ) {

	let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;

			case CubeUVReflectionMapping:
			case CubeUVRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;

		}

	}

	return envMapTypeDefine;

}

function generateEnvMapModeDefine( parameters ) {

	let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeRefractionMapping:
			case CubeUVRefractionMapping:

				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;

		}

	}

	return envMapModeDefine;

}

function generateEnvMapBlendingDefine( parameters ) {

	let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

	if ( parameters.envMap ) {

		switch ( parameters.combine ) {

			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;

			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;

			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;

		}

	}

	return envMapBlendingDefine;

}

function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

	const gl = renderer.getContext();

	const defines = parameters.defines;

	let vertexShader = parameters.vertexShader;
	let fragmentShader = parameters.fragmentShader;

	const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
	const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
	const envMapModeDefine = generateEnvMapModeDefine( parameters );
	const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );


	const gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

	const customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

	const customDefines = generateDefines( defines );

	const program = gl.createProgram();

	let prefixVertex, prefixFragment;
	let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

	if ( parameters.isRawShaderMaterial ) {

		prefixVertex = [

			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixVertex.length > 0 ) {

			prefixVertex += '\n';

		}

		prefixFragment = [

			customExtensions,
			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixFragment.length > 0 ) {

			prefixFragment += '\n';

		}

	} else {

		prefixVertex = [

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.instancing ? '#define USE_INSTANCING' : '',
			parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			'#define MAX_BONES ' + parameters.maxBones,
			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',
			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.skinning ? '#define USE_SKINNING' : '',
			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			'uniform mat4 modelMatrix;',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			'#ifdef USE_INSTANCING',

			'	attribute mat4 instanceMatrix;',

			'#endif',

			'#ifdef USE_INSTANCING_COLOR',

			'	attribute vec3 instanceColor;',

			'#endif',

			'attribute vec3 position;',
			'attribute vec3 normal;',
			'attribute vec2 uv;',

			'#ifdef USE_TANGENT',

			'	attribute vec4 tangent;',

			'#endif',

			'#if defined( USE_COLOR_ALPHA )',

			'	attribute vec4 color;',

			'#elif defined( USE_COLOR )',

			'	attribute vec3 color;',

			'#endif',

			'#ifdef USE_MORPHTARGETS',

			'	attribute vec3 morphTarget0;',
			'	attribute vec3 morphTarget1;',
			'	attribute vec3 morphTarget2;',
			'	attribute vec3 morphTarget3;',

			'	#ifdef USE_MORPHNORMALS',

			'		attribute vec3 morphNormal0;',
			'		attribute vec3 morphNormal1;',
			'		attribute vec3 morphNormal2;',
			'		attribute vec3 morphNormal3;',

			'	#else',

			'		attribute vec3 morphTarget4;',
			'		attribute vec3 morphTarget5;',
			'		attribute vec3 morphTarget6;',
			'		attribute vec3 morphTarget7;',

			'	#endif',

			'#endif',

			'#ifdef USE_SKINNING',

			'	attribute vec4 skinIndex;',
			'	attribute vec4 skinWeight;',

			'#endif',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			customExtensions,

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.matcap ? '#define USE_MATCAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapTypeDefine : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',
			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

			parameters.sheen ? '#define USE_SHEEN' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

			parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			( ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ) ? '#define TEXTURE_LOD_EXT' : '',

			'uniform mat4 viewMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

			parameters.dithering ? '#define DITHERING' : '',

			ShaderChunk[ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
			parameters.map ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
			parameters.matcap ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
			parameters.envMap ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
			parameters.emissiveMap ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
			parameters.lightMap ? getTexelDecodingFunction( 'lightMapTexelToLinear', parameters.lightMapEncoding ) : '',
			getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ),

			parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	}

	vertexShader = resolveIncludes( vertexShader );
	vertexShader = replaceLightNums( vertexShader, parameters );
	vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

	fragmentShader = resolveIncludes( fragmentShader );
	fragmentShader = replaceLightNums( fragmentShader, parameters );
	fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

	vertexShader = unrollLoops( vertexShader );
	fragmentShader = unrollLoops( fragmentShader );

	if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {

		// GLSL 3.0 conversion for built-in materials and ShaderMaterial

		versionString = '#version 300 es\n';

		prefixVertex = [
			'#define attribute in',
			'#define varying out',
			'#define texture2D texture'
		].join( '\n' ) + '\n' + prefixVertex;

		prefixFragment = [
			'#define varying in',
			( parameters.glslVersion === GLSL3 ) ? '' : 'out highp vec4 pc_fragColor;',
			( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
			'#define gl_FragDepthEXT gl_FragDepth',
			'#define texture2D texture',
			'#define textureCube texture',
			'#define texture2DProj textureProj',
			'#define texture2DLodEXT textureLod',
			'#define texture2DProjLodEXT textureProjLod',
			'#define textureCubeLodEXT textureLod',
			'#define texture2DGradEXT textureGrad',
			'#define texture2DProjGradEXT textureProjGrad',
			'#define textureCubeGradEXT textureGrad'
		].join( '\n' ) + '\n' + prefixFragment;

	}

	const vertexGlsl = versionString + prefixVertex + vertexShader;
	const fragmentGlsl = versionString + prefixFragment + fragmentShader;

	// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );

	const glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
	const glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );

	gl.attachShader( program, glVertexShader );
	gl.attachShader( program, glFragmentShader );

	// Force a particular attribute to index 0.

	if ( parameters.index0AttributeName !== undefined ) {

		gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

	} else if ( parameters.morphTargets === true ) {

		// programs with morphTargets displace position out of attribute 0
		gl.bindAttribLocation( program, 0, 'position' );

	}

	gl.linkProgram( program );

	// check for link errors
	if ( renderer.debug.checkShaderErrors ) {

		const programLog = gl.getProgramInfoLog( program ).trim();
		const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
		const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

		let runnable = true;
		let haveDiagnostics = true;

		if ( gl.getProgramParameter( program, 35714 ) === false ) {

			runnable = false;

			const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
			const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors );

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

	}

	// Clean up

	// Crashes in iOS9 and iOS10. #18402
	// gl.detachShader( program, glVertexShader );
	// gl.detachShader( program, glFragmentShader );

	gl.deleteShader( glVertexShader );
	gl.deleteShader( glFragmentShader );

	// set up caching for uniform locations

	let cachedUniforms;

	this.getUniforms = function () {

		if ( cachedUniforms === undefined ) {

			cachedUniforms = new WebGLUniforms( gl, program );

		}

		return cachedUniforms;

	};

	// set up caching for attribute locations

	let cachedAttributes;

	this.getAttributes = function () {

		if ( cachedAttributes === undefined ) {

			cachedAttributes = fetchAttributeLocations( gl, program );

		}

		return cachedAttributes;

	};

	// free resource

	this.destroy = function () {

		bindingStates.releaseStatesOfProgram( this );

		gl.deleteProgram( program );
		this.program = undefined;

	};

	//

	this.name = parameters.shaderName;
	this.id = programIdCount ++;
	this.cacheKey = cacheKey;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;

	return this;

}

function WebGLPrograms( renderer, cubemaps, extensions, capabilities, bindingStates, clipping ) {

	const programs = [];

	const isWebGL2 = capabilities.isWebGL2;
	const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
	const floatVertexTextures = capabilities.floatVertexTextures;
	const maxVertexUniforms = capabilities.maxVertexUniforms;
	const vertexTextures = capabilities.vertexTextures;

	let precision = capabilities.precision;

	const shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'toon',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		MeshMatcapMaterial: 'matcap',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow',
		SpriteMaterial: 'sprite'
	};

	const parameterNames = [
		'precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor',
		'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV',
		'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap',
		'roughnessMap', 'metalnessMap', 'gradientMap',
		'alphaMap', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2',
		'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning',
		'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'premultipliedAlpha',
		'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights',
		'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows',
		'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights',
		'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering',
		'sheen', 'transmissionMap'
	];

	function getMaxBones( object ) {

		const skeleton = object.skeleton;
		const bones = skeleton.bones;

		if ( floatVertexTextures ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			const nVertexUniforms = maxVertexUniforms;
			const nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			const maxBones = Math.min( nVertexMatrices, bones.length );

			if ( maxBones < bones.length ) {

				console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
				return 0;

			}

			return maxBones;

		}

	}

	function getTextureEncodingFromMap( map ) {

		let encoding;

		if ( map && map.isTexture ) {

			encoding = map.encoding;

		} else if ( map && map.isWebGLRenderTarget ) {

			console.warn( 'THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.' );
			encoding = map.texture.encoding;

		} else {

			encoding = LinearEncoding;

		}

		return encoding;

	}

	function getParameters( material, lights, shadows, scene, object ) {

		const fog = scene.fog;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;

		const envMap = cubemaps.get( material.envMap || environment );

		const shaderID = shaderIDs[ material.type ];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		const maxBones = object.isSkinnedMesh ? getMaxBones( object ) : 0;

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		let vertexShader, fragmentShader;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];

			vertexShader = shader.vertexShader;
			fragmentShader = shader.fragmentShader;

		} else {

			vertexShader = material.vertexShader;
			fragmentShader = material.fragmentShader;

		}

		const currentRenderTarget = renderer.getRenderTarget();

		const parameters = {

			isWebGL2: isWebGL2,

			shaderID: shaderID,
			shaderName: material.type,

			vertexShader: vertexShader,
			fragmentShader: fragmentShader,
			defines: material.defines,

			isRawShaderMaterial: material.isRawShaderMaterial === true,
			glslVersion: material.glslVersion,

			precision: precision,

			instancing: object.isInstancedMesh === true,
			instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,

			supportsVertexTextures: vertexTextures,
			outputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,
			map: !! material.map,
			mapEncoding: getTextureEncodingFromMap( material.map ),
			matcap: !! material.matcap,
			matcapEncoding: getTextureEncodingFromMap( material.matcap ),
			envMap: !! envMap,
			envMapMode: envMap && envMap.mapping,
			envMapEncoding: getTextureEncodingFromMap( envMap ),
			envMapCubeUV: ( !! envMap ) && ( ( envMap.mapping === CubeUVReflectionMapping ) || ( envMap.mapping === CubeUVRefractionMapping ) ),
			lightMap: !! material.lightMap,
			lightMapEncoding: getTextureEncodingFromMap( material.lightMap ),
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
			tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
			clearcoatMap: !! material.clearcoatMap,
			clearcoatRoughnessMap: !! material.clearcoatRoughnessMap,
			clearcoatNormalMap: !! material.clearcoatNormalMap,
			displacementMap: !! material.displacementMap,
			roughnessMap: !! material.roughnessMap,
			metalnessMap: !! material.metalnessMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,

			gradientMap: !! material.gradientMap,

			sheen: !! material.sheen,

			transmissionMap: !! material.transmissionMap,

			combine: material.combine,

			vertexTangents: ( material.normalMap && material.vertexTangents ),
			vertexColors: material.vertexColors,
			vertexAlphas: material.vertexColors === true && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
			vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap || !! material.transmissionMap,
			uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || !! material.transmissionMap ) && !! material.displacementMap,

			fog: !! fog,
			useFog: material.fog,
			fogExp2: ( fog && fog.isFogExp2 ),

			flatShading: !! material.flatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			skinning: material.skinning && maxBones > 0,
			maxBones: maxBones,
			useVertexTexture: floatVertexTextures,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,

			numDirLightShadows: lights.directionalShadowMap.length,
			numPointLightShadows: lights.pointShadowMap.length,
			numSpotLightShadows: lights.spotShadowMap.length,

			numClippingPlanes: clipping.numPlanes,
			numClipIntersection: clipping.numIntersection,

			dithering: material.dithering,

			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
			physicallyCorrectLights: renderer.physicallyCorrectLights,

			premultipliedAlpha: material.premultipliedAlpha,

			alphaTest: material.alphaTest,
			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,

			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,

			index0AttributeName: material.index0AttributeName,

			extensionDerivatives: material.extensions && material.extensions.derivatives,
			extensionFragDepth: material.extensions && material.extensions.fragDepth,
			extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
			extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

			rendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),
			rendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),
			rendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),

			customProgramCacheKey: material.customProgramCacheKey()

		};

		return parameters;

	}

	function getProgramCacheKey( parameters ) {

		const array = [];

		if ( parameters.shaderID ) {

			array.push( parameters.shaderID );

		} else {

			array.push( parameters.fragmentShader );
			array.push( parameters.vertexShader );

		}

		if ( parameters.defines !== undefined ) {

			for ( const name in parameters.defines ) {

				array.push( name );
				array.push( parameters.defines[ name ] );

			}

		}

		if ( parameters.isRawShaderMaterial === false ) {

			for ( let i = 0; i < parameterNames.length; i ++ ) {

				array.push( parameters[ parameterNames[ i ] ] );

			}

			array.push( renderer.outputEncoding );
			array.push( renderer.gammaFactor );

		}

		array.push( parameters.customProgramCacheKey );

		return array.join();

	}

	function getUniforms( material ) {

		const shaderID = shaderIDs[ material.type ];
		let uniforms;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];
			uniforms = UniformsUtils.clone( shader.uniforms );

		} else {

			uniforms = material.uniforms;

		}

		return uniforms;

	}

	function acquireProgram( parameters, cacheKey ) {

		let program;

		// Check if code has been already compiled
		for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

			const preexistingProgram = programs[ p ];

			if ( preexistingProgram.cacheKey === cacheKey ) {

				program = preexistingProgram;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
			programs.push( program );

		}

		return program;

	}

	function releaseProgram( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			const i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	}

	return {
		getParameters: getParameters,
		getProgramCacheKey: getProgramCacheKey,
		getUniforms: getUniforms,
		acquireProgram: acquireProgram,
		releaseProgram: releaseProgram,
		// Exposed for resource monitoring & error feedback via renderer.info:
		programs: programs
	};

}

function WebGLProperties() {

	let properties = new WeakMap();

	function get( object ) {

		let map = properties.get( object );

		if ( map === undefined ) {

			map = {};
			properties.set( object, map );

		}

		return map;

	}

	function remove( object ) {

		properties.delete( object );

	}

	function update( object, key, value ) {

		properties.get( object )[ key ] = value;

	}

	function dispose() {

		properties = new WeakMap();

	}

	return {
		get: get,
		remove: remove,
		update: update,
		dispose: dispose
	};

}

function painterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.program !== b.program ) {

		return a.program.id - b.program.id;

	} else if ( a.material.id !== b.material.id ) {

		return a.material.id - b.material.id;

	} else if ( a.z !== b.z ) {

		return a.z - b.z;

	} else {

		return a.id - b.id;

	}

}

function reversePainterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.z !== b.z ) {

		return b.z - a.z;

	} else {

		return a.id - b.id;

	}

}


function WebGLRenderList( properties ) {

	const renderItems = [];
	let renderItemsIndex = 0;

	const opaque = [];
	const transparent = [];

	const defaultProgram = { id: - 1 };

	function init() {

		renderItemsIndex = 0;

		opaque.length = 0;
		transparent.length = 0;

	}

	function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

		let renderItem = renderItems[ renderItemsIndex ];
		const materialProperties = properties.get( material );

		if ( renderItem === undefined ) {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				program: materialProperties.program || defaultProgram,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group
			};

			renderItems[ renderItemsIndex ] = renderItem;

		} else {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.program = materialProperties.program || defaultProgram;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;

		}

		renderItemsIndex ++;

		return renderItem;

	}

	function push( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		( material.transparent === true ? transparent : opaque ).push( renderItem );

	}

	function unshift( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		( material.transparent === true ? transparent : opaque ).unshift( renderItem );

	}

	function sort( customOpaqueSort, customTransparentSort ) {

		if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
		if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

	}

	function finish() {

		// Clear references from inactive renderItems in the list

		for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

			const renderItem = renderItems[ i ];

			if ( renderItem.id === null ) break;

			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.program = null;
			renderItem.group = null;

		}

	}

	return {

		opaque: opaque,
		transparent: transparent,

		init: init,
		push: push,
		unshift: unshift,
		finish: finish,

		sort: sort
	};

}

function WebGLRenderLists( properties ) {

	let lists = new WeakMap();

	function get( scene, renderCallDepth ) {

		let list;

		if ( lists.has( scene ) === false ) {

			list = new WebGLRenderList( properties );
			lists.set( scene, [ list ] );

		} else {

			if ( renderCallDepth >= lists.get( scene ).length ) {

				list = new WebGLRenderList( properties );
				lists.get( scene ).push( list );

			} else {

				list = lists.get( scene )[ renderCallDepth ];

			}

		}

		return list;

	}

	function dispose() {

		lists = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

function UniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3(),
						color: new Color()
					};
					break;

				case 'SpotLight':
					uniforms = {
						position: new Vector3(),
						direction: new Vector3(),
						color: new Color(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0
					};
					break;

				case 'PointLight':
					uniforms = {
						position: new Vector3(),
						color: new Color(),
						distance: 0,
						decay: 0
					};
					break;

				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3(),
						skyColor: new Color(),
						groundColor: new Color()
					};
					break;

				case 'RectAreaLight':
					uniforms = {
						color: new Color(),
						position: new Vector3(),
						halfWidth: new Vector3(),
						halfHeight: new Vector3()
					};
					break;

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}

function ShadowUniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'SpotLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'PointLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2(),
						shadowCameraNear: 1,
						shadowCameraFar: 1000
					};
					break;

				// TODO (abelnation): set RectAreaLight shadow uniforms

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}



let nextVersion = 0;

function shadowCastingLightsFirst( lightA, lightB ) {

	return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );

}

function WebGLLights( extensions, capabilities ) {

	const cache = new UniformsCache();

	const shadowCache = ShadowUniformsCache();

	const state = {

		version: 0,

		hash: {
			directionalLength: - 1,
			pointLength: - 1,
			spotLength: - 1,
			rectAreaLength: - 1,
			hemiLength: - 1,

			numDirectionalShadows: - 1,
			numPointShadows: - 1,
			numSpotShadows: - 1
		},

		ambient: [ 0, 0, 0 ],
		probe: [],
		directional: [],
		directionalShadow: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotShadow: [],
		spotShadowMap: [],
		spotShadowMatrix: [],
		rectArea: [],
		rectAreaLTC1: null,
		rectAreaLTC2: null,
		point: [],
		pointShadow: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: []

	};

	for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

	const vector3 = new Vector3();
	const matrix4 = new Matrix4();
	const matrix42 = new Matrix4();

	function setup( lights ) {

		let r = 0, g = 0, b = 0;

		for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		let numDirectionalShadows = 0;
		let numPointShadows = 0;
		let numSpotShadows = 0;

		lights.sort( shadowCastingLightsFirst );

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			const color = light.color;
			const intensity = light.intensity;
			const distance = light.distance;

			const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			if ( light.isAmbientLight ) {

				r += color.r * intensity;
				g += color.g * intensity;
				b += color.b * intensity;

			} else if ( light.isLightProbe ) {

				for ( let j = 0; j < 9; j ++ ) {

					state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

				}

			} else if ( light.isDirectionalLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.directionalShadow[ directionalLength ] = shadowUniforms;
					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

					numDirectionalShadows ++;

				}

				state.directional[ directionalLength ] = uniforms;

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = cache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );

				uniforms.color.copy( color ).multiplyScalar( intensity );
				uniforms.distance = distance;

				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.spotShadow[ spotLength ] = shadowUniforms;
					state.spotShadowMap[ spotLength ] = shadowMap;
					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;

					numSpotShadows ++;

				}

				state.spot[ spotLength ] = uniforms;

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = cache.get( light );

				// (a) intensity is the total visible light emitted
				//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

				// (b) intensity is the brightness of the light
				uniforms.color.copy( color ).multiplyScalar( intensity );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				state.rectArea[ rectAreaLength ] = uniforms;

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.distance = light.distance;
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;
					shadowUniforms.shadowCameraNear = shadow.camera.near;
					shadowUniforms.shadowCameraFar = shadow.camera.far;

					state.pointShadow[ pointLength ] = shadowUniforms;
					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

					numPointShadows ++;

				}

				state.point[ pointLength ] = uniforms;

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = cache.get( light );

				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

				state.hemi[ hemiLength ] = uniforms;

				hemiLength ++;

			}

		}

		if ( rectAreaLength > 0 ) {

			if ( capabilities.isWebGL2 ) {

				// WebGL 2

				state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
				state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

			} else {

				// WebGL 1

				if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

				} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {

					state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
					state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

				} else {

					console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );

				}

			}

		}

		state.ambient[ 0 ] = r;
		state.ambient[ 1 ] = g;
		state.ambient[ 2 ] = b;

		const hash = state.hash;

		if ( hash.directionalLength !== directionalLength ||
			hash.pointLength !== pointLength ||
			hash.spotLength !== spotLength ||
			hash.rectAreaLength !== rectAreaLength ||
			hash.hemiLength !== hemiLength ||
			hash.numDirectionalShadows !== numDirectionalShadows ||
			hash.numPointShadows !== numPointShadows ||
			hash.numSpotShadows !== numSpotShadows ) {

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			state.directionalShadow.length = numDirectionalShadows;
			state.directionalShadowMap.length = numDirectionalShadows;
			state.pointShadow.length = numPointShadows;
			state.pointShadowMap.length = numPointShadows;
			state.spotShadow.length = numSpotShadows;
			state.spotShadowMap.length = numSpotShadows;
			state.directionalShadowMatrix.length = numDirectionalShadows;
			state.pointShadowMatrix.length = numPointShadows;
			state.spotShadowMatrix.length = numSpotShadows;

			hash.directionalLength = directionalLength;
			hash.pointLength = pointLength;
			hash.spotLength = spotLength;
			hash.rectAreaLength = rectAreaLength;
			hash.hemiLength = hemiLength;

			hash.numDirectionalShadows = numDirectionalShadows;
			hash.numPointShadows = numPointShadows;
			hash.numSpotShadows = numSpotShadows;

			state.version = nextVersion ++;

		}

	}

	function setupView( lights, camera ) {

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		const viewMatrix = camera.matrixWorldInverse;

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			if ( light.isDirectionalLight ) {

				const uniforms = state.directional[ directionalLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = state.spot[ spotLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = state.rectArea[ rectAreaLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				// extract local rotation of light to derive width/height half vectors
				matrix42.identity();
				matrix4.copy( light.matrixWorld );
				matrix4.premultiply( viewMatrix );
				matrix42.extractRotation( matrix4 );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				uniforms.halfWidth.applyMatrix4( matrix42 );
				uniforms.halfHeight.applyMatrix4( matrix42 );

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = state.point[ pointLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = state.hemi[ hemiLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );
				uniforms.direction.normalize();

				hemiLength ++;

			}

		}

	}

	return {
		setup: setup,
		setupView: setupView,
		state: state
	};

}

function WebGLRenderState( extensions, capabilities ) {

	const lights = new WebGLLights( extensions, capabilities );

	const lightsArray = [];
	const shadowsArray = [];

	function init() {

		lightsArray.length = 0;
		shadowsArray.length = 0;

	}

	function pushLight( light ) {

		lightsArray.push( light );

	}

	function pushShadow( shadowLight ) {

		shadowsArray.push( shadowLight );

	}

	function setupLights() {

		lights.setup( lightsArray );

	}

	function setupLightsView( camera ) {

		lights.setupView( lightsArray, camera );

	}

	const state = {
		lightsArray: lightsArray,
		shadowsArray: shadowsArray,

		lights: lights
	};

	return {
		init: init,
		state: state,
		setupLights: setupLights,
		setupLightsView: setupLightsView,

		pushLight: pushLight,
		pushShadow: pushShadow
	};

}

function WebGLRenderStates( extensions, capabilities ) {

	let renderStates = new WeakMap();

	function get( scene, renderCallDepth = 0 ) {

		let renderState;

		if ( renderStates.has( scene ) === false ) {

			renderState = new WebGLRenderState( extensions, capabilities );
			renderStates.set( scene, [ renderState ] );

		} else {

			if ( renderCallDepth >= renderStates.get( scene ).length ) {

				renderState = new WebGLRenderState( extensions, capabilities );
				renderStates.get( scene ).push( renderState );

			} else {

				renderState = renderStates.get( scene )[ renderCallDepth ];

			}

		}

		return renderState;

	}

	function dispose() {

		renderStates = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

/**
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

class MeshDepthMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshDepthMaterial';

		this.depthPacking = BasicDepthPacking;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.depthPacking = source.depthPacking;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	}

}

MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

/**
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */

class MeshDistanceMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshDistanceMaterial';

		this.referencePosition = new Vector3();
		this.nearDistance = 1;
		this.farDistance = 1000;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.fog = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.referencePosition.copy( source.referencePosition );
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		return this;

	}

}

MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

function WebGLShadowMap( _renderer, _objects, _capabilities ) {

	let _frustum = new Frustum();

	const _shadowMapSize = new Vector2(),
		_viewportSize = new Vector2(),

		_viewport = new Vector4(),

		_depthMaterials = [],
		_distanceMaterials = [],

		_materialCache = {},

		_maxTextureSize = _capabilities.maxTextureSize;

	const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

	const shadowMaterialVertical = new ShaderMaterial( {

		defines: {
			SAMPLE_RATE: 2.0 / 8.0,
			HALF_SAMPLE_RATE: 1.0 / 8.0
		},

		uniforms: {
			shadow_pass: { value: null },
			resolution: { value: new Vector2() },
			radius: { value: 4.0 }
		},

		vertexShader: vsm_vert,

		fragmentShader: vsm_frag

	} );

	const shadowMaterialHorizontal = shadowMaterialVertical.clone();
	shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

	const fullScreenTri = new BufferGeometry();
	fullScreenTri.setAttribute(
		'position',
		new BufferAttribute(
			new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
			3
		)
	);

	const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

	const scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = PCFShadowMap;

	this.render = function ( lights, scene, camera ) {

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		if ( lights.length === 0 ) return;

		const currentRenderTarget = _renderer.getRenderTarget();
		const activeCubeFace = _renderer.getActiveCubeFace();
		const activeMipmapLevel = _renderer.getActiveMipmapLevel();

		const _state = _renderer.state;

		// Set GL state for depth map.
		_state.setBlending( NoBlending );
		_state.buffers.color.setClear( 1, 1, 1, 1 );
		_state.buffers.depth.setTest( true );
		_state.setScissorTest( false );

		// render depth map

		for ( let i = 0, il = lights.length; i < il; i ++ ) {

			const light = lights[ i ];
			const shadow = light.shadow;

			if ( shadow === undefined ) {

				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				continue;

			}

			if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

			_shadowMapSize.copy( shadow.mapSize );

			const shadowFrameExtents = shadow.getFrameExtents();

			_shadowMapSize.multiply( shadowFrameExtents );

			_viewportSize.copy( shadow.mapSize );

			if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

				if ( _shadowMapSize.x > _maxTextureSize ) {

					_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
					shadow.mapSize.x = _viewportSize.x;

				}

				if ( _shadowMapSize.y > _maxTextureSize ) {

					_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
					shadow.mapSize.y = _viewportSize.y;

				}

			}

			if ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

				const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + '.shadowMap';

				shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

				shadow.camera.updateProjectionMatrix();

			}

			if ( shadow.map === null ) {

				const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + '.shadowMap';

				shadow.camera.updateProjectionMatrix();

			}

			_renderer.setRenderTarget( shadow.map );
			_renderer.clear();

			const viewportCount = shadow.getViewportCount();

			for ( let vp = 0; vp < viewportCount; vp ++ ) {

				const viewport = shadow.getViewport( vp );

				_viewport.set(
					_viewportSize.x * viewport.x,
					_viewportSize.y * viewport.y,
					_viewportSize.x * viewport.z,
					_viewportSize.y * viewport.w
				);

				_state.viewport( _viewport );

				shadow.updateMatrices( light, vp );

				_frustum = shadow.getFrustum();

				renderObject( scene, camera, shadow.camera, light, this.type );

			}

			// do blur pass for VSM

			if ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

				VSMPass( shadow, camera );

			}

			shadow.needsUpdate = false;

		}

		scope.needsUpdate = false;

		_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

	};

	function VSMPass( shadow, camera ) {

		const geometry = _objects.update( fullScreenMesh );

		// vertical pass

		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialVertical.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.mapPass );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

		// horizontal pass

		shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
		shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.map );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

	}

	function getDepthMaterialVariant( useMorphing, useSkinning, useInstancing ) {

		const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

		let material = _depthMaterials[ index ];

		if ( material === undefined ) {

			material = new MeshDepthMaterial( {

				depthPacking: RGBADepthPacking,

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_depthMaterials[ index ] = material;

		}

		return material;

	}

	function getDistanceMaterialVariant( useMorphing, useSkinning, useInstancing ) {

		const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

		let material = _distanceMaterials[ index ];

		if ( material === undefined ) {

			material = new MeshDistanceMaterial( {

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_distanceMaterials[ index ] = material;

		}

		return material;

	}

	function getDepthMaterial( object, geometry, material, light, shadowCameraNear, shadowCameraFar, type ) {

		let result = null;

		let getMaterialVariant = getDepthMaterialVariant;
		let customMaterial = object.customDepthMaterial;

		if ( light.isPointLight === true ) {

			getMaterialVariant = getDistanceMaterialVariant;
			customMaterial = object.customDistanceMaterial;

		}

		if ( customMaterial === undefined ) {

			let useMorphing = false;

			if ( material.morphTargets === true ) {

				useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

			}

			let useSkinning = false;

			if ( object.isSkinnedMesh === true ) {

				if ( material.skinning === true ) {

					useSkinning = true;

				} else {

					console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

				}

			}

			const useInstancing = object.isInstancedMesh === true;

			result = getMaterialVariant( useMorphing, useSkinning, useInstancing );

		} else {

			result = customMaterial;

		}

		if ( _renderer.localClippingEnabled &&
				material.clipShadows === true &&
				material.clippingPlanes.length !== 0 ) {

			// in this case we need a unique material instance reflecting the
			// appropriate state

			const keyA = result.uuid, keyB = material.uuid;

			let materialsForVariant = _materialCache[ keyA ];

			if ( materialsForVariant === undefined ) {

				materialsForVariant = {};
				_materialCache[ keyA ] = materialsForVariant;

			}

			let cachedMaterial = materialsForVariant[ keyB ];

			if ( cachedMaterial === undefined ) {

				cachedMaterial = result.clone();
				materialsForVariant[ keyB ] = cachedMaterial;

			}

			result = cachedMaterial;

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;

		if ( type === VSMShadowMap ) {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

		} else {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

		}

		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.clipIntersection = material.clipIntersection;

		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

			result.referencePosition.setFromMatrixPosition( light.matrixWorld );
			result.nearDistance = shadowCameraNear;
			result.farDistance = shadowCameraFar;

		}

		return result;

	}

	function renderObject( object, camera, shadowCamera, light, type ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

			if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

				const geometry = _objects.update( object );
				const material = object.material;

				if ( Array.isArray( material ) ) {

					const groups = geometry.groups;

					for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

						const group = groups[ k ];
						const groupMaterial = material[ group.materialIndex ];

						if ( groupMaterial && groupMaterial.visible ) {

							const depthMaterial = getDepthMaterial( object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

						}

					}

				} else if ( material.visible ) {

					const depthMaterial = getDepthMaterial( object, geometry, material, light, shadowCamera.near, shadowCamera.far, type );

					_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

				}

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			renderObject( children[ i ], camera, shadowCamera, light, type );

		}

	}

}

function WebGLState( gl, extensions, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	function ColorBuffer() {

		let locked = false;

		const color = new Vector4();
		let currentColorMask = null;
		const currentColorClear = new Vector4( 0, 0, 0, 0 );

		return {

			setMask: function ( colorMask ) {

				if ( currentColorMask !== colorMask && ! locked ) {

					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					currentColorMask = colorMask;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( r, g, b, a, premultipliedAlpha ) {

				if ( premultipliedAlpha === true ) {

					r *= a; g *= a; b *= a;

				}

				color.set( r, g, b, a );

				if ( currentColorClear.equals( color ) === false ) {

					gl.clearColor( r, g, b, a );
					currentColorClear.copy( color );

				}

			},

			reset: function () {

				locked = false;

				currentColorMask = null;
				currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

			}

		};

	}

	function DepthBuffer() {

		let locked = false;

		let currentDepthMask = null;
		let currentDepthFunc = null;
		let currentDepthClear = null;

		return {

			setTest: function ( depthTest ) {

				if ( depthTest ) {

					enable( 2929 );

				} else {

					disable( 2929 );

				}

			},

			setMask: function ( depthMask ) {

				if ( currentDepthMask !== depthMask && ! locked ) {

					gl.depthMask( depthMask );
					currentDepthMask = depthMask;

				}

			},

			setFunc: function ( depthFunc ) {

				if ( currentDepthFunc !== depthFunc ) {

					if ( depthFunc ) {

						switch ( depthFunc ) {

							case NeverDepth:

								gl.depthFunc( 512 );
								break;

							case AlwaysDepth:

								gl.depthFunc( 519 );
								break;

							case LessDepth:

								gl.depthFunc( 513 );
								break;

							case LessEqualDepth:

								gl.depthFunc( 515 );
								break;

							case EqualDepth:

								gl.depthFunc( 514 );
								break;

							case GreaterEqualDepth:

								gl.depthFunc( 518 );
								break;

							case GreaterDepth:

								gl.depthFunc( 516 );
								break;

							case NotEqualDepth:

								gl.depthFunc( 517 );
								break;

							default:

								gl.depthFunc( 515 );

						}

					} else {

						gl.depthFunc( 515 );

					}

					currentDepthFunc = depthFunc;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( depth ) {

				if ( currentDepthClear !== depth ) {

					gl.clearDepth( depth );
					currentDepthClear = depth;

				}

			},

			reset: function () {

				locked = false;

				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;

			}

		};

	}

	function StencilBuffer() {

		let locked = false;

		let currentStencilMask = null;
		let currentStencilFunc = null;
		let currentStencilRef = null;
		let currentStencilFuncMask = null;
		let currentStencilFail = null;
		let currentStencilZFail = null;
		let currentStencilZPass = null;
		let currentStencilClear = null;

		return {

			setTest: function ( stencilTest ) {

				if ( ! locked ) {

					if ( stencilTest ) {

						enable( 2960 );

					} else {

						disable( 2960 );

					}

				}

			},

			setMask: function ( stencilMask ) {

				if ( currentStencilMask !== stencilMask && ! locked ) {

					gl.stencilMask( stencilMask );
					currentStencilMask = stencilMask;

				}

			},

			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

				if ( currentStencilFunc !== stencilFunc ||
				     currentStencilRef !== stencilRef ||
				     currentStencilFuncMask !== stencilMask ) {

					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;

				}

			},

			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

				if ( currentStencilFail !== stencilFail ||
				     currentStencilZFail !== stencilZFail ||
				     currentStencilZPass !== stencilZPass ) {

					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( stencil ) {

				if ( currentStencilClear !== stencil ) {

					gl.clearStencil( stencil );
					currentStencilClear = stencil;

				}

			},

			reset: function () {

				locked = false;

				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;

			}

		};

	}

	//

	const colorBuffer = new ColorBuffer();
	const depthBuffer = new DepthBuffer();
	const stencilBuffer = new StencilBuffer();

	let enabledCapabilities = {};

	let xrFramebuffer = null;
	let currentBoundFramebuffers = {};

	let currentProgram = null;

	let currentBlendingEnabled = false;
	let currentBlending = null;
	let currentBlendEquation = null;
	let currentBlendSrc = null;
	let currentBlendDst = null;
	let currentBlendEquationAlpha = null;
	let currentBlendSrcAlpha = null;
	let currentBlendDstAlpha = null;
	let currentPremultipledAlpha = false;

	let currentFlipSided = null;
	let currentCullFace = null;

	let currentLineWidth = null;

	let currentPolygonOffsetFactor = null;
	let currentPolygonOffsetUnits = null;

	const maxTextures = gl.getParameter( 35661 );

	let lineWidthAvailable = false;
	let version = 0;
	const glVersion = gl.getParameter( 7938 );

	if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

		version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 1.0 );

	} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

		version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 2.0 );

	}

	let currentTextureSlot = null;
	let currentBoundTextures = {};

	const currentScissor = new Vector4( 0, 0, gl.canvas.width, gl.canvas.height );
	const currentViewport = new Vector4( 0, 0, gl.canvas.width, gl.canvas.height );

	function createTexture( type, target, count ) {

		const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		const texture = gl.createTexture();

		gl.bindTexture( type, texture );
		gl.texParameteri( type, 10241, 9728 );
		gl.texParameteri( type, 10240, 9728 );

		for ( let i = 0; i < count; i ++ ) {

			gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

		}

		return texture;

	}

	const emptyTextures = {};
	emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
	emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

	// init

	colorBuffer.setClear( 0, 0, 0, 1 );
	depthBuffer.setClear( 1 );
	stencilBuffer.setClear( 0 );

	enable( 2929 );
	depthBuffer.setFunc( LessEqualDepth );

	setFlipSided( false );
	setCullFace( CullFaceBack );
	enable( 2884 );

	setBlending( NoBlending );

	//

	function enable( id ) {

		if ( enabledCapabilities[ id ] !== true ) {

			gl.enable( id );
			enabledCapabilities[ id ] = true;

		}

	}

	function disable( id ) {

		if ( enabledCapabilities[ id ] !== false ) {

			gl.disable( id );
			enabledCapabilities[ id ] = false;

		}

	}

	function bindXRFramebuffer( framebuffer ) {

		if ( framebuffer !== xrFramebuffer ) {

			gl.bindFramebuffer( 36160, framebuffer );

			xrFramebuffer = framebuffer;

		}

	}

	function bindFramebuffer( target, framebuffer ) {

		if ( framebuffer === null && xrFramebuffer !== null ) framebuffer = xrFramebuffer; // use active XR framebuffer if available

		if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

			gl.bindFramebuffer( target, framebuffer );

			currentBoundFramebuffers[ target ] = framebuffer;

		}

	}

	function useProgram( program ) {

		if ( currentProgram !== program ) {

			gl.useProgram( program );

			currentProgram = program;

			return true;

		}

		return false;

	}

	const equationToGL = {
		[ AddEquation ]: 32774,
		[ SubtractEquation ]: 32778,
		[ ReverseSubtractEquation ]: 32779
	};

	if ( isWebGL2 ) {

		equationToGL[ MinEquation ] = 32775;
		equationToGL[ MaxEquation ] = 32776;

	} else {

		const extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			equationToGL[ MinEquation ] = extension.MIN_EXT;
			equationToGL[ MaxEquation ] = extension.MAX_EXT;

		}

	}

	const factorToGL = {
		[ ZeroFactor ]: 0,
		[ OneFactor ]: 1,
		[ SrcColorFactor ]: 768,
		[ SrcAlphaFactor ]: 770,
		[ SrcAlphaSaturateFactor ]: 776,
		[ DstColorFactor ]: 774,
		[ DstAlphaFactor ]: 772,
		[ OneMinusSrcColorFactor ]: 769,
		[ OneMinusSrcAlphaFactor ]: 771,
		[ OneMinusDstColorFactor ]: 775,
		[ OneMinusDstAlphaFactor ]: 773
	};

	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		if ( blending === NoBlending ) {

			if ( currentBlendingEnabled === true ) {

				disable( 3042 );
				currentBlendingEnabled = false;

			}

			return;

		}

		if ( currentBlendingEnabled === false ) {

			enable( 3042 );
			currentBlendingEnabled = true;

		}

		if ( blending !== CustomBlending ) {

			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

				if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

					gl.blendEquation( 32774 );

					currentBlendEquation = AddEquation;
					currentBlendEquationAlpha = AddEquation;

				}

				if ( premultipliedAlpha ) {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( 1, 771, 1, 771 );
							break;

						case AdditiveBlending:
							gl.blendFunc( 1, 1 );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( 0, 0, 769, 771 );
							break;

						case MultiplyBlending:
							gl.blendFuncSeparate( 0, 768, 0, 770 );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				} else {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( 770, 771, 1, 771 );
							break;

						case AdditiveBlending:
							gl.blendFunc( 770, 1 );
							break;

						case SubtractiveBlending:
							gl.blendFunc( 0, 769 );
							break;

						case MultiplyBlending:
							gl.blendFunc( 0, 768 );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				}

				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

				currentBlending = blending;
				currentPremultipledAlpha = premultipliedAlpha;

			}

			return;

		}

		// custom blending

		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;

		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

			currentBlendEquation = blendEquation;
			currentBlendEquationAlpha = blendEquationAlpha;

		}

		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

			currentBlendSrc = blendSrc;
			currentBlendDst = blendDst;
			currentBlendSrcAlpha = blendSrcAlpha;
			currentBlendDstAlpha = blendDstAlpha;

		}

		currentBlending = blending;
		currentPremultipledAlpha = null;

	}

	function setMaterial( material, frontFaceCW ) {

		material.side === DoubleSide
			? disable( 2884 )
			: enable( 2884 );

		let flipSided = ( material.side === BackSide );
		if ( frontFaceCW ) flipSided = ! flipSided;

		setFlipSided( flipSided );

		( material.blending === NormalBlending && material.transparent === false )
			? setBlending( NoBlending )
			: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

		depthBuffer.setFunc( material.depthFunc );
		depthBuffer.setTest( material.depthTest );
		depthBuffer.setMask( material.depthWrite );
		colorBuffer.setMask( material.colorWrite );

		const stencilWrite = material.stencilWrite;
		stencilBuffer.setTest( stencilWrite );
		if ( stencilWrite ) {

			stencilBuffer.setMask( material.stencilWriteMask );
			stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
			stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

		}

		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		material.alphaToCoverage === true
			? enable( 32926 )
			: disable( 32926 );

	}

	//

	function setFlipSided( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( 2304 );

			} else {

				gl.frontFace( 2305 );

			}

			currentFlipSided = flipSided;

		}

	}

	function setCullFace( cullFace ) {

		if ( cullFace !== CullFaceNone ) {

			enable( 2884 );

			if ( cullFace !== currentCullFace ) {

				if ( cullFace === CullFaceBack ) {

					gl.cullFace( 1029 );

				} else if ( cullFace === CullFaceFront ) {

					gl.cullFace( 1028 );

				} else {

					gl.cullFace( 1032 );

				}

			}

		} else {

			disable( 2884 );

		}

		currentCullFace = cullFace;

	}

	function setLineWidth( width ) {

		if ( width !== currentLineWidth ) {

			if ( lineWidthAvailable ) gl.lineWidth( width );

			currentLineWidth = width;

		}

	}

	function setPolygonOffset( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			enable( 32823 );

			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		} else {

			disable( 32823 );

		}

	}

	function setScissorTest( scissorTest ) {

		if ( scissorTest ) {

			enable( 3089 );

		} else {

			disable( 3089 );

		}

	}

	// texture

	function activeTexture( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	function bindTexture( webglType, webglTexture ) {

		if ( currentTextureSlot === null ) {

			activeTexture();

		}

		let boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ currentTextureSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	function unbindTexture() {

		const boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

			gl.bindTexture( boundTexture.type, null );

			boundTexture.type = undefined;
			boundTexture.texture = undefined;

		}

	}

	function compressedTexImage2D() {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage2D() {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage3D() {

		try {

			gl.texImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	//

	function scissor( scissor ) {

		if ( currentScissor.equals( scissor ) === false ) {

			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );

		}

	}

	function viewport( viewport ) {

		if ( currentViewport.equals( viewport ) === false ) {

			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );

		}

	}

	//

	function reset() {

		// reset state

		gl.disable( 3042 );
		gl.disable( 2884 );
		gl.disable( 2929 );
		gl.disable( 32823 );
		gl.disable( 3089 );
		gl.disable( 2960 );
		gl.disable( 32926 );

		gl.blendEquation( 32774 );
		gl.blendFunc( 1, 0 );
		gl.blendFuncSeparate( 1, 0, 1, 0 );

		gl.colorMask( true, true, true, true );
		gl.clearColor( 0, 0, 0, 0 );

		gl.depthMask( true );
		gl.depthFunc( 513 );
		gl.clearDepth( 1 );

		gl.stencilMask( 0xffffffff );
		gl.stencilFunc( 519, 0, 0xffffffff );
		gl.stencilOp( 7680, 7680, 7680 );
		gl.clearStencil( 0 );

		gl.cullFace( 1029 );
		gl.frontFace( 2305 );

		gl.polygonOffset( 0, 0 );

		gl.activeTexture( 33984 );

		gl.bindFramebuffer( 36160, null );

		if ( isWebGL2 === true ) {

			gl.bindFramebuffer( 36009, null );
			gl.bindFramebuffer( 36008, null );

		}

		gl.useProgram( null );

		gl.lineWidth( 1 );

		gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
		gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

		// reset internals

		enabledCapabilities = {};

		currentTextureSlot = null;
		currentBoundTextures = {};

		xrFramebuffer = null;
		currentBoundFramebuffers = {};

		currentProgram = null;

		currentBlendingEnabled = false;
		currentBlending = null;
		currentBlendEquation = null;
		currentBlendSrc = null;
		currentBlendDst = null;
		currentBlendEquationAlpha = null;
		currentBlendSrcAlpha = null;
		currentBlendDstAlpha = null;
		currentPremultipledAlpha = false;

		currentFlipSided = null;
		currentCullFace = null;

		currentLineWidth = null;

		currentPolygonOffsetFactor = null;
		currentPolygonOffsetUnits = null;

		currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
		currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();

	}

	return {

		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},

		enable: enable,
		disable: disable,

		bindFramebuffer: bindFramebuffer,
		bindXRFramebuffer: bindXRFramebuffer,

		useProgram: useProgram,

		setBlending: setBlending,
		setMaterial: setMaterial,

		setFlipSided: setFlipSided,
		setCullFace: setCullFace,

		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,

		setScissorTest: setScissorTest,

		activeTexture: activeTexture,
		bindTexture: bindTexture,
		unbindTexture: unbindTexture,
		compressedTexImage2D: compressedTexImage2D,
		texImage2D: texImage2D,
		texImage3D: texImage3D,

		scissor: scissor,
		viewport: viewport,

		reset: reset

	};

}

function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

	const isWebGL2 = capabilities.isWebGL2;
	const maxTextures = capabilities.maxTextures;
	const maxCubemapSize = capabilities.maxCubemapSize;
	const maxTextureSize = capabilities.maxTextureSize;
	const maxSamples = capabilities.maxSamples;

	const _videoTextures = new WeakMap();
	let _canvas;

	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

	let useOffscreenCanvas = false;

	try {

		useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
			&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

	} catch ( err ) {

		// Ignore any errors

	}

	function createCanvas( width, height ) {

		// Use OffscreenCanvas when available. Specially needed in web workers

		return useOffscreenCanvas ?
			new OffscreenCanvas( width, height ) :
			document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

	}

	function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

		let scale = 1;

		// handle case if texture exceeds max size

		if ( image.width > maxSize || image.height > maxSize ) {

			scale = maxSize / Math.max( image.width, image.height );

		}

		// only perform resize if necessary

		if ( scale < 1 || needsPowerOfTwo === true ) {

			// only perform resize for certain image types

			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

				const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;

				const width = floor( scale * image.width );
				const height = floor( scale * image.height );

				if ( _canvas === undefined ) _canvas = createCanvas( width, height );

				// cube textures can't reuse the same canvas

				const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

				canvas.width = width;
				canvas.height = height;

				const context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, width, height );

				console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

				return canvas;

			} else {

				if ( 'data' in image ) {

					console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

				}

				return image;

			}

		}

		return image;

	}

	function isPowerOfTwo( image ) {

		return MathUtils.isPowerOfTwo( image.width ) && MathUtils.isPowerOfTwo( image.height );

	}

	function textureNeedsPowerOfTwo( texture ) {

		if ( isWebGL2 ) return false;

		return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
			( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

	}

	function textureNeedsGenerateMipmaps( texture, supportsMips ) {

		return texture.generateMipmaps && supportsMips &&
			texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

	}

	function generateMipmap( target, texture, width, height ) {

		_gl.generateMipmap( target );

		const textureProperties = properties.get( texture );

		textureProperties.__maxMipLevel = Math.log2( Math.max( width, height ) );

	}

	function getInternalFormat( internalFormatName, glFormat, glType ) {

		if ( isWebGL2 === false ) return glFormat;

		if ( internalFormatName !== null ) {

			if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

		}

		let internalFormat = glFormat;

		if ( glFormat === 6403 ) {

			if ( glType === 5126 ) internalFormat = 33326;
			if ( glType === 5131 ) internalFormat = 33325;
			if ( glType === 5121 ) internalFormat = 33321;

		}

		if ( glFormat === 6407 ) {

			if ( glType === 5126 ) internalFormat = 34837;
			if ( glType === 5131 ) internalFormat = 34843;
			if ( glType === 5121 ) internalFormat = 32849;

		}

		if ( glFormat === 6408 ) {

			if ( glType === 5126 ) internalFormat = 34836;
			if ( glType === 5131 ) internalFormat = 34842;
			if ( glType === 5121 ) internalFormat = 32856;

		}

		if ( internalFormat === 33325 || internalFormat === 33326 ||
			internalFormat === 34842 || internalFormat === 34836 ) {

			extensions.get( 'EXT_color_buffer_float' );

		}

		return internalFormat;

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback( f ) {

		if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

			return 9728;

		}

		return 9729;

	}

	//

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		if ( texture.isVideoTexture ) {

			_videoTextures.delete( texture );

		}

		info.memory.textures --;

	}

	function onRenderTargetDispose( event ) {

		const renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		info.memory.textures --;

	}

	//

	function deallocateTexture( texture ) {

		const textureProperties = properties.get( texture );

		if ( textureProperties.__webglInit === undefined ) return;

		_gl.deleteTexture( textureProperties.__webglTexture );

		properties.remove( texture );

	}

	function deallocateRenderTarget( renderTarget ) {

		const texture = renderTarget.texture;

		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( texture );

		if ( ! renderTarget ) return;

		if ( textureProperties.__webglTexture !== undefined ) {

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		if ( renderTarget.depthTexture ) {

			renderTarget.depthTexture.dispose();

		}

		if ( renderTarget.isWebGLCubeRenderTarget ) {

			for ( let i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
			if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );
			if ( renderTargetProperties.__webglColorRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer );
			if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

		}

		properties.remove( texture );
		properties.remove( renderTarget );

	}

	//

	let textureUnits = 0;

	function resetTextureUnits() {

		textureUnits = 0;

	}

	function allocateTextureUnit() {

		const textureUnit = textureUnits;

		if ( textureUnit >= maxTextures ) {

			console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

		}

		textureUnits += 1;

		return textureUnit;

	}

	//

	function setTexture2D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.isVideoTexture ) updateVideoTexture( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			const image = texture.image;

			if ( image === undefined ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

			} else if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

			} else {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 3553, textureProperties.__webglTexture );

	}

	function setTexture2DArray( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 35866, textureProperties.__webglTexture );

	}

	function setTexture3D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 32879, textureProperties.__webglTexture );

	}

	function setTextureCube( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadCubeTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 34067, textureProperties.__webglTexture );

	}

	const wrappingToGL = {
		[ RepeatWrapping ]: 10497,
		[ ClampToEdgeWrapping ]: 33071,
		[ MirroredRepeatWrapping ]: 33648
	};

	const filterToGL = {
		[ NearestFilter ]: 9728,
		[ NearestMipmapNearestFilter ]: 9984,
		[ NearestMipmapLinearFilter ]: 9986,

		[ LinearFilter ]: 9729,
		[ LinearMipmapNearestFilter ]: 9985,
		[ LinearMipmapLinearFilter ]: 9987
	};

	function setTextureParameters( textureType, texture, supportsMips ) {

		if ( supportsMips ) {

			_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
			_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );

			if ( textureType === 32879 || textureType === 35866 ) {

				_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );

			}

			_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
			_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );

		} else {

			_gl.texParameteri( textureType, 10242, 33071 );
			_gl.texParameteri( textureType, 10243, 33071 );

			if ( textureType === 32879 || textureType === 35866 ) {

				_gl.texParameteri( textureType, 32882, 33071 );

			}

			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

			}

			_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

			}

		}

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2
			if ( isWebGL2 === false && ( texture.type === HalfFloatType && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) return; // verify extension for WebGL 1 only

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function initTexture( textureProperties, texture ) {

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			info.memory.textures ++;

		}

	}

	function uploadTexture( textureProperties, texture, slot ) {

		let textureType = 3553;

		if ( texture.isDataTexture2DArray ) textureType = 35866;
		if ( texture.isDataTexture3D ) textureType = 32879;

		initTexture( textureProperties, texture );

		state.activeTexture( 33984 + slot );
		state.bindTexture( textureType, textureProperties.__webglTexture );

		_gl.pixelStorei( 37440, texture.flipY );
		_gl.pixelStorei( 37441, texture.premultiplyAlpha );
		_gl.pixelStorei( 3317, texture.unpackAlignment );
		_gl.pixelStorei( 37443, 0 );

		const needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;
		const image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );

		const supportsMips = isPowerOfTwo( image ) || isWebGL2,
			glFormat = utils.convert( texture.format );

		let glType = utils.convert( texture.type ),
			glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

		setTextureParameters( textureType, texture, supportsMips );

		let mipmap;
		const mipmaps = texture.mipmaps;

		if ( texture.isDepthTexture ) {

			// populate depth texture with dummy data

			glInternalFormat = 6402;

			if ( isWebGL2 ) {

				if ( texture.type === FloatType ) {

					glInternalFormat = 36012;

				} else if ( texture.type === UnsignedIntType ) {

					glInternalFormat = 33190;

				} else if ( texture.type === UnsignedInt248Type ) {

					glInternalFormat = 35056;

				} else {

					glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D

				}

			} else {

				if ( texture.type === FloatType ) {

					console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

				}

			}

			// validation checks for WebGL 1

			if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

					console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

					texture.type = UnsignedShortType;
					glType = utils.convert( texture.type );

				}

			}

			if ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {

				// Depth stencil textures need the DEPTH_STENCIL internal format
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				glInternalFormat = 34041;

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedInt248Type ) {

					console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

					texture.type = UnsignedInt248Type;
					glType = utils.convert( texture.type );

				}

			}

			//

			state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

		} else if ( texture.isDataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && supportsMips ) {

				for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;
				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			}

		} else if ( texture.isCompressedTexture ) {

			for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

					if ( glFormat !== null ) {

						state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

					}

				} else {

					state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

			textureProperties.__maxMipLevel = mipmaps.length - 1;

		} else if ( texture.isDataTexture2DArray ) {

			state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
			textureProperties.__maxMipLevel = 0;

		} else if ( texture.isDataTexture3D ) {

			state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
			textureProperties.__maxMipLevel = 0;

		} else {

			// regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && supportsMips ) {

				for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;
				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );
				textureProperties.__maxMipLevel = 0;

			}

		}

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			generateMipmap( textureType, texture, image.width, image.height );

		}

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	function uploadCubeTexture( textureProperties, texture, slot ) {

		if ( texture.image.length !== 6 ) return;

		initTexture( textureProperties, texture );

		state.activeTexture( 33984 + slot );
		state.bindTexture( 34067, textureProperties.__webglTexture );

		_gl.pixelStorei( 37440, texture.flipY );
		_gl.pixelStorei( 37441, texture.premultiplyAlpha );
		_gl.pixelStorei( 3317, texture.unpackAlignment );
		_gl.pixelStorei( 37443, 0 );

		const isCompressed = ( texture && ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture ) );
		const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

		const cubeImage = [];

		for ( let i = 0; i < 6; i ++ ) {

			if ( ! isCompressed && ! isDataTexture ) {

				cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

			} else {

				cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

			}

		}

		const image = cubeImage[ 0 ],
			supportsMips = isPowerOfTwo( image ) || isWebGL2,
			glFormat = utils.convert( texture.format ),
			glType = utils.convert( texture.type ),
			glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

		setTextureParameters( 34067, texture, supportsMips );

		let mipmaps;

		if ( isCompressed ) {

			for ( let i = 0; i < 6; i ++ ) {

				mipmaps = cubeImage[ i ].mipmaps;

				for ( let j = 0; j < mipmaps.length; j ++ ) {

					const mipmap = mipmaps[ j ];

					if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

						if ( glFormat !== null ) {

							state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

						}

					} else {

						state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

			}

			textureProperties.__maxMipLevel = mipmaps.length - 1;

		} else {

			mipmaps = texture.mipmaps;

			for ( let i = 0; i < 6; i ++ ) {

				if ( isDataTexture ) {

					state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

					for ( let j = 0; j < mipmaps.length; j ++ ) {

						const mipmap = mipmaps[ j ];
						const mipmapImage = mipmap.image[ i ].image;

						state.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

					}

				} else {

					state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

					for ( let j = 0; j < mipmaps.length; j ++ ) {

						const mipmap = mipmaps[ j ];

						state.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

					}

				}

			}

			textureProperties.__maxMipLevel = mipmaps.length;

		}

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			// We assume images for cube map have the same size.
			generateMipmap( 34067, texture, image.width, image.height );

		}

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

		const texture = renderTarget.texture;

		const glFormat = utils.convert( texture.format );
		const glType = utils.convert( texture.type );
		const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

		if ( textureTarget === 32879 || textureTarget === 35866 ) {

			state.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );

		} else {

			state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

		}

		state.bindFramebuffer( 36160, framebuffer );
		_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );
		state.bindFramebuffer( 36160, null );

	}

	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

		_gl.bindRenderbuffer( 36161, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			let glInternalFormat = 33189;

			if ( isMultisample ) {

				const depthTexture = renderTarget.depthTexture;

				if ( depthTexture && depthTexture.isDepthTexture ) {

					if ( depthTexture.type === FloatType ) {

						glInternalFormat = 36012;

					} else if ( depthTexture.type === UnsignedIntType ) {

						glInternalFormat = 33190;

					}

				}

				const samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			}

			_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			if ( isMultisample ) {

				const samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

			}


			_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

		} else {

			const texture = renderTarget.texture;

			const glFormat = utils.convert( texture.format );
			const glType = utils.convert( texture.type );
			const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

			if ( isMultisample ) {

				const samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			}

		}

		_gl.bindRenderbuffer( 36161, null );

	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture( framebuffer, renderTarget ) {

		const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
		if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

		state.bindFramebuffer( 36160, framebuffer );

		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

		}

		// upload an empty depth texture with framebuffer size
		if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {

			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;

		}

		setTexture2D( renderTarget.depthTexture, 0 );

		const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

		if ( renderTarget.depthTexture.format === DepthFormat ) {

			_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

			_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

		} else {

			throw new Error( 'Unknown depthTexture format' );

		}

	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );

		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

		if ( renderTarget.depthTexture ) {

			if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		} else {

			if ( isCube ) {

				renderTargetProperties.__webglDepthbuffer = [];

				for ( let i = 0; i < 6; i ++ ) {

					state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

				}

			} else {

				state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

			}

		}

		state.bindFramebuffer( 36160, null );

	}

	// Set up GL resources for the render target
	function setupRenderTarget( renderTarget ) {

		const texture = renderTarget.texture;

		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( texture );

		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		textureProperties.__webglTexture = _gl.createTexture();
		textureProperties.__version = texture.version;

		info.memory.textures ++;

		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
		const isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
		const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
		const supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

		// Handles WebGL2 RGBFormat fallback - #18858

		if ( isWebGL2 && texture.format === RGBFormat && ( texture.type === FloatType || texture.type === HalfFloatType ) ) {

			texture.format = RGBAFormat;

			console.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' );

		}

		// Setup framebuffer

		if ( isCube ) {

			renderTargetProperties.__webglFramebuffer = [];

			for ( let i = 0; i < 6; i ++ ) {

				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

			}

		} else {

			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			if ( isMultisample ) {

				if ( isWebGL2 ) {

					renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
					renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

					_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );

					const glFormat = utils.convert( texture.format );
					const glType = utils.convert( texture.type );
					const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );
					const samples = getRenderTargetSamples( renderTarget );
					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
					_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );
					_gl.bindRenderbuffer( 36161, null );

					if ( renderTarget.depthBuffer ) {

						renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

					}

					state.bindFramebuffer( 36160, null );


				} else {

					console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

				}

			}

		}

		// Setup color buffer

		if ( isCube ) {

			state.bindTexture( 34067, textureProperties.__webglTexture );
			setTextureParameters( 34067, texture, supportsMips );

			for ( let i = 0; i < 6; i ++ ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, 36064, 34069 + i );

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( 34067, texture, renderTarget.width, renderTarget.height );

			}

			state.bindTexture( 34067, null );

		} else {

			let glTextureType = 3553;

			if ( isRenderTarget3D ) {

				// Render targets containing layers, i.e: Texture 3D and 2d arrays

				if ( isWebGL2 ) {

					const isTexture3D = texture.isDataTexture3D;
					glTextureType = isTexture3D ? 32879 : 35866;

				} else {

					console.warn( 'THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.' );

				}

			}

			state.bindTexture( glTextureType, textureProperties.__webglTexture );
			setTextureParameters( glTextureType, texture, supportsMips );
			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, glTextureType );

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( 3553, texture, renderTarget.width, renderTarget.height );

			}

			state.bindTexture( 3553, null );

		}

		// Setup depth and stencil buffers

		if ( renderTarget.depthBuffer ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	function updateRenderTargetMipmap( renderTarget ) {

		const texture = renderTarget.texture;

		const supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
			const webglTexture = properties.get( texture ).__webglTexture;

			state.bindTexture( target, webglTexture );
			generateMipmap( target, texture, renderTarget.width, renderTarget.height );
			state.bindTexture( target, null );

		}

	}

	function updateMultisampleRenderTarget( renderTarget ) {

		if ( renderTarget.isWebGLMultisampleRenderTarget ) {

			if ( isWebGL2 ) {

				const renderTargetProperties = properties.get( renderTarget );

				state.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
				state.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

				const width = renderTarget.width;
				const height = renderTarget.height;
				let mask = 16384;

				if ( renderTarget.depthBuffer ) mask |= 256;
				if ( renderTarget.stencilBuffer ) mask |= 1024;

				_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

				state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer ); // see #18905

			} else {

				console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

			}

		}

	}

	function getRenderTargetSamples( renderTarget ) {

		return ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
			Math.min( maxSamples, renderTarget.samples ) : 0;

	}

	function updateVideoTexture( texture ) {

		const frame = info.render.frame;

		// Check the last frame we updated the VideoTexture

		if ( _videoTextures.get( texture ) !== frame ) {

			_videoTextures.set( texture, frame );
			texture.update();

		}

	}

	// backwards compatibility

	let warnedTexture2D = false;
	let warnedTextureCube = false;

	function safeSetTexture2D( texture, slot ) {

		if ( texture && texture.isWebGLRenderTarget ) {

			if ( warnedTexture2D === false ) {

				console.warn( 'THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.' );
				warnedTexture2D = true;

			}

			texture = texture.texture;

		}

		setTexture2D( texture, slot );

	}

	function safeSetTextureCube( texture, slot ) {

		if ( texture && texture.isWebGLCubeRenderTarget ) {

			if ( warnedTextureCube === false ) {

				console.warn( 'THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.' );
				warnedTextureCube = true;

			}

			texture = texture.texture;

		}


		setTextureCube( texture, slot );

	}

	//

	this.allocateTextureUnit = allocateTextureUnit;
	this.resetTextureUnits = resetTextureUnits;

	this.setTexture2D = setTexture2D;
	this.setTexture2DArray = setTexture2DArray;
	this.setTexture3D = setTexture3D;
	this.setTextureCube = setTextureCube;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

	this.safeSetTexture2D = safeSetTexture2D;
	this.safeSetTextureCube = safeSetTextureCube;

}

function WebGLUtils( gl, extensions, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	function convert( p ) {

		let extension;

		if ( p === UnsignedByteType ) return 5121;
		if ( p === UnsignedShort4444Type ) return 32819;
		if ( p === UnsignedShort5551Type ) return 32820;
		if ( p === UnsignedShort565Type ) return 33635;

		if ( p === ByteType ) return 5120;
		if ( p === ShortType ) return 5122;
		if ( p === UnsignedShortType ) return 5123;
		if ( p === IntType ) return 5124;
		if ( p === UnsignedIntType ) return 5125;
		if ( p === FloatType ) return 5126;

		if ( p === HalfFloatType ) {

			if ( isWebGL2 ) return 5131;

			extension = extensions.get( 'OES_texture_half_float' );

			if ( extension !== null ) {

				return extension.HALF_FLOAT_OES;

			} else {

				return null;

			}

		}

		if ( p === AlphaFormat ) return 6406;
		if ( p === RGBFormat ) return 6407;
		if ( p === RGBAFormat ) return 6408;
		if ( p === LuminanceFormat ) return 6409;
		if ( p === LuminanceAlphaFormat ) return 6410;
		if ( p === DepthFormat ) return 6402;
		if ( p === DepthStencilFormat ) return 34041;
		if ( p === RedFormat ) return 6403;

		// WebGL2 formats.

		if ( p === RedIntegerFormat ) return 36244;
		if ( p === RGFormat ) return 33319;
		if ( p === RGIntegerFormat ) return 33320;
		if ( p === RGBIntegerFormat ) return 36248;
		if ( p === RGBAIntegerFormat ) return 36249;

		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
			p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

			if ( extension !== null ) {

				if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

			} else {

				return null;

			}

		}

		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
			p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			} else {

				return null;

			}

		}

		if ( p === RGB_ETC1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

			if ( extension !== null ) {

				return extension.COMPRESSED_RGB_ETC1_WEBGL;

			} else {

				return null;

			}

		}

		if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

			if ( extension !== null ) {

				if ( p === RGB_ETC2_Format ) return extension.COMPRESSED_RGB8_ETC2;
				if ( p === RGBA_ETC2_EAC_Format ) return extension.COMPRESSED_RGBA8_ETC2_EAC;

			}

		}

		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||
			p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||
			p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||
			p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||
			p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||
			p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

			if ( extension !== null ) {

				// TODO Complete?

				return p;

			} else {

				return null;

			}

		}

		if ( p === RGBA_BPTC_Format ) {

			extension = extensions.get( 'EXT_texture_compression_bptc' );

			if ( extension !== null ) {

				// TODO Complete?

				return p;

			} else {

				return null;

			}

		}

		if ( p === UnsignedInt248Type ) {

			if ( isWebGL2 ) return 34042;

			extension = extensions.get( 'WEBGL_depth_texture' );

			if ( extension !== null ) {

				return extension.UNSIGNED_INT_24_8_WEBGL;

			} else {

				return null;

			}

		}

	}

	return { convert: convert };

}

class ArrayCamera extends PerspectiveCamera {

	constructor( array = [] ) {

		super();

		this.cameras = array;

	}

}

ArrayCamera.prototype.isArrayCamera = true;

class Group extends Object3D {

	constructor() {

		super();

		this.type = 'Group';

	}

}

Group.prototype.isGroup = true;

function WebXRController() {

	this._targetRay = null;
	this._grip = null;
	this._hand = null;

}

Object.assign( WebXRController.prototype, {

	constructor: WebXRController,

	getHandSpace: function () {

		if ( this._hand === null ) {

			this._hand = new Group();
			this._hand.matrixAutoUpdate = false;
			this._hand.visible = false;

			this._hand.joints = {};
			this._hand.inputState = { pinching: false };

		}

		return this._hand;

	},

	getTargetRaySpace: function () {

		if ( this._targetRay === null ) {

			this._targetRay = new Group();
			this._targetRay.matrixAutoUpdate = false;
			this._targetRay.visible = false;

		}

		return this._targetRay;

	},

	getGripSpace: function () {

		if ( this._grip === null ) {

			this._grip = new Group();
			this._grip.matrixAutoUpdate = false;
			this._grip.visible = false;

		}

		return this._grip;

	},

	dispatchEvent: function ( event ) {

		if ( this._targetRay !== null ) {

			this._targetRay.dispatchEvent( event );

		}

		if ( this._grip !== null ) {

			this._grip.dispatchEvent( event );

		}

		if ( this._hand !== null ) {

			this._hand.dispatchEvent( event );

		}

		return this;

	},

	disconnect: function ( inputSource ) {

		this.dispatchEvent( { type: 'disconnected', data: inputSource } );

		if ( this._targetRay !== null ) {

			this._targetRay.visible = false;

		}

		if ( this._grip !== null ) {

			this._grip.visible = false;

		}

		if ( this._hand !== null ) {

			this._hand.visible = false;

		}

		return this;

	},

	update: function ( inputSource, frame, referenceSpace ) {

		let inputPose = null;
		let gripPose = null;
		let handPose = null;

		const targetRay = this._targetRay;
		const grip = this._grip;
		const hand = this._hand;

		if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

			if ( targetRay !== null ) {

				inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

				if ( inputPose !== null ) {

					targetRay.matrix.fromArray( inputPose.transform.matrix );
					targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );

				}

			}

			if ( hand && inputSource.hand ) {

				handPose = true;

				for ( const inputjoint of inputSource.hand.values() ) {

					// Update the joints groups with the XRJoint poses
					const jointPose = frame.getJointPose( inputjoint, referenceSpace );

					if ( hand.joints[ inputjoint.jointName ] === undefined ) {

						// The transform of this joint will be updated with the joint pose on each frame
						const joint = new Group();
						joint.matrixAutoUpdate = false;
						joint.visible = false;
						hand.joints[ inputjoint.jointName ] = joint;
						// ??
						hand.add( joint );

					}

					const joint = hand.joints[ inputjoint.jointName ];

					if ( jointPose !== null ) {

						joint.matrix.fromArray( jointPose.transform.matrix );
						joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
						joint.jointRadius = jointPose.radius;

					}

					joint.visible = jointPose !== null;

				}

				// Custom events

				// Check pinchz
				const indexTip = hand.joints[ 'index-finger-tip' ];
				const thumbTip = hand.joints[ 'thumb-tip' ];
				const distance = indexTip.position.distanceTo( thumbTip.position );

				const distanceToPinch = 0.02;
				const threshold = 0.005;

				if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

					hand.inputState.pinching = false;
					this.dispatchEvent( {
						type: 'pinchend',
						handedness: inputSource.handedness,
						target: this
					} );

				} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

					hand.inputState.pinching = true;
					this.dispatchEvent( {
						type: 'pinchstart',
						handedness: inputSource.handedness,
						target: this
					} );

				}

			} else {

				if ( grip !== null && inputSource.gripSpace ) {

					gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

					if ( gripPose !== null ) {

						grip.matrix.fromArray( gripPose.transform.matrix );
						grip.matrix.decompose( grip.position, grip.rotation, grip.scale );

					}

				}

			}

		}

		if ( targetRay !== null ) {

			targetRay.visible = ( inputPose !== null );

		}

		if ( grip !== null ) {

			grip.visible = ( gripPose !== null );

		}

		if ( hand !== null ) {

			hand.visible = ( handPose !== null );

		}

		return this;

	}

} );

function WebXRManager( renderer, gl ) {

	const scope = this;
	const state = renderer.state;

	let session = null;

	let framebufferScaleFactor = 1.0;

	let referenceSpace = null;
	let referenceSpaceType = 'local-floor';

	let pose = null;

	const controllers = [];
	const inputSourcesMap = new Map();

	//

	const cameraL = new PerspectiveCamera();
	cameraL.layers.enable( 1 );
	cameraL.viewport = new Vector4();

	const cameraR = new PerspectiveCamera();
	cameraR.layers.enable( 2 );
	cameraR.viewport = new Vector4();

	const cameras = [ cameraL, cameraR ];

	const cameraVR = new ArrayCamera();
	cameraVR.layers.enable( 1 );
	cameraVR.layers.enable( 2 );

	let _currentDepthNear = null;
	let _currentDepthFar = null;

	//

	this.enabled = false;

	this.isPresenting = false;

	this.getController = function ( index ) {

		let controller = controllers[ index ];

		if ( controller === undefined ) {

			controller = new WebXRController();
			controllers[ index ] = controller;

		}

		return controller.getTargetRaySpace();

	};

	this.getControllerGrip = function ( index ) {

		let controller = controllers[ index ];

		if ( controller === undefined ) {

			controller = new WebXRController();
			controllers[ index ] = controller;

		}

		return controller.getGripSpace();

	};

	this.getHand = function ( index ) {

		let controller = controllers[ index ];

		if ( controller === undefined ) {

			controller = new WebXRController();
			controllers[ index ] = controller;

		}

		return controller.getHandSpace();

	};

	//

	function onSessionEvent( event ) {

		const controller = inputSourcesMap.get( event.inputSource );

		if ( controller ) {

			controller.dispatchEvent( { type: event.type, data: event.inputSource } );

		}

	}

	function onSessionEnd() {

		inputSourcesMap.forEach( function ( controller, inputSource ) {

			controller.disconnect( inputSource );

		} );

		inputSourcesMap.clear();

		_currentDepthNear = null;
		_currentDepthFar = null;

		// restore framebuffer/rendering state

		state.bindXRFramebuffer( null );
		renderer.setRenderTarget( renderer.getRenderTarget() );

		//

		animation.stop();

		scope.isPresenting = false;

		scope.dispatchEvent( { type: 'sessionend' } );

	}

	this.setFramebufferScaleFactor = function ( value ) {

		framebufferScaleFactor = value;

		if ( scope.isPresenting === true ) {

			console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

		}

	};

	this.setReferenceSpaceType = function ( value ) {

		referenceSpaceType = value;

		if ( scope.isPresenting === true ) {

			console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

		}

	};

	this.getReferenceSpace = function () {

		return referenceSpace;

	};

	this.getSession = function () {

		return session;

	};

	this.setSession = async function ( value ) {

		session = value;

		if ( session !== null ) {

			session.addEventListener( 'select', onSessionEvent );
			session.addEventListener( 'selectstart', onSessionEvent );
			session.addEventListener( 'selectend', onSessionEvent );
			session.addEventListener( 'squeeze', onSessionEvent );
			session.addEventListener( 'squeezestart', onSessionEvent );
			session.addEventListener( 'squeezeend', onSessionEvent );
			session.addEventListener( 'end', onSessionEnd );
			session.addEventListener( 'inputsourceschange', onInputSourcesChange );

			const attributes = gl.getContextAttributes();

			if ( attributes.xrCompatible !== true ) {

				await gl.makeXRCompatible();

			}

			const layerInit = {
				antialias: attributes.antialias,
				alpha: attributes.alpha,
				depth: attributes.depth,
				stencil: attributes.stencil,
				framebufferScaleFactor: framebufferScaleFactor
			};

			// eslint-disable-next-line no-undef
			const baseLayer = new XRWebGLLayer( session, gl, layerInit );

			session.updateRenderState( { baseLayer: baseLayer } );

			referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

			animation.setContext( session );
			animation.start();

			scope.isPresenting = true;

			scope.dispatchEvent( { type: 'sessionstart' } );

		}

	};

	function onInputSourcesChange( event ) {

		const inputSources = session.inputSources;

		// Assign inputSources to available controllers

		for ( let i = 0; i < controllers.length; i ++ ) {

			inputSourcesMap.set( inputSources[ i ], controllers[ i ] );

		}

		// Notify disconnected

		for ( let i = 0; i < event.removed.length; i ++ ) {

			const inputSource = event.removed[ i ];
			const controller = inputSourcesMap.get( inputSource );

			if ( controller ) {

				controller.dispatchEvent( { type: 'disconnected', data: inputSource } );
				inputSourcesMap.delete( inputSource );

			}

		}

		// Notify connected

		for ( let i = 0; i < event.added.length; i ++ ) {

			const inputSource = event.added[ i ];
			const controller = inputSourcesMap.get( inputSource );

			if ( controller ) {

				controller.dispatchEvent( { type: 'connected', data: inputSource } );

			}

		}

	}

	//

	const cameraLPos = new Vector3();
	const cameraRPos = new Vector3();

	/**
	 * Assumes 2 cameras that are parallel and share an X-axis, and that
	 * the cameras' projection and world matrices have already been set.
	 * And that near and far planes are identical for both cameras.
	 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
	 */
	function setProjectionFromUnion( camera, cameraL, cameraR ) {

		cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
		cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

		const ipd = cameraLPos.distanceTo( cameraRPos );

		const projL = cameraL.projectionMatrix.elements;
		const projR = cameraR.projectionMatrix.elements;

		// VR systems will have identical far and near planes, and
		// most likely identical top and bottom frustum extents.
		// Use the left camera for these values.
		const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
		const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
		const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
		const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

		const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
		const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
		const left = near * leftFov;
		const right = near * rightFov;

		// Calculate the new camera's position offset from the
		// left camera. xOffset should be roughly half `ipd`.
		const zOffset = ipd / ( - leftFov + rightFov );
		const xOffset = zOffset * - leftFov;

		// TODO: Better way to apply this offset?
		cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
		camera.translateX( xOffset );
		camera.translateZ( zOffset );
		camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
		camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

		// Find the union of the frustum values of the cameras and scale
		// the values so that the near plane's position does not change in world space,
		// although must now be relative to the new union camera.
		const near2 = near + zOffset;
		const far2 = far + zOffset;
		const left2 = left - xOffset;
		const right2 = right + ( ipd - xOffset );
		const top2 = topFov * far / far2 * near2;
		const bottom2 = bottomFov * far / far2 * near2;

		camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

	}

	function updateCamera( camera, parent ) {

		if ( parent === null ) {

			camera.matrixWorld.copy( camera.matrix );

		} else {

			camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

		}

		camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

	}

	this.getCamera = function ( camera ) {

		cameraVR.near = cameraR.near = cameraL.near = camera.near;
		cameraVR.far = cameraR.far = cameraL.far = camera.far;

		if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

			// Note that the new renderState won't apply until the next frame. See #18320

			session.updateRenderState( {
				depthNear: cameraVR.near,
				depthFar: cameraVR.far
			} );

			_currentDepthNear = cameraVR.near;
			_currentDepthFar = cameraVR.far;

		}

		const parent = camera.parent;
		const cameras = cameraVR.cameras;

		updateCamera( cameraVR, parent );

		for ( let i = 0; i < cameras.length; i ++ ) {

			updateCamera( cameras[ i ], parent );

		}

		// update camera and its children

		camera.matrixWorld.copy( cameraVR.matrixWorld );
		camera.matrix.copy( cameraVR.matrix );
		camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );

		const children = camera.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( true );

		}

		// update projection matrix for proper view frustum culling

		if ( cameras.length === 2 ) {

			setProjectionFromUnion( cameraVR, cameraL, cameraR );

		} else {

			// assume single camera setup (AR)

			cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

		}

		return cameraVR;

	};

	// Animation Loop

	let onAnimationFrameCallback = null;

	function onAnimationFrame( time, frame ) {

		pose = frame.getViewerPose( referenceSpace );

		if ( pose !== null ) {

			const views = pose.views;
			const baseLayer = session.renderState.baseLayer;

			state.bindXRFramebuffer( baseLayer.framebuffer );

			let cameraVRNeedsUpdate = false;

			// check if it's necessary to rebuild cameraVR's camera list

			if ( views.length !== cameraVR.cameras.length ) {

				cameraVR.cameras.length = 0;
				cameraVRNeedsUpdate = true;

			}

			for ( let i = 0; i < views.length; i ++ ) {

				const view = views[ i ];
				const viewport = baseLayer.getViewport( view );

				const camera = cameras[ i ];
				camera.matrix.fromArray( view.transform.matrix );
				camera.projectionMatrix.fromArray( view.projectionMatrix );
				camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

				if ( i === 0 ) {

					cameraVR.matrix.copy( camera.matrix );

				}

				if ( cameraVRNeedsUpdate === true ) {

					cameraVR.cameras.push( camera );

				}

			}

		}

		//

		const inputSources = session.inputSources;

		for ( let i = 0; i < controllers.length; i ++ ) {

			const controller = controllers[ i ];
			const inputSource = inputSources[ i ];

			controller.update( inputSource, frame, referenceSpace );

		}

		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

	}

	const animation = new WebGLAnimation();
	animation.setAnimationLoop( onAnimationFrame );

	this.setAnimationLoop = function ( callback ) {

		onAnimationFrameCallback = callback;

	};

	this.dispose = function () {};

}

Object.assign( WebXRManager.prototype, EventDispatcher.prototype );

function WebGLMaterials( properties ) {

	function refreshFogUniforms( uniforms, fog ) {

		uniforms.fogColor.value.copy( fog.color );

		if ( fog.isFog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog.isFogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshMaterialUniforms( uniforms, material, pixelRatio, height ) {

		if ( material.isMeshBasicMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshLambertMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsLambert( uniforms, material );

		} else if ( material.isMeshToonMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsToon( uniforms, material );

		} else if ( material.isMeshPhongMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsPhong( uniforms, material );

		} else if ( material.isMeshStandardMaterial ) {

			refreshUniformsCommon( uniforms, material );

			if ( material.isMeshPhysicalMaterial ) {

				refreshUniformsPhysical( uniforms, material );

			} else {

				refreshUniformsStandard( uniforms, material );

			}

		} else if ( material.isMeshMatcapMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsMatcap( uniforms, material );

		} else if ( material.isMeshDepthMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsDepth( uniforms, material );

		} else if ( material.isMeshDistanceMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsDistance( uniforms, material );

		} else if ( material.isMeshNormalMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsNormal( uniforms, material );

		} else if ( material.isLineBasicMaterial ) {

			refreshUniformsLine( uniforms, material );

			if ( material.isLineDashedMaterial ) {

				refreshUniformsDash( uniforms, material );

			}

		} else if ( material.isPointsMaterial ) {

			refreshUniformsPoints( uniforms, material, pixelRatio, height );

		} else if ( material.isSpriteMaterial ) {

			refreshUniformsSprites( uniforms, material );

		} else if ( material.isShadowMaterial ) {

			uniforms.color.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

		} else if ( material.isShaderMaterial ) {

			material.uniformsNeedUpdate = false; // #15581

		}

	}

	function refreshUniformsCommon( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( material.color ) {

			uniforms.diffuse.value.copy( material.color );

		}

		if ( material.emissive ) {

			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		}

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		if ( material.specularMap ) {

			uniforms.specularMap.value = material.specularMap;

		}

		const envMap = properties.get( material ).envMap;

		if ( envMap ) {

			uniforms.envMap.value = envMap;

			uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap._needsFlipEnvMap ) ? - 1 : 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;

			const maxMipLevel = properties.get( envMap ).__maxMipLevel;

			if ( maxMipLevel !== undefined ) {

				uniforms.maxMipLevel.value = maxMipLevel;

			}

		}

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. displacementMap map
		// 4. normal map
		// 5. bump map
		// 6. roughnessMap map
		// 7. metalnessMap map
		// 8. alphaMap map
		// 9. emissiveMap map
		// 10. clearcoat map
		// 11. clearcoat normal map
		// 12. clearcoat roughnessMap map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.displacementMap ) {

			uvScaleMap = material.displacementMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.roughnessMap ) {

			uvScaleMap = material.roughnessMap;

		} else if ( material.metalnessMap ) {

			uvScaleMap = material.metalnessMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		} else if ( material.emissiveMap ) {

			uvScaleMap = material.emissiveMap;

		} else if ( material.clearcoatMap ) {

			uvScaleMap = material.clearcoatMap;

		} else if ( material.clearcoatNormalMap ) {

			uvScaleMap = material.clearcoatNormalMap;

		} else if ( material.clearcoatRoughnessMap ) {

			uvScaleMap = material.clearcoatRoughnessMap;

		}

		if ( uvScaleMap !== undefined ) {

			// backwards compatibility
			if ( uvScaleMap.isWebGLRenderTarget ) {

				uvScaleMap = uvScaleMap.texture;

			}

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

		// uv repeat and offset setting priorities for uv2
		// 1. ao map
		// 2. light map

		let uv2ScaleMap;

		if ( material.aoMap ) {

			uv2ScaleMap = material.aoMap;

		} else if ( material.lightMap ) {

			uv2ScaleMap = material.lightMap;

		}

		if ( uv2ScaleMap !== undefined ) {

			// backwards compatibility
			if ( uv2ScaleMap.isWebGLRenderTarget ) {

				uv2ScaleMap = uv2ScaleMap.texture;

			}

			if ( uv2ScaleMap.matrixAutoUpdate === true ) {

				uv2ScaleMap.updateMatrix();

			}

			uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

		}

	}

	function refreshUniformsLine( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * pixelRatio;
		uniforms.scale.value = height * 0.5;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsSprites( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.rotation.value = material.rotation;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsLambert( uniforms, material ) {

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

	}

	function refreshUniformsPhong( uniforms, material ) {

		uniforms.specular.value.copy( material.specular );
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsToon( uniforms, material ) {

		if ( material.gradientMap ) {

			uniforms.gradientMap.value = material.gradientMap;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsStandard( uniforms, material ) {

		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;

		if ( material.roughnessMap ) {

			uniforms.roughnessMap.value = material.roughnessMap;

		}

		if ( material.metalnessMap ) {

			uniforms.metalnessMap.value = material.metalnessMap;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		const envMap = properties.get( material ).envMap;

		if ( envMap ) {

			//uniforms.envMap.value = material.envMap; // part of uniforms common
			uniforms.envMapIntensity.value = material.envMapIntensity;

		}

	}

	function refreshUniformsPhysical( uniforms, material ) {

		refreshUniformsStandard( uniforms, material );

		uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

		uniforms.clearcoat.value = material.clearcoat;
		uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
		if ( material.sheen ) uniforms.sheen.value.copy( material.sheen );

		if ( material.clearcoatMap ) {

			uniforms.clearcoatMap.value = material.clearcoatMap;

		}

		if ( material.clearcoatRoughnessMap ) {

			uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

		}

		if ( material.clearcoatNormalMap ) {

			uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
			uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

			if ( material.side === BackSide ) {

				uniforms.clearcoatNormalScale.value.negate();

			}

		}

		uniforms.transmission.value = material.transmission;

		if ( material.transmissionMap ) {

			uniforms.transmissionMap.value = material.transmissionMap;

		}

	}

	function refreshUniformsMatcap( uniforms, material ) {

		if ( material.matcap ) {

			uniforms.matcap.value = material.matcap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsDepth( uniforms, material ) {

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsDistance( uniforms, material ) {

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		uniforms.referencePosition.value.copy( material.referencePosition );
		uniforms.nearDistance.value = material.nearDistance;
		uniforms.farDistance.value = material.farDistance;

	}

	function refreshUniformsNormal( uniforms, material ) {

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	return {
		refreshFogUniforms: refreshFogUniforms,
		refreshMaterialUniforms: refreshMaterialUniforms
	};

}

function createCanvasElement() {

	const canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
	canvas.style.display = 'block';
	return canvas;

}

function WebGLRenderer( parameters ) {

	parameters = parameters || {};

	const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
		_context = parameters.context !== undefined ? parameters.context : null,

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
		_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
		_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

	let currentRenderList = null;
	let currentRenderState = null;

	// render() can be called from within a callback triggered by another render.
	// We track this so that the nested render call gets its list and state isolated from the parent render call.

	const renderListStack = [];
	const renderStateStack = [];

	// public properties

	this.domElement = _canvas;

	// Debug configuration container
	this.debug = {

		/**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */
		checkShaderErrors: true
	};

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// user-defined clipping

	this.clippingPlanes = [];
	this.localClippingEnabled = false;

	// physically based shading

	this.gammaFactor = 2.0;	// for backwards compatibility
	this.outputEncoding = LinearEncoding;

	// physical lights

	this.physicallyCorrectLights = false;

	// tone mapping

	this.toneMapping = NoToneMapping;
	this.toneMappingExposure = 1.0;

	// internal properties

	const _this = this;

	let _isContextLost = false;

	// internal state cache

	let _currentActiveCubeFace = 0;
	let _currentActiveMipmapLevel = 0;
	let _currentRenderTarget = null;
	let _currentMaterialId = - 1;

	let _currentCamera = null;

	const _currentViewport = new Vector4();
	const _currentScissor = new Vector4();
	let _currentScissorTest = null;

	//

	let _width = _canvas.width;
	let _height = _canvas.height;

	let _pixelRatio = 1;
	let _opaqueSort = null;
	let _transparentSort = null;

	const _viewport = new Vector4( 0, 0, _width, _height );
	const _scissor = new Vector4( 0, 0, _width, _height );
	let _scissorTest = false;

	// frustum

	const _frustum = new Frustum();

	// clipping

	let _clippingEnabled = false;
	let _localClippingEnabled = false;

	// camera matrices cache

	const _projScreenMatrix = new Matrix4();

	const _vector3 = new Vector3();

	const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

	function getTargetPixelRatio() {

		return _currentRenderTarget === null ? _pixelRatio : 1;

	}

	// initialize

	let _gl = _context;

	function getContext( contextNames, contextAttributes ) {

		for ( let i = 0; i < contextNames.length; i ++ ) {

			const contextName = contextNames[ i ];
			const context = _canvas.getContext( contextName, contextAttributes );
			if ( context !== null ) return context;

		}

		return null;

	}

	try {

		const contextAttributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer,
			powerPreference: _powerPreference,
			failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
		};

		// event listeners must be registered before WebGL context is created, see #12753

		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

		if ( _gl === null ) {

			const contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];

			if ( _this.isWebGL1Renderer === true ) {

				contextNames.shift();

			}

			_gl = getContext( contextNames, contextAttributes );

			if ( _gl === null ) {

				if ( getContext( contextNames ) ) {

					throw new Error( 'Error creating WebGL context with your selected attributes.' );

				} else {

					throw new Error( 'Error creating WebGL context.' );

				}

			}

		}

		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function () {

				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

			};

		}

	} catch ( error ) {

		console.error( 'THREE.WebGLRenderer: ' + error.message );
		throw error;

	}

	let extensions, capabilities, state, info;
	let properties, textures, cubemaps, attributes, geometries, objects;
	let programCache, materials, renderLists, renderStates, clipping, shadowMap;

	let background, morphtargets, bufferRenderer, indexedBufferRenderer;

	let utils, bindingStates;

	function initGLContext() {

		extensions = new WebGLExtensions( _gl );

		capabilities = new WebGLCapabilities( _gl, extensions, parameters );

		extensions.init( capabilities );

		utils = new WebGLUtils( _gl, extensions, capabilities );

		state = new WebGLState( _gl, extensions, capabilities );

		info = new WebGLInfo( _gl );
		properties = new WebGLProperties();
		textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
		cubemaps = new WebGLCubeMaps( _this );
		attributes = new WebGLAttributes( _gl, capabilities );
		bindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );
		geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
		objects = new WebGLObjects( _gl, geometries, attributes, info );
		morphtargets = new WebGLMorphtargets( _gl );
		clipping = new WebGLClipping( properties );
		programCache = new WebGLPrograms( _this, cubemaps, extensions, capabilities, bindingStates, clipping );
		materials = new WebGLMaterials( properties );
		renderLists = new WebGLRenderLists( properties );
		renderStates = new WebGLRenderStates( extensions, capabilities );
		background = new WebGLBackground( _this, cubemaps, state, objects, _premultipliedAlpha );
		shadowMap = new WebGLShadowMap( _this, objects, capabilities );

		bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
		indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

		info.programs = programCache.programs;

		_this.capabilities = capabilities;
		_this.extensions = extensions;
		_this.properties = properties;
		_this.renderLists = renderLists;
		_this.shadowMap = shadowMap;
		_this.state = state;
		_this.info = info;

	}

	initGLContext();

	// xr

	const xr = new WebXRManager( _this, _gl );

	this.xr = xr;

	// API

	this.getContext = function () {

		return _gl;

	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();

	};

	this.forceContextLoss = function () {

		const extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.loseContext();

	};

	this.forceContextRestore = function () {

		const extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.restoreContext();

	};

	this.getPixelRatio = function () {

		return _pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		if ( value === undefined ) return;

		_pixelRatio = value;

		this.setSize( _width, _height, false );

	};

	this.getSize = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );

			target = new Vector2();

		}

		return target.set( _width, _height );

	};

	this.setSize = function ( width, height, updateStyle ) {

		if ( xr.isPresenting ) {

			console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
			return;

		}

		_width = width;
		_height = height;

		_canvas.width = Math.floor( width * _pixelRatio );
		_canvas.height = Math.floor( height * _pixelRatio );

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.getDrawingBufferSize = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );

			target = new Vector2();

		}

		return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

	};

	this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

		_width = width;
		_height = height;

		_pixelRatio = pixelRatio;

		_canvas.width = Math.floor( width * pixelRatio );
		_canvas.height = Math.floor( height * pixelRatio );

		this.setViewport( 0, 0, width, height );

	};

	this.getCurrentViewport = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );

			target = new Vector4();

		}

		return target.copy( _currentViewport );

	};

	this.getViewport = function ( target ) {

		return target.copy( _viewport );

	};

	this.setViewport = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_viewport.set( x.x, x.y, x.z, x.w );

		} else {

			_viewport.set( x, y, width, height );

		}

		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissor = function ( target ) {

		return target.copy( _scissor );

	};

	this.setScissor = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_scissor.set( x.x, x.y, x.z, x.w );

		} else {

			_scissor.set( x, y, width, height );

		}

		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissorTest = function () {

		return _scissorTest;

	};

	this.setScissorTest = function ( boolean ) {

		state.setScissorTest( _scissorTest = boolean );

	};

	this.setOpaqueSort = function ( method ) {

		_opaqueSort = method;

	};

	this.setTransparentSort = function ( method ) {

		_transparentSort = method;

	};

	// Clearing

	this.getClearColor = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getClearColor() now requires a Color as an argument' );

			target = new Color();

		}

		return target.copy( background.getClearColor() );

	};

	this.setClearColor = function () {

		background.setClearColor.apply( background, arguments );

	};

	this.getClearAlpha = function () {

		return background.getClearAlpha();

	};

	this.setClearAlpha = function () {

		background.setClearAlpha.apply( background, arguments );

	};

	this.clear = function ( color, depth, stencil ) {

		let bits = 0;

		if ( color === undefined || color ) bits |= 16384;
		if ( depth === undefined || depth ) bits |= 256;
		if ( stencil === undefined || stencil ) bits |= 1024;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		this.clear( true, false, false );

	};

	this.clearDepth = function () {

		this.clear( false, true, false );

	};

	this.clearStencil = function () {

		this.clear( false, false, true );

	};

	//

	this.dispose = function () {

		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

		renderLists.dispose();
		renderStates.dispose();
		properties.dispose();
		cubemaps.dispose();
		objects.dispose();
		bindingStates.dispose();

		xr.dispose();

		xr.removeEventListener( 'sessionstart', onXRSessionStart );
		xr.removeEventListener( 'sessionend', onXRSessionEnd );

		animation.stop();

	};

	// Events

	function onContextLost( event ) {

		event.preventDefault();

		console.log( 'THREE.WebGLRenderer: Context Lost.' );

		_isContextLost = true;

	}

	function onContextRestore( /* event */ ) {

		console.log( 'THREE.WebGLRenderer: Context Restored.' );

		_isContextLost = false;

		const infoAutoReset = info.autoReset;
		const shadowMapEnabled = shadowMap.enabled;
		const shadowMapAutoUpdate = shadowMap.autoUpdate;
		const shadowMapNeedsUpdate = shadowMap.needsUpdate;
		const shadowMapType = shadowMap.type;

		initGLContext();

		info.autoReset = infoAutoReset;
		shadowMap.enabled = shadowMapEnabled;
		shadowMap.autoUpdate = shadowMapAutoUpdate;
		shadowMap.needsUpdate = shadowMapNeedsUpdate;
		shadowMap.type = shadowMapType;

	}

	function onMaterialDispose( event ) {

		const material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation

	function deallocateMaterial( material ) {

		releaseMaterialProgramReferences( material );

		properties.remove( material );

	}


	function releaseMaterialProgramReferences( material ) {

		const programs = properties.get( material ).programs;

		if ( programs !== undefined ) {

			programs.forEach( function ( program ) {

				programCache.releaseProgram( program );

			} );

		}

	}

	// Buffer rendering

	function renderObjectImmediate( object, program ) {

		object.render( function ( object ) {

			_this.renderBufferImmediate( object, program );

		} );

	}

	this.renderBufferImmediate = function ( object, program ) {

		bindingStates.initAttributes();

		const buffers = properties.get( object );

		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

		const programAttributes = program.getAttributes();

		if ( object.hasPositions ) {

			_gl.bindBuffer( 34962, buffers.position );
			_gl.bufferData( 34962, object.positionArray, 35048 );

			bindingStates.enableAttribute( programAttributes.position );
			_gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( 34962, buffers.normal );
			_gl.bufferData( 34962, object.normalArray, 35048 );

			bindingStates.enableAttribute( programAttributes.normal );
			_gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );

		}

		if ( object.hasUvs ) {

			_gl.bindBuffer( 34962, buffers.uv );
			_gl.bufferData( 34962, object.uvArray, 35048 );

			bindingStates.enableAttribute( programAttributes.uv );
			_gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );

		}

		if ( object.hasColors ) {

			_gl.bindBuffer( 34962, buffers.color );
			_gl.bufferData( 34962, object.colorArray, 35048 );

			bindingStates.enableAttribute( programAttributes.color );
			_gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );

		}

		bindingStates.disableUnusedAttributes();

		_gl.drawArrays( 4, 0, object.count );

		object.count = 0;

	};

	this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

		if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

		const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

		const program = setProgram( camera, scene, material, object );

		state.setMaterial( material, frontFaceCW );

		//

		let index = geometry.index;
		const position = geometry.attributes.position;

		//

		if ( index === null ) {

			if ( position === undefined || position.count === 0 ) return;

		} else if ( index.count === 0 ) {

			return;

		}

		//

		let rangeFactor = 1;

		if ( material.wireframe === true ) {

			index = geometries.getWireframeAttribute( geometry );
			rangeFactor = 2;

		}

		if ( material.morphTargets || material.morphNormals ) {

			morphtargets.update( object, geometry, material, program );

		}

		bindingStates.setup( object, material, program, geometry, index );

		let attribute;
		let renderer = bufferRenderer;

		if ( index !== null ) {

			attribute = attributes.get( index );

			renderer = indexedBufferRenderer;
			renderer.setIndex( attribute );

		}

		//

		const dataCount = ( index !== null ) ? index.count : position.count;

		const rangeStart = geometry.drawRange.start * rangeFactor;
		const rangeCount = geometry.drawRange.count * rangeFactor;

		const groupStart = group !== null ? group.start * rangeFactor : 0;
		const groupCount = group !== null ? group.count * rangeFactor : Infinity;

		const drawStart = Math.max( rangeStart, groupStart );
		const drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		const drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		if ( drawCount === 0 ) return;

		//

		if ( object.isMesh ) {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
				renderer.setMode( 1 );

			} else {

				renderer.setMode( 4 );

			}

		} else if ( object.isLine ) {

			let lineWidth = material.linewidth;

			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			state.setLineWidth( lineWidth * getTargetPixelRatio() );

			if ( object.isLineSegments ) {

				renderer.setMode( 1 );

			} else if ( object.isLineLoop ) {

				renderer.setMode( 2 );

			} else {

				renderer.setMode( 3 );

			}

		} else if ( object.isPoints ) {

			renderer.setMode( 0 );

		} else if ( object.isSprite ) {

			renderer.setMode( 4 );

		}

		if ( object.isInstancedMesh ) {

			renderer.renderInstances( drawStart, drawCount, object.count );

		} else if ( geometry.isInstancedBufferGeometry ) {

			const instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );

			renderer.renderInstances( drawStart, drawCount, instanceCount );

		} else {

			renderer.render( drawStart, drawCount );

		}

	};

	// Compile

	this.compile = function ( scene, camera ) {

		currentRenderState = renderStates.get( scene );
		currentRenderState.init();

		scene.traverseVisible( function ( object ) {

			if ( object.isLight && object.layers.test( camera.layers ) ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			}

		} );

		currentRenderState.setupLights();

		scene.traverse( function ( object ) {

			const material = object.material;

			if ( material ) {

				if ( Array.isArray( material ) ) {

					for ( let i = 0; i < material.length; i ++ ) {

						const material2 = material[ i ];

						getProgram( material2, scene, object );

					}

				} else {

					getProgram( material, scene, object );

				}

			}

		} );

	};

	// Animation Loop

	let onAnimationFrameCallback = null;

	function onAnimationFrame( time ) {

		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

	}

	function onXRSessionStart() {

		animation.stop();

	}

	function onXRSessionEnd() {

		animation.start();

	}

	const animation = new WebGLAnimation();
	animation.setAnimationLoop( onAnimationFrame );

	if ( typeof window !== 'undefined' ) animation.setContext( window );

	this.setAnimationLoop = function ( callback ) {

		onAnimationFrameCallback = callback;
		xr.setAnimationLoop( callback );

		( callback === null ) ? animation.stop() : animation.start();

	};

	xr.addEventListener( 'sessionstart', onXRSessionStart );
	xr.addEventListener( 'sessionend', onXRSessionEnd );

	// Rendering

	this.render = function ( scene, camera ) {

		let renderTarget, forceClear;

		if ( arguments[ 2 ] !== undefined ) {

			console.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );
			renderTarget = arguments[ 2 ];

		}

		if ( arguments[ 3 ] !== undefined ) {

			console.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' );
			forceClear = arguments[ 3 ];

		}

		if ( camera !== undefined && camera.isCamera !== true ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		if ( _isContextLost === true ) return;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === null ) camera.updateMatrixWorld();

		if ( xr.enabled === true && xr.isPresenting === true ) {

			camera = xr.getCamera( camera );

		}

		//
		if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );

		currentRenderState = renderStates.get( scene, renderStateStack.length );
		currentRenderState.init();

		renderStateStack.push( currentRenderState );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromProjectionMatrix( _projScreenMatrix );

		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

		currentRenderList = renderLists.get( scene, renderListStack.length );
		currentRenderList.init();

		renderListStack.push( currentRenderList );

		projectObject( scene, camera, 0, _this.sortObjects );

		currentRenderList.finish();

		if ( _this.sortObjects === true ) {

			currentRenderList.sort( _opaqueSort, _transparentSort );

		}

		//

		if ( _clippingEnabled === true ) clipping.beginShadows();

		const shadowsArray = currentRenderState.state.shadowsArray;

		shadowMap.render( shadowsArray, scene, camera );

		currentRenderState.setupLights();
		currentRenderState.setupLightsView( camera );

		if ( _clippingEnabled === true ) clipping.endShadows();

		//

		if ( this.info.autoReset === true ) this.info.reset();

		if ( renderTarget !== undefined ) {

			this.setRenderTarget( renderTarget );

		}

		//

		background.render( currentRenderList, scene, camera, forceClear );

		// render scene

		const opaqueObjects = currentRenderList.opaque;
		const transparentObjects = currentRenderList.transparent;

		if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
		if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

		//

		if ( _currentRenderTarget !== null ) {

			// Generate mipmap if we're using any kind of mipmap filtering

			textures.updateRenderTargetMipmap( _currentRenderTarget );

			// resolve multisample renderbuffers to a single-sample texture if necessary

			textures.updateMultisampleRenderTarget( _currentRenderTarget );

		}

		//

		if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.buffers.depth.setTest( true );
		state.buffers.depth.setMask( true );
		state.buffers.color.setMask( true );

		state.setPolygonOffset( false );

		// _gl.finish();

		bindingStates.resetDefaultState();
		_currentMaterialId = - 1;
		_currentCamera = null;

		renderStateStack.pop();

		if ( renderStateStack.length > 0 ) {

			currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

		} else {

			currentRenderState = null;

		}

		renderListStack.pop();

		if ( renderListStack.length > 0 ) {

			currentRenderList = renderListStack[ renderListStack.length - 1 ];

		} else {

			currentRenderList = null;

		}

	};

	function projectObject( object, camera, groupOrder, sortObjects ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible ) {

			if ( object.isGroup ) {

				groupOrder = object.renderOrder;

			} else if ( object.isLOD ) {

				if ( object.autoUpdate === true ) object.update( camera );

			} else if ( object.isLight ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			} else if ( object.isSprite ) {

				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					const geometry = objects.update( object );
					const material = object.material;

					if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			} else if ( object.isImmediateRenderObject ) {

				if ( sortObjects ) {

					_vector3.setFromMatrixPosition( object.matrixWorld )
						.applyMatrix4( _projScreenMatrix );

				}

				currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );

			} else if ( object.isMesh || object.isLine || object.isPoints ) {

				if ( object.isSkinnedMesh ) {

					// update skeleton only once in a frame

					if ( object.skeleton.frame !== info.render.frame ) {

						object.skeleton.update();
						object.skeleton.frame = info.render.frame;

					}

				}

				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					const geometry = objects.update( object );
					const material = object.material;

					if ( Array.isArray( material ) ) {

						const groups = geometry.groups;

						for ( let i = 0, l = groups.length; i < l; i ++ ) {

							const group = groups[ i ];
							const groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

							}

						}

					} else if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera, groupOrder, sortObjects );

		}

	}

	function renderObjects( renderList, scene, camera ) {

		const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

		for ( let i = 0, l = renderList.length; i < l; i ++ ) {

			const renderItem = renderList[ i ];

			const object = renderItem.object;
			const geometry = renderItem.geometry;
			const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
			const group = renderItem.group;

			if ( camera.isArrayCamera ) {

				const cameras = camera.cameras;

				for ( let j = 0, jl = cameras.length; j < jl; j ++ ) {

					const camera2 = cameras[ j ];

					if ( object.layers.test( camera2.layers ) ) {

						state.viewport( _currentViewport.copy( camera2.viewport ) );

						currentRenderState.setupLightsView( camera2 );

						renderObject( object, scene, camera2, geometry, material, group );

					}

				}

			} else {

				renderObject( object, scene, camera, geometry, material, group );

			}

		}

	}

	function renderObject( object, scene, camera, geometry, material, group ) {

		object.onBeforeRender( _this, scene, camera, geometry, material, group );

		object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

		if ( object.isImmediateRenderObject ) {

			const program = setProgram( camera, scene, material, object );

			state.setMaterial( material );

			bindingStates.reset();

			renderObjectImmediate( object, program );

		} else {

			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

		}

		object.onAfterRender( _this, scene, camera, geometry, material, group );

	}

	function getProgram( material, scene, object ) {

		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		const materialProperties = properties.get( material );

		const lights = currentRenderState.state.lights;
		const shadowsArray = currentRenderState.state.shadowsArray;

		const lightsStateVersion = lights.state.version;

		const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
		const programCacheKey = programCache.getProgramCacheKey( parameters );

		let programs = materialProperties.programs;

		// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

		materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
		materialProperties.fog = scene.fog;
		materialProperties.envMap = cubemaps.get( material.envMap || materialProperties.environment );

		if ( programs === undefined ) {

			// new material

			material.addEventListener( 'dispose', onMaterialDispose );

			programs = new Map();
			materialProperties.programs = programs;

		}

		let program = programs.get( programCacheKey );

		if ( program !== undefined ) {

			// early out if program and light state is identical

			if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

				updateCommonMaterialProperties( material, parameters );

				return program;

			}

		} else {

			parameters.uniforms = programCache.getUniforms( material );

			material.onBeforeCompile( parameters, _this );

			program = programCache.acquireProgram( parameters, programCacheKey );
			programs.set( programCacheKey, program );

			materialProperties.uniforms = parameters.uniforms;

		}

		const uniforms = materialProperties.uniforms;

		if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

			uniforms.clippingPlanes = clipping.uniform;

		}

		updateCommonMaterialProperties( material, parameters );

		// store the light setup it was created for

		materialProperties.needsLights = materialNeedsLights( material );
		materialProperties.lightsStateVersion = lightsStateVersion;

		if ( materialProperties.needsLights ) {

			// wire up the material to this renderer's lighting state

			uniforms.ambientLightColor.value = lights.state.ambient;
			uniforms.lightProbe.value = lights.state.probe;
			uniforms.directionalLights.value = lights.state.directional;
			uniforms.directionalLightShadows.value = lights.state.directionalShadow;
			uniforms.spotLights.value = lights.state.spot;
			uniforms.spotLightShadows.value = lights.state.spotShadow;
			uniforms.rectAreaLights.value = lights.state.rectArea;
			uniforms.ltc_1.value = lights.state.rectAreaLTC1;
			uniforms.ltc_2.value = lights.state.rectAreaLTC2;
			uniforms.pointLights.value = lights.state.point;
			uniforms.pointLightShadows.value = lights.state.pointShadow;
			uniforms.hemisphereLights.value = lights.state.hemi;

			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
			uniforms.spotShadowMap.value = lights.state.spotShadowMap;
			uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
			uniforms.pointShadowMap.value = lights.state.pointShadowMap;
			uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
			// TODO (abelnation): add area lights shadow info to uniforms

		}

		const progUniforms = program.getUniforms();
		const uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

		materialProperties.currentProgram = program;
		materialProperties.uniformsList = uniformsList;

		return program;

	}

	function updateCommonMaterialProperties( material, parameters ) {

		const materialProperties = properties.get( material );

		materialProperties.outputEncoding = parameters.outputEncoding;
		materialProperties.instancing = parameters.instancing;
		materialProperties.numClippingPlanes = parameters.numClippingPlanes;
		materialProperties.numIntersection = parameters.numClipIntersection;
		materialProperties.vertexAlphas = parameters.vertexAlphas;

	}

	function setProgram( camera, scene, material, object ) {

		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		textures.resetTextureUnits();

		const fog = scene.fog;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;
		const encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
		const envMap = cubemaps.get( material.envMap || environment );
		const vertexAlphas = material.vertexColors === true && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;

		const materialProperties = properties.get( material );
		const lights = currentRenderState.state.lights;

		if ( _clippingEnabled === true ) {

			if ( _localClippingEnabled === true || camera !== _currentCamera ) {

				const useCache =
					camera === _currentCamera &&
					material.id === _currentMaterialId;

				// we might want to call this function with some ClippingGroup
				// object instead of the material, once it becomes feasible
				// (#8465, #8379)
				clipping.setState( material, camera, useCache );

			}

		}

		//

		let needsProgramChange = false;

		if ( material.version === materialProperties.__version ) {

			if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

				needsProgramChange = true;

			} else if ( materialProperties.outputEncoding !== encoding ) {

				needsProgramChange = true;

			} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

				needsProgramChange = true;

			} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

				needsProgramChange = true;

			} else if ( materialProperties.envMap !== envMap ) {

				needsProgramChange = true;

			} else if ( material.fog && materialProperties.fog !== fog ) {

				needsProgramChange = true;

			} else if ( materialProperties.numClippingPlanes !== undefined &&
				( materialProperties.numClippingPlanes !== clipping.numPlanes ||
				materialProperties.numIntersection !== clipping.numIntersection ) ) {

				needsProgramChange = true;

			} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

				needsProgramChange = true;

			}

		} else {

			needsProgramChange = true;
			materialProperties.__version = material.version;

		}

		//

		let program = materialProperties.currentProgram;

		if ( needsProgramChange === true ) {

			program = getProgram( material, scene, object );

		}

		let refreshProgram = false;
		let refreshMaterial = false;
		let refreshLights = false;

		const p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.uniforms;

		if ( state.useProgram( program.program ) ) {

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || _currentCamera !== camera ) {

			p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

			if ( capabilities.logarithmicDepthBuffer ) {

				p_uniforms.setValue( _gl, 'logDepthBufFC',
					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}

			if ( _currentCamera !== camera ) {

				_currentCamera = camera;

				// lighting uniforms depend on the camera so enforce an update
				// now, in case this material supports lights - or later, when
				// the next material that does gets activated:

				refreshMaterial = true;		// set to true on material change
				refreshLights = true;		// remains set until update done

			}

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material.isShaderMaterial ||
				material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshStandardMaterial ||
				material.envMap ) {

				const uCamPos = p_uniforms.map.cameraPosition;

				if ( uCamPos !== undefined ) {

					uCamPos.setValue( _gl,
						_vector3.setFromMatrixPosition( camera.matrixWorld ) );

				}

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ) {

				p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ||
				material.isShadowMaterial ||
				material.skinning ) {

				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

			}

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// otherwise textures used for skinning can take over texture units reserved for other material textures

		if ( material.skinning ) {

			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

			const skeleton = object.skeleton;

			if ( skeleton ) {

				const bones = skeleton.bones;

				if ( capabilities.floatVertexTextures ) {

					if ( skeleton.boneTexture === null ) {

						// layout (1 matrix = 4 pixels)
						//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
						//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
						//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
						//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
						//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


						let size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
						size = MathUtils.ceilPowerOfTwo( size );
						size = Math.max( size, 4 );

						const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
						boneMatrices.set( skeleton.boneMatrices ); // copy current values

						const boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );

						skeleton.boneMatrices = boneMatrices;
						skeleton.boneTexture = boneTexture;
						skeleton.boneTextureSize = size;

					}

					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
					p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

				} else {

					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

				}

			}

		}

		if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

			materialProperties.receiveShadow = object.receiveShadow;
			p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

		}

		if ( refreshMaterial ) {

			p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

			if ( materialProperties.needsLights ) {

				// the current material requires lighting info

				// note: all lighting uniforms are always set correctly
				// they simply reference the renderer's state for their
				// values
				//
				// use the current material's .needsUpdate flags to set
				// the GL state when required

				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

			}

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				materials.refreshFogUniforms( m_uniforms, fog );

			}

			materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height );

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

		}

		if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
			material.uniformsNeedUpdate = false;

		}

		if ( material.isSpriteMaterial ) {

			p_uniforms.setValue( _gl, 'center', object.center );

		}

		// common matrices

		p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
		p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

		return program;

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate( uniforms, value ) {

		uniforms.ambientLightColor.needsUpdate = value;
		uniforms.lightProbe.needsUpdate = value;

		uniforms.directionalLights.needsUpdate = value;
		uniforms.directionalLightShadows.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.pointLightShadows.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.spotLightShadows.needsUpdate = value;
		uniforms.rectAreaLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;

	}

	function materialNeedsLights( material ) {

		return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
			material.isMeshStandardMaterial || material.isShadowMaterial ||
			( material.isShaderMaterial && material.lights === true );

	}

	this.getActiveCubeFace = function () {

		return _currentActiveCubeFace;

	};

	this.getActiveMipmapLevel = function () {

		return _currentActiveMipmapLevel;

	};

	this.getRenderTarget = function () {

		return _currentRenderTarget;

	};

	this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

		_currentRenderTarget = renderTarget;
		_currentActiveCubeFace = activeCubeFace;
		_currentActiveMipmapLevel = activeMipmapLevel;

		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

			textures.setupRenderTarget( renderTarget );

		}

		let framebuffer = null;
		let isCube = false;
		let isRenderTarget3D = false;

		if ( renderTarget ) {

			const texture = renderTarget.texture;

			if ( texture.isDataTexture3D || texture.isDataTexture2DArray ) {

				isRenderTarget3D = true;

			}

			const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( renderTarget.isWebGLCubeRenderTarget ) {

				framebuffer = __webglFramebuffer[ activeCubeFace ];
				isCube = true;

			} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {

				framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

			} else {

				framebuffer = __webglFramebuffer;

			}

			_currentViewport.copy( renderTarget.viewport );
			_currentScissor.copy( renderTarget.scissor );
			_currentScissorTest = renderTarget.scissorTest;

		} else {

			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
			_currentScissorTest = _scissorTest;

		}

		state.bindFramebuffer( 36160, framebuffer );

		state.viewport( _currentViewport );
		state.scissor( _currentScissor );
		state.setScissorTest( _currentScissorTest );

		if ( isCube ) {

			const textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( 36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

		} else if ( isRenderTarget3D ) {

			const textureProperties = properties.get( renderTarget.texture );
			const layer = activeCubeFace || 0;
			_gl.framebufferTextureLayer( 36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );

		}

	};

	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

		if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;

		}

		let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

			framebuffer = framebuffer[ activeCubeFaceIndex ];

		}

		if ( framebuffer ) {

			state.bindFramebuffer( 36160, framebuffer );

			try {

				const texture = renderTarget.texture;
				const textureFormat = texture.format;
				const textureType = texture.type;

				if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;

				}

				const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );

				if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // Edge and Chrome Mac < 52 (#9513)
					! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
					! halfFloatSupportedByExt ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;

				}

				if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {

					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

					}

				} else {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

			} finally {

				// restore framebuffer of current render target if necessary

				const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
				state.bindFramebuffer( 36160, framebuffer );

			}

		}

	};

	this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

		const levelScale = Math.pow( 2, - level );
		const width = Math.floor( texture.image.width * levelScale );
		const height = Math.floor( texture.image.height * levelScale );
		const glFormat = utils.convert( texture.format );

		textures.setTexture2D( texture, 0 );

		_gl.copyTexImage2D( 3553, level, glFormat, position.x, position.y, width, height, 0 );

		state.unbindTexture();

	};

	this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

		const width = srcTexture.image.width;
		const height = srcTexture.image.height;
		const glFormat = utils.convert( dstTexture.format );
		const glType = utils.convert( dstTexture.type );

		textures.setTexture2D( dstTexture, 0 );

		// As another texture upload may have changed pixelStorei
		// parameters, make sure they are correct for the dstTexture
		_gl.pixelStorei( 37440, dstTexture.flipY );
		_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
		_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

		if ( srcTexture.isDataTexture ) {

			_gl.texSubImage2D( 3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

		} else {

			if ( srcTexture.isCompressedTexture ) {

				_gl.compressedTexSubImage2D( 3553, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

			} else {

				_gl.texSubImage2D( 3553, level, position.x, position.y, glFormat, glType, srcTexture.image );

			}

		}

		// Generate mipmaps only when copying level 0
		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( 3553 );

		state.unbindTexture();

	};

	this.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {

		if ( _this.isWebGL1Renderer ) {

			console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );
			return;

		}

		const { width, height, data } = srcTexture.image;
		const glFormat = utils.convert( dstTexture.format );
		const glType = utils.convert( dstTexture.type );
		let glTarget;

		if ( dstTexture.isDataTexture3D ) {

			textures.setTexture3D( dstTexture, 0 );
			glTarget = 32879;

		} else if ( dstTexture.isDataTexture2DArray ) {

			textures.setTexture2DArray( dstTexture, 0 );
			glTarget = 35866;

		} else {

			console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
			return;

		}

		_gl.pixelStorei( 37440, dstTexture.flipY );
		_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
		_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

		const unpackRowLen = _gl.getParameter( 3314 );
		const unpackImageHeight = _gl.getParameter( 32878 );
		const unpackSkipPixels = _gl.getParameter( 3316 );
		const unpackSkipRows = _gl.getParameter( 3315 );
		const unpackSkipImages = _gl.getParameter( 32877 );

		_gl.pixelStorei( 3314, width );
		_gl.pixelStorei( 32878, height );
		_gl.pixelStorei( 3316, sourceBox.min.x );
		_gl.pixelStorei( 3315, sourceBox.min.y );
		_gl.pixelStorei( 32877, sourceBox.min.z );

		_gl.texSubImage3D(
			glTarget,
			level,
			position.x,
			position.y,
			position.z,
			sourceBox.max.x - sourceBox.min.x + 1,
			sourceBox.max.y - sourceBox.min.y + 1,
			sourceBox.max.z - sourceBox.min.z + 1,
			glFormat,
			glType,
			data
		);

		_gl.pixelStorei( 3314, unpackRowLen );
		_gl.pixelStorei( 32878, unpackImageHeight );
		_gl.pixelStorei( 3316, unpackSkipPixels );
		_gl.pixelStorei( 3315, unpackSkipRows );
		_gl.pixelStorei( 32877, unpackSkipImages );

		// Generate mipmaps only when copying level 0
		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );

		state.unbindTexture();

	};

	this.initTexture = function ( texture ) {

		textures.setTexture2D( texture, 0 );

		state.unbindTexture();

	};

	this.resetState = function () {

		_currentActiveCubeFace = 0;
		_currentActiveMipmapLevel = 0;
		_currentRenderTarget = null;

		state.reset();
		bindingStates.reset();

	};

	if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

		__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

	}

}

class WebGL1Renderer extends WebGLRenderer {}

WebGL1Renderer.prototype.isWebGL1Renderer = true;

class FogExp2 {

	constructor( color, density = 0.00025 ) {

		this.name = '';

		this.color = new Color( color );
		this.density = density;

	}

	clone() {

		return new FogExp2( this.color, this.density );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'FogExp2',
			color: this.color.getHex(),
			density: this.density
		};

	}

}

FogExp2.prototype.isFogExp2 = true;

class Fog {

	constructor( color, near = 1, far = 1000 ) {

		this.name = '';

		this.color = new Color( color );

		this.near = near;
		this.far = far;

	}

	clone() {

		return new Fog( this.color, this.near, this.far );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'Fog',
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};

	}

}

Fog.prototype.isFog = true;

class Scene extends Object3D {

	constructor() {

		super();

		this.type = 'Scene';

		this.background = null;
		this.environment = null;
		this.fog = null;

		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.background !== null ) this.background = source.background.clone();
		if ( source.environment !== null ) this.environment = source.environment.clone();
		if ( source.fog !== null ) this.fog = source.fog.clone();

		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
		if ( this.environment !== null ) data.object.environment = this.environment.toJSON( meta );
		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

		return data;

	}

}

Scene.prototype.isScene = true;

function InterleavedBuffer( array, stride ) {

	this.array = array;
	this.stride = stride;
	this.count = array !== undefined ? array.length / stride : 0;

	this.usage = StaticDrawUsage;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

	this.uuid = MathUtils.generateUUID();

}

Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

Object.assign( InterleavedBuffer.prototype, {

	isInterleavedBuffer: true,

	onUploadCallback: function () {},

	setUsage: function ( value ) {

		this.usage = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.usage = source.usage;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( let i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	set: function ( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	},

	clone: function ( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = MathUtils.generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

		}

		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

		const ib = new InterleavedBuffer( array, this.stride );
		ib.setUsage( this.usage );

		return ib;

	},

	onUpload: function ( callback ) {

		this.onUploadCallback = callback;

		return this;

	},

	toJSON: function ( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		// generate UUID for array buffer if necessary

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = MathUtils.generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = Array.prototype.slice.call( new Uint32Array( this.array.buffer ) );

		}

		//

		return {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		};

	}

} );

const _vector$6 = new Vector3();

function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

	this.name = '';

	this.data = interleavedBuffer;
	this.itemSize = itemSize;
	this.offset = offset;

	this.normalized = normalized === true;

}

Object.defineProperties( InterleavedBufferAttribute.prototype, {

	count: {

		get: function () {

			return this.data.count;

		}

	},

	array: {

		get: function () {

			return this.data.array;

		}

	},

	needsUpdate: {

		set: function ( value ) {

			this.data.needsUpdate = value;

		}

	}

} );

Object.assign( InterleavedBufferAttribute.prototype, {

	isInterleavedBufferAttribute: true,

	applyMatrix4: function ( m ) {

		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

			_vector$6.x = this.getX( i );
			_vector$6.y = this.getY( i );
			_vector$6.z = this.getZ( i );

			_vector$6.applyMatrix4( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	},

	applyNormalMatrix: function ( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$6.x = this.getX( i );
			_vector$6.y = this.getY( i );
			_vector$6.z = this.getZ( i );

			_vector$6.applyNormalMatrix( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	},

	transformDirection: function ( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$6.x = this.getX( i );
			_vector$6.y = this.getY( i );
			_vector$6.z = this.getZ( i );

			_vector$6.transformDirection( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	},

	setX: function ( index, x ) {

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	},

	setY: function ( index, y ) {

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	},

	setZ: function ( index, z ) {

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	},

	setW: function ( index, w ) {

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	},

	getX: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset ];

	},

	getY: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 1 ];

	},

	getZ: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 2 ];

	},

	getW: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 3 ];

	},

	setXY: function ( index, x, y ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	},

	clone: function ( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

		} else {

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

			}

			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

		}

	},

	toJSON: function ( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			// deinterleave data and save it as an ordinary buffer attribute for now

			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: array,
				normalized: this.normalized
			};

		} else {

			// save as true interlaved attribtue

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

			}

			return {
				isInterleavedBufferAttribute: true,
				itemSize: this.itemSize,
				data: this.data.uuid,
				offset: this.offset,
				normalized: this.normalized
			};

		}

	}

} );

/**
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */

class SpriteMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'SpriteMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.rotation = 0;

		this.sizeAttenuation = true;

		this.transparent = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.rotation = source.rotation;

		this.sizeAttenuation = source.sizeAttenuation;

		return this;

	}

}

SpriteMaterial.prototype.isSpriteMaterial = true;

let _geometry;

const _intersectPoint = /*@__PURE__*/ new Vector3();
const _worldScale = /*@__PURE__*/ new Vector3();
const _mvPosition = /*@__PURE__*/ new Vector3();

const _alignedPosition = /*@__PURE__*/ new Vector2();
const _rotatedPosition = /*@__PURE__*/ new Vector2();
const _viewWorldMatrix = /*@__PURE__*/ new Matrix4();

const _vA = /*@__PURE__*/ new Vector3();
const _vB = /*@__PURE__*/ new Vector3();
const _vC = /*@__PURE__*/ new Vector3();

const _uvA = /*@__PURE__*/ new Vector2();
const _uvB = /*@__PURE__*/ new Vector2();
const _uvC = /*@__PURE__*/ new Vector2();

class Sprite extends Object3D {

	constructor( material ) {

		super();

		this.type = 'Sprite';

		if ( _geometry === undefined ) {

			_geometry = new BufferGeometry();

			const float32Array = new Float32Array( [
				- 0.5, - 0.5, 0, 0, 0,
				0.5, - 0.5, 0, 1, 0,
				0.5, 0.5, 0, 1, 1,
				- 0.5, 0.5, 0, 0, 1
			] );

			const interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

			_geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
			_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
			_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

		}

		this.geometry = _geometry;
		this.material = ( material !== undefined ) ? material : new SpriteMaterial();

		this.center = new Vector2( 0.5, 0.5 );

	}

	raycast( raycaster, intersects ) {

		if ( raycaster.camera === null ) {

			console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

		}

		_worldScale.setFromMatrixScale( this.matrixWorld );

		_viewWorldMatrix.copy( raycaster.camera.matrixWorld );
		this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

		_mvPosition.setFromMatrixPosition( this.modelViewMatrix );

		if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

			_worldScale.multiplyScalar( - _mvPosition.z );

		}

		const rotation = this.material.rotation;
		let sin, cos;

		if ( rotation !== 0 ) {

			cos = Math.cos( rotation );
			sin = Math.sin( rotation );

		}

		const center = this.center;

		transformVertex( _vA.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vB.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );

		_uvA.set( 0, 0 );
		_uvB.set( 1, 0 );
		_uvC.set( 1, 1 );

		// check first triangle
		let intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );

		if ( intersect === null ) {

			// check second triangle
			transformVertex( _vB.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			_uvB.set( 0, 1 );

			intersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );
			if ( intersect === null ) {

				return;

			}

		}

		const distance = raycaster.ray.origin.distanceTo( _intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			point: _intersectPoint.clone(),
			uv: Triangle.getUV( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ),
			face: null,
			object: this

		} );

	}

	copy( source ) {

		super.copy( source );

		if ( source.center !== undefined ) this.center.copy( source.center );

		this.material = source.material;

		return this;

	}

}

Sprite.prototype.isSprite = true;

function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

	// compute position in camera space
	_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

	// to check if rotation is not zero
	if ( sin !== undefined ) {

		_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
		_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );

	} else {

		_rotatedPosition.copy( _alignedPosition );

	}


	vertexPosition.copy( mvPosition );
	vertexPosition.x += _rotatedPosition.x;
	vertexPosition.y += _rotatedPosition.y;

	// transform to world space
	vertexPosition.applyMatrix4( _viewWorldMatrix );

}

const _v1$2 = /*@__PURE__*/ new Vector3();
const _v2$1 = /*@__PURE__*/ new Vector3();

class LOD extends Object3D {

	constructor() {

		super();

		this._currentLevel = 0;

		this.type = 'LOD';

		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			},
			isLOD: {
				value: true,
			}
		} );

		this.autoUpdate = true;

	}

	copy( source ) {

		super.copy( source, false );

		const levels = source.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			this.addLevel( level.object.clone(), level.distance );

		}

		this.autoUpdate = source.autoUpdate;

		return this;

	}

	addLevel( object, distance = 0 ) {

		distance = Math.abs( distance );

		const levels = this.levels;

		let l;

		for ( l = 0; l < levels.length; l ++ ) {

			if ( distance < levels[ l ].distance ) {

				break;

			}

		}

		levels.splice( l, 0, { distance: distance, object: object } );

		this.add( object );

		return this;

	}

	getCurrentLevel() {

		return this._currentLevel;

	}

	getObjectForDistance( distance ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance < levels[ i ].distance ) {

					break;

				}

			}

			return levels[ i - 1 ].object;

		}

		return null;

	}

	raycast( raycaster, intersects ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			_v1$2.setFromMatrixPosition( this.matrixWorld );

			const distance = raycaster.ray.origin.distanceTo( _v1$2 );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		}

	}

	update( camera ) {

		const levels = this.levels;

		if ( levels.length > 1 ) {

			_v1$2.setFromMatrixPosition( camera.matrixWorld );
			_v2$1.setFromMatrixPosition( this.matrixWorld );

			const distance = _v1$2.distanceTo( _v2$1 ) / camera.zoom;

			levels[ 0 ].object.visible = true;

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance >= levels[ i ].distance ) {

					levels[ i - 1 ].object.visible = false;
					levels[ i ].object.visible = true;

				} else {

					break;

				}

			}

			this._currentLevel = i - 1;

			for ( ; i < l; i ++ ) {

				levels[ i ].object.visible = false;

			}

		}

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.autoUpdate === false ) data.object.autoUpdate = false;

		data.object.levels = [];

		const levels = this.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance
			} );

		}

		return data;

	}

}

const _basePosition = new Vector3();

const _skinIndex = new Vector4();
const _skinWeight = new Vector4();

const _vector$5 = new Vector3();
const _matrix = new Matrix4();

function SkinnedMesh( geometry, material ) {

	Mesh.call( this, geometry, material );

	this.type = 'SkinnedMesh';

	this.bindMode = 'attached';
	this.bindMatrix = new Matrix4();
	this.bindMatrixInverse = new Matrix4();

}

SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

	constructor: SkinnedMesh,

	isSkinnedMesh: true,

	copy: function ( source ) {

		Mesh.prototype.copy.call( this, source );

		this.bindMode = source.bindMode;
		this.bindMatrix.copy( source.bindMatrix );
		this.bindMatrixInverse.copy( source.bindMatrixInverse );

		this.skeleton = source.skeleton;

		return this;

	},

	bind: function ( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.copy( bindMatrix ).invert();

	},

	pose: function () {

		this.skeleton.pose();

	},

	normalizeSkinWeights: function () {

		const vector = new Vector4();

		const skinWeight = this.geometry.attributes.skinWeight;

		for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

			vector.x = skinWeight.getX( i );
			vector.y = skinWeight.getY( i );
			vector.z = skinWeight.getZ( i );
			vector.w = skinWeight.getW( i );

			const scale = 1.0 / vector.manhattanLength();

			if ( scale !== Infinity ) {

				vector.multiplyScalar( scale );

			} else {

				vector.set( 1, 0, 0, 0 ); // do something reasonable

			}

			skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

		}

	},

	updateMatrixWorld: function ( force ) {

		Mesh.prototype.updateMatrixWorld.call( this, force );

		if ( this.bindMode === 'attached' ) {

			this.bindMatrixInverse.copy( this.matrixWorld ).invert();

		} else if ( this.bindMode === 'detached' ) {

			this.bindMatrixInverse.copy( this.bindMatrix ).invert();

		} else {

			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

		}

	},

	boneTransform: function ( index, target ) {

		const skeleton = this.skeleton;
		const geometry = this.geometry;

		_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
		_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

		_basePosition.fromBufferAttribute( geometry.attributes.position, index ).applyMatrix4( this.bindMatrix );

		target.set( 0, 0, 0 );

		for ( let i = 0; i < 4; i ++ ) {

			const weight = _skinWeight.getComponent( i );

			if ( weight !== 0 ) {

				const boneIndex = _skinIndex.getComponent( i );

				_matrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

				target.addScaledVector( _vector$5.copy( _basePosition ).applyMatrix4( _matrix ), weight );

			}

		}

		return target.applyMatrix4( this.bindMatrixInverse );

	}

} );

function Bone() {

	Object3D.call( this );

	this.type = 'Bone';

}

Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Bone,

	isBone: true

} );

const _offsetMatrix = /*@__PURE__*/ new Matrix4();
const _identityMatrix = /*@__PURE__*/ new Matrix4();

class Skeleton {

	constructor( bones = [], boneInverses = [] ) {

		this.uuid = MathUtils.generateUUID();

		this.bones = bones.slice( 0 );
		this.boneInverses = boneInverses;
		this.boneMatrices = null;

		this.boneTexture = null;
		this.boneTextureSize = 0;

		this.frame = - 1;

		this.init();

	}

	init() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		this.boneMatrices = new Float32Array( bones.length * 16 );

		// calculate inverse bone matrices if necessary

		if ( boneInverses.length === 0 ) {

			this.calculateInverses();

		} else {

			// handle special case

			if ( bones.length !== boneInverses.length ) {

				console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

				this.boneInverses = [];

				for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

					this.boneInverses.push( new Matrix4() );

				}

			}

		}

	}

	calculateInverses() {

		this.boneInverses.length = 0;

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const inverse = new Matrix4();

			if ( this.bones[ i ] ) {

				inverse.copy( this.bones[ i ].matrixWorld ).invert();

			}

			this.boneInverses.push( inverse );

		}

	}

	pose() {

		// recover the bind-time world matrices

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				if ( bone.parent && bone.parent.isBone ) {

					bone.matrix.copy( bone.parent.matrixWorld ).invert();
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	}

	update() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;
		const boneMatrices = this.boneMatrices;
		const boneTexture = this.boneTexture;

		// flatten bone matrices to array

		for ( let i = 0, il = bones.length; i < il; i ++ ) {

			// compute the offset between the current and the original transform

			const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

			_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
			_offsetMatrix.toArray( boneMatrices, i * 16 );

		}

		if ( boneTexture !== null ) {

			boneTexture.needsUpdate = true;

		}

	}

	clone() {

		return new Skeleton( this.bones, this.boneInverses );

	}

	getBoneByName( name ) {

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone.name === name ) {

				return bone;

			}

		}

		return undefined;

	}

	dispose( ) {

		if ( this.boneTexture !== null ) {

			this.boneTexture.dispose();

			this.boneTexture = null;

		}

	}

	fromJSON( json, bones ) {

		this.uuid = json.uuid;

		for ( let i = 0, l = json.bones.length; i < l; i ++ ) {

			const uuid = json.bones[ i ];
			let bone = bones[ uuid ];

			if ( bone === undefined ) {

				console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
				bone = new Bone();

			}

			this.bones.push( bone );
			this.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );

		}

		this.init();

		return this;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.5,
				type: 'Skeleton',
				generator: 'Skeleton.toJSON'
			},
			bones: [],
			boneInverses: []
		};

		data.uuid = this.uuid;

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		for ( let i = 0, l = bones.length; i < l; i ++ ) {

			const bone = bones[ i ];
			data.bones.push( bone.uuid );

			const boneInverse = boneInverses[ i ];
			data.boneInverses.push( boneInverse.toArray() );

		}

		return data;

	}

}

const _instanceLocalMatrix = new Matrix4();
const _instanceWorldMatrix = new Matrix4();

const _instanceIntersects = [];

const _mesh = new Mesh();

function InstancedMesh( geometry, material, count ) {

	Mesh.call( this, geometry, material );

	this.instanceMatrix = new BufferAttribute( new Float32Array( count * 16 ), 16 );
	this.instanceColor = null;

	this.count = count;

	this.frustumCulled = false;

}

InstancedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

	constructor: InstancedMesh,

	isInstancedMesh: true,

	copy: function ( source ) {

		Mesh.prototype.copy.call( this, source );

		this.instanceMatrix.copy( source.instanceMatrix );

		if ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();

		this.count = source.count;

		return this;

	},

	getColorAt: function ( index, color ) {

		color.fromArray( this.instanceColor.array, index * 3 );

	},

	getMatrixAt: function ( index, matrix ) {

		matrix.fromArray( this.instanceMatrix.array, index * 16 );

	},

	raycast: function ( raycaster, intersects ) {

		const matrixWorld = this.matrixWorld;
		const raycastTimes = this.count;

		_mesh.geometry = this.geometry;
		_mesh.material = this.material;

		if ( _mesh.material === undefined ) return;

		for ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

			// calculate the world matrix for each instance

			this.getMatrixAt( instanceId, _instanceLocalMatrix );

			_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

			// the mesh represents this single instance

			_mesh.matrixWorld = _instanceWorldMatrix;

			_mesh.raycast( raycaster, _instanceIntersects );

			// process the result of raycast

			for ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

				const intersect = _instanceIntersects[ i ];
				intersect.instanceId = instanceId;
				intersect.object = this;
				intersects.push( intersect );

			}

			_instanceIntersects.length = 0;

		}

	},

	setColorAt: function ( index, color ) {

		if ( this.instanceColor === null ) {

			this.instanceColor = new BufferAttribute( new Float32Array( this.count * 3 ), 3 );

		}

		color.toArray( this.instanceColor.array, index * 3 );

	},

	setMatrixAt: function ( index, matrix ) {

		matrix.toArray( this.instanceMatrix.array, index * 16 );

	},

	updateMorphTargets: function () {

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

class LineBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'LineBasicMaterial';

		this.color = new Color( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.morphTargets = false;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		this.morphTargets = source.morphTargets;

		return this;

	}

}

LineBasicMaterial.prototype.isLineBasicMaterial = true;

const _start$1 = new Vector3();
const _end$1 = new Vector3();
const _inverseMatrix$1 = new Matrix4();
const _ray$1 = new Ray();
const _sphere$1 = new Sphere();

function Line( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

	Object3D.call( this );

	this.type = 'Line';

	this.geometry = geometry;
	this.material = material;

	this.updateMorphTargets();

}

Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Line,

	isLine: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	},

	computeLineDistances: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				const positionAttribute = geometry.attributes.position;
				const lineDistances = [ 0 ];

				for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

					_start$1.fromBufferAttribute( positionAttribute, i - 1 );
					_end$1.fromBufferAttribute( positionAttribute, i );

					lineDistances[ i ] = lineDistances[ i - 1 ];
					lineDistances[ i ] += _start$1.distanceTo( _end$1 );

				}

				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			} else {

				console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

		return this;

	},

	raycast: function ( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Line.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$1.copy( geometry.boundingSphere );
		_sphere$1.applyMatrix4( matrixWorld );
		_sphere$1.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

		//

		_inverseMatrix$1.copy( matrixWorld ).invert();
		_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const vStart = new Vector3();
		const vEnd = new Vector3();
		const interSegment = new Vector3();
		const interRay = new Vector3();
		const step = this.isLineSegments ? 2 : 1;

		if ( geometry.isBufferGeometry ) {

			const index = geometry.index;
			const attributes = geometry.attributes;
			const positionAttribute = attributes.position;

			if ( index !== null ) {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, l = end - 1; i < l; i += step ) {

					const a = index.getX( i );
					const b = index.getX( i + 1 );

					vStart.fromBufferAttribute( positionAttribute, a );
					vEnd.fromBufferAttribute( positionAttribute, b );

					const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					const distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, l = end - 1; i < l; i += step ) {

					vStart.fromBufferAttribute( positionAttribute, i );
					vEnd.fromBufferAttribute( positionAttribute, i + 1 );

					const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					const distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

	},

	updateMorphTargets: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			const morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	}

} );

const _start = new Vector3();
const _end = new Vector3();

function LineSegments( geometry, material ) {

	Line.call( this, geometry, material );

	this.type = 'LineSegments';

}

LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

	constructor: LineSegments,

	isLineSegments: true,

	computeLineDistances: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				const positionAttribute = geometry.attributes.position;
				const lineDistances = [];

				for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

					_start.fromBufferAttribute( positionAttribute, i );
					_end.fromBufferAttribute( positionAttribute, i + 1 );

					lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
					lineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );

				}

				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			} else {

				console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

		return this;

	}

} );

class LineLoop extends Line {

	constructor( geometry, material ) {

		super( geometry, material );

		this.type = 'LineLoop';

	}

}

LineLoop.prototype.isLineLoop = true;

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */

class PointsMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'PointsMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.morphTargets = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.morphTargets = source.morphTargets;

		return this;

	}

}

PointsMaterial.prototype.isPointsMaterial = true;

const _inverseMatrix = new Matrix4();
const _ray = new Ray();
const _sphere = new Sphere();
const _position$2 = new Vector3();

function Points( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

	Object3D.call( this );

	this.type = 'Points';

	this.geometry = geometry;
	this.material = material;

	this.updateMorphTargets();

}

Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Points,

	isPoints: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	},

	raycast: function ( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Points.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );
		_sphere.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.copy( matrixWorld ).invert();
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		if ( geometry.isBufferGeometry ) {

			const index = geometry.index;
			const attributes = geometry.attributes;
			const positionAttribute = attributes.position;

			if ( index !== null ) {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i ++ ) {

					const a = index.getX( i );

					_position$2.fromBufferAttribute( positionAttribute, a );

					testPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, l = end; i < l; i ++ ) {

					_position$2.fromBufferAttribute( positionAttribute, i );

					testPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			}

		} else {

			console.error( 'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

	},

	updateMorphTargets: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			const morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	}

} );

function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

	const rayPointDistanceSq = _ray.distanceSqToPoint( point );

	if ( rayPointDistanceSq < localThresholdSq ) {

		const intersectPoint = new Vector3();

		_ray.closestPointToPoint( point, intersectPoint );
		intersectPoint.applyMatrix4( matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			distanceToRay: Math.sqrt( rayPointDistanceSq ),
			point: intersectPoint,
			index: index,
			face: null,
			object: object

		} );

	}

}

class VideoTexture extends Texture {

	constructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		super( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.format = format !== undefined ? format : RGBFormat;

		this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

		this.generateMipmaps = false;

		const scope = this;

		function updateVideo() {

			scope.needsUpdate = true;
			video.requestVideoFrameCallback( updateVideo );

		}

		if ( 'requestVideoFrameCallback' in video ) {

			video.requestVideoFrameCallback( updateVideo );

		}

	}

	clone() {

		return new this.constructor( this.image ).copy( this );

	}

	update() {

		const video = this.image;
		const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;

		if ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {

			this.needsUpdate = true;

		}

	}

}

VideoTexture.prototype.isVideoTexture = true;

class CompressedTexture extends Texture {

	constructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	}

}

CompressedTexture.prototype.isCompressedTexture = true;

class CanvasTexture extends Texture {

	constructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		super( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.needsUpdate = true;

	}

}

CanvasTexture.prototype.isCanvasTexture = true;

class DepthTexture extends Texture {

	constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

		format = format !== undefined ? format : DepthFormat;

		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		}

		if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.flipY = false;
		this.generateMipmaps	= false;

	}


}

DepthTexture.prototype.isDepthTexture = true;

class CircleGeometry extends BufferGeometry {

	constructor( radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		segments = Math.max( 3, segments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const uv = new Vector2();

		// center point

		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );

		for ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {

			const segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uvs

			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// indices

		for ( let i = 1; i <= segments; i ++ ) {

			indices.push( i, i + 1, 0 );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

}

class CylinderGeometry extends BufferGeometry {

	constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();
		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		const scope = this;

		radialSegments = Math.floor( radialSegments );
		heightSegments = Math.floor( heightSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let index = 0;
		const indexArray = [];
		const halfHeight = height / 2;
		let groupStart = 0;

		// generate geometry

		generateTorso();

		if ( openEnded === false ) {

			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function generateTorso() {

			const normal = new Vector3();
			const vertex = new Vector3();

			let groupCount = 0;

			// this will be used to calculate the normal
			const slope = ( radiusBottom - radiusTop ) / height;

			// generate vertices, normals and uvs

			for ( let y = 0; y <= heightSegments; y ++ ) {

				const indexRow = [];

				const v = y / heightSegments;

				// calculate the radius of the current row

				const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

				for ( let x = 0; x <= radialSegments; x ++ ) {

					const u = x / radialSegments;

					const theta = u * thetaLength + thetaStart;

					const sinTheta = Math.sin( theta );
					const cosTheta = Math.cos( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 1 - v );

					// save index of vertex in respective row

					indexRow.push( index ++ );

				}

				// now save vertices of the row in our index array

				indexArray.push( indexRow );

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				for ( let y = 0; y < heightSegments; y ++ ) {

					// we use the index array to access the correct indices

					const a = indexArray[ y ][ x ];
					const b = indexArray[ y + 1 ][ x ];
					const c = indexArray[ y + 1 ][ x + 1 ];
					const d = indexArray[ y ][ x + 1 ];

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// update group counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, 0 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

		function generateCap( top ) {

			// save the index of the first center vertex
			const centerIndexStart = index;

			const uv = new Vector2();
			const vertex = new Vector3();

			let groupCount = 0;

			const radius = ( top === true ) ? radiusTop : radiusBottom;
			const sign = ( top === true ) ? 1 : - 1;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for ( let x = 1; x <= radialSegments; x ++ ) {

				// vertex

				vertices.push( 0, halfHeight * sign, 0 );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uvs.push( 0.5, 0.5 );

				// increase index

				index ++;

			}

			// save the index of the last center vertex
			const centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for ( let x = 0; x <= radialSegments; x ++ ) {

				const u = x / radialSegments;
				const theta = u * thetaLength + thetaStart;

				const cosTheta = Math.cos( theta );
				const sinTheta = Math.sin( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );

				// increase index

				index ++;

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				const c = centerIndexStart + x;
				const i = centerIndexEnd + x;

				if ( top === true ) {

					// face top

					indices.push( i, i + 1, c );

				} else {

					// face bottom

					indices.push( i + 1, i, c );

				}

				groupCount += 3;

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

	}

}

class ConeGeometry extends CylinderGeometry {

	constructor( radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

}

class PolyhedronGeometry extends BufferGeometry {

	constructor( vertices, indices, radius = 1, detail = 0 ) {

		super();

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		// default buffer data

		const vertexBuffer = [];
		const uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide( detail );

		// all vertices should lie on a conceptual sphere with a given radius

		applyRadius( radius );

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

		if ( detail === 0 ) {

			this.computeVertexNormals(); // flat normals

		} else {

			this.normalizeNormals(); // smooth normals

		}

		// helper functions

		function subdivide( detail ) {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			// iterate over all faces and apply a subdivison with the given detail value

			for ( let i = 0; i < indices.length; i += 3 ) {

				// get the vertices of the face

				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );

				// perform subdivision

				subdivideFace( a, b, c, detail );

			}

		}

		function subdivideFace( a, b, c, detail ) {

			const cols = detail + 1;

			// we use this multidimensional array as a data structure for creating the subdivision

			const v = [];

			// construct all of the vertices for this subdivision

			for ( let i = 0; i <= cols; i ++ ) {

				v[ i ] = [];

				const aj = a.clone().lerp( c, i / cols );
				const bj = b.clone().lerp( c, i / cols );

				const rows = cols - i;

				for ( let j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

					}

				}

			}

			// construct all of the faces

			for ( let i = 0; i < cols; i ++ ) {

				for ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					const k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );

					} else {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );

					}

				}

			}

		}

		function applyRadius( radius ) {

			const vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				vertex.normalize().multiplyScalar( radius );

				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;

			}

		}

		function generateUVs() {

			const vertex = new Vector3();

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				const u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				const v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );

			}

			correctUVs();

			correctSeam();

		}

		function correctSeam() {

			// handle case when face straddles the seam, see #3269

			for ( let i = 0; i < uvBuffer.length; i += 6 ) {

				// uv data of a single face

				const x0 = uvBuffer[ i + 0 ];
				const x1 = uvBuffer[ i + 2 ];
				const x2 = uvBuffer[ i + 4 ];

				const max = Math.max( x0, x1, x2 );
				const min = Math.min( x0, x1, x2 );

				// 0.9 is somewhat arbitrary

				if ( max > 0.9 && min < 0.1 ) {

					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

				}

			}

		}

		function pushVertex( vertex ) {

			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

		}

		function getVertexByIndex( index, vertex ) {

			const stride = index * 3;

			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];

		}

		function correctUVs() {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			const centroid = new Vector3();

			const uvA = new Vector2();
			const uvB = new Vector2();
			const uvC = new Vector2();

			for ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

				const azi = azimuth( centroid );

				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );

			}

		}

		function correctUV( uv, stride, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

				uvBuffer[ stride ] = uv.x - 1;

			}

			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

			}

		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}

	}

}

class DodecahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;
		const r = 1 / t;

		const vertices = [

			// (1, 1, 1)
			- 1, - 1, - 1,	- 1, - 1, 1,
			- 1, 1, - 1, - 1, 1, 1,
			1, - 1, - 1, 1, - 1, 1,
			1, 1, - 1, 1, 1, 1,

			// (0, 1/, )
			0, - r, - t, 0, - r, t,
			0, r, - t, 0, r, t,

			// (1/, , 0)
			- r, - t, 0, - r, t, 0,
			r, - t, 0, r, t, 0,

			// (, 0, 1/)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];

		const indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9
		];

		super( vertices, indices, radius, detail );

		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

}

const _v0 = new Vector3();
const _v1$1 = new Vector3();
const _normal = new Vector3();
const _triangle = new Triangle();

class EdgesGeometry extends BufferGeometry {

	constructor( geometry, thresholdAngle ) {

		super();

		this.type = 'EdgesGeometry';

		this.parameters = {
			thresholdAngle: thresholdAngle
		};

		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

		if ( geometry.isGeometry === true ) {

			console.error( 'THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );
			return;

		}

		const precisionPoints = 4;
		const precision = Math.pow( 10, precisionPoints );
		const thresholdDot = Math.cos( MathUtils.DEG2RAD * thresholdAngle );

		const indexAttr = geometry.getIndex();
		const positionAttr = geometry.getAttribute( 'position' );
		const indexCount = indexAttr ? indexAttr.count : positionAttr.count;

		const indexArr = [ 0, 0, 0 ];
		const vertKeys = [ 'a', 'b', 'c' ];
		const hashes = new Array( 3 );

		const edgeData = {};
		const vertices = [];
		for ( let i = 0; i < indexCount; i += 3 ) {

			if ( indexAttr ) {

				indexArr[ 0 ] = indexAttr.getX( i );
				indexArr[ 1 ] = indexAttr.getX( i + 1 );
				indexArr[ 2 ] = indexAttr.getX( i + 2 );

			} else {

				indexArr[ 0 ] = i;
				indexArr[ 1 ] = i + 1;
				indexArr[ 2 ] = i + 2;

			}

			const { a, b, c } = _triangle;
			a.fromBufferAttribute( positionAttr, indexArr[ 0 ] );
			b.fromBufferAttribute( positionAttr, indexArr[ 1 ] );
			c.fromBufferAttribute( positionAttr, indexArr[ 2 ] );
			_triangle.getNormal( _normal );

			// create hashes for the edge from the vertices
			hashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;
			hashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;
			hashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;

			// skip degenerate triangles
			if ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {

				continue;

			}

			// iterate over every edge
			for ( let j = 0; j < 3; j ++ ) {

				// get the first and next vertex making up the edge
				const jNext = ( j + 1 ) % 3;
				const vecHash0 = hashes[ j ];
				const vecHash1 = hashes[ jNext ];
				const v0 = _triangle[ vertKeys[ j ] ];
				const v1 = _triangle[ vertKeys[ jNext ] ];

				const hash = `${ vecHash0 }_${ vecHash1 }`;
				const reverseHash = `${ vecHash1 }_${ vecHash0 }`;

				if ( reverseHash in edgeData && edgeData[ reverseHash ] ) {

					// if we found a sibling edge add it into the vertex array if
					// it meets the angle threshold and delete the edge from the map.
					if ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {

						vertices.push( v0.x, v0.y, v0.z );
						vertices.push( v1.x, v1.y, v1.z );

					}

					edgeData[ reverseHash ] = null;

				} else if ( ! ( hash in edgeData ) ) {

					// if we've already got an edge here then skip adding a new one
					edgeData[ hash ] = {

						index0: indexArr[ j ],
						index1: indexArr[ jNext ],
						normal: _normal.clone(),

					};

				}

			}

		}

		// iterate over all remaining, unmatched edges and add them to the vertex array
		for ( const key in edgeData ) {

			if ( edgeData[ key ] ) {

				const { index0, index1 } = edgeData[ key ];
				_v0.fromBufferAttribute( positionAttr, index0 );
				_v1$1.fromBufferAttribute( positionAttr, index1 );

				vertices.push( _v0.x, _v0.y, _v0.z );
				vertices.push( _v1$1.x, _v1$1.y, _v1$1.z );

			}

		}

		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	}

}

/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */

const Earcut = {

	triangulate: function ( data, holeIndices, dim ) {

		dim = dim || 2;

		const hasHoles = holeIndices && holeIndices.length;
		const outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;
		let outerNode = linkedList( data, 0, outerLen, dim, true );
		const triangles = [];

		if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

		let minX, minY, maxX, maxY, x, y, invSize;

		if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

		// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
		if ( data.length > 80 * dim ) {

			minX = maxX = data[ 0 ];
			minY = maxY = data[ 1 ];

			for ( let i = dim; i < outerLen; i += dim ) {

				x = data[ i ];
				y = data[ i + 1 ];
				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;

			}

			// minX, minY and invSize are later used to transform coords into integers for z-order calculation
			invSize = Math.max( maxX - minX, maxY - minY );
			invSize = invSize !== 0 ? 1 / invSize : 0;

		}

		earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

		return triangles;

	}

};

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList( data, start, end, dim, clockwise ) {

	let i, last;

	if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

		for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	} else {

		for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	}

	if ( last && equals( last, last.next ) ) {

		removeNode( last );
		last = last.next;

	}

	return last;

}

// eliminate colinear or duplicate points
function filterPoints( start, end ) {

	if ( ! start ) return start;
	if ( ! end ) end = start;

	let p = start,
		again;
	do {

		again = false;

		if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

			removeNode( p );
			p = end = p.prev;
			if ( p === p.next ) break;
			again = true;

		} else {

			p = p.next;

		}

	} while ( again || p !== end );

	return end;

}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

	if ( ! ear ) return;

	// interlink polygon nodes in z-order
	if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

	let stop = ear,
		prev, next;

	// iterate through ears, slicing them one by one
	while ( ear.prev !== ear.next ) {

		prev = ear.prev;
		next = ear.next;

		if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

			// cut off the triangle
			triangles.push( prev.i / dim );
			triangles.push( ear.i / dim );
			triangles.push( next.i / dim );

			removeNode( ear );

			// skipping the next vertex leads to less sliver triangles
			ear = next.next;
			stop = next.next;

			continue;

		}

		ear = next;

		// if we looped through the whole remaining polygon and can't find any more ears
		if ( ear === stop ) {

			// try filtering points and slicing again
			if ( ! pass ) {

				earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

				// if this didn't work, try curing all small self-intersections locally

			} else if ( pass === 1 ) {

				ear = cureLocalIntersections( filterPoints( ear ), triangles, dim );
				earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

				// as a last resort, try splitting the remaining polygon into two

			} else if ( pass === 2 ) {

				splitEarcut( ear, triangles, dim, minX, minY, invSize );

			}

			break;

		}

	}

}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar( ear ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// now make sure we don't have other points inside the potential ear
	let p = ear.next.next;

	while ( p !== ear.prev ) {

		if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.next;

	}

	return true;

}

function isEarHashed( ear, minX, minY, invSize ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// triangle bbox; min & max are calculated like this for speed
	const minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
		minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
		maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
		maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

	// z-order range for the current triangle bbox;
	const minZ = zOrder( minTX, minTY, minX, minY, invSize ),
		maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

	let p = ear.prevZ,
		n = ear.nextZ;

	// look for points inside the triangle in both directions
	while ( p && p.z >= minZ && n && n.z <= maxZ ) {

		if ( p !== ear.prev && p !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

		if ( n !== ear.prev && n !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	// look for remaining points in decreasing z-order
	while ( p && p.z >= minZ ) {

		if ( p !== ear.prev && p !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

	}

	// look for remaining points in increasing z-order
	while ( n && n.z <= maxZ ) {

		if ( n !== ear.prev && n !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	return true;

}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections( start, triangles, dim ) {

	let p = start;
	do {

		const a = p.prev,
			b = p.next.next;

		if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

			triangles.push( a.i / dim );
			triangles.push( p.i / dim );
			triangles.push( b.i / dim );

			// remove two nodes involved
			removeNode( p );
			removeNode( p.next );

			p = start = b;

		}

		p = p.next;

	} while ( p !== start );

	return filterPoints( p );

}

// try splitting polygon into two and triangulate them independently
function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

	// look for a valid diagonal that divides the polygon into two
	let a = start;
	do {

		let b = a.next.next;
		while ( b !== a.prev ) {

			if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

				// split the polygon in two by the diagonal
				let c = splitPolygon( a, b );

				// filter colinear points around the cuts
				a = filterPoints( a, a.next );
				c = filterPoints( c, c.next );

				// run earcut on each half
				earcutLinked( a, triangles, dim, minX, minY, invSize );
				earcutLinked( c, triangles, dim, minX, minY, invSize );
				return;

			}

			b = b.next;

		}

		a = a.next;

	} while ( a !== start );

}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles( data, holeIndices, outerNode, dim ) {

	const queue = [];
	let i, len, start, end, list;

	for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

		start = holeIndices[ i ] * dim;
		end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
		list = linkedList( data, start, end, dim, false );
		if ( list === list.next ) list.steiner = true;
		queue.push( getLeftmost( list ) );

	}

	queue.sort( compareX );

	// process holes from left to right
	for ( i = 0; i < queue.length; i ++ ) {

		eliminateHole( queue[ i ], outerNode );
		outerNode = filterPoints( outerNode, outerNode.next );

	}

	return outerNode;

}

function compareX( a, b ) {

	return a.x - b.x;

}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole( hole, outerNode ) {

	outerNode = findHoleBridge( hole, outerNode );
	if ( outerNode ) {

		const b = splitPolygon( outerNode, hole );

		// filter collinear points around the cuts
		filterPoints( outerNode, outerNode.next );
		filterPoints( b, b.next );

	}

}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge( hole, outerNode ) {

	let p = outerNode;
	const hx = hole.x;
	const hy = hole.y;
	let qx = - Infinity, m;

	// find a segment intersected by a ray from the hole's leftmost point to the left;
	// segment's endpoint with lesser x will be potential connection point
	do {

		if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

			const x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
			if ( x <= hx && x > qx ) {

				qx = x;
				if ( x === hx ) {

					if ( hy === p.y ) return p;
					if ( hy === p.next.y ) return p.next;

				}

				m = p.x < p.next.x ? p : p.next;

			}

		}

		p = p.next;

	} while ( p !== outerNode );

	if ( ! m ) return null;

	if ( hx === qx ) return m; // hole touches outer segment; pick leftmost endpoint

	// look for points inside the triangle of hole point, segment intersection and endpoint;
	// if there are no points found, we have a valid connection;
	// otherwise choose the point of the minimum angle with the ray as connection point

	const stop = m,
		mx = m.x,
		my = m.y;
	let tanMin = Infinity, tan;

	p = m;

	do {

		if ( hx >= p.x && p.x >= mx && hx !== p.x &&
				pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

			tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

			if ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {

				m = p;
				tanMin = tan;

			}

		}

		p = p.next;

	} while ( p !== stop );

	return m;

}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector( m, p ) {

	return area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;

}

// interlink polygon nodes in z-order
function indexCurve( start, minX, minY, invSize ) {

	let p = start;
	do {

		if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
		p.prevZ = p.prev;
		p.nextZ = p.next;
		p = p.next;

	} while ( p !== start );

	p.prevZ.nextZ = null;
	p.prevZ = null;

	sortLinked( p );

}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked( list ) {

	let i, p, q, e, tail, numMerges, pSize, qSize,
		inSize = 1;

	do {

		p = list;
		list = null;
		tail = null;
		numMerges = 0;

		while ( p ) {

			numMerges ++;
			q = p;
			pSize = 0;
			for ( i = 0; i < inSize; i ++ ) {

				pSize ++;
				q = q.nextZ;
				if ( ! q ) break;

			}

			qSize = inSize;

			while ( pSize > 0 || ( qSize > 0 && q ) ) {

				if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

					e = p;
					p = p.nextZ;
					pSize --;

				} else {

					e = q;
					q = q.nextZ;
					qSize --;

				}

				if ( tail ) tail.nextZ = e;
				else list = e;

				e.prevZ = tail;
				tail = e;

			}

			p = q;

		}

		tail.nextZ = null;
		inSize *= 2;

	} while ( numMerges > 1 );

	return list;

}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder( x, y, minX, minY, invSize ) {

	// coords are transformed into non-negative 15-bit integer range
	x = 32767 * ( x - minX ) * invSize;
	y = 32767 * ( y - minY ) * invSize;

	x = ( x | ( x << 8 ) ) & 0x00FF00FF;
	x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
	x = ( x | ( x << 2 ) ) & 0x33333333;
	x = ( x | ( x << 1 ) ) & 0x55555555;

	y = ( y | ( y << 8 ) ) & 0x00FF00FF;
	y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
	y = ( y | ( y << 2 ) ) & 0x33333333;
	y = ( y | ( y << 1 ) ) & 0x55555555;

	return x | ( y << 1 );

}

// find the leftmost node of a polygon ring
function getLeftmost( start ) {

	let p = start,
		leftmost = start;
	do {

		if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
		p = p.next;

	} while ( p !== start );

	return leftmost;

}

// check if a point lies within a convex triangle
function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

	return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
			( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
			( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal( a, b ) {

	return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges
		( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible
		( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors
		equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case

}

// signed area of a triangle
function area( p, q, r ) {

	return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

}

// check if two points are equal
function equals( p1, p2 ) {

	return p1.x === p2.x && p1.y === p2.y;

}

// check if two segments intersect
function intersects( p1, q1, p2, q2 ) {

	const o1 = sign( area( p1, q1, p2 ) );
	const o2 = sign( area( p1, q1, q2 ) );
	const o3 = sign( area( p2, q2, p1 ) );
	const o4 = sign( area( p2, q2, q1 ) );

	if ( o1 !== o2 && o3 !== o4 ) return true; // general case

	if ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
	if ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
	if ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
	if ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

	return false;

}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment( p, q, r ) {

	return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

}

function sign( num ) {

	return num > 0 ? 1 : num < 0 ? - 1 : 0;

}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon( a, b ) {

	let p = a;
	do {

		if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
				intersects( p, p.next, a, b ) ) return true;
		p = p.next;

	} while ( p !== a );

	return false;

}

// check if a polygon diagonal is locally inside the polygon
function locallyInside( a, b ) {

	return area( a.prev, a, a.next ) < 0 ?
		area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
		area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside( a, b ) {

	let p = a,
		inside = false;
	const px = ( a.x + b.x ) / 2,
		py = ( a.y + b.y ) / 2;
	do {

		if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
				( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
			inside = ! inside;
		p = p.next;

	} while ( p !== a );

	return inside;

}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon( a, b ) {

	const a2 = new Node( a.i, a.x, a.y ),
		b2 = new Node( b.i, b.x, b.y ),
		an = a.next,
		bp = b.prev;

	a.next = b;
	b.prev = a;

	a2.next = an;
	an.prev = a2;

	b2.next = a2;
	a2.prev = b2;

	bp.next = b2;
	b2.prev = bp;

	return b2;

}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode( i, x, y, last ) {

	const p = new Node( i, x, y );

	if ( ! last ) {

		p.prev = p;
		p.next = p;

	} else {

		p.next = last.next;
		p.prev = last;
		last.next.prev = p;
		last.next = p;

	}

	return p;

}

function removeNode( p ) {

	p.next.prev = p.prev;
	p.prev.next = p.next;

	if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
	if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

}

function Node( i, x, y ) {

	// vertex index in coordinates array
	this.i = i;

	// vertex coordinates
	this.x = x;
	this.y = y;

	// previous and next vertex nodes in a polygon ring
	this.prev = null;
	this.next = null;

	// z-order curve value
	this.z = null;

	// previous and next nodes in z-order
	this.prevZ = null;
	this.nextZ = null;

	// indicates whether this is a steiner point
	this.steiner = false;

}

function signedArea( data, start, end, dim ) {

	let sum = 0;
	for ( let i = start, j = end - dim; i < end; i += dim ) {

		sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
		j = i;

	}

	return sum;

}

const ShapeUtils = {

	// calculate area of the contour polygon

	area: function ( contour ) {

		const n = contour.length;
		let a = 0.0;

		for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	},

	isClockWise: function ( pts ) {

		return ShapeUtils.area( pts ) < 0;

	},

	triangulateShape: function ( contour, holes ) {

		const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
		const holeIndices = []; // array of hole indices
		const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

		removeDupEndPts( contour );
		addContour( vertices, contour );

		//

		let holeIndex = contour.length;

		holes.forEach( removeDupEndPts );

		for ( let i = 0; i < holes.length; i ++ ) {

			holeIndices.push( holeIndex );
			holeIndex += holes[ i ].length;
			addContour( vertices, holes[ i ] );

		}

		//

		const triangles = Earcut.triangulate( vertices, holeIndices );

		//

		for ( let i = 0; i < triangles.length; i += 3 ) {

			faces.push( triangles.slice( i, i + 3 ) );

		}

		return faces;

	}

};

function removeDupEndPts( points ) {

	const l = points.length;

	if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

		points.pop();

	}

}

function addContour( vertices, contour ) {

	for ( let i = 0; i < contour.length; i ++ ) {

		vertices.push( contour[ i ].x );
		vertices.push( contour[ i ].y );

	}

}

/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */

class ExtrudeGeometry extends BufferGeometry {

	constructor( shapes, options ) {

		super();

		this.type = 'ExtrudeGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		const scope = this;

		const verticesArray = [];
		const uvArray = [];

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];
			addShape( shape );

		}

		// build geometry

		this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

		this.computeVertexNormals();

		// functions

		function addShape( shape ) {

			const placeholder = [];

			// options

			const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			const steps = options.steps !== undefined ? options.steps : 1;
			let depth = options.depth !== undefined ? options.depth : 100;

			let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
			let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
			let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
			let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			const extrudePath = options.extrudePath;

			const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

			// deprecated options

			if ( options.amount !== undefined ) {

				console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
				depth = options.amount;

			}

			//

			let extrudePts, extrudeByPath = false;
			let splineTube, binormal, normal, position2;

			if ( extrudePath ) {

				extrudePts = extrudePath.getSpacedPoints( steps );

				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = extrudePath.computeFrenetFrames( steps, false );

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();

			}

			// Safeguards if bevels are not enabled

			if ( ! bevelEnabled ) {

				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;
				bevelOffset = 0;

			}

			// Variables initialization

			const shapePoints = shape.extractPoints( curveSegments );

			let vertices = shapePoints.shape;
			const holes = shapePoints.holes;

			const reverse = ! ShapeUtils.isClockWise( vertices );

			if ( reverse ) {

				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];

					if ( ShapeUtils.isClockWise( ahole ) ) {

						holes[ h ] = ahole.reverse();

					}

				}

			}


			const faces = ShapeUtils.triangulateShape( vertices, holes );

			/* Vertices */

			const contour = vertices; // vertices has all points but contour has only points of circumference

			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				const ahole = holes[ h ];

				vertices = vertices.concat( ahole );

			}


			function scalePt2( pt, vec, size ) {

				if ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );

				return vec.clone().multiplyScalar( size ).add( pt );

			}

			const vlen = vertices.length, flen = faces.length;


			// Find directions for point movement


			function getBevelVec( inPt, inPrev, inNext ) {

				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.

				let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				const v_prev_x = inPt.x - inPrev.x,
					v_prev_y = inPt.y - inPrev.y;
				const v_next_x = inNext.x - inPt.x,
					v_next_y = inNext.y - inPt.y;

				const v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

				// check for collinear edges
				const collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

					// not collinear

					// length of vectors for normalizing

					const v_prev_len = Math.sqrt( v_prev_lensq );
					const v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

					// shift adjacent points by unit vectors to the left

					const ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					const ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

					const ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					const ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

					// scaling factor for v_prev to intersection point

					const sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
						( v_prev_x * v_next_y - v_prev_y * v_next_x );

					// vector from inPt to intersection point

					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					const v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {

						return new Vector2( v_trans_x, v_trans_y );

					} else {

						shrink_by = Math.sqrt( v_trans_lensq / 2 );

					}

				} else {

					// handle special case of collinear edges

					let direction_eq = false; // assumes: opposite

					if ( v_prev_x > Number.EPSILON ) {

						if ( v_next_x > Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( v_prev_x < - Number.EPSILON ) {

							if ( v_next_x < - Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

								direction_eq = true;

							}

						}

					}

					if ( direction_eq ) {

						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );

					} else {

						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );

					}

				}

				return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

			}


			const contourMovements = [];

			for ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

			}

			const holesMovements = [];
			let oneHoleMovements, verticesMovements = contourMovements.concat();

			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				const ahole = holes[ h ];

				oneHoleMovements = [];

				for ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

				}

				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );

			}


			// Loop bevelSegments, 1 for the front, 1 for the back

			for ( let b = 0; b < bevelSegments; b ++ ) {

				//for ( b = bevelSegments; b > 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				// contract shape

				for ( let i = 0, il = contour.length; i < il; i ++ ) {

					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

					v( vert.x, vert.y, - z );

				}

				// expand holes

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						v( vert.x, vert.y, - z );

					}

				}

			}

			const bs = bevelSize + bevelOffset;

			// Back facing vertices

			for ( let i = 0; i < vlen; i ++ ) {

				const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, 0 );

				} else {

					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

			// Add stepped vertices...
			// Including front facing vertices

			for ( let s = 1; s <= steps; s ++ ) {

				for ( let i = 0; i < vlen; i ++ ) {

					const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, depth / steps * s );

					} else {

						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

			}


			// Add bevel segments planes

			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( let b = bevelSegments - 1; b >= 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				// contract shape

				for ( let i = 0, il = contour.length; i < il; i ++ ) {

					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y, depth + z );

				}

				// expand holes

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y, depth + z );

						} else {

							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

						}

					}

				}

			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();


			/////  Internal functions

			function buildLidFaces() {

				const start = verticesArray.length / 3;

				if ( bevelEnabled ) {

					let layer = 0; // steps + 1
					let offset = vlen * layer;

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

					}

					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

					}

				} else {

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

					}

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

					}

				}

				scope.addGroup( start, verticesArray.length / 3 - start, 0 );

			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {

				const start = verticesArray.length / 3;
				let layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					sidewalls( ahole, layeroffset );

					//, true
					layeroffset += ahole.length;

				}


				scope.addGroup( start, verticesArray.length / 3 - start, 1 );


			}

			function sidewalls( contour, layeroffset ) {

				let i = contour.length;

				while ( -- i >= 0 ) {

					const j = i;
					let k = i - 1;
					if ( k < 0 ) k = contour.length - 1;

					//console.log('b', i,j, i-1, k,vertices.length);

					for ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {

						const slen1 = vlen * s;
						const slen2 = vlen * ( s + 1 );

						const a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;

						f4( a, b, c, d );

					}

				}

			}

			function v( x, y, z ) {

				placeholder.push( x );
				placeholder.push( y );
				placeholder.push( z );

			}


			function f3( a, b, c ) {

				addVertex( a );
				addVertex( b );
				addVertex( c );

				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );

			}

			function f4( a, b, c, d ) {

				addVertex( a );
				addVertex( b );
				addVertex( d );

				addVertex( b );
				addVertex( c );
				addVertex( d );


				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 3 ] );

				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
				addUV( uvs[ 3 ] );

			}

			function addVertex( index ) {

				verticesArray.push( placeholder[ index * 3 + 0 ] );
				verticesArray.push( placeholder[ index * 3 + 1 ] );
				verticesArray.push( placeholder[ index * 3 + 2 ] );

			}


			function addUV( vector2 ) {

				uvArray.push( vector2.x );
				uvArray.push( vector2.y );

			}

		}

	}

	toJSON() {

		const data = BufferGeometry.prototype.toJSON.call( this );

		const shapes = this.parameters.shapes;
		const options = this.parameters.options;

		return toJSON$1( shapes, options, data );

	}

}

const WorldUVGenerator = {

	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];

		return [
			new Vector2( a_x, a_y ),
			new Vector2( b_x, b_y ),
			new Vector2( c_x, c_y )
		];

	},

	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const a_z = vertices[ indexA * 3 + 2 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const b_z = vertices[ indexB * 3 + 2 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];
		const c_z = vertices[ indexC * 3 + 2 ];
		const d_x = vertices[ indexD * 3 ];
		const d_y = vertices[ indexD * 3 + 1 ];
		const d_z = vertices[ indexD * 3 + 2 ];

		if ( Math.abs( a_y - b_y ) < 0.01 ) {

			return [
				new Vector2( a_x, 1 - a_z ),
				new Vector2( b_x, 1 - b_z ),
				new Vector2( c_x, 1 - c_z ),
				new Vector2( d_x, 1 - d_z )
			];

		} else {

			return [
				new Vector2( a_y, 1 - a_z ),
				new Vector2( b_y, 1 - b_z ),
				new Vector2( c_y, 1 - c_z ),
				new Vector2( d_y, 1 - d_z )
			];

		}

	}

};

function toJSON$1( shapes, options, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

	return data;

}

class IcosahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;

		const vertices = [
			- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
			0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
			t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
		];

		const indices = [
			0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

}

class LatheGeometry extends BufferGeometry {

	constructor( points, segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {

		super();

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = Math.floor( segments );

		// clamp phiLength so it's in range of [ 0, 2PI ]

		phiLength = MathUtils.clamp( phiLength, 0, Math.PI * 2 );

		// buffers

		const indices = [];
		const vertices = [];
		const uvs = [];

		// helper variables

		const inverseSegments = 1.0 / segments;
		const vertex = new Vector3();
		const uv = new Vector2();

		// generate vertices and uvs

		for ( let i = 0; i <= segments; i ++ ) {

			const phi = phiStart + i * inverseSegments * phiLength;

			const sin = Math.sin( phi );
			const cos = Math.cos( phi );

			for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

				// vertex

				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;

				vertices.push( vertex.x, vertex.y, vertex.z );

				// uv

				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );

				uvs.push( uv.x, uv.y );


			}

		}

		// indices

		for ( let i = 0; i < segments; i ++ ) {

			for ( let j = 0; j < ( points.length - 1 ); j ++ ) {

				const base = j + i * points.length;

				const a = base;
				const b = base + points.length;
				const c = base + points.length + 1;
				const d = base + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// generate normals

		this.computeVertexNormals();

		// if the geometry is closed, we need to average the normals along the seam.
		// because the corresponding vertices are identical (but still have different UVs).

		if ( phiLength === Math.PI * 2 ) {

			const normals = this.attributes.normal.array;
			const n1 = new Vector3();
			const n2 = new Vector3();
			const n = new Vector3();

			// this is the buffer offset for the last line of vertices

			const base = segments * points.length * 3;

			for ( let i = 0, j = 0; i < points.length; i ++, j += 3 ) {

				// select the normal of the vertex in the first line

				n1.x = normals[ j + 0 ];
				n1.y = normals[ j + 1 ];
				n1.z = normals[ j + 2 ];

				// select the normal of the vertex in the last line

				n2.x = normals[ base + j + 0 ];
				n2.y = normals[ base + j + 1 ];
				n2.z = normals[ base + j + 2 ];

				// average normals

				n.addVectors( n1, n2 ).normalize();

				// assign the new values to both normals

				normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
				normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
				normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

			}

		}

	}

}

class OctahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
		];

		const indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];

		super( vertices, indices, radius, detail );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

}

/**
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */

function ParametricGeometry( func, slices, stacks ) {

	BufferGeometry.call( this );

	this.type = 'ParametricGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	// buffers

	const indices = [];
	const vertices = [];
	const normals = [];
	const uvs = [];

	const EPS = 0.00001;

	const normal = new Vector3();

	const p0 = new Vector3(), p1 = new Vector3();
	const pu = new Vector3(), pv = new Vector3();

	if ( func.length < 3 ) {

		console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );

	}

	// generate vertices, normals and uvs

	const sliceCount = slices + 1;

	for ( let i = 0; i <= stacks; i ++ ) {

		const v = i / stacks;

		for ( let j = 0; j <= slices; j ++ ) {

			const u = j / slices;

			// vertex

			func( u, v, p0 );
			vertices.push( p0.x, p0.y, p0.z );

			// normal

			// approximate tangent vectors via finite differences

			if ( u - EPS >= 0 ) {

				func( u - EPS, v, p1 );
				pu.subVectors( p0, p1 );

			} else {

				func( u + EPS, v, p1 );
				pu.subVectors( p1, p0 );

			}

			if ( v - EPS >= 0 ) {

				func( u, v - EPS, p1 );
				pv.subVectors( p0, p1 );

			} else {

				func( u, v + EPS, p1 );
				pv.subVectors( p1, p0 );

			}

			// cross product of tangent vectors returns surface normal

			normal.crossVectors( pu, pv ).normalize();
			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( u, v );

		}

	}

	// generate indices

	for ( let i = 0; i < stacks; i ++ ) {

		for ( let j = 0; j < slices; j ++ ) {

			const a = i * sliceCount + j;
			const b = i * sliceCount + j + 1;
			const c = ( i + 1 ) * sliceCount + j + 1;
			const d = ( i + 1 ) * sliceCount + j;

			// faces one and two

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

ParametricGeometry.prototype = Object.create( BufferGeometry.prototype );
ParametricGeometry.prototype.constructor = ParametricGeometry;

class RingGeometry extends BufferGeometry {

	constructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		thetaSegments = Math.max( 3, thetaSegments );
		phiSegments = Math.max( 1, phiSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// some helper variables

		let radius = innerRadius;
		const radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		const vertex = new Vector3();
		const uv = new Vector2();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= phiSegments; j ++ ) {

			for ( let i = 0; i <= thetaSegments; i ++ ) {

				// values are generate from the inside of the ring to the outside

				const segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uv

				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// increase the radius for next row of vertices

			radius += radiusStep;

		}

		// indices

		for ( let j = 0; j < phiSegments; j ++ ) {

			const thetaSegmentLevel = j * ( thetaSegments + 1 );

			for ( let i = 0; i < thetaSegments; i ++ ) {

				const segment = i + thetaSegmentLevel;

				const a = segment;
				const b = segment + thetaSegments + 1;
				const c = segment + thetaSegments + 2;
				const d = segment + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

}

class ShapeGeometry extends BufferGeometry {

	constructor( shapes, curveSegments = 12 ) {

		super();
		this.type = 'ShapeGeometry';

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let groupStart = 0;
		let groupCount = 0;

		// allow single and array values for "shapes" parameter

		if ( Array.isArray( shapes ) === false ) {

			addShape( shapes );

		} else {

			for ( let i = 0; i < shapes.length; i ++ ) {

				addShape( shapes[ i ] );

				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

				groupStart += groupCount;
				groupCount = 0;

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


		// helper functions

		function addShape( shape ) {

			const indexOffset = vertices.length / 3;
			const points = shape.extractPoints( curveSegments );

			let shapeVertices = points.shape;
			const shapeHoles = points.holes;

			// check direction of vertices

			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

				shapeVertices = shapeVertices.reverse();

			}

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];

				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

					shapeHoles[ i ] = shapeHole.reverse();

				}

			}

			const faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

			// join vertices of inner and outer paths to a single array

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];
				shapeVertices = shapeVertices.concat( shapeHole );

			}

			// vertices, normals, uvs

			for ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {

				const vertex = shapeVertices[ i ];

				vertices.push( vertex.x, vertex.y, 0 );
				normals.push( 0, 0, 1 );
				uvs.push( vertex.x, vertex.y ); // world uvs

			}

			// incides

			for ( let i = 0, l = faces.length; i < l; i ++ ) {

				const face = faces[ i ];

				const a = face[ 0 ] + indexOffset;
				const b = face[ 1 ] + indexOffset;
				const c = face[ 2 ] + indexOffset;

				indices.push( a, b, c );
				groupCount += 3;

			}

		}

	}

	toJSON() {

		const data = BufferGeometry.prototype.toJSON.call( this );

		const shapes = this.parameters.shapes;

		return toJSON( shapes, data );

	}

}

function toJSON( shapes, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	return data;

}

class SphereGeometry extends BufferGeometry {

	constructor( radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

		super();
		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		widthSegments = Math.max( 3, Math.floor( widthSegments ) );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) );

		const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

		let index = 0;
		const grid = [];

		const vertex = new Vector3();
		const normal = new Vector3();

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// generate vertices, normals and uvs

		for ( let iy = 0; iy <= heightSegments; iy ++ ) {

			const verticesRow = [];

			const v = iy / heightSegments;

			// special case for the poles

			let uOffset = 0;

			if ( iy == 0 && thetaStart == 0 ) {

				uOffset = 0.5 / widthSegments;

			} else if ( iy == heightSegments && thetaEnd == Math.PI ) {

				uOffset = - 0.5 / widthSegments;

			}

			for ( let ix = 0; ix <= widthSegments; ix ++ ) {

				const u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.copy( vertex ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u + uOffset, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( let iy = 0; iy < heightSegments; iy ++ ) {

			for ( let ix = 0; ix < widthSegments; ix ++ ) {

				const a = grid[ iy ][ ix + 1 ];
				const b = grid[ iy ][ ix ];
				const c = grid[ iy + 1 ][ ix ];
				const d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

}

class TetrahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
		];

		const indices = [
			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

}

/**
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */

class TextGeometry extends ExtrudeGeometry {

	constructor( text, parameters = {} ) {

		const font = parameters.font;

		if ( ! ( font && font.isFont ) ) {

			console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
			return new BufferGeometry();

		}

		const shapes = font.generateShapes( text, parameters.size );

		// translate parameters to ExtrudeGeometry API

		parameters.depth = parameters.height !== undefined ? parameters.height : 50;

		// defaults

		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

		super( shapes, parameters );

		this.type = 'TextGeometry';

	}

}

class TorusGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2 ) {

		super();
		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radialSegments = Math.floor( radialSegments );
		tubularSegments = Math.floor( tubularSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const center = new Vector3();
		const vertex = new Vector3();
		const normal = new Vector3();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= radialSegments; j ++ ) {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				const u = i / tubularSegments * arc;
				const v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= radialSegments; j ++ ) {

			for ( let i = 1; i <= tubularSegments; i ++ ) {

				// indices

				const a = ( tubularSegments + 1 ) * j + i - 1;
				const b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				const c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				const d = ( tubularSegments + 1 ) * j + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

}

class TorusKnotGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {

		super();
		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		tubularSegments = Math.floor( tubularSegments );
		radialSegments = Math.floor( radialSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();

		const P1 = new Vector3();
		const P2 = new Vector3();

		const B = new Vector3();
		const T = new Vector3();
		const N = new Vector3();

		// generate vertices, normals and uvs

		for ( let i = 0; i <= tubularSegments; ++ i ) {

			// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

			const u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

			// calculate orthonormal basis

			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for ( let j = 0; j <= radialSegments; ++ j ) {

				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				const v = j / radialSegments * Math.PI * 2;
				const cx = - tube * Math.cos( v );
				const cy = tube * Math.sin( v );

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors( vertex, P1 ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= tubularSegments; j ++ ) {

			for ( let i = 1; i <= radialSegments; i ++ ) {

				// indices

				const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				const b = ( radialSegments + 1 ) * j + ( i - 1 );
				const c = ( radialSegments + 1 ) * j + i;
				const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve( u, p, q, radius, position ) {

			const cu = Math.cos( u );
			const su = Math.sin( u );
			const quOverP = q / p * u;
			const cs = Math.cos( quOverP );

			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;

		}

	}

}

class TubeGeometry extends BufferGeometry {

	constructor( path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {

		super();
		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		const frames = path.computeFrenetFrames( tubularSegments, closed );

		// expose internals

		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();
		const uv = new Vector2();
		let P = new Vector3();

		// buffer

		const vertices = [];
		const normals = [];
		const uvs = [];
		const indices = [];

		// create buffer data

		generateBufferData();

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// functions

		function generateBufferData() {

			for ( let i = 0; i < tubularSegments; i ++ ) {

				generateSegment( i );

			}

			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

			generateSegment( ( closed === false ) ? tubularSegments : 0 );

			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries

			generateUVs();

			// finally create faces

			generateIndices();

		}

		function generateSegment( i ) {

			// we use getPointAt to sample evenly distributed points from the given path

			P = path.getPointAt( i / tubularSegments, P );

			// retrieve corresponding normal and binormal

			const N = frames.normals[ i ];
			const B = frames.binormals[ i ];

			// generate normals and vertices for the current segment

			for ( let j = 0; j <= radialSegments; j ++ ) {

				const v = j / radialSegments * Math.PI * 2;

				const sin = Math.sin( v );
				const cos = - Math.cos( v );

				// normal

				normal.x = ( cos * N.x + sin * B.x );
				normal.y = ( cos * N.y + sin * B.y );
				normal.z = ( cos * N.z + sin * B.z );
				normal.normalize();

				normals.push( normal.x, normal.y, normal.z );

				// vertex

				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;

				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		function generateIndices() {

			for ( let j = 1; j <= tubularSegments; j ++ ) {

				for ( let i = 1; i <= radialSegments; i ++ ) {

					const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					const b = ( radialSegments + 1 ) * j + ( i - 1 );
					const c = ( radialSegments + 1 ) * j + i;
					const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

		}

		function generateUVs() {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				for ( let j = 0; j <= radialSegments; j ++ ) {

					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;

					uvs.push( uv.x, uv.y );

				}

			}

		}

	}
	toJSON() {

		const data = BufferGeometry.prototype.toJSON.call( this );

		data.path = this.parameters.path.toJSON();

		return data;

	}

}

class WireframeGeometry extends BufferGeometry {

	constructor( geometry ) {

		super();
		this.type = 'WireframeGeometry';

		if ( geometry.isGeometry === true ) {

			console.error( 'THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );
			return;

		}

		// buffer

		const vertices = [];

		// helper variables

		const edge = [ 0, 0 ], edges = {};

		const vertex = new Vector3();

		if ( geometry.index !== null ) {

			// indexed BufferGeometry

			const position = geometry.attributes.position;
			const indices = geometry.index;
			let groups = geometry.groups;

			if ( groups.length === 0 ) {

				groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

			}

			// create a data structure that contains all eges without duplicates

			for ( let o = 0, ol = groups.length; o < ol; ++ o ) {

				const group = groups[ o ];

				const start = group.start;
				const count = group.count;

				for ( let i = start, l = ( start + count ); i < l; i += 3 ) {

					for ( let j = 0; j < 3; j ++ ) {

						const edge1 = indices.getX( i + j );
						const edge2 = indices.getX( i + ( j + 1 ) % 3 );
						edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
						edge[ 1 ] = Math.max( edge1, edge2 );

						const key = edge[ 0 ] + ',' + edge[ 1 ];

						if ( edges[ key ] === undefined ) {

							edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

						}

					}

				}

			}

			// generate vertices

			for ( const key in edges ) {

				const e = edges[ key ];

				vertex.fromBufferAttribute( position, e.index1 );
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex.fromBufferAttribute( position, e.index2 );
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		} else {

			// non-indexed BufferGeometry

			const position = geometry.attributes.position;

			for ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

				for ( let j = 0; j < 3; j ++ ) {

					// three edges per triangle, an edge is represented as (index1, index2)
					// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

					const index1 = 3 * i + j;
					vertex.fromBufferAttribute( position, index1 );
					vertices.push( vertex.x, vertex.y, vertex.z );

					const index2 = 3 * i + ( ( j + 1 ) % 3 );
					vertex.fromBufferAttribute( position, index2 );
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			}

		}

		// build geometry

		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	}

}

var Geometries = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BoxGeometry: BoxGeometry,
	BoxBufferGeometry: BoxGeometry,
	CircleGeometry: CircleGeometry,
	CircleBufferGeometry: CircleGeometry,
	ConeGeometry: ConeGeometry,
	ConeBufferGeometry: ConeGeometry,
	CylinderGeometry: CylinderGeometry,
	CylinderBufferGeometry: CylinderGeometry,
	DodecahedronGeometry: DodecahedronGeometry,
	DodecahedronBufferGeometry: DodecahedronGeometry,
	EdgesGeometry: EdgesGeometry,
	ExtrudeGeometry: ExtrudeGeometry,
	ExtrudeBufferGeometry: ExtrudeGeometry,
	IcosahedronGeometry: IcosahedronGeometry,
	IcosahedronBufferGeometry: IcosahedronGeometry,
	LatheGeometry: LatheGeometry,
	LatheBufferGeometry: LatheGeometry,
	OctahedronGeometry: OctahedronGeometry,
	OctahedronBufferGeometry: OctahedronGeometry,
	ParametricGeometry: ParametricGeometry,
	ParametricBufferGeometry: ParametricGeometry,
	PlaneGeometry: PlaneGeometry,
	PlaneBufferGeometry: PlaneGeometry,
	PolyhedronGeometry: PolyhedronGeometry,
	PolyhedronBufferGeometry: PolyhedronGeometry,
	RingGeometry: RingGeometry,
	RingBufferGeometry: RingGeometry,
	ShapeGeometry: ShapeGeometry,
	ShapeBufferGeometry: ShapeGeometry,
	SphereGeometry: SphereGeometry,
	SphereBufferGeometry: SphereGeometry,
	TetrahedronGeometry: TetrahedronGeometry,
	TetrahedronBufferGeometry: TetrahedronGeometry,
	TextGeometry: TextGeometry,
	TextBufferGeometry: TextGeometry,
	TorusGeometry: TorusGeometry,
	TorusBufferGeometry: TorusGeometry,
	TorusKnotGeometry: TorusKnotGeometry,
	TorusKnotBufferGeometry: TorusKnotGeometry,
	TubeGeometry: TubeGeometry,
	TubeBufferGeometry: TubeGeometry,
	WireframeGeometry: WireframeGeometry
});

/**
 * parameters = {
 *  color: <THREE.Color>
 * }
 */

class ShadowMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'ShadowMaterial';

		this.color = new Color( 0x000000 );
		this.transparent = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		return this;

	}

}

ShadowMaterial.prototype.isShadowMaterial = true;

class RawShaderMaterial extends ShaderMaterial {

	constructor( parameters ) {

		super( parameters );

		this.type = 'RawShaderMaterial';

	}

}

RawShaderMaterial.prototype.isRawShaderMaterial = true;

/**
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  flatShading: <bool>
 * }
 */

function MeshStandardMaterial( parameters ) {

	Material.call( this );

	this.defines = { 'STANDARD': '' };

	this.type = 'MeshStandardMaterial';

	this.color = new Color( 0xffffff ); // diffuse
	this.roughness = 1.0;
	this.metalness = 0.0;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalMapType = TangentSpaceNormalMap;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.roughnessMap = null;

	this.metalnessMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.envMapIntensity = 1.0;

	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.flatShading = false;

	this.vertexTangents = false;

	this.setValues( parameters );

}

MeshStandardMaterial.prototype = Object.create( Material.prototype );
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

MeshStandardMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.defines = { 'STANDARD': '' };

	this.color.copy( source.color );
	this.roughness = source.roughness;
	this.metalness = source.metalness;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalMapType = source.normalMapType;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.roughnessMap = source.roughnessMap;

	this.metalnessMap = source.metalnessMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.envMapIntensity = source.envMapIntensity;

	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.flatShading = source.flatShading;

	this.vertexTangents = source.vertexTangents;

	return this;

};

/**
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  reflectivity: <float>,
 *  ior: <float>,
 *
 *  sheen: <Color>,
 *
 *  transmission: <float>,
 *  transmissionMap: new THREE.Texture( <Image> )
 * }
 */

function MeshPhysicalMaterial( parameters ) {

	MeshStandardMaterial.call( this );

	this.defines = {

		'STANDARD': '',
		'PHYSICAL': ''

	};

	this.type = 'MeshPhysicalMaterial';

	this.clearcoat = 0.0;
	this.clearcoatMap = null;
	this.clearcoatRoughness = 0.0;
	this.clearcoatRoughnessMap = null;
	this.clearcoatNormalScale = new Vector2( 1, 1 );
	this.clearcoatNormalMap = null;

	this.reflectivity = 0.5; // maps to F0 = 0.04

	Object.defineProperty( this, 'ior', {
		get: function () {

			return ( 1 + 0.4 * this.reflectivity ) / ( 1 - 0.4 * this.reflectivity );

		},
		set: function ( ior ) {

			this.reflectivity = MathUtils.clamp( 2.5 * ( ior - 1 ) / ( ior + 1 ), 0, 1 );

		}
	} );

	this.sheen = null; // null will disable sheen bsdf

	this.transmission = 0.0;
	this.transmissionMap = null;

	this.setValues( parameters );

}

MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

MeshPhysicalMaterial.prototype.copy = function ( source ) {

	MeshStandardMaterial.prototype.copy.call( this, source );

	this.defines = {

		'STANDARD': '',
		'PHYSICAL': ''

	};

	this.clearcoat = source.clearcoat;
	this.clearcoatMap = source.clearcoatMap;
	this.clearcoatRoughness = source.clearcoatRoughness;
	this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
	this.clearcoatNormalMap = source.clearcoatNormalMap;
	this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

	this.reflectivity = source.reflectivity;

	if ( source.sheen ) {

		this.sheen = ( this.sheen || new Color() ).copy( source.sheen );

	} else {

		this.sheen = null;

	}

	this.transmission = source.transmission;
	this.transmissionMap = source.transmissionMap;

	return this;

};

/**
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  flatShading: <bool>
 * }
 */

class MeshPhongMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshPhongMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.specular = new Color( 0x111111 );
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.flatShading = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.flatShading = source.flatShading;

		return this;

	}

}

MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

/**
 * parameters = {
 *  color: <hex>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

class MeshToonMaterial extends Material {

	constructor( parameters ) {

		super();

		this.defines = { 'TOON': '' };

		this.type = 'MeshToonMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;
		this.gradientMap = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;
		this.gradientMap = source.gradientMap;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	}

}

MeshToonMaterial.prototype.isMeshToonMaterial = true;

/**
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  flatShading: <bool>
 * }
 */

class MeshNormalMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshNormalMaterial';

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.flatShading = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.flatShading = source.flatShading;

		return this;

	}

}

MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

class MeshLambertMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshLambertMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	}

}

MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 *
 *  flatShading: <bool>
 * }
 */

class MeshMatcapMaterial extends Material {

	constructor( parameters ) {

		super();

		this.defines = { 'MATCAP': '' };

		this.type = 'MeshMatcapMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.matcap = null;

		this.map = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.flatShading = false;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.defines = { 'MATCAP': '' };

		this.color.copy( source.color );

		this.matcap = source.matcap;

		this.map = source.map;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.flatShading = source.flatShading;

		return this;

	}

}

MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */

class LineDashedMaterial extends LineBasicMaterial {

	constructor( parameters ) {

		super();

		this.type = 'LineDashedMaterial';

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		return this;

	}

}

LineDashedMaterial.prototype.isLineDashedMaterial = true;

var Materials = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ShadowMaterial: ShadowMaterial,
	SpriteMaterial: SpriteMaterial,
	RawShaderMaterial: RawShaderMaterial,
	ShaderMaterial: ShaderMaterial,
	PointsMaterial: PointsMaterial,
	MeshPhysicalMaterial: MeshPhysicalMaterial,
	MeshStandardMaterial: MeshStandardMaterial,
	MeshPhongMaterial: MeshPhongMaterial,
	MeshToonMaterial: MeshToonMaterial,
	MeshNormalMaterial: MeshNormalMaterial,
	MeshLambertMaterial: MeshLambertMaterial,
	MeshDepthMaterial: MeshDepthMaterial,
	MeshDistanceMaterial: MeshDistanceMaterial,
	MeshBasicMaterial: MeshBasicMaterial,
	MeshMatcapMaterial: MeshMatcapMaterial,
	LineDashedMaterial: LineDashedMaterial,
	LineBasicMaterial: LineBasicMaterial,
	Material: Material
});

const AnimationUtils = {

	// same as Array.prototype.slice, but also works on typed arrays
	arraySlice: function ( array, from, to ) {

		if ( AnimationUtils.isTypedArray( array ) ) {

			// in ios9 array.subarray(from, undefined) will return empty array
			// but array.subarray(from) or array.subarray(from, len) is correct
			return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

		}

		return array.slice( from, to );

	},

	// converts an array to a specific type
	convertArray: function ( array, type, forceClone ) {

		if ( ! array || // let 'undefined' and 'null' pass
			! forceClone && array.constructor === type ) return array;

		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

			return new type( array ); // create typed array

		}

		return Array.prototype.slice.call( array ); // create Array

	},

	isTypedArray: function ( object ) {

		return ArrayBuffer.isView( object ) &&
			! ( object instanceof DataView );

	},

	// returns an array by which times and values can be sorted
	getKeyframeOrder: function ( times ) {

		function compareTime( i, j ) {

			return times[ i ] - times[ j ];

		}

		const n = times.length;
		const result = new Array( n );
		for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

		result.sort( compareTime );

		return result;

	},

	// uses the array previously returned by 'getKeyframeOrder' to sort data
	sortedArray: function ( values, stride, order ) {

		const nValues = values.length;
		const result = new values.constructor( nValues );

		for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

			const srcOffset = order[ i ] * stride;

			for ( let j = 0; j !== stride; ++ j ) {

				result[ dstOffset ++ ] = values[ srcOffset + j ];

			}

		}

		return result;

	},

	// function for parsing AOS keyframe formats
	flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

		let i = 1, key = jsonKeys[ 0 ];

		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

			key = jsonKeys[ i ++ ];

		}

		if ( key === undefined ) return; // no data

		let value = key[ valuePropertyName ];
		if ( value === undefined ) return; // no data

		if ( Array.isArray( value ) ) {

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push.apply( values, value ); // push all elements

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else if ( value.toArray !== undefined ) {

			// ...assume THREE.Math-ish

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					value.toArray( values, values.length );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else {

			// otherwise push as-is

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push( value );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		}

	},

	subclip: function ( sourceClip, name, startFrame, endFrame, fps = 30 ) {

		const clip = sourceClip.clone();

		clip.name = name;

		const tracks = [];

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			const track = clip.tracks[ i ];
			const valueSize = track.getValueSize();

			const times = [];
			const values = [];

			for ( let j = 0; j < track.times.length; ++ j ) {

				const frame = track.times[ j ] * fps;

				if ( frame < startFrame || frame >= endFrame ) continue;

				times.push( track.times[ j ] );

				for ( let k = 0; k < valueSize; ++ k ) {

					values.push( track.values[ j * valueSize + k ] );

				}

			}

			if ( times.length === 0 ) continue;

			track.times = AnimationUtils.convertArray( times, track.times.constructor );
			track.values = AnimationUtils.convertArray( values, track.values.constructor );

			tracks.push( track );

		}

		clip.tracks = tracks;

		// find minimum .times value across all tracks in the trimmed clip

		let minStartTime = Infinity;

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

				minStartTime = clip.tracks[ i ].times[ 0 ];

			}

		}

		// shift all tracks such that clip begins at t=0

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			clip.tracks[ i ].shift( - 1 * minStartTime );

		}

		clip.resetDuration();

		return clip;

	},

	makeClipAdditive: function ( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {

		if ( fps <= 0 ) fps = 30;

		const numTracks = referenceClip.tracks.length;
		const referenceTime = referenceFrame / fps;

		// Make each track's values relative to the values at the reference frame
		for ( let i = 0; i < numTracks; ++ i ) {

			const referenceTrack = referenceClip.tracks[ i ];
			const referenceTrackType = referenceTrack.ValueTypeName;

			// Skip this track if it's non-numeric
			if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;

			// Find the track in the target clip whose name and type matches the reference track
			const targetTrack = targetClip.tracks.find( function ( track ) {

				return track.name === referenceTrack.name
					&& track.ValueTypeName === referenceTrackType;

			} );

			if ( targetTrack === undefined ) continue;

			let referenceOffset = 0;
			const referenceValueSize = referenceTrack.getValueSize();

			if ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				referenceOffset = referenceValueSize / 3;

			}

			let targetOffset = 0;
			const targetValueSize = targetTrack.getValueSize();

			if ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				targetOffset = targetValueSize / 3;

			}

			const lastIndex = referenceTrack.times.length - 1;
			let referenceValue;

			// Find the value to subtract out of the track
			if ( referenceTime <= referenceTrack.times[ 0 ] ) {

				// Reference frame is earlier than the first keyframe, so just use the first keyframe
				const startIndex = referenceOffset;
				const endIndex = referenceValueSize - referenceOffset;
				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

			} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

				// Reference frame is after the last keyframe, so just use the last keyframe
				const startIndex = lastIndex * referenceValueSize + referenceOffset;
				const endIndex = startIndex + referenceValueSize - referenceOffset;
				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

			} else {

				// Interpolate to the reference value
				const interpolant = referenceTrack.createInterpolant();
				const startIndex = referenceOffset;
				const endIndex = referenceValueSize - referenceOffset;
				interpolant.evaluate( referenceTime );
				referenceValue = AnimationUtils.arraySlice( interpolant.resultBuffer, startIndex, endIndex );

			}

			// Conjugate the quaternion
			if ( referenceTrackType === 'quaternion' ) {

				const referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();
				referenceQuat.toArray( referenceValue );

			}

			// Subtract the reference value from all of the track values

			const numTimes = targetTrack.times.length;
			for ( let j = 0; j < numTimes; ++ j ) {

				const valueStart = j * targetValueSize + targetOffset;

				if ( referenceTrackType === 'quaternion' ) {

					// Multiply the conjugate for quaternion track types
					Quaternion.multiplyQuaternionsFlat(
						targetTrack.values,
						valueStart,
						referenceValue,
						0,
						targetTrack.values,
						valueStart
					);

				} else {

					const valueEnd = targetValueSize - targetOffset * 2;

					// Subtract each value for all other numeric track types
					for ( let k = 0; k < valueEnd; ++ k ) {

						targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

					}

				}

			}

		}

		targetClip.blendMode = AdditiveAnimationBlendMode;

		return targetClip;

	}

};

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */

function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	this.parameterPositions = parameterPositions;
	this._cachedIndex = 0;

	this.resultBuffer = resultBuffer !== undefined ?
		resultBuffer : new sampleValues.constructor( sampleSize );
	this.sampleValues = sampleValues;
	this.valueSize = sampleSize;

}

Object.assign( Interpolant.prototype, {

	evaluate: function ( t ) {

		const pp = this.parameterPositions;
		let i1 = this._cachedIndex,
			t1 = pp[ i1 ],
			t0 = pp[ i1 - 1 ];

		validate_interval: {

			seek: {

				let right;

				linear_scan: {

					//- See http://jsperf.com/comparison-to-undefined/3
					//- slower code:
					//-
					//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if ( ! ( t < t1 ) ) {

						for ( let giveUpAt = i1 + 2; ; ) {

							if ( t1 === undefined ) {

								if ( t < t0 ) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.afterEnd_( i1 - 1, t, t0 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t0 = t1;
							t1 = pp[ ++ i1 ];

							if ( t < t1 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;

					}

					//- slower code:
					//-					if ( t < t0 || t0 === undefined ) {
					if ( ! ( t >= t0 ) ) {

						// looping?

						const t1global = pp[ 1 ];

						if ( t < t1global ) {

							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;

						}

						// linear reverse scan

						for ( let giveUpAt = i1 - 2; ; ) {

							if ( t0 === undefined ) {

								// before start

								this._cachedIndex = 0;
								return this.beforeStart_( 0, t, t1 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t1 = t0;
							t0 = pp[ -- i1 - 1 ];

							if ( t >= t0 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;

					}

					// the interval is valid

					break validate_interval;

				} // linear scan

				// binary search

				while ( i1 < right ) {

					const mid = ( i1 + right ) >>> 1;

					if ( t < pp[ mid ] ) {

						right = mid;

					} else {

						i1 = mid + 1;

					}

				}

				t1 = pp[ i1 ];
				t0 = pp[ i1 - 1 ];

				// check boundary cases, again

				if ( t0 === undefined ) {

					this._cachedIndex = 0;
					return this.beforeStart_( 0, t, t1 );

				}

				if ( t1 === undefined ) {

					i1 = pp.length;
					this._cachedIndex = i1;
					return this.afterEnd_( i1 - 1, t0, t );

				}

			} // seek

			this._cachedIndex = i1;

			this.intervalChanged_( i1, t0, t1 );

		} // validate_interval

		return this.interpolate_( i1, t0, t, t1 );

	},

	settings: null, // optional, subclass-specific settings structure
	// Note: The indirection allows central control of many interpolants.

	// --- Protected interface

	DefaultSettings_: {},

	getSettings_: function () {

		return this.settings || this.DefaultSettings_;

	},

	copySampleValue_: function ( index ) {

		// copies a sample value to the result buffer

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	},

	// Template methods for derived classes:

	interpolate_: function ( /* i1, t0, t, t1 */ ) {

		throw new Error( 'call to abstract method' );
		// implementations shall return this.resultBuffer

	},

	intervalChanged_: function ( /* i1, t0, t1 */ ) {

		// empty

	}

} );

// DECLARE ALIAS AFTER assign prototype
Object.assign( Interpolant.prototype, {

	//( 0, t, t0 ), returns this.resultBuffer
	beforeStart_: Interpolant.prototype.copySampleValue_,

	//( N-1, tN-1, t ), returns this.resultBuffer
	afterEnd_: Interpolant.prototype.copySampleValue_,

} );

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */

function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	this._weightPrev = - 0;
	this._offsetPrev = - 0;
	this._weightNext = - 0;
	this._offsetNext = - 0;

}

CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: CubicInterpolant,

	DefaultSettings_: {

		endingStart: ZeroCurvatureEnding,
		endingEnd: ZeroCurvatureEnding

	},

	intervalChanged_: function ( i1, t0, t1 ) {

		const pp = this.parameterPositions;
		let iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		const halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	},

	interpolate_: function ( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		const sP = - wP * ppp + 2 * wP * pp - wP * p;
		const s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
		const s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
		const sN = wN * ppp - wN * pp;

		// combine data linearly

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

} );

function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: LinearInterpolant,

	interpolate_: function ( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

} );

/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 */

function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: DiscreteInterpolant,

	interpolate_: function ( i1 /*, t0, t, t1 */ ) {

		return this.copySampleValue_( i1 - 1 );

	}

} );

class KeyframeTrack {

	constructor( name, times, values, interpolation ) {

		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

		this.name = name;

		this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
		this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

		this.setInterpolation( interpolation || this.DefaultInterpolation );

	}

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	static toJSON( track ) {

		const trackType = track.constructor;

		let json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== this.toJSON ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': AnimationUtils.convertArray( track.times, Array ),
				'values': AnimationUtils.convertArray( track.values, Array )

			};

			const interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	}

	InterpolantFactoryMethodDiscrete( result ) {

		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodLinear( result ) {

		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodSmooth( result ) {

		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	setInterpolation( interpolation ) {

		let factoryMethod;

		switch ( interpolation ) {

			case InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			const message = 'unsupported interpolation for ' +
				this.ValueTypeName + ' keyframe track named ' + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( 'THREE.KeyframeTrack:', message );
			return this;

		}

		this.createInterpolant = factoryMethod;

		return this;

	}

	getInterpolation() {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return InterpolateSmooth;

		}

	}

	getValueSize() {

		return this.values.length / this.times.length;

	}

	// move all keyframes either forwards or backwards in time
	shift( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	}

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale( timeScale ) {

		if ( timeScale !== 1.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	}

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim( startTime, endTime ) {

		const times = this.times,
			nKeys = times.length;

		let from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) {

			++ from;

		}

		while ( to !== - 1 && times[ to ] > endTime ) {

			-- to;

		}

		++ to; // inclusive -> exclusive bound

		if ( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) {

				to = Math.max( to, 1 );
				from = to - 1;

			}

			const stride = this.getValueSize();
			this.times = AnimationUtils.arraySlice( times, from, to );
			this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

		}

		return this;

	}

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate() {

		let valid = true;

		const valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
			valid = false;

		}

		const times = this.times,
			values = this.values,

			nKeys = times.length;

		if ( nKeys === 0 ) {

			console.error( 'THREE.KeyframeTrack: Track is empty.', this );
			valid = false;

		}

		let prevTime = null;

		for ( let i = 0; i !== nKeys; i ++ ) {

			const currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
				valid = false;
				break;

			}

			if ( prevTime !== null && prevTime > currTime ) {

				console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( AnimationUtils.isTypedArray( values ) ) {

				for ( let i = 0, n = values.length; i !== n; ++ i ) {

					const value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	}

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize() {

		// times or values may be shared with other tracks, so overwriting is unsafe
		const times = AnimationUtils.arraySlice( this.times ),
			values = AnimationUtils.arraySlice( this.values ),
			stride = this.getValueSize(),

			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

			lastIndex = times.length - 1;

		let writeIndex = 1;

		for ( let i = 1; i < lastIndex; ++ i ) {

			let keep = false;

			const time = times[ i ];
			const timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

				if ( ! smoothInterpolation ) {

					// remove unnecessary keyframes same as their neighbors

					const offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for ( let j = 0; j !== stride; ++ j ) {

						const value = values[ offset + j ];

						if ( value !== values[ offsetP + j ] ||
							value !== values[ offsetN + j ] ) {

							keep = true;
							break;

						}

					}

				} else {

					keep = true;

				}

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					const readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( let j = 0; j !== stride; ++ j ) {

						values[ writeOffset + j ] = values[ readOffset + j ];

					}

				}

				++ writeIndex;

			}

		}

		// flush last keyframe (compaction looks ahead)

		if ( lastIndex > 0 ) {

			times[ writeIndex ] = times[ lastIndex ];

			for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

				values[ writeOffset + j ] = values[ readOffset + j ];

			}

			++ writeIndex;

		}

		if ( writeIndex !== times.length ) {

			this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
			this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

		} else {

			this.times = times;
			this.values = values;

		}

		return this;

	}

	clone() {

		const times = AnimationUtils.arraySlice( this.times, 0 );
		const values = AnimationUtils.arraySlice( this.values, 0 );

		const TypedKeyframeTrack = this.constructor;
		const track = new TypedKeyframeTrack( this.name, times, values );

		// Interpolant argument to constructor is not saved, so copy the factory method directly.
		track.createInterpolant = this.createInterpolant;

		return track;

	}

}

KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

/**
 * A Track of Boolean keyframe values.
 */
class BooleanKeyframeTrack extends KeyframeTrack {}

BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of keyframe values that represent color.
 */
class ColorKeyframeTrack extends KeyframeTrack {}

ColorKeyframeTrack.prototype.ValueTypeName = 'color';

/**
 * A Track of numeric keyframe values.
 */
class NumberKeyframeTrack extends KeyframeTrack {}

NumberKeyframeTrack.prototype.ValueTypeName = 'number';

/**
 * Spherical linear unit quaternion interpolant.
 */

function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: QuaternionLinearInterpolant,

	interpolate_: function ( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			alpha = ( t - t0 ) / ( t1 - t0 );

		let offset = i1 * stride;

		for ( let end = offset + stride; offset !== end; offset += 4 ) {

			Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

		}

		return result;

	}

} );

/**
 * A Track of quaternion keyframe values.
 */
class QuaternionKeyframeTrack extends KeyframeTrack {

	InterpolantFactoryMethodLinear( result ) {

		return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

}

QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
// ValueBufferType is inherited
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track that interpolates Strings
 */
class StringKeyframeTrack extends KeyframeTrack {}

StringKeyframeTrack.prototype.ValueTypeName = 'string';
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of vectored keyframe values.
 */
class VectorKeyframeTrack extends KeyframeTrack {}

VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

class AnimationClip {

	constructor( name, duration = - 1, tracks, blendMode = NormalAnimationBlendMode ) {

		this.name = name;
		this.tracks = tracks;
		this.duration = duration;
		this.blendMode = blendMode;

		this.uuid = MathUtils.generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {

			this.resetDuration();

		}

	}


	static parse( json ) {

		const tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

		}

		const clip = new this( json.name, json.duration, tracks, json.blendMode );
		clip.uuid = json.uuid;

		return clip;

	}

	static toJSON( clip ) {

		const tracks = [],
			clipTracks = clip.tracks;

		const json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks,
			'uuid': clip.uuid,
			'blendMode': clip.blendMode

		};

		for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	}

	static CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {

		const numMorphTargets = morphTargetSequence.length;
		const tracks = [];

		for ( let i = 0; i < numMorphTargets; i ++ ) {

			let times = [];
			let values = [];

			times.push(
				( i + numMorphTargets - 1 ) % numMorphTargets,
				i,
				( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			const order = AnimationUtils.getKeyframeOrder( times );
			times = AnimationUtils.sortedArray( times, 1, order );
			values = AnimationUtils.sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
				new NumberKeyframeTrack(
					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
					times, values
				).scale( 1.0 / fps ) );

		}

		return new this( name, - 1, tracks );

	}

	static findByName( objectOrClipArray, name ) {

		let clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			const o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( let i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}

		}

		return null;

	}

	static CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {

		const animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		const pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

			const morphTarget = morphTargets[ i ];
			const parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				const name = parts[ 1 ];

				let animationMorphTargets = animationToMorphTargets[ name ];

				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		const clips = [];

		for ( const name in animationToMorphTargets ) {

			clips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	}

	// parse the animation.hierarchy format
	static parseAnimation( animation, bones ) {

		if ( ! animation ) {

			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			return null;

		}

		const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				const times = [];
				const values = [];

				AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		const tracks = [];

		const clipName = animation.name || 'default';
		const fps = animation.fps || 30;
		const blendMode = animation.blendMode;

		// automatic length determination in AnimationClip.
		let duration = animation.length || - 1;

		const hierarchyTracks = animation.hierarchy || [];

		for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

			const animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) continue;

			// process morph targets
			if ( animationKeys[ 0 ].morphTargets ) {

				// figure out all morph targets used in this track
				const morphTargetNames = {};

				let k;

				for ( k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[ k ].morphTargets ) {

						for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( const morphTargetName in morphTargetNames ) {

					const times = [];
					const values = [];

					for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

						const animationKey = animationKeys[ k ];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * ( fps || 1.0 );

			} else {

				// ...assume skeletal animation

				const boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.position',
					animationKeys, 'pos', tracks );

				addNonemptyTrack(
					QuaternionKeyframeTrack, boneName + '.quaternion',
					animationKeys, 'rot', tracks );

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.scale',
					animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		const clip = new this( clipName, duration, tracks, blendMode );

		return clip;

	}

	resetDuration() {

		const tracks = this.tracks;
		let duration = 0;

		for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

			const track = this.tracks[ i ];

			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

		return this;

	}

	trim() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	}

	validate() {

		let valid = true;

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			valid = valid && this.tracks[ i ].validate();

		}

		return valid;

	}

	optimize() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	}

	clone() {

		const tracks = [];

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			tracks.push( this.tracks[ i ].clone() );

		}

		return new this.constructor( this.name, this.duration, tracks, this.blendMode );

	}

	toJSON() {

		return this.constructor.toJSON( this );

	}

}

function getTrackTypeForValueTypeName( typeName ) {

	switch ( typeName.toLowerCase() ) {

		case 'scalar':
		case 'double':
		case 'float':
		case 'number':
		case 'integer':

			return NumberKeyframeTrack;

		case 'vector':
		case 'vector2':
		case 'vector3':
		case 'vector4':

			return VectorKeyframeTrack;

		case 'color':

			return ColorKeyframeTrack;

		case 'quaternion':

			return QuaternionKeyframeTrack;

		case 'bool':
		case 'boolean':

			return BooleanKeyframeTrack;

		case 'string':

			return StringKeyframeTrack;

	}

	throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

}

function parseKeyframeTrack( json ) {

	if ( json.type === undefined ) {

		throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

	}

	const trackType = getTrackTypeForValueTypeName( json.type );

	if ( json.times === undefined ) {

		const times = [], values = [];

		AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

		json.times = times;
		json.values = values;

	}

	// derived classes can define a static parse method
	if ( trackType.parse !== undefined ) {

		return trackType.parse( json );

	} else {

		// by default, we assume a constructor compatible with the base
		return new trackType( json.name, json.times, json.values, json.interpolation );

	}

}

const Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

function LoadingManager( onLoad, onProgress, onError ) {

	const scope = this;

	let isLoading = false;
	let itemsLoaded = 0;
	let itemsTotal = 0;
	let urlModifier = undefined;
	const handlers = [];

	// Refer to #5689 for the reason why we don't set .onStart
	// in the constructor

	this.onStart = undefined;
	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		itemsTotal ++;

		if ( isLoading === false ) {

			if ( scope.onStart !== undefined ) {

				scope.onStart( url, itemsLoaded, itemsTotal );

			}

		}

		isLoading = true;

	};

	this.itemEnd = function ( url ) {

		itemsLoaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, itemsLoaded, itemsTotal );

		}

		if ( itemsLoaded === itemsTotal ) {

			isLoading = false;

			if ( scope.onLoad !== undefined ) {

				scope.onLoad();

			}

		}

	};

	this.itemError = function ( url ) {

		if ( scope.onError !== undefined ) {

			scope.onError( url );

		}

	};

	this.resolveURL = function ( url ) {

		if ( urlModifier ) {

			return urlModifier( url );

		}

		return url;

	};

	this.setURLModifier = function ( transform ) {

		urlModifier = transform;

		return this;

	};

	this.addHandler = function ( regex, loader ) {

		handlers.push( regex, loader );

		return this;

	};

	this.removeHandler = function ( regex ) {

		const index = handlers.indexOf( regex );

		if ( index !== - 1 ) {

			handlers.splice( index, 2 );

		}

		return this;

	};

	this.getHandler = function ( file ) {

		for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

			const regex = handlers[ i ];
			const loader = handlers[ i + 1 ];

			if ( regex.global ) regex.lastIndex = 0; // see #17920

			if ( regex.test( file ) ) {

				return loader;

			}

		}

		return null;

	};

}

const DefaultLoadingManager = new LoadingManager();

function Loader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	this.crossOrigin = 'anonymous';
	this.withCredentials = false;
	this.path = '';
	this.resourcePath = '';
	this.requestHeader = {};

}

Object.assign( Loader.prototype, {

	load: function ( /* url, onLoad, onProgress, onError */ ) {},

	loadAsync: function ( url, onProgress ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.load( url, resolve, onProgress, reject );

		} );

	},

	parse: function ( /* data */ ) {},

	setCrossOrigin: function ( crossOrigin ) {

		this.crossOrigin = crossOrigin;
		return this;

	},

	setWithCredentials: function ( value ) {

		this.withCredentials = value;
		return this;

	},

	setPath: function ( path ) {

		this.path = path;
		return this;

	},

	setResourcePath: function ( resourcePath ) {

		this.resourcePath = resourcePath;
		return this;

	},

	setRequestHeader: function ( requestHeader ) {

		this.requestHeader = requestHeader;
		return this;

	}

} );

const loading = {};

function FileLoader( manager ) {

	Loader.call( this, manager );

}

FileLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: FileLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		// Check if request is duplicate

		if ( loading[ url ] !== undefined ) {

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			return;

		}

		// Check for data: URI
		const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
		const dataUriRegexResult = url.match( dataUriRegex );
		let request;

		// Safari can not handle Data URIs through XMLHttpRequest so process manually
		if ( dataUriRegexResult ) {

			const mimeType = dataUriRegexResult[ 1 ];
			const isBase64 = !! dataUriRegexResult[ 2 ];

			let data = dataUriRegexResult[ 3 ];
			data = decodeURIComponent( data );

			if ( isBase64 ) data = atob( data );

			try {

				let response;
				const responseType = ( this.responseType || '' ).toLowerCase();

				switch ( responseType ) {

					case 'arraybuffer':
					case 'blob':

						const view = new Uint8Array( data.length );

						for ( let i = 0; i < data.length; i ++ ) {

							view[ i ] = data.charCodeAt( i );

						}

						if ( responseType === 'blob' ) {

							response = new Blob( [ view.buffer ], { type: mimeType } );

						} else {

							response = view.buffer;

						}

						break;

					case 'document':

						const parser = new DOMParser();
						response = parser.parseFromString( data, mimeType );

						break;

					case 'json':

						response = JSON.parse( data );

						break;

					default: // 'text' or other

						response = data;

						break;

				}

				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
				setTimeout( function () {

					if ( onLoad ) onLoad( response );

					scope.manager.itemEnd( url );

				}, 0 );

			} catch ( error ) {

				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
				setTimeout( function () {

					if ( onError ) onError( error );

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}, 0 );

			}

		} else {

			// Initialise array for duplicate requests

			loading[ url ] = [];

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			request = new XMLHttpRequest();

			request.open( 'GET', url, true );

			request.addEventListener( 'load', function ( event ) {

				const response = this.response;

				const callbacks = loading[ url ];

				delete loading[ url ];

				if ( this.status === 200 || this.status === 0 ) {

					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.

					if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

					// Add to cache only on HTTP success, so that we do not cache
					// error response bodies as proper responses to requests.
					Cache.add( url, response );

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onLoad ) callback.onLoad( response );

					}

					scope.manager.itemEnd( url );

				} else {

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}

			}, false );

			request.addEventListener( 'progress', function ( event ) {

				const callbacks = loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onProgress ) callback.onProgress( event );

				}

			}, false );

			request.addEventListener( 'error', function ( event ) {

				const callbacks = loading[ url ];

				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( event );

				}

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}, false );

			request.addEventListener( 'abort', function ( event ) {

				const callbacks = loading[ url ];

				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( event );

				}

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}, false );

			if ( this.responseType !== undefined ) request.responseType = this.responseType;
			if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

			if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

			for ( const header in this.requestHeader ) {

				request.setRequestHeader( header, this.requestHeader[ header ] );

			}

			request.send( null );

		}

		scope.manager.itemStart( url );

		return request;

	},

	setResponseType: function ( value ) {

		this.responseType = value;
		return this;

	},

	setMimeType: function ( value ) {

		this.mimeType = value;
		return this;

	}

} );

class AnimationLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const animations = [];

		for ( let i = 0; i < json.length; i ++ ) {

			const clip = AnimationClip.parse( json[ i ] );

			animations.push( clip );

		}

		return animations;

	}

}

/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

function CompressedTextureLoader( manager ) {

	Loader.call( this, manager );

}

CompressedTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: CompressedTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		const scope = this;

		const images = [];

		const texture = new CompressedTexture();

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( scope.withCredentials );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( url[ i ], function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				images[ i ] = {
					width: texDatas.width,
					height: texDatas.height,
					format: texDatas.format,
					mipmaps: texDatas.mipmaps
				};

				loaded += 1;

				if ( loaded === 6 ) {

					if ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;

					texture.image = images;
					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, onProgress, onError );

		}

		if ( Array.isArray( url ) ) {

			for ( let i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				if ( texDatas.isCubemap ) {

					const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( let f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps: [] };

						for ( let i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

					texture.image = images;

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	}

} );

class ImageLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

		function onImageLoad() {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

			Cache.add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}

		function onImageError( event ) {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

			if ( onError ) onError( event );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		}

		image.addEventListener( 'load', onImageLoad, false );
		image.addEventListener( 'error', onImageError, false );

		if ( url.substr( 0, 5 ) !== 'data:' ) {

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		}

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	}

}

class CubeTextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( urls, onLoad, onProgress, onError ) {

		const texture = new CubeTexture();

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( let i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	}

}

/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

function DataTextureLoader( manager ) {

	Loader.call( this, manager );

}

DataTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: DataTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		const scope = this;

		const texture = new DataTexture();

		const loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setPath( this.path );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( buffer ) {

			const texData = scope.parse( buffer );

			if ( ! texData ) return;

			if ( texData.image !== undefined ) {

				texture.image = texData.image;

			} else if ( texData.data !== undefined ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
			texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

			texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
			texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;

			texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

			if ( texData.encoding !== undefined ) {

				texture.encoding = texData.encoding;

			}

			if ( texData.flipY !== undefined ) {

				texture.flipY = texData.flipY;

			}

			if ( texData.format !== undefined ) {

				texture.format = texData.format;

			}

			if ( texData.type !== undefined ) {

				texture.type = texData.type;

			}

			if ( texData.mipmaps !== undefined ) {

				texture.mipmaps = texData.mipmaps;
				texture.minFilter = LinearMipmapLinearFilter; // presumably...

			}

			if ( texData.mipmapCount === 1 ) {

				texture.minFilter = LinearFilter;

			}

			if ( texData.generateMipmaps !== undefined ) {

				texture.generateMipmaps = texData.generateMipmaps;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	}

} );

function TextureLoader( manager ) {

	Loader.call( this, manager );

}

TextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: TextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		const texture = new Texture();

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		loader.load( url, function ( image ) {

			texture.image = image;

			// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
			const isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

			texture.format = isJPEG ? RGBFormat : RGBAFormat;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	}

} );

/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

function Curve() {

	this.type = 'Curve';

	this.arcLengthDivisions = 200;

}

Object.assign( Curve.prototype, {

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint: function ( /* t, optionalTarget */ ) {

		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
		return null;

	},

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt: function ( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getPoint( t, optionalTarget );

	},

	// Get sequence of points using getPoint( t )

	getPoints: function ( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPoint( d / divisions ) );

		}

		return points;

	},

	// Get sequence of points using getPointAt( u )

	getSpacedPoints: function ( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPointAt( d / divisions ) );

		}

		return points;

	},

	// Get total curve arc length

	getLength: function () {

		const lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	},

	// Get list of cumulative segment lengths

	getLengths: function ( divisions ) {

		if ( divisions === undefined ) divisions = this.arcLengthDivisions;

		if ( this.cacheArcLengths &&
			( this.cacheArcLengths.length === divisions + 1 ) &&
			! this.needsUpdate ) {

			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		const cache = [];
		let current, last = this.getPoint( 0 );
		let sum = 0;

		cache.push( 0 );

		for ( let p = 1; p <= divisions; p ++ ) {

			current = this.getPoint( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

	},

	updateArcLengths: function () {

		this.needsUpdate = true;
		this.getLengths();

	},

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping: function ( u, distance ) {

		const arcLengths = this.getLengths();

		let i = 0;
		const il = arcLengths.length;

		let targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		// binary search for the index with largest value smaller than target u distance

		let low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		if ( arcLengths[ i ] === targetArcLength ) {

			return i / ( il - 1 );

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		const lengthBefore = arcLengths[ i ];
		const lengthAfter = arcLengths[ i + 1 ];

		const segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		const segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		const t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	},

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent: function ( t, optionalTarget ) {

		const delta = 0.0001;
		let t1 = t - delta;
		let t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		const pt1 = this.getPoint( t1 );
		const pt2 = this.getPoint( t2 );

		const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );

		tangent.copy( pt2 ).sub( pt1 ).normalize();

		return tangent;

	},

	getTangentAt: function ( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getTangent( t, optionalTarget );

	},

	computeFrenetFrames: function ( segments, closed ) {

		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		const normal = new Vector3();

		const tangents = [];
		const normals = [];
		const binormals = [];

		const vec = new Vector3();
		const mat = new Matrix4();

		// compute the tangent vectors for each segment on the curve

		for ( let i = 0; i <= segments; i ++ ) {

			const u = i / segments;

			tangents[ i ] = this.getTangentAt( u, new Vector3() );
			tangents[ i ].normalize();

		}

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the minimum tangent xyz component

		normals[ 0 ] = new Vector3();
		binormals[ 0 ] = new Vector3();
		let min = Number.MAX_VALUE;
		const tx = Math.abs( tangents[ 0 ].x );
		const ty = Math.abs( tangents[ 0 ].y );
		const tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= min ) {

			min = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= min ) {

			min = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= min ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


		// compute the slowly-varying normal and binormal vectors for each segment on the curve

		for ( let i = 1; i <= segments; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > Number.EPSILON ) {

				vec.normalize();

				const theta = Math.acos( MathUtils.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed === true ) {

			let theta = Math.acos( MathUtils.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
			theta /= segments;

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( let i = 1; i <= segments; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}

		return {
			tangents: tangents,
			normals: normals,
			binormals: binormals
		};

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.arcLengthDivisions = source.arcLengthDivisions;

		return this;

	},

	toJSON: function () {

		const data = {
			metadata: {
				version: 4.5,
				type: 'Curve',
				generator: 'Curve.toJSON'
			}
		};

		data.arcLengthDivisions = this.arcLengthDivisions;
		data.type = this.type;

		return data;

	},

	fromJSON: function ( json ) {

		this.arcLengthDivisions = json.arcLengthDivisions;

		return this;

	}

} );

class EllipseCurve extends Curve {

	constructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {

		super();

		this.type = 'EllipseCurve';

		this.aX = aX;
		this.aY = aY;

		this.xRadius = xRadius;
		this.yRadius = yRadius;

		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;

		this.aClockwise = aClockwise;

		this.aRotation = aRotation;

	}

	getPoint( t, optionalTarget ) {

		const point = optionalTarget || new Vector2();

		const twoPi = Math.PI * 2;
		let deltaAngle = this.aEndAngle - this.aStartAngle;
		const samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle < 0 ) deltaAngle += twoPi;
		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

		if ( deltaAngle < Number.EPSILON ) {

			if ( samePoints ) {

				deltaAngle = 0;

			} else {

				deltaAngle = twoPi;

			}

		}

		if ( this.aClockwise === true && ! samePoints ) {

			if ( deltaAngle === twoPi ) {

				deltaAngle = - twoPi;

			} else {

				deltaAngle = deltaAngle - twoPi;

			}

		}

		const angle = this.aStartAngle + t * deltaAngle;
		let x = this.aX + this.xRadius * Math.cos( angle );
		let y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			const cos = Math.cos( this.aRotation );
			const sin = Math.sin( this.aRotation );

			const tx = x - this.aX;
			const ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;

		}

		return point.set( x, y );

	}

	copy( source ) {

		super.copy( source );

		this.aX = source.aX;
		this.aY = source.aY;

		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;

		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;

		this.aClockwise = source.aClockwise;

		this.aRotation = source.aRotation;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.aX = this.aX;
		data.aY = this.aY;

		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;

		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;

		data.aClockwise = this.aClockwise;

		data.aRotation = this.aRotation;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.aX = json.aX;
		this.aY = json.aY;

		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;

		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;

		this.aClockwise = json.aClockwise;

		this.aRotation = json.aRotation;

		return this;

	}

}

EllipseCurve.prototype.isEllipseCurve = true;

class ArcCurve extends EllipseCurve {

	constructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		super( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		this.type = 'ArcCurve';

	}

}

ArcCurve.prototype.isArcCurve = true;

/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */


/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {

	let c0 = 0, c1 = 0, c2 = 0, c3 = 0;

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	function init( x0, x1, t0, t1 ) {

		c0 = x0;
		c1 = t0;
		c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		c3 = 2 * x0 - 2 * x1 + t0 + t1;

	}

	return {

		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		},

		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			// compute tangents when parameterized in [t1,t2]
			let t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			let t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;

			init( x1, x2, t1, t2 );

		},

		calc: function ( t ) {

			const t2 = t * t;
			const t3 = t2 * t;
			return c0 + c1 * t + c2 * t2 + c3 * t3;

		}

	};

}

//

const tmp = new Vector3();
const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

class CatmullRomCurve3 extends Curve {

	constructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {

		super();

		this.type = 'CatmullRomCurve3';

		this.points = points;
		this.closed = closed;
		this.curveType = curveType;
		this.tension = tension;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const points = this.points;
		const l = points.length;

		const p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		let intPoint = Math.floor( p );
		let weight = p - intPoint;

		if ( this.closed ) {

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

		} else if ( weight === 0 && intPoint === l - 1 ) {

			intPoint = l - 2;
			weight = 1;

		}

		let p0, p3; // 4 points (p1 & p2 defined below)

		if ( this.closed || intPoint > 0 ) {

			p0 = points[ ( intPoint - 1 ) % l ];

		} else {

			// extrapolate first point
			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			p0 = tmp;

		}

		const p1 = points[ intPoint % l ];
		const p2 = points[ ( intPoint + 1 ) % l ];

		if ( this.closed || intPoint + 2 < l ) {

			p3 = points[ ( intPoint + 2 ) % l ];

		} else {

			// extrapolate last point
			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			p3 = tmp;

		}

		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

			// init Centripetal / Chordal Catmull-Rom
			const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			let dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			let dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			let dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

			// safety check for repeated points
			if ( dt1 < 1e-4 ) dt1 = 1.0;
			if ( dt0 < 1e-4 ) dt0 = dt1;
			if ( dt2 < 1e-4 ) dt2 = dt1;

			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

		} else if ( this.curveType === 'catmullrom' ) {

			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

		}

		point.set(
			px.calc( weight ),
			py.calc( weight ),
			pz.calc( weight )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new Vector3().fromArray( point ) );

		}

		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;

		return this;

	}

}

CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

/**
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bzier_curve
 */

function CatmullRom( t, p0, p1, p2, p3 ) {

	const v0 = ( p2 - p0 ) * 0.5;
	const v1 = ( p3 - p1 ) * 0.5;
	const t2 = t * t;
	const t3 = t * t2;
	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

}

//

function QuadraticBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * p;

}

function QuadraticBezierP1( t, p ) {

	return 2 * ( 1 - t ) * t * p;

}

function QuadraticBezierP2( t, p ) {

	return t * t * p;

}

function QuadraticBezier( t, p0, p1, p2 ) {

	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
		QuadraticBezierP2( t, p2 );

}

//

function CubicBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * k * p;

}

function CubicBezierP1( t, p ) {

	const k = 1 - t;
	return 3 * k * k * t * p;

}

function CubicBezierP2( t, p ) {

	return 3 * ( 1 - t ) * t * t * p;

}

function CubicBezierP3( t, p ) {

	return t * t * t * p;

}

function CubicBezier( t, p0, p1, p2, p3 ) {

	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
		CubicBezierP3( t, p3 );

}

class CubicBezierCurve extends Curve {

	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {

		super();

		this.type = 'CubicBezierCurve';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

CubicBezierCurve.prototype.isCubicBezierCurve = true;

class CubicBezierCurve3 extends Curve {

	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {

		super();

		this.type = 'CubicBezierCurve3';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

class LineCurve extends Curve {

	constructor( v1 = new Vector2(), v2 = new Vector2() ) {

		super();

		this.type = 'LineCurve';

		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}

	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}

	getTangent( t, optionalTarget ) {

		const tangent = optionalTarget || new Vector2();

		tangent.copy( this.v2 ).sub( this.v1 ).normalize();

		return tangent;

	}

	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

LineCurve.prototype.isLineCurve = true;

class LineCurve3 extends Curve {

	constructor( v1 = new Vector3(), v2 = new Vector3() ) {

		super();

		this.type = 'LineCurve3';
		this.isLineCurve3 = true;

		this.v1 = v1;
		this.v2 = v2;

	}
	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}
	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}
	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}
	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}
	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class QuadraticBezierCurve extends Curve {

	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {

		super();

		this.type = 'QuadraticBezierCurve';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

class QuadraticBezierCurve3 extends Curve {

	constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {

		super();

		this.type = 'QuadraticBezierCurve3';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector3() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y ),
			QuadraticBezier( t, v0.z, v1.z, v2.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

class SplineCurve extends Curve {

	constructor( points = [] ) {

		super();

		this.type = 'SplineCurve';

		this.points = points;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const points = this.points;
		const p = ( points.length - 1 ) * t;

		const intPoint = Math.floor( p );
		const weight = p - intPoint;

		const p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		const p1 = points[ intPoint ];
		const p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		const p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		point.set(
			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new Vector2().fromArray( point ) );

		}

		return this;

	}

}

SplineCurve.prototype.isSplineCurve = true;

var Curves = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ArcCurve: ArcCurve,
	CatmullRomCurve3: CatmullRomCurve3,
	CubicBezierCurve: CubicBezierCurve,
	CubicBezierCurve3: CubicBezierCurve3,
	EllipseCurve: EllipseCurve,
	LineCurve: LineCurve,
	LineCurve3: LineCurve3,
	QuadraticBezierCurve: QuadraticBezierCurve,
	QuadraticBezierCurve3: QuadraticBezierCurve3,
	SplineCurve: SplineCurve
});

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

class CurvePath extends Curve {

	constructor() {

		super();

		this.type = 'CurvePath';

		this.curves = [];
		this.autoClose = false; // Automatically closes the path

	}

	add( curve ) {

		this.curves.push( curve );

	}

	closePath() {

		// Add a line curve if start and end of lines are not connected
		const startPoint = this.curves[ 0 ].getPoint( 0 );
		const endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			this.curves.push( new LineCurve( endPoint, startPoint ) );

		}

	}

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	getPoint( t ) {

		const d = t * this.getLength();
		const curveLengths = this.getCurveLengths();
		let i = 0;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				const diff = curveLengths[ i ] - d;
				const curve = this.curves[ i ];

				const segmentLength = curve.getLength();
				const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

				return curve.getPointAt( u );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	}

	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	getLength() {

		const lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	}

	// cacheLengths must be recalculated.
	updateArcLengths() {

		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getCurveLengths();

	}

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	getCurveLengths() {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		const lengths = [];
		let sums = 0;

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	}

	getSpacedPoints( divisions = 40 ) {

		const points = [];

		for ( let i = 0; i <= divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

		}

		if ( this.autoClose ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	getPoints( divisions = 12 ) {

		const points = [];
		let last;

		for ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {

			const curve = curves[ i ];
			const resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
				: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
					: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
						: divisions;

			const pts = curve.getPoints( resolution );

			for ( let j = 0; j < pts.length; j ++ ) {

				const point = pts[ j ];

				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

				points.push( point );
				last = point;

			}

		}

		if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	copy( source ) {

		super.copy( source );

		this.curves = [];

		for ( let i = 0, l = source.curves.length; i < l; i ++ ) {

			const curve = source.curves[ i ];

			this.curves.push( curve.clone() );

		}

		this.autoClose = source.autoClose;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.autoClose = this.autoClose;
		data.curves = [];

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			const curve = this.curves[ i ];
			data.curves.push( curve.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.autoClose = json.autoClose;
		this.curves = [];

		for ( let i = 0, l = json.curves.length; i < l; i ++ ) {

			const curve = json.curves[ i ];
			this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

		}

		return this;

	}

}

class Path extends CurvePath {

	constructor( points ) {

		super();
		this.type = 'Path';

		this.currentPoint = new Vector2();

		if ( points ) {

			this.setFromPoints( points );

		}

	}

	setFromPoints( points ) {

		this.moveTo( points[ 0 ].x, points[ 0 ].y );

		for ( let i = 1, l = points.length; i < l; i ++ ) {

			this.lineTo( points[ i ].x, points[ i ].y );

		}

		return this;

	}

	moveTo( x, y ) {

		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		return this;

	}

	lineTo( x, y ) {

		const curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
		this.curves.push( curve );

		this.currentPoint.set( x, y );

		return this;

	}

	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		const curve = new QuadraticBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCPx, aCPy ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		const curve = new CubicBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCP1x, aCP1y ),
			new Vector2( aCP2x, aCP2y ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	splineThru( pts /*Array of Vector*/ ) {

		const npts = [ this.currentPoint.clone() ].concat( pts );

		const curve = new SplineCurve( npts );
		this.curves.push( curve );

		this.currentPoint.copy( pts[ pts.length - 1 ] );

		return this;

	}

	arc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	absarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	ellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		return this;

	}

	absellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		if ( this.curves.length > 0 ) {

			// if a previous curve is present, attempt to join
			const firstPoint = curve.getPoint( 0 );

			if ( ! firstPoint.equals( this.currentPoint ) ) {

				this.lineTo( firstPoint.x, firstPoint.y );

			}

		}

		this.curves.push( curve );

		const lastPoint = curve.getPoint( 1 );
		this.currentPoint.copy( lastPoint );

		return this;

	}

	copy( source ) {

		super.copy( source );

		this.currentPoint.copy( source.currentPoint );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.currentPoint = this.currentPoint.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.currentPoint.fromArray( json.currentPoint );

		return this;

	}

}

class Shape extends Path {

	constructor( points ) {

		super( points );

		this.uuid = MathUtils.generateUUID();

		this.type = 'Shape';

		this.holes = [];

	}

	getPointsHoles( divisions ) {

		const holesPts = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		}

		return holesPts;

	}

	// get points of shape and holes (keypoints based on segments parameter)

	extractPoints( divisions ) {

		return {

			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	}

	copy( source ) {

		super.copy( source );

		this.holes = [];

		for ( let i = 0, l = source.holes.length; i < l; i ++ ) {

			const hole = source.holes[ i ];

			this.holes.push( hole.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.uuid = this.uuid;
		data.holes = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			const hole = this.holes[ i ];
			data.holes.push( hole.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.uuid = json.uuid;
		this.holes = [];

		for ( let i = 0, l = json.holes.length; i < l; i ++ ) {

			const hole = json.holes[ i ];
			this.holes.push( new Path().fromJSON( hole ) );

		}

		return this;

	}

}

class Light extends Object3D {

	constructor( color, intensity = 1 ) {

		super();

		this.type = 'Light';

		this.color = new Color( color );
		this.intensity = intensity;

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

		return data;

	}

}

Light.prototype.isLight = true;

class HemisphereLight extends Light {

	constructor( skyColor, groundColor, intensity ) {

		super( skyColor, intensity );

		this.type = 'HemisphereLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.groundColor = new Color( groundColor );

	}

	copy( source ) {

		Light.prototype.copy.call( this, source );

		this.groundColor.copy( source.groundColor );

		return this;

	}

}

HemisphereLight.prototype.isHemisphereLight = true;

const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
const _lookTarget$1 = /*@__PURE__*/ new Vector3();

class LightShadow {

	constructor( camera ) {

		this.camera = camera;

		this.bias = 0;
		this.normalBias = 0;
		this.radius = 1;

		this.mapSize = new Vector2( 512, 512 );

		this.map = null;
		this.mapPass = null;
		this.matrix = new Matrix4();

		this.autoUpdate = true;
		this.needsUpdate = false;

		this._frustum = new Frustum();
		this._frameExtents = new Vector2( 1, 1 );

		this._viewportCount = 1;

		this._viewports = [

			new Vector4( 0, 0, 1, 1 )

		];

	}

	getViewportCount() {

		return this._viewportCount;

	}

	getFrustum() {

		return this._frustum;

	}

	updateMatrices( light ) {

		const shadowCamera = this.camera;
		const shadowMatrix = this.matrix;

		_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
		shadowCamera.position.copy( _lightPositionWorld$1 );

		_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
		shadowCamera.lookAt( _lookTarget$1 );
		shadowCamera.updateMatrixWorld();

		_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

		shadowMatrix.set(
			0.5, 0.0, 0.0, 0.5,
			0.0, 0.5, 0.0, 0.5,
			0.0, 0.0, 0.5, 0.5,
			0.0, 0.0, 0.0, 1.0
		);

		shadowMatrix.multiply( shadowCamera.projectionMatrix );
		shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

	}

	getViewport( viewportIndex ) {

		return this._viewports[ viewportIndex ];

	}

	getFrameExtents() {

		return this._frameExtents;

	}

	copy( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	toJSON() {

		const object = {};

		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	}

}

class SpotLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

		this.focus = 1;

	}

	updateMatrices( light ) {

		const camera = this.camera;

		const fov = MathUtils.RAD2DEG * 2 * light.angle * this.focus;
		const aspect = this.mapSize.width / this.mapSize.height;
		const far = light.distance || camera.far;

		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();

		}

		super.updateMatrices( light );

	}

	copy( source ) {

		super.copy( source );

		this.focus = source.focus;

		return this;

	}

}

SpotLightShadow.prototype.isSpotLightShadow = true;

class SpotLight extends Light {

	constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1 ) {

		super( color, intensity );

		this.type = 'SpotLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		this.distance = distance;
		this.angle = angle;
		this.penumbra = penumbra;
		this.decay = decay; // for physically correct lights, should be 2.

		this.shadow = new SpotLightShadow();

	}

	get power() {

		// intensity = power per solid angle.
		// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		return this.intensity * Math.PI;

	}

	set power( power ) {

		// intensity = power per solid angle.
		// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		this.intensity = power / Math.PI;

	}

	copy( source ) {

		super.copy( source );

		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

}

SpotLight.prototype.isSpotLight = true;

const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld = /*@__PURE__*/ new Vector3();
const _lookTarget = /*@__PURE__*/ new Vector3();

class PointLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

		this._frameExtents = new Vector2( 4, 2 );

		this._viewportCount = 6;

		this._viewports = [
			// These viewports map a cube-map onto a 2D texture with the
			// following orientation:
			//
			//  xzXZ
			//   y Y
			//
			// X - Positive x direction
			// x - Negative x direction
			// Y - Positive y direction
			// y - Negative y direction
			// Z - Positive z direction
			// z - Negative z direction

			// positive X
			new Vector4( 2, 1, 1, 1 ),
			// negative X
			new Vector4( 0, 1, 1, 1 ),
			// positive Z
			new Vector4( 3, 1, 1, 1 ),
			// negative Z
			new Vector4( 1, 1, 1, 1 ),
			// positive Y
			new Vector4( 3, 0, 1, 1 ),
			// negative Y
			new Vector4( 1, 0, 1, 1 )
		];

		this._cubeDirections = [
			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
		];

		this._cubeUps = [
			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
		];

	}

	updateMatrices( light, viewportIndex = 0 ) {

		const camera = this.camera;
		const shadowMatrix = this.matrix;

		const far = light.distance || camera.far;

		if ( far !== camera.far ) {

			camera.far = far;
			camera.updateProjectionMatrix();

		}

		_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		camera.position.copy( _lightPositionWorld );

		_lookTarget.copy( camera.position );
		_lookTarget.add( this._cubeDirections[ viewportIndex ] );
		camera.up.copy( this._cubeUps[ viewportIndex ] );
		camera.lookAt( _lookTarget );
		camera.updateMatrixWorld();

		shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix );

	}

}

PointLightShadow.prototype.isPointLightShadow = true;

class PointLight extends Light {

	constructor( color, intensity, distance = 0, decay = 1 ) {

		super( color, intensity );

		this.type = 'PointLight';

		this.distance = distance;
		this.decay = decay; // for physically correct lights, should be 2.

		this.shadow = new PointLightShadow();

	}

	get power() {

		// intensity = power per solid angle.
		// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		return this.intensity * 4 * Math.PI;

	}

	set power( power ) {

		// intensity = power per solid angle.
		// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		this.intensity = power / ( 4 * Math.PI );

	}

	copy( source ) {

		super.copy( source );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

}

PointLight.prototype.isPointLight = true;

class OrthographicCamera extends Camera {

	constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

		super();

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = near;
		this.far = far;

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	}

	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	updateProjectionMatrix() {

		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		const cx = ( this.right + this.left ) / 2;
		const cy = ( this.top + this.bottom ) / 2;

		let left = cx - dx;
		let right = cx + dx;
		let top = cy + dy;
		let bottom = cy - dy;

		if ( this.view !== null && this.view.enabled ) {

			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

			left += scaleW * this.view.offsetX;
			right = left + scaleW * this.view.width;
			top -= scaleH * this.view.offsetY;
			bottom = top - scaleH * this.view.height;

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = Object3D.prototype.toJSON.call( this, meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

}

OrthographicCamera.prototype.isOrthographicCamera = true;

class DirectionalLightShadow extends LightShadow {

	constructor() {

		super( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

	}

}

DirectionalLightShadow.prototype.isDirectionalLightShadow = true;

class DirectionalLight extends Light {

	constructor( color, intensity ) {

		super( color, intensity );

		this.type = 'DirectionalLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		this.shadow = new DirectionalLightShadow();

	}

	copy( source ) {

		super.copy( source );

		this.target = source.target.clone();
		this.shadow = source.shadow.clone();

		return this;

	}

}

DirectionalLight.prototype.isDirectionalLight = true;

class AmbientLight extends Light {

	constructor( color, intensity ) {

		super( color, intensity );

		this.type = 'AmbientLight';

	}

}

AmbientLight.prototype.isAmbientLight = true;

class RectAreaLight extends Light {

	constructor( color, intensity, width = 10, height = 10 ) {

		super( color, intensity );

		this.type = 'RectAreaLight';

		this.width = width;
		this.height = height;

	}

	copy( source ) {

		super.copy( source );

		this.width = source.width;
		this.height = source.height;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.width = this.width;
		data.object.height = this.height;

		return data;

	}

}

RectAreaLight.prototype.isRectAreaLight = true;

/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */

// 3-band SH defined by 9 coefficients

class SphericalHarmonics3 {

	constructor() {

		this.coefficients = [];

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients.push( new Vector3() );

		}

	}

	set( coefficients ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].copy( coefficients[ i ] );

		}

		return this;

	}

	zero() {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].set( 0, 0, 0 );

		}

		return this;

	}

	// get the radiance in the direction of the normal
	// target is a Vector3
	getAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

		// band 1
		target.addScaledVector( coeff[ 1 ], 0.488603 * y );
		target.addScaledVector( coeff[ 2 ], 0.488603 * z );
		target.addScaledVector( coeff[ 3 ], 0.488603 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
		target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
		target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
		target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
		target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

		return target;

	}

	// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
	// target is a Vector3
	// https://graphics.stanford.edu/papers/envmap/envmap.pdf
	getIrradianceAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); //  * 0.282095

		// band 1
		target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 *  / 3 ) * 0.488603
		target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
		target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // (  / 4 ) * 1.092548
		target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
		target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // (  / 4 ) * 0.315392 * 3
		target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
		target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // (  / 4 ) * 0.546274

		return target;

	}

	add( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].add( sh.coefficients[ i ] );

		}

		return this;

	}

	addScaledSH( sh, s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

		}

		return this;

	}

	scale( s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].multiplyScalar( s );

		}

		return this;

	}

	lerp( sh, alpha ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

		}

		return this;

	}

	equals( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

				return false;

			}

		}

		return true;

	}

	copy( sh ) {

		return this.set( sh.coefficients );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	fromArray( array, offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].toArray( array, offset + ( i * 3 ) );

		}

		return array;

	}

	// evaluate the basis functions
	// shBasis is an Array[ 9 ]
	static getBasisAt( normal, shBasis ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		// band 0
		shBasis[ 0 ] = 0.282095;

		// band 1
		shBasis[ 1 ] = 0.488603 * y;
		shBasis[ 2 ] = 0.488603 * z;
		shBasis[ 3 ] = 0.488603 * x;

		// band 2
		shBasis[ 4 ] = 1.092548 * x * y;
		shBasis[ 5 ] = 1.092548 * y * z;
		shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
		shBasis[ 7 ] = 1.092548 * x * z;
		shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

	}

}

SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;

class LightProbe extends Light {

	constructor( sh = new SphericalHarmonics3(), intensity = 1 ) {

		super( undefined, intensity );

		this.sh = sh;

	}

	copy( source ) {

		super.copy( source );

		this.sh.copy( source.sh );

		return this;

	}

	fromJSON( json ) {

		this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
		this.sh.fromArray( json.sh );

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.sh = this.sh.toArray();

		return data;

	}

}

LightProbe.prototype.isLightProbe = true;

class MaterialLoader extends Loader {

	constructor( manager ) {

		super( manager );
		this.textures = {};

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const textures = this.textures;

		function getTexture( name ) {

			if ( textures[ name ] === undefined ) {

				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		}

		const material = new Materials[ json.type ]();

		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.sheen !== undefined ) material.sheen = new Color().setHex( json.sheen );
		if ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;
		if ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;
		if ( json.fog !== undefined ) material.fog = json.fog;
		if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.combine !== undefined ) material.combine = json.combine;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.shadowSide !== undefined ) material.shadowSide = json.shadowSide;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;

		if ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;
		if ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;
		if ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;
		if ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;
		if ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;
		if ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;
		if ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;
		if ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;

		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

		if ( json.rotation !== undefined ) material.rotation = json.rotation;

		if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
		if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
		if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
		if ( json.scale !== undefined ) material.scale = json.scale;

		if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
		if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
		if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

		if ( json.skinning !== undefined ) material.skinning = json.skinning;
		if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
		if ( json.morphNormals !== undefined ) material.morphNormals = json.morphNormals;
		if ( json.dithering !== undefined ) material.dithering = json.dithering;

		if ( json.alphaToCoverage !== undefined ) material.alphaToCoverage = json.alphaToCoverage;
		if ( json.premultipliedAlpha !== undefined ) material.premultipliedAlpha = json.premultipliedAlpha;

		if ( json.vertexTangents !== undefined ) material.vertexTangents = json.vertexTangents;

		if ( json.visible !== undefined ) material.visible = json.visible;

		if ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;

		if ( json.userData !== undefined ) material.userData = json.userData;

		if ( json.vertexColors !== undefined ) {

			if ( typeof json.vertexColors === 'number' ) {

				material.vertexColors = ( json.vertexColors > 0 ) ? true : false;

			} else {

				material.vertexColors = json.vertexColors;

			}

		}

		// Shader Material

		if ( json.uniforms !== undefined ) {

			for ( const name in json.uniforms ) {

				const uniform = json.uniforms[ name ];

				material.uniforms[ name ] = {};

				switch ( uniform.type ) {

					case 't':
						material.uniforms[ name ].value = getTexture( uniform.value );
						break;

					case 'c':
						material.uniforms[ name ].value = new Color().setHex( uniform.value );
						break;

					case 'v2':
						material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
						break;

					case 'v3':
						material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
						break;

					case 'v4':
						material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
						break;

					case 'm3':
						material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );
						break;

					case 'm4':
						material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
						break;

					default:
						material.uniforms[ name ].value = uniform.value;

				}

			}

		}

		if ( json.defines !== undefined ) material.defines = json.defines;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;

		if ( json.extensions !== undefined ) {

			for ( const key in json.extensions ) {

				material.extensions[ key ] = json.extensions[ key ];

			}

		}

		// Deprecated

		if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

		// for PointsMaterial

		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = getTexture( json.map );
		if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );

		if ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );

		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
		if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
		if ( json.normalScale !== undefined ) {

			let normalScale = json.normalScale;

			if ( Array.isArray( normalScale ) === false ) {

				// Blender exporter used to export a scalar. See #7459

				normalScale = [ normalScale, normalScale ];

			}

			material.normalScale = new Vector2().fromArray( normalScale );

		}

		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
		if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
		if ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;

		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

		if ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );
		if ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );
		if ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );
		if ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );

		if ( json.transmission !== undefined ) material.transmission = json.transmission;
		if ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );

		return material;

	}

	setTextures( value ) {

		this.textures = value;
		return this;

	}

}

const LoaderUtils = {

	decodeText: function ( array ) {

		if ( typeof TextDecoder !== 'undefined' ) {

			return new TextDecoder().decode( array );

		}

		// Avoid the String.fromCharCode.apply(null, array) shortcut, which
		// throws a "maximum call stack size exceeded" error for large arrays.

		let s = '';

		for ( let i = 0, il = array.length; i < il; i ++ ) {

			// Implicitly assumes little-endian.
			s += String.fromCharCode( array[ i ] );

		}

		try {

			// merges multi-byte utf-8 characters.

			return decodeURIComponent( escape( s ) );

		} catch ( e ) { // see #16358

			return s;

		}

	},

	extractUrlBase: function ( url ) {

		const index = url.lastIndexOf( '/' );

		if ( index === - 1 ) return './';

		return url.substr( 0, index + 1 );

	}

};

function InstancedBufferGeometry() {

	BufferGeometry.call( this );

	this.type = 'InstancedBufferGeometry';
	this.instanceCount = Infinity;

}

InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

	constructor: InstancedBufferGeometry,

	isInstancedBufferGeometry: true,

	copy: function ( source ) {

		BufferGeometry.prototype.copy.call( this, source );

		this.instanceCount = source.instanceCount;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	toJSON: function () {

		const data = BufferGeometry.prototype.toJSON.call( this );

		data.instanceCount = this.instanceCount;

		data.isInstancedBufferGeometry = true;

		return data;

	}

} );

function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {

	if ( typeof ( normalized ) === 'number' ) {

		meshPerAttribute = normalized;

		normalized = false;

		console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

	}

	BufferAttribute.call( this, array, itemSize, normalized );

	this.meshPerAttribute = meshPerAttribute || 1;

}

InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

	constructor: InstancedBufferAttribute,

	isInstancedBufferAttribute: true,

	copy: function ( source ) {

		BufferAttribute.prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	},

	toJSON: function ()	{

		const data = BufferAttribute.prototype.toJSON.call( this );

		data.meshPerAttribute = this.meshPerAttribute;

		data.isInstancedBufferAttribute = true;

		return data;

	}

} );

class BufferGeometryLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const interleavedBufferMap = {};
		const arrayBufferMap = {};

		function getInterleavedBuffer( json, uuid ) {

			if ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];

			const interleavedBuffers = json.interleavedBuffers;
			const interleavedBuffer = interleavedBuffers[ uuid ];

			const buffer = getArrayBuffer( json, interleavedBuffer.buffer );

			const array = getTypedArray( interleavedBuffer.type, buffer );
			const ib = new InterleavedBuffer( array, interleavedBuffer.stride );
			ib.uuid = interleavedBuffer.uuid;

			interleavedBufferMap[ uuid ] = ib;

			return ib;

		}

		function getArrayBuffer( json, uuid ) {

			if ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];

			const arrayBuffers = json.arrayBuffers;
			const arrayBuffer = arrayBuffers[ uuid ];

			const ab = new Uint32Array( arrayBuffer ).buffer;

			arrayBufferMap[ uuid ] = ab;

			return ab;

		}

		const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();

		const index = json.data.index;

		if ( index !== undefined ) {

			const typedArray = getTypedArray( index.type, index.array );
			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

		}

		const attributes = json.data.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];
			let bufferAttribute;

			if ( attribute.isInterleavedBufferAttribute ) {

				const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
				bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

			} else {

				const typedArray = getTypedArray( attribute.type, attribute.array );
				const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
				bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );

			}

			if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
			if ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );

			if ( attribute.updateRange !== undefined ) {

				bufferAttribute.updateRange.offset = attribute.updateRange.offset;
				bufferAttribute.updateRange.count = attribute.updateRange.count;

			}

			geometry.setAttribute( key, bufferAttribute );

		}

		const morphAttributes = json.data.morphAttributes;

		if ( morphAttributes ) {

			for ( const key in morphAttributes ) {

				const attributeArray = morphAttributes[ key ];

				const array = [];

				for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

					const attribute = attributeArray[ i ];
					let bufferAttribute;

					if ( attribute.isInterleavedBufferAttribute ) {

						const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
						bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

					} else {

						const typedArray = getTypedArray( attribute.type, attribute.array );
						bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );

					}

					if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
					array.push( bufferAttribute );

				}

				geometry.morphAttributes[ key ] = array;

			}

		}

		const morphTargetsRelative = json.data.morphTargetsRelative;

		if ( morphTargetsRelative ) {

			geometry.morphTargetsRelative = true;

		}

		const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( let i = 0, n = groups.length; i !== n; ++ i ) {

				const group = groups[ i ];

				geometry.addGroup( group.start, group.count, group.materialIndex );

			}

		}

		const boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			const center = new Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

		}

		if ( json.name ) geometry.name = json.name;
		if ( json.userData ) geometry.userData = json.userData;

		return geometry;

	}

}

class ObjectLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			let json = null;

			try {

				json = JSON.parse( text );

			} catch ( error ) {

				if ( onError !== undefined ) onError( error );

				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

				return;

			}

			const metadata = json.metadata;

			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

				console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
				return;

			}

			scope.parse( json, onLoad );

		}, onProgress, onError );

	}

	parse( json, onLoad ) {

		const animations = this.parseAnimations( json.animations );
		const shapes = this.parseShapes( json.shapes );
		const geometries = this.parseGeometries( json.geometries, shapes );

		const images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		const textures = this.parseTextures( json.textures, images );
		const materials = this.parseMaterials( json.materials, textures );

		const object = this.parseObject( json.object, geometries, materials, animations );
		const skeletons = this.parseSkeletons( json.skeletons, object );

		this.bindSkeletons( object, skeletons );

		//

		if ( onLoad !== undefined ) {

			let hasImages = false;

			for ( const uuid in images ) {

				if ( images[ uuid ] instanceof HTMLImageElement ) {

					hasImages = true;
					break;

				}

			}

			if ( hasImages === false ) onLoad( object );

		}

		return object;

	}

	parseShapes( json ) {

		const shapes = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const shape = new Shape().fromJSON( json[ i ] );

				shapes[ shape.uuid ] = shape;

			}

		}

		return shapes;

	}

	parseSkeletons( json, object ) {

		const skeletons = {};
		const bones = {};

		// generate bone lookup table

		object.traverse( function ( child ) {

			if ( child.isBone ) bones[ child.uuid ] = child;

		} );

		// create skeletons

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const skeleton = new Skeleton().fromJSON( json[ i ], bones );

				skeletons[ skeleton.uuid ] = skeleton;

			}

		}

		return skeletons;

	}

	parseGeometries( json, shapes ) {

		const geometries = {};
		let geometryShapes;

		if ( json !== undefined ) {

			const bufferGeometryLoader = new BufferGeometryLoader();

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				let geometry;
				const data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':
					case 'PlaneBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'BoxBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleGeometry':
					case 'CircleBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.segments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'CylinderGeometry':
					case 'CylinderBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'ConeGeometry':
					case 'ConeBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'SphereGeometry':
					case 'SphereBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'DodecahedronGeometry':
					case 'DodecahedronBufferGeometry':
					case 'IcosahedronGeometry':
					case 'IcosahedronBufferGeometry':
					case 'OctahedronGeometry':
					case 'OctahedronBufferGeometry':
					case 'TetrahedronGeometry':
					case 'TetrahedronBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.detail
						);

						break;

					case 'RingGeometry':
					case 'RingBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.innerRadius,
							data.outerRadius,
							data.thetaSegments,
							data.phiSegments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'TorusGeometry':
					case 'TorusBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':
					case 'TorusKnotBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.tube,
							data.tubularSegments,
							data.radialSegments,
							data.p,
							data.q
						);

						break;

					case 'TubeGeometry':
					case 'TubeBufferGeometry':

						// This only works for built-in curves (e.g. CatmullRomCurve3).
						// User defined curves or instances of CurvePath will not be deserialized.
						geometry = new Geometries[ data.type ](
							new Curves[ data.path.type ]().fromJSON( data.path ),
							data.tubularSegments,
							data.radius,
							data.radialSegments,
							data.closed
						);

						break;

					case 'LatheGeometry':
					case 'LatheBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.points,
							data.segments,
							data.phiStart,
							data.phiLength
						);

						break;

					case 'PolyhedronGeometry':
					case 'PolyhedronBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.vertices,
							data.indices,
							data.radius,
							data.details
						);

						break;

					case 'ShapeGeometry':
					case 'ShapeBufferGeometry':

						geometryShapes = [];

						for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

							const shape = shapes[ data.shapes[ j ] ];

							geometryShapes.push( shape );

						}

						geometry = new Geometries[ data.type ](
							geometryShapes,
							data.curveSegments
						);

						break;


					case 'ExtrudeGeometry':
					case 'ExtrudeBufferGeometry':

						geometryShapes = [];

						for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

							const shape = shapes[ data.shapes[ j ] ];

							geometryShapes.push( shape );

						}

						const extrudePath = data.options.extrudePath;

						if ( extrudePath !== undefined ) {

							data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

						}

						geometry = new Geometries[ data.type ](
							geometryShapes,
							data.options
						);

						break;

					case 'BufferGeometry':
					case 'InstancedBufferGeometry':

						geometry = bufferGeometryLoader.parse( data );

						break;

					case 'Geometry':

						console.error( 'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.' );

						break;

					default:

						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

						continue;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;
				if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	}

	parseMaterials( json, textures ) {

		const cache = {}; // MultiMaterial
		const materials = {};

		if ( json !== undefined ) {

			const loader = new MaterialLoader();
			loader.setTextures( textures );

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( data.type === 'MultiMaterial' ) {

					// Deprecated

					const array = [];

					for ( let j = 0; j < data.materials.length; j ++ ) {

						const material = data.materials[ j ];

						if ( cache[ material.uuid ] === undefined ) {

							cache[ material.uuid ] = loader.parse( material );

						}

						array.push( cache[ material.uuid ] );

					}

					materials[ data.uuid ] = array;

				} else {

					if ( cache[ data.uuid ] === undefined ) {

						cache[ data.uuid ] = loader.parse( data );

					}

					materials[ data.uuid ] = cache[ data.uuid ];

				}

			}

		}

		return materials;

	}

	parseAnimations( json ) {

		const animations = {};

		if ( json !== undefined ) {

			for ( let i = 0; i < json.length; i ++ ) {

				const data = json[ i ];

				const clip = AnimationClip.parse( data );

				animations[ clip.uuid ] = clip;

			}

		}

		return animations;

	}

	parseImages( json, onLoad ) {

		const scope = this;
		const images = {};

		let loader;

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			}, undefined, function () {

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			} );

		}

		function deserializeImage( image ) {

			if ( typeof image === 'string' ) {

				const url = image;

				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

				return loadImage( path );

			} else {

				if ( image.data ) {

					return {
						data: getTypedArray( image.type, image.data ),
						width: image.width,
						height: image.height
					};

				} else {

					return null;

				}

			}

		}

		if ( json !== undefined && json.length > 0 ) {

			const manager = new LoadingManager( onLoad );

			loader = new ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( let i = 0, il = json.length; i < il; i ++ ) {

				const image = json[ i ];
				const url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					images[ image.uuid ] = [];

					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

						const currentUrl = url[ j ];

						const deserializedImage = deserializeImage( currentUrl );

						if ( deserializedImage !== null ) {

							if ( deserializedImage instanceof HTMLImageElement ) {

								images[ image.uuid ].push( deserializedImage );

							} else {

								// special case: handle array of data textures for cube textures

								images[ image.uuid ].push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

							}

						}

					}

				} else {

					// load single image

					const deserializedImage = deserializeImage( image.url );

					if ( deserializedImage !== null ) {

						images[ image.uuid ] = deserializedImage;

					}

				}

			}

		}

		return images;

	}

	parseTextures( json, images ) {

		function parseConstant( value, type ) {

			if ( typeof value === 'number' ) return value;

			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return type[ value ];

		}

		const textures = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

				}

				let texture;
				const image = images[ data.image ];

				if ( Array.isArray( image ) ) {

					texture = new CubeTexture( image );

					if ( image.length === 6 ) texture.needsUpdate = true;

				} else {

					if ( image && image.data ) {

						texture = new DataTexture( image.data, image.width, image.height );

					} else {

						texture = new Texture( image );

					}

					if ( image ) texture.needsUpdate = true; // textures can have undefined image data

				}

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;

				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
				if ( data.center !== undefined ) texture.center.fromArray( data.center );
				if ( data.rotation !== undefined ) texture.rotation = data.rotation;

				if ( data.wrap !== undefined ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
					texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

				}

				if ( data.format !== undefined ) texture.format = data.format;
				if ( data.type !== undefined ) texture.type = data.type;
				if ( data.encoding !== undefined ) texture.encoding = data.encoding;

				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

				if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
				if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	}

	parseObject( data, geometries, materials, animations ) {

		let object;

		function getGeometry( name ) {

			if ( geometries[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

			}

			return geometries[ name ];

		}

		function getMaterial( name ) {

			if ( name === undefined ) return undefined;

			if ( Array.isArray( name ) ) {

				const array = [];

				for ( let i = 0, l = name.length; i < l; i ++ ) {

					const uuid = name[ i ];

					if ( materials[ uuid ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

					}

					array.push( materials[ uuid ] );

				}

				return array;

			}

			if ( materials[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined material', name );

			}

			return materials[ name ];

		}

		let geometry, material;

		switch ( data.type ) {

			case 'Scene':

				object = new Scene();

				if ( data.background !== undefined ) {

					if ( Number.isInteger( data.background ) ) {

						object.background = new Color( data.background );

					}

				}

				if ( data.fog !== undefined ) {

					if ( data.fog.type === 'Fog' ) {

						object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

					} else if ( data.fog.type === 'FogExp2' ) {

						object.fog = new FogExp2( data.fog.color, data.fog.density );

					}

				}

				break;

			case 'PerspectiveCamera':

				object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

				if ( data.focus !== undefined ) object.focus = data.focus;
				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
				if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'OrthographicCamera':

				object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'AmbientLight':

				object = new AmbientLight( data.color, data.intensity );

				break;

			case 'DirectionalLight':

				object = new DirectionalLight( data.color, data.intensity );

				break;

			case 'PointLight':

				object = new PointLight( data.color, data.intensity, data.distance, data.decay );

				break;

			case 'RectAreaLight':

				object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

				break;

			case 'SpotLight':

				object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

				break;

			case 'HemisphereLight':

				object = new HemisphereLight( data.color, data.groundColor, data.intensity );

				break;

			case 'LightProbe':

				object = new LightProbe().fromJSON( data );

				break;

			case 'SkinnedMesh':

				geometry = getGeometry( data.geometry );
			 	material = getMaterial( data.material );

				object = new SkinnedMesh( geometry, material );

				if ( data.bindMode !== undefined ) object.bindMode = data.bindMode;
				if ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );
				if ( data.skeleton !== undefined ) object.skeleton = data.skeleton;

				break;

			case 'Mesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );

				object = new Mesh( geometry, material );

				break;

			case 'InstancedMesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );
				const count = data.count;
				const instanceMatrix = data.instanceMatrix;
				const instanceColor = data.instanceColor;

				object = new InstancedMesh( geometry, material, count );
				object.instanceMatrix = new BufferAttribute( new Float32Array( instanceMatrix.array ), 16 );
				if ( instanceColor !== undefined ) object.instanceColor = new BufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );

				break;

			case 'LOD':

				object = new LOD();

				break;

			case 'Line':

				object = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineLoop':

				object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineSegments':

				object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'PointCloud':
			case 'Points':

				object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'Sprite':

				object = new Sprite( getMaterial( data.material ) );

				break;

			case 'Group':

				object = new Group();

				break;

			case 'Bone':

				object = new Bone();

				break;

			default:

				object = new Object3D();

		}

		object.uuid = data.uuid;

		if ( data.name !== undefined ) object.name = data.name;

		if ( data.matrix !== undefined ) {

			object.matrix.fromArray( data.matrix );

			if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
			if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

		} else {

			if ( data.position !== undefined ) object.position.fromArray( data.position );
			if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
			if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
			if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

		}

		if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
		if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

		if ( data.shadow ) {

			if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
			if ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;
			if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
			if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
			if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

		}

		if ( data.visible !== undefined ) object.visible = data.visible;
		if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
		if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
		if ( data.userData !== undefined ) object.userData = data.userData;
		if ( data.layers !== undefined ) object.layers.mask = data.layers;

		if ( data.children !== undefined ) {

			const children = data.children;

			for ( let i = 0; i < children.length; i ++ ) {

				object.add( this.parseObject( children[ i ], geometries, materials, animations ) );

			}

		}

		if ( data.animations !== undefined ) {

			const objectAnimations = data.animations;

			for ( let i = 0; i < objectAnimations.length; i ++ ) {

				const uuid = objectAnimations[ i ];

				object.animations.push( animations[ uuid ] );

			}

		}

		if ( data.type === 'LOD' ) {

			if ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;

			const levels = data.levels;

			for ( let l = 0; l < levels.length; l ++ ) {

				const level = levels[ l ];
				const child = object.getObjectByProperty( 'uuid', level.object );

				if ( child !== undefined ) {

					object.addLevel( child, level.distance );

				}

			}

		}

		return object;

	}

	bindSkeletons( object, skeletons ) {

		if ( Object.keys( skeletons ).length === 0 ) return;

		object.traverse( function ( child ) {

			if ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {

				const skeleton = skeletons[ child.skeleton ];

				if ( skeleton === undefined ) {

					console.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );

				} else {

					child.bind( skeleton, child.bindMatrix );

				}

			}

		} );

	}

	/* DEPRECATED */

	setTexturePath( value ) {

		console.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );
		return this.setResourcePath( value );

	}

}

const TEXTURE_MAPPING = {
	UVMapping: UVMapping,
	CubeReflectionMapping: CubeReflectionMapping,
	CubeRefractionMapping: CubeRefractionMapping,
	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
	CubeUVReflectionMapping: CubeUVReflectionMapping,
	CubeUVRefractionMapping: CubeUVRefractionMapping
};

const TEXTURE_WRAPPING = {
	RepeatWrapping: RepeatWrapping,
	ClampToEdgeWrapping: ClampToEdgeWrapping,
	MirroredRepeatWrapping: MirroredRepeatWrapping
};

const TEXTURE_FILTER = {
	NearestFilter: NearestFilter,
	NearestMipmapNearestFilter: NearestMipmapNearestFilter,
	NearestMipmapLinearFilter: NearestMipmapLinearFilter,
	LinearFilter: LinearFilter,
	LinearMipmapNearestFilter: LinearMipmapNearestFilter,
	LinearMipmapLinearFilter: LinearMipmapLinearFilter
};

function ImageBitmapLoader( manager ) {

	if ( typeof createImageBitmap === 'undefined' ) {

		console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

	}

	if ( typeof fetch === 'undefined' ) {

		console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

	}

	Loader.call( this, manager );

	this.options = { premultiplyAlpha: 'none' };

}

ImageBitmapLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

	constructor: ImageBitmapLoader,

	isImageBitmapLoader: true,

	setOptions: function setOptions( options ) {

		this.options = options;

		return this;

	},

	load: function ( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const fetchOptions = {};
		fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';
		fetchOptions.headers = this.requestHeader;

		fetch( url, fetchOptions ).then( function ( res ) {

			return res.blob();

		} ).then( function ( blob ) {

			return createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );

		} ).then( function ( imageBitmap ) {

			Cache.add( url, imageBitmap );

			if ( onLoad ) onLoad( imageBitmap );

			scope.manager.itemEnd( url );

		} ).catch( function ( e ) {

			if ( onError ) onError( e );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		} );

		scope.manager.itemStart( url );

	}

} );

class ShapePath {

	constructor() {

		this.type = 'ShapePath';

		this.color = new Color();

		this.subPaths = [];
		this.currentPath = null;

	}

	moveTo( x, y ) {

		this.currentPath = new Path();
		this.subPaths.push( this.currentPath );
		this.currentPath.moveTo( x, y );

		return this;

	}

	lineTo( x, y ) {

		this.currentPath.lineTo( x, y );

		return this;

	}

	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

		return this;

	}

	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

		return this;

	}

	splineThru( pts ) {

		this.currentPath.splineThru( pts );

		return this;

	}

	toShapes( isCCW, noHoles ) {

		function toShapesNoHoles( inSubpaths ) {

			const shapes = [];

			for ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {

				const tmpPath = inSubpaths[ i ];

				const tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );

			}

			return shapes;

		}

		function isPointInsidePolygon( inPt, inPolygon ) {

			const polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			let inside = false;
			for ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

				let edgeLowPt = inPolygon[ p ];
				let edgeHighPt = inPolygon[ q ];

				let edgeDx = edgeHighPt.x - edgeLowPt.x;
				let edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

					// not parallel
					if ( edgeDy < 0 ) {

						edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

					}

					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y === edgeLowPt.y ) {

						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!

					} else {

						const perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt

					}

				} else {

					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;

				}

			}

			return	inside;

		}

		const isClockWise = ShapeUtils.isClockWise;

		const subPaths = this.subPaths;
		if ( subPaths.length === 0 ) return [];

		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


		let solid, tmpPath, tmpShape;
		const shapes = [];

		if ( subPaths.length === 1 ) {

			tmpPath = subPaths[ 0 ];
			tmpShape = new Shape();
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		let holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		const betterShapeHoles = [];
		const newShapes = [];
		let newShapeHoles = [];
		let mainIdx = 0;
		let tmpPoints;

		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];

		for ( let i = 0, l = subPaths.length; i < l; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.curves = tmpPath.curves;

				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {

			let ambiguous = false;
			const toChange = [];

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				betterShapeHoles[ sIdx ] = [];

			}

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				const sho = newShapeHoles[ sIdx ];

				for ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {

					const ho = sho[ hIdx ];
					let hole_unassigned = true;

					for ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {

								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );

							} else {

								ambiguous = true;

							}

						}

					}

					if ( hole_unassigned ) {

						betterShapeHoles[ sIdx ].push( ho );

					}

				}

			}
			// console.log("ambiguous: ", ambiguous);

			if ( toChange.length > 0 ) {

				// console.log("to change: ", toChange);
				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

			}

		}

		let tmpHoles;

		for ( let i = 0, il = newShapes.length; i < il; i ++ ) {

			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];

			for ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

				tmpShape.holes.push( tmpHoles[ j ].h );

			}

		}

		//console.log("shape", shapes);

		return shapes;

	}

}

class Font {

	constructor( data ) {

		this.type = 'Font';

		this.data = data;

	}

	generateShapes( text, size = 100 ) {

		const shapes = [];
		const paths = createPaths( text, size, this.data );

		for ( let p = 0, pl = paths.length; p < pl; p ++ ) {

			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

		}

		return shapes;

	}

}

function createPaths( text, size, data ) {

	const chars = Array.from( text );
	const scale = size / data.resolution;
	const line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

	const paths = [];

	let offsetX = 0, offsetY = 0;

	for ( let i = 0; i < chars.length; i ++ ) {

		const char = chars[ i ];

		if ( char === '\n' ) {

			offsetX = 0;
			offsetY -= line_height;

		} else {

			const ret = createPath( char, scale, offsetX, offsetY, data );
			offsetX += ret.offsetX;
			paths.push( ret.path );

		}

	}

	return paths;

}

function createPath( char, scale, offsetX, offsetY, data ) {

	const glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

	if ( ! glyph ) {

		console.error( 'THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.' );

		return;

	}

	const path = new ShapePath();

	let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

	if ( glyph.o ) {

		const outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

		for ( let i = 0, l = outline.length; i < l; ) {

			const action = outline[ i ++ ];

			switch ( action ) {

				case 'm': // moveTo

					x = outline[ i ++ ] * scale + offsetX;
					y = outline[ i ++ ] * scale + offsetY;

					path.moveTo( x, y );

					break;

				case 'l': // lineTo

					x = outline[ i ++ ] * scale + offsetX;
					y = outline[ i ++ ] * scale + offsetY;

					path.lineTo( x, y );

					break;

				case 'q': // quadraticCurveTo

					cpx = outline[ i ++ ] * scale + offsetX;
					cpy = outline[ i ++ ] * scale + offsetY;
					cpx1 = outline[ i ++ ] * scale + offsetX;
					cpy1 = outline[ i ++ ] * scale + offsetY;

					path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

					break;

				case 'b': // bezierCurveTo

					cpx = outline[ i ++ ] * scale + offsetX;
					cpy = outline[ i ++ ] * scale + offsetY;
					cpx1 = outline[ i ++ ] * scale + offsetX;
					cpy1 = outline[ i ++ ] * scale + offsetY;
					cpx2 = outline[ i ++ ] * scale + offsetX;
					cpy2 = outline[ i ++ ] * scale + offsetY;

					path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

					break;

			}

		}

	}

	return { offsetX: glyph.ha * scale, path: path };

}

Font.prototype.isFont = true;

class FontLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			let json;

			try {

				json = JSON.parse( text );

			} catch ( e ) {

				console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
				json = JSON.parse( text.substring( 65, text.length - 2 ) );

			}

			const font = scope.parse( json );

			if ( onLoad ) onLoad( font );

		}, onProgress, onError );

	}

	parse( json ) {

		return new Font( json );

	}

}

let _context;

const AudioContext = {

	getContext: function () {

		if ( _context === undefined ) {

			_context = new ( window.AudioContext || window.webkitAudioContext )();

		}

		return _context;

	},

	setContext: function ( value ) {

		_context = value;

	}

};

class AudioLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( buffer ) {

			try {

				// Create a copy of the buffer. The `decodeAudioData` method
				// detaches the buffer when complete, preventing reuse.
				const bufferCopy = buffer.slice( 0 );

				const context = AudioContext.getContext();
				context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

					onLoad( audioBuffer );

				} );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

}

class HemisphereLightProbe extends LightProbe {

	constructor( skyColor, groundColor, intensity = 1 ) {

		super( undefined, intensity );

		const color1 = new Color().set( skyColor );
		const color2 = new Color().set( groundColor );

		const sky = new Vector3( color1.r, color1.g, color1.b );
		const ground = new Vector3( color2.r, color2.g, color2.b );

		// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
		const c0 = Math.sqrt( Math.PI );
		const c1 = c0 * Math.sqrt( 0.75 );

		this.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );
		this.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );

	}

}

HemisphereLightProbe.prototype.isHemisphereLightProbe = true;

class AmbientLightProbe extends LightProbe {

	constructor( color, intensity = 1 ) {

		super( undefined, intensity );

		const color1 = new Color().set( color );

		// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
		this.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );

	}

}

AmbientLightProbe.prototype.isAmbientLightProbe = true;

const _eyeRight = new Matrix4();
const _eyeLeft = new Matrix4();

class StereoCamera {

	constructor() {

		this.type = 'StereoCamera';

		this.aspect = 1;

		this.eyeSep = 0.064;

		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;

		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;

		this._cache = {
			focus: null,
			fov: null,
			aspect: null,
			near: null,
			far: null,
			zoom: null,
			eyeSep: null
		};

	}

	update( camera ) {

		const cache = this._cache;

		const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
			cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
			cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

		if ( needsUpdate ) {

			cache.focus = camera.focus;
			cache.fov = camera.fov;
			cache.aspect = camera.aspect * this.aspect;
			cache.near = camera.near;
			cache.far = camera.far;
			cache.zoom = camera.zoom;
			cache.eyeSep = this.eyeSep;

			// Off-axis stereoscopic effect based on
			// http://paulbourke.net/stereographics/stereorender/

			const projectionMatrix = camera.projectionMatrix.clone();
			const eyeSepHalf = cache.eyeSep / 2;
			const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
			const ymax = ( cache.near * Math.tan( MathUtils.DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;
			let xmin, xmax;

			// translate xOffset

			_eyeLeft.elements[ 12 ] = - eyeSepHalf;
			_eyeRight.elements[ 12 ] = eyeSepHalf;

			// for left eye

			xmin = - ymax * cache.aspect + eyeSepOnProjection;
			xmax = ymax * cache.aspect + eyeSepOnProjection;

			projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraL.projectionMatrix.copy( projectionMatrix );

			// for right eye

			xmin = - ymax * cache.aspect - eyeSepOnProjection;
			xmax = ymax * cache.aspect - eyeSepOnProjection;

			projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraR.projectionMatrix.copy( projectionMatrix );

		}

		this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );
		this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );

	}

}

class Clock {

	constructor( autoStart ) {

		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	}

	start() {

		this.startTime = now();

		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;

	}

	stop() {

		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;

	}

	getElapsedTime() {

		this.getDelta();
		return this.elapsedTime;

	}

	getDelta() {

		let diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();
			return 0;

		}

		if ( this.running ) {

			const newTime = now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

}

function now() {

	return ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

}

const _position$1 = /*@__PURE__*/ new Vector3();
const _quaternion$1 = /*@__PURE__*/ new Quaternion();
const _scale$1 = /*@__PURE__*/ new Vector3();
const _orientation$1 = /*@__PURE__*/ new Vector3();

class AudioListener extends Object3D {

	constructor() {

		super();

		this.type = 'AudioListener';

		this.context = AudioContext.getContext();

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.filter = null;

		this.timeDelta = 0;

		// private

		this._clock = new Clock();

	}

	getInput() {

		return this.gain;

	}

	removeFilter() {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
			this.gain.connect( this.context.destination );
			this.filter = null;

		}

		return this;

	}

	getFilter() {

		return this.filter;

	}

	setFilter( value ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );

		} else {

			this.gain.disconnect( this.context.destination );

		}

		this.filter = value;
		this.gain.connect( this.filter );
		this.filter.connect( this.context.destination );

		return this;

	}

	getMasterVolume() {

		return this.gain.gain.value;

	}

	setMasterVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		const listener = this.context.listener;
		const up = this.up;

		this.timeDelta = this._clock.getDelta();

		this.matrixWorld.decompose( _position$1, _quaternion$1, _scale$1 );

		_orientation$1.set( 0, 0, - 1 ).applyQuaternion( _quaternion$1 );

		if ( listener.positionX ) {

			// code path for Chrome (see #14393)

			const endTime = this.context.currentTime + this.timeDelta;

			listener.positionX.linearRampToValueAtTime( _position$1.x, endTime );
			listener.positionY.linearRampToValueAtTime( _position$1.y, endTime );
			listener.positionZ.linearRampToValueAtTime( _position$1.z, endTime );
			listener.forwardX.linearRampToValueAtTime( _orientation$1.x, endTime );
			listener.forwardY.linearRampToValueAtTime( _orientation$1.y, endTime );
			listener.forwardZ.linearRampToValueAtTime( _orientation$1.z, endTime );
			listener.upX.linearRampToValueAtTime( up.x, endTime );
			listener.upY.linearRampToValueAtTime( up.y, endTime );
			listener.upZ.linearRampToValueAtTime( up.z, endTime );

		} else {

			listener.setPosition( _position$1.x, _position$1.y, _position$1.z );
			listener.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z );

		}

	}

}

class Audio extends Object3D {

	constructor( listener ) {

		super();

		this.type = 'Audio';

		this.listener = listener;
		this.context = listener.context;

		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );

		this.autoplay = false;

		this.buffer = null;
		this.detune = 0;
		this.loop = false;
		this.loopStart = 0;
		this.loopEnd = 0;
		this.offset = 0;
		this.duration = undefined;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.source = null;
		this.sourceType = 'empty';

		this._startedAt = 0;
		this._progress = 0;
		this._connected = false;

		this.filters = [];

	}

	getOutput() {

		return this.gain;

	}

	setNodeSource( audioNode ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();

		return this;

	}

	setMediaElementSource( mediaElement ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaNode';
		this.source = this.context.createMediaElementSource( mediaElement );
		this.connect();

		return this;

	}

	setMediaStreamSource( mediaStream ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaStreamNode';
		this.source = this.context.createMediaStreamSource( mediaStream );
		this.connect();

		return this;

	}

	setBuffer( audioBuffer ) {

		this.buffer = audioBuffer;
		this.sourceType = 'buffer';

		if ( this.autoplay ) this.play();

		return this;

	}

	play( delay = 0 ) {

		if ( this.isPlaying === true ) {

			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._startedAt = this.context.currentTime + delay;

		const source = this.context.createBufferSource();
		source.buffer = this.buffer;
		source.loop = this.loop;
		source.loopStart = this.loopStart;
		source.loopEnd = this.loopEnd;
		source.onended = this.onEnded.bind( this );
		source.start( this._startedAt, this._progress + this.offset, this.duration );

		this.isPlaying = true;

		this.source = source;

		this.setDetune( this.detune );
		this.setPlaybackRate( this.playbackRate );

		return this.connect();

	}

	pause() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		if ( this.isPlaying === true ) {

			// update current progress

			this._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

			if ( this.loop === true ) {

				// ensure _progress does not exceed duration with looped audios

				this._progress = this._progress % ( this.duration || this.buffer.duration );

			}

			this.source.stop();
			this.source.onended = null;

			this.isPlaying = false;

		}

		return this;

	}

	stop() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._progress = 0;

		this.source.stop();
		this.source.onended = null;
		this.isPlaying = false;

		return this;

	}

	connect() {

		if ( this.filters.length > 0 ) {

			this.source.connect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].connect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

		} else {

			this.source.connect( this.getOutput() );

		}

		this._connected = true;

		return this;

	}

	disconnect() {

		if ( this.filters.length > 0 ) {

			this.source.disconnect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

		} else {

			this.source.disconnect( this.getOutput() );

		}

		this._connected = false;

		return this;

	}

	getFilters() {

		return this.filters;

	}

	setFilters( value ) {

		if ( ! value ) value = [];

		if ( this._connected === true ) {

			this.disconnect();
			this.filters = value.slice();
			this.connect();

		} else {

			this.filters = value.slice();

		}

		return this;

	}

	setDetune( value ) {

		this.detune = value;

		if ( this.source.detune === undefined ) return; // only set detune when available

		if ( this.isPlaying === true ) {

			this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

		}

		return this;

	}

	getDetune() {

		return this.detune;

	}

	getFilter() {

		return this.getFilters()[ 0 ];

	}

	setFilter( filter ) {

		return this.setFilters( filter ? [ filter ] : [] );

	}

	setPlaybackRate( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.playbackRate = value;

		if ( this.isPlaying === true ) {

			this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

		}

		return this;

	}

	getPlaybackRate() {

		return this.playbackRate;

	}

	onEnded() {

		this.isPlaying = false;

	}

	getLoop() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return false;

		}

		return this.loop;

	}

	setLoop( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.loop = value;

		if ( this.isPlaying === true ) {

			this.source.loop = this.loop;

		}

		return this;

	}

	setLoopStart( value ) {

		this.loopStart = value;

		return this;

	}

	setLoopEnd( value ) {

		this.loopEnd = value;

		return this;

	}

	getVolume() {

		return this.gain.gain.value;

	}

	setVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

}

const _position = /*@__PURE__*/ new Vector3();
const _quaternion = /*@__PURE__*/ new Quaternion();
const _scale = /*@__PURE__*/ new Vector3();
const _orientation = /*@__PURE__*/ new Vector3();

class PositionalAudio extends Audio {

	constructor( listener ) {

		super( listener );

		this.panner = this.context.createPanner();
		this.panner.panningModel = 'HRTF';
		this.panner.connect( this.gain );

	}

	getOutput() {

		return this.panner;

	}

	getRefDistance() {

		return this.panner.refDistance;

	}

	setRefDistance( value ) {

		this.panner.refDistance = value;

		return this;

	}

	getRolloffFactor() {

		return this.panner.rolloffFactor;

	}

	setRolloffFactor( value ) {

		this.panner.rolloffFactor = value;

		return this;

	}

	getDistanceModel() {

		return this.panner.distanceModel;

	}

	setDistanceModel( value ) {

		this.panner.distanceModel = value;

		return this;

	}

	getMaxDistance() {

		return this.panner.maxDistance;

	}

	setMaxDistance( value ) {

		this.panner.maxDistance = value;

		return this;

	}

	setDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

		this.panner.coneInnerAngle = coneInnerAngle;
		this.panner.coneOuterAngle = coneOuterAngle;
		this.panner.coneOuterGain = coneOuterGain;

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		if ( this.hasPlaybackControl === true && this.isPlaying === false ) return;

		this.matrixWorld.decompose( _position, _quaternion, _scale );

		_orientation.set( 0, 0, 1 ).applyQuaternion( _quaternion );

		const panner = this.panner;

		if ( panner.positionX ) {

			// code path for Chrome and Firefox (see #14393)

			const endTime = this.context.currentTime + this.listener.timeDelta;

			panner.positionX.linearRampToValueAtTime( _position.x, endTime );
			panner.positionY.linearRampToValueAtTime( _position.y, endTime );
			panner.positionZ.linearRampToValueAtTime( _position.z, endTime );
			panner.orientationX.linearRampToValueAtTime( _orientation.x, endTime );
			panner.orientationY.linearRampToValueAtTime( _orientation.y, endTime );
			panner.orientationZ.linearRampToValueAtTime( _orientation.z, endTime );

		} else {

			panner.setPosition( _position.x, _position.y, _position.z );
			panner.setOrientation( _orientation.x, _orientation.y, _orientation.z );

		}

	}

}

class AudioAnalyser {

	constructor( audio, fftSize = 2048 ) {

		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize;

		this.data = new Uint8Array( this.analyser.frequencyBinCount );

		audio.getOutput().connect( this.analyser );

	}


	getFrequencyData() {

		this.analyser.getByteFrequencyData( this.data );

		return this.data;

	}

	getAverageFrequency() {

		let value = 0;
		const data = this.getFrequencyData();

		for ( let i = 0; i < data.length; i ++ ) {

			value += data[ i ];

		}

		return value / data.length;

	}

}

class PropertyMixer {

	constructor( binding, typeName, valueSize ) {

		this.binding = binding;
		this.valueSize = valueSize;

		let mixFunction,
			mixFunctionAdditive,
			setIdentity;

		// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property
		//
		// 'add' is used for additive cumulative results
		//
		// 'work' is optional and is only present for quaternion types. It is used
		// to store intermediate quaternion multiplication results

		switch ( typeName ) {

			case 'quaternion':
				mixFunction = this._slerp;
				mixFunctionAdditive = this._slerpAdditive;
				setIdentity = this._setAdditiveIdentityQuaternion;

				this.buffer = new Float64Array( valueSize * 6 );
				this._workIndex = 5;
				break;

			case 'string':
			case 'bool':
				mixFunction = this._select;

				// Use the regular mix function and for additive on these types,
				// additive is not relevant for non-numeric types
				mixFunctionAdditive = this._select;

				setIdentity = this._setAdditiveIdentityOther;

				this.buffer = new Array( valueSize * 5 );
				break;

			default:
				mixFunction = this._lerp;
				mixFunctionAdditive = this._lerpAdditive;
				setIdentity = this._setAdditiveIdentityNumeric;

				this.buffer = new Float64Array( valueSize * 5 );

		}

		this._mixBufferRegion = mixFunction;
		this._mixBufferRegionAdditive = mixFunctionAdditive;
		this._setIdentity = setIdentity;
		this._origIndex = 3;
		this._addIndex = 4;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		this.useCount = 0;
		this.referenceCount = 0;

	}

	// accumulate data in the 'incoming' region into 'accu<i>'
	accumulate( accuIndex, weight ) {

		// note: happily accumulating nothing when weight = 0, the caller knows
		// the weight and shouldn't have made the call in the first place

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride;

		let currentWeight = this.cumulativeWeight;

		if ( currentWeight === 0 ) {

			// accuN := incoming * weight

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ offset + i ] = buffer[ i ];

			}

			currentWeight = weight;

		} else {

			// accuN := accuN + incoming * weight

			currentWeight += weight;
			const mix = weight / currentWeight;
			this._mixBufferRegion( buffer, offset, 0, mix, stride );

		}

		this.cumulativeWeight = currentWeight;

	}

	// accumulate data in the 'incoming' region into 'add'
	accumulateAdditive( weight ) {

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = stride * this._addIndex;

		if ( this.cumulativeWeightAdditive === 0 ) {

			// add = identity

			this._setIdentity();

		}

		// add := add + incoming * weight

		this._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );
		this.cumulativeWeightAdditive += weight;

	}

	// apply the state of 'accu<i>' to the binding when accus differ
	apply( accuIndex ) {

		const stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,

			weight = this.cumulativeWeight,
			weightAdditive = this.cumulativeWeightAdditive,

			binding = this.binding;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		if ( weight < 1 ) {

			// accuN := accuN + original * ( 1 - cumulativeWeight )

			const originalValueOffset = stride * this._origIndex;

			this._mixBufferRegion(
				buffer, offset, originalValueOffset, 1 - weight, stride );

		}

		if ( weightAdditive > 0 ) {

			// accuN := accuN + additive accuN

			this._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );

		}

		for ( let i = stride, e = stride + stride; i !== e; ++ i ) {

			if ( buffer[ i ] !== buffer[ i + stride ] ) {

				// value has changed -> update scene graph

				binding.setValue( buffer, offset );
				break;

			}

		}

	}

	// remember the state of the bound property and copy it to both accus
	saveOriginalState() {

		const binding = this.binding;

		const buffer = this.buffer,
			stride = this.valueSize,

			originalValueOffset = stride * this._origIndex;

		binding.getValue( buffer, originalValueOffset );

		// accu[0..1] := orig -- initially detect changes against the original
		for ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {

			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		}

		// Add to identity for additive
		this._setIdentity();

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

	}

	// apply the state previously taken via 'saveOriginalState' to the binding
	restoreOriginalState() {

		const originalValueOffset = this.valueSize * 3;
		this.binding.setValue( this.buffer, originalValueOffset );

	}

	_setAdditiveIdentityNumeric() {

		const startIndex = this._addIndex * this.valueSize;
		const endIndex = startIndex + this.valueSize;

		for ( let i = startIndex; i < endIndex; i ++ ) {

			this.buffer[ i ] = 0;

		}

	}

	_setAdditiveIdentityQuaternion() {

		this._setAdditiveIdentityNumeric();
		this.buffer[ this._addIndex * this.valueSize + 3 ] = 1;

	}

	_setAdditiveIdentityOther() {

		const startIndex = this._origIndex * this.valueSize;
		const targetIndex = this._addIndex * this.valueSize;

		for ( let i = 0; i < this.valueSize; i ++ ) {

			this.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];

		}

	}


	// mix functions

	_select( buffer, dstOffset, srcOffset, t, stride ) {

		if ( t >= 0.5 ) {

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			}

		}

	}

	_slerp( buffer, dstOffset, srcOffset, t ) {

		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

	}

	_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		const workOffset = this._workIndex * stride;

		// Store result in intermediate buffer offset
		Quaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );

		// Slerp to the intermediate result
		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );

	}

	_lerp( buffer, dstOffset, srcOffset, t, stride ) {

		const s = 1 - t;

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		}

	}

	_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;

		}

	}

}

// Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

const _trackRe = new RegExp( ''
	+ '^'
	+ _directoryRe
	+ _nodeRe
	+ _objectRe
	+ _propertyRe
	+ '$'
);

const _supportedObjectNames = [ 'material', 'materials', 'bones' ];

function Composite( targetGroup, path, optionalParsedPath ) {

	const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

	this._targetGroup = targetGroup;
	this._bindings = targetGroup.subscribe_( path, parsedPath );

}

Object.assign( Composite.prototype, {

	getValue: function ( array, offset ) {

		this.bind(); // bind all binding

		const firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	},

	setValue: function ( array, offset ) {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	},

	bind: function () {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	},

	unbind: function () {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

} );


function PropertyBinding( rootNode, path, parsedPath ) {

	this.path = path;
	this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

	this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

	this.rootNode = rootNode;

}

Object.assign( PropertyBinding, {

	Composite: Composite,

	create: function ( root, path, parsedPath ) {

		if ( ! ( root && root.isAnimationObjectGroup ) ) {

			return new PropertyBinding( root, path, parsedPath );

		} else {

			return new PropertyBinding.Composite( root, path, parsedPath );

		}

	},

	/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */
	sanitizeNodeName: function ( name ) {

		return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

	},

	parseTrackName: function ( trackName ) {

		const matches = _trackRe.exec( trackName );

		if ( ! matches ) {

			throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

		}

		const results = {
			// directoryName: matches[ 1 ], // (tschw) currently unused
			nodeName: matches[ 2 ],
			objectName: matches[ 3 ],
			objectIndex: matches[ 4 ],
			propertyName: matches[ 5 ], // required
			propertyIndex: matches[ 6 ]
		};

		const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

		if ( lastDot !== undefined && lastDot !== - 1 ) {

			const objectName = results.nodeName.substring( lastDot + 1 );

			// Object names must be checked against an allowlist. Otherwise, there
			// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
			// 'bar' could be the objectName, or part of a nodeName (which can
			// include '.' characters).
			if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

				results.nodeName = results.nodeName.substring( 0, lastDot );
				results.objectName = objectName;

			}

		}

		if ( results.propertyName === null || results.propertyName.length === 0 ) {

			throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

		}

		return results;

	},

	findNode: function ( root, nodeName ) {

		if ( ! nodeName || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

			return root;

		}

		// search into skeleton bones.
		if ( root.skeleton ) {

			const bone = root.skeleton.getBoneByName( nodeName );

			if ( bone !== undefined ) {

				return bone;

			}

		}

		// search into node subtree.
		if ( root.children ) {

			const searchNodeSubtree = function ( children ) {

				for ( let i = 0; i < children.length; i ++ ) {

					const childNode = children[ i ];

					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

						return childNode;

					}

					const result = searchNodeSubtree( childNode.children );

					if ( result ) return result;

				}

				return null;

			};

			const subTreeNode = searchNodeSubtree( root.children );

			if ( subTreeNode ) {

				return subTreeNode;

			}

		}

		return null;

	}

} );

Object.assign( PropertyBinding.prototype, { // prototype, continued

	// these are used to "bind" a nonexistent property
	_getValue_unavailable: function () {},
	_setValue_unavailable: function () {},

	BindingType: {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	},

	Versioning: {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	},

	GetterByBindingType: [

		function getValue_direct( buffer, offset ) {

			buffer[ offset ] = this.node[ this.propertyName ];

		},

		function getValue_array( buffer, offset ) {

			const source = this.resolvedProperty;

			for ( let i = 0, n = source.length; i !== n; ++ i ) {

				buffer[ offset ++ ] = source[ i ];

			}

		},

		function getValue_arrayElement( buffer, offset ) {

			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

		},

		function getValue_toArray( buffer, offset ) {

			this.resolvedProperty.toArray( buffer, offset );

		}

	],

	SetterByBindingTypeAndVersioning: [

		[
			// Direct

			function setValue_direct( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];

			},

			function setValue_direct_setNeedsUpdate( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// EntireArray

			function setValue_array( buffer, offset ) {

				const dest = this.resolvedProperty;

				for ( let i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

			},

			function setValue_array_setNeedsUpdate( buffer, offset ) {

				const dest = this.resolvedProperty;

				for ( let i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.needsUpdate = true;

			},

			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

				const dest = this.resolvedProperty;

				for ( let i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// ArrayElement

			function setValue_arrayElement( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

			},

			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// HasToFromArray

			function setValue_fromArray( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );

			},

			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.needsUpdate = true;

			},

			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		]

	],

	getValue: function getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

		// Note: This class uses a State pattern on a per-method basis:
		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
		// prototype version of these methods with one that represents
		// the bound state. When the property is not found, the methods
		// become no-ops.

	},

	setValue: function getValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	},

	// create getter / setter pair for a property in the scene graph
	bind: function () {

		let targetObject = this.node;
		const parsedPath = this.parsedPath;

		const objectName = parsedPath.objectName;
		const propertyName = parsedPath.propertyName;
		let propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

		// ensure there is a value node
		if ( ! targetObject ) {

			console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
			return;

		}

		if ( objectName ) {

			let objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.materials ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if ( ! targetObject.skeleton ) {

						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( let i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[ i ].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {

				if ( targetObject[ objectIndex ] === undefined ) {

					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		const nodeProperty = targetObject[ propertyName ];

		if ( nodeProperty === undefined ) {

			const nodeName = parsedPath.nodeName;

			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
				'.' + propertyName + ' but it wasn\'t found.', targetObject );
			return;

		}

		// determine versioning scheme
		let versioning = this.Versioning.None;

		this.targetObject = targetObject;

		if ( targetObject.needsUpdate !== undefined ) { // material

			versioning = this.Versioning.NeedsUpdate;

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;

		}

		// determine how the property gets bound
		let bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {

			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === 'morphTargetInfluences' ) {

				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
					return;

				}

				if ( targetObject.geometry.isBufferGeometry ) {

					if ( ! targetObject.geometry.morphAttributes ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
						return;

					}

					if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

						propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

					}


				} else {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );
					return;

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( Array.isArray( nodeProperty ) ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	},

	unbind: function () {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

} );

// DECLARE ALIAS AFTER assign prototype
Object.assign( PropertyBinding.prototype, {

	// initial state of these methods that calls 'bind'
	_getValue_unbound: PropertyBinding.prototype.getValue,
	_setValue_unbound: PropertyBinding.prototype.setValue,

} );

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */

class AnimationObjectGroup {

	constructor() {

		this.uuid = MathUtils.generateUUID();

		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );

		this.nCachedObjects_ = 0; // threshold
		// note: read by PropertyBinding.Composite

		const indices = {};
		this._indicesByUUID = indices; // for bookkeeping

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			indices[ arguments[ i ].uuid ] = i;

		}

		this._paths = []; // inside: string
		this._parsedPaths = []; // inside: { we don't care, here }
		this._bindings = []; // inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; // inside: indices in these arrays

		const scope = this;

		this.stats = {

			objects: {
				get total() {

					return scope._objects.length;

				},
				get inUse() {

					return this.total - scope.nCachedObjects_;

				}
			},
			get bindingsPerObject() {

				return scope._bindings.length;

			}

		};

	}

	add() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			paths = this._paths,
			parsedPaths = this._parsedPaths,
			bindings = this._bindings,
			nBindings = bindings.length;

		let knownObject = undefined,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid;
			let index = indicesByUUID[ uuid ];

			if ( index === undefined ) {

				// unknown object -> add it to the ACTIVE region

				index = nObjects ++;
				indicesByUUID[ uuid ] = index;
				objects.push( object );

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

				}

			} else if ( index < nCachedObjects ) {

				knownObject = objects[ index ];

				// move existing object to the ACTIVE region

				const firstActiveIndex = -- nCachedObjects,
					lastCachedObject = objects[ firstActiveIndex ];

				indicesByUUID[ lastCachedObject.uuid ] = index;
				objects[ index ] = lastCachedObject;

				indicesByUUID[ uuid ] = firstActiveIndex;
				objects[ firstActiveIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						lastCached = bindingsForPath[ firstActiveIndex ];

					let binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = lastCached;

					if ( binding === undefined ) {

						// since we do not bother to create new bindings
						// for objects that are cached, the binding may
						// or may not exist

						binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

					}

					bindingsForPath[ firstActiveIndex ] = binding;

				}

			} else if ( objects[ index ] !== knownObject ) {

				console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
					'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

			} // else the object is already where we want it to be

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	remove() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined && index >= nCachedObjects ) {

				// move existing object into the CACHED region

				const lastCachedIndex = nCachedObjects ++,
					firstActiveObject = objects[ lastCachedIndex ];

				indicesByUUID[ firstActiveObject.uuid ] = index;
				objects[ index ] = firstActiveObject;

				indicesByUUID[ uuid ] = lastCachedIndex;
				objects[ lastCachedIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						firstActive = bindingsForPath[ lastCachedIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = firstActive;
					bindingsForPath[ lastCachedIndex ] = binding;

				}

			}

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	// remove & forget
	uncache() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_,
			nObjects = objects.length;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined ) {

				delete indicesByUUID[ uuid ];

				if ( index < nCachedObjects ) {

					// object is cached, shrink the CACHED region

					const firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ],
						lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					// last cached object takes this object's place
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					// last object goes to the activated slot and pop
					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							last = bindingsForPath[ lastIndex ];

						bindingsForPath[ index ] = lastCached;
						bindingsForPath[ firstActiveIndex ] = last;
						bindingsForPath.pop();

					}

				} else {

					// object is active, just swap with the last and pop

					const lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					if ( lastIndex > 0 ) {

						indicesByUUID[ lastObject.uuid ] = index;

					}

					objects[ index ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ];

						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
						bindingsForPath.pop();

					}

				} // cached or active

			} // if object is known

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	// Internal interface used by befriended PropertyBinding.Composite:

	subscribe_( path, parsedPath ) {

		// returns an array of bindings for the given path that is changed
		// according to the contained objects in the group

		const indicesByPath = this._bindingsIndicesByPath;
		let index = indicesByPath[ path ];
		const bindings = this._bindings;

		if ( index !== undefined ) return bindings[ index ];

		const paths = this._paths,
			parsedPaths = this._parsedPaths,
			objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			bindingsForPath = new Array( nObjects );

		index = bindings.length;

		indicesByPath[ path ] = index;

		paths.push( path );
		parsedPaths.push( parsedPath );
		bindings.push( bindingsForPath );

		for ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

			const object = objects[ i ];
			bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

		}

		return bindingsForPath;

	}

	unsubscribe_( path ) {

		// tells the group to forget about a property path and no longer
		// update the array previously obtained with 'subscribe_'

		const indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ];

		if ( index !== undefined ) {

			const paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				lastBindingsIndex = bindings.length - 1,
				lastBindings = bindings[ lastBindingsIndex ],
				lastBindingsPath = path[ lastBindingsIndex ];

			indicesByPath[ lastBindingsPath ] = index;

			bindings[ index ] = lastBindings;
			bindings.pop();

			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
			parsedPaths.pop();

			paths[ index ] = paths[ lastBindingsIndex ];
			paths.pop();

		}

	}

}

AnimationObjectGroup.prototype.isAnimationObjectGroup = true;

class AnimationAction {

	constructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {

		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot;
		this.blendMode = blendMode;

		const tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );

		const interpolantSettings = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};

		for ( let i = 0; i !== nTracks; ++ i ) {

			const interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings;

		}

		this._interpolantSettings = interpolantSettings;

		this._interpolants = interpolants; // bound by the mixer

		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );

		this._cacheIndex = null; // for the memory manager
		this._byClipCacheIndex = null; // for the memory manager

		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;

		this.loop = LoopRepeat;
		this._loopCount = - 1;

		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;

		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;

		this.timeScale = 1;
		this._effectiveTimeScale = 1;

		this.weight = 1;
		this._effectiveWeight = 1;

		this.repetitions = Infinity; // no. of repetitions when looping

		this.paused = false; // true -> zero effective time scale
		this.enabled = true; // false -> zero effective weight

		this.clampWhenFinished = false;// keep feeding the last frame?

		this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd = true;// clips for start, loop and end

	}

	// State & Scheduling

	play() {

		this._mixer._activateAction( this );

		return this;

	}

	stop() {

		this._mixer._deactivateAction( this );

		return this.reset();

	}

	reset() {

		this.paused = false;
		this.enabled = true;

		this.time = 0; // restart clip
		this._loopCount = - 1;// forget previous loops
		this._startTime = null;// forget scheduling

		return this.stopFading().stopWarping();

	}

	isRunning() {

		return this.enabled && ! this.paused && this.timeScale !== 0 &&
			this._startTime === null && this._mixer._isActiveAction( this );

	}

	// return true when play has been called
	isScheduled() {

		return this._mixer._isActiveAction( this );

	}

	startAt( time ) {

		this._startTime = time;

		return this;

	}

	setLoop( mode, repetitions ) {

		this.loop = mode;
		this.repetitions = repetitions;

		return this;

	}

	// Weight

	// set the weight stopping any scheduled fading
	// although .enabled = false yields an effective weight of zero, this
	// method does *not* change .enabled, because it would be confusing
	setEffectiveWeight( weight ) {

		this.weight = weight;

		// note: same logic as when updated at runtime
		this._effectiveWeight = this.enabled ? weight : 0;

		return this.stopFading();

	}

	// return the weight considering fading and .enabled
	getEffectiveWeight() {

		return this._effectiveWeight;

	}

	fadeIn( duration ) {

		return this._scheduleFading( duration, 0, 1 );

	}

	fadeOut( duration ) {

		return this._scheduleFading( duration, 1, 0 );

	}

	crossFadeFrom( fadeOutAction, duration, warp ) {

		fadeOutAction.fadeOut( duration );
		this.fadeIn( duration );

		if ( warp ) {

			const fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration,

				startEndRatio = fadeOutDuration / fadeInDuration,
				endStartRatio = fadeInDuration / fadeOutDuration;

			fadeOutAction.warp( 1.0, startEndRatio, duration );
			this.warp( endStartRatio, 1.0, duration );

		}

		return this;

	}

	crossFadeTo( fadeInAction, duration, warp ) {

		return fadeInAction.crossFadeFrom( this, duration, warp );

	}

	stopFading() {

		const weightInterpolant = this._weightInterpolant;

		if ( weightInterpolant !== null ) {

			this._weightInterpolant = null;
			this._mixer._takeBackControlInterpolant( weightInterpolant );

		}

		return this;

	}

	// Time Scale Control

	// set the time scale stopping any scheduled warping
	// although .paused = true yields an effective time scale of zero, this
	// method does *not* change .paused, because it would be confusing
	setEffectiveTimeScale( timeScale ) {

		this.timeScale = timeScale;
		this._effectiveTimeScale = this.paused ? 0 : timeScale;

		return this.stopWarping();

	}

	// return the time scale considering warping and .paused
	getEffectiveTimeScale() {

		return this._effectiveTimeScale;

	}

	setDuration( duration ) {

		this.timeScale = this._clip.duration / duration;

		return this.stopWarping();

	}

	syncWith( action ) {

		this.time = action.time;
		this.timeScale = action.timeScale;

		return this.stopWarping();

	}

	halt( duration ) {

		return this.warp( this._effectiveTimeScale, 0, duration );

	}

	warp( startTimeScale, endTimeScale, duration ) {

		const mixer = this._mixer,
			now = mixer.time,
			timeScale = this.timeScale;

		let interpolant = this._timeScaleInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._timeScaleInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		times[ 1 ] = now + duration;

		values[ 0 ] = startTimeScale / timeScale;
		values[ 1 ] = endTimeScale / timeScale;

		return this;

	}

	stopWarping() {

		const timeScaleInterpolant = this._timeScaleInterpolant;

		if ( timeScaleInterpolant !== null ) {

			this._timeScaleInterpolant = null;
			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

		}

		return this;

	}

	// Object Accessors

	getMixer() {

		return this._mixer;

	}

	getClip() {

		return this._clip;

	}

	getRoot() {

		return this._localRoot || this._mixer._root;

	}

	// Interna

	_update( time, deltaTime, timeDirection, accuIndex ) {

		// called by the mixer

		if ( ! this.enabled ) {

			// call ._updateWeight() to update ._effectiveWeight

			this._updateWeight( time );
			return;

		}

		const startTime = this._startTime;

		if ( startTime !== null ) {

			// check for scheduled start of action

			const timeRunning = ( time - startTime ) * timeDirection;
			if ( timeRunning < 0 || timeDirection === 0 ) {

				return; // yet to come / don't decide when delta = 0

			}

			// start

			this._startTime = null; // unschedule
			deltaTime = timeDirection * timeRunning;

		}

		// apply time scale and advance time

		deltaTime *= this._updateTimeScale( time );
		const clipTime = this._updateTime( deltaTime );

		// note: _updateTime may disable the action resulting in
		// an effective weight of 0

		const weight = this._updateWeight( time );

		if ( weight > 0 ) {

			const interpolants = this._interpolants;
			const propertyMixers = this._propertyBindings;

			switch ( this.blendMode ) {

				case AdditiveAnimationBlendMode:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulateAdditive( weight );

					}

					break;

				case NormalAnimationBlendMode:
				default:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulate( accuIndex, weight );

					}

			}

		}

	}

	_updateWeight( time ) {

		let weight = 0;

		if ( this.enabled ) {

			weight = this.weight;
			const interpolant = this._weightInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				weight *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopFading();

					if ( interpolantValue === 0 ) {

						// faded out, disable
						this.enabled = false;

					}

				}

			}

		}

		this._effectiveWeight = weight;
		return weight;

	}

	_updateTimeScale( time ) {

		let timeScale = 0;

		if ( ! this.paused ) {

			timeScale = this.timeScale;

			const interpolant = this._timeScaleInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				timeScale *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopWarping();

					if ( timeScale === 0 ) {

						// motion has halted, pause
						this.paused = true;

					} else {

						// warp done - apply final time scale
						this.timeScale = timeScale;

					}

				}

			}

		}

		this._effectiveTimeScale = timeScale;
		return timeScale;

	}

	_updateTime( deltaTime ) {

		const duration = this._clip.duration;
		const loop = this.loop;

		let time = this.time + deltaTime;
		let loopCount = this._loopCount;

		const pingPong = ( loop === LoopPingPong );

		if ( deltaTime === 0 ) {

			if ( loopCount === - 1 ) return time;

			return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

		}

		if ( loop === LoopOnce ) {

			if ( loopCount === - 1 ) {

				// just started

				this._loopCount = 0;
				this._setEndings( true, true, false );

			}

			handle_stop: {

				if ( time >= duration ) {

					time = duration;

				} else if ( time < 0 ) {

					time = 0;

				} else {

					this.time = time;

					break handle_stop;

				}

				if ( this.clampWhenFinished ) this.paused = true;
				else this.enabled = false;

				this.time = time;

				this._mixer.dispatchEvent( {
					type: 'finished', action: this,
					direction: deltaTime < 0 ? - 1 : 1
				} );

			}

		} else { // repetitive Repeat or PingPong

			if ( loopCount === - 1 ) {

				// just started

				if ( deltaTime >= 0 ) {

					loopCount = 0;

					this._setEndings( true, this.repetitions === 0, pingPong );

				} else {

					// when looping in reverse direction, the initial
					// transition through zero counts as a repetition,
					// so leave loopCount at -1

					this._setEndings( this.repetitions === 0, true, pingPong );

				}

			}

			if ( time >= duration || time < 0 ) {

				// wrap around

				const loopDelta = Math.floor( time / duration ); // signed
				time -= duration * loopDelta;

				loopCount += Math.abs( loopDelta );

				const pending = this.repetitions - loopCount;

				if ( pending <= 0 ) {

					// have to stop (switch state, clamp time, fire event)

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					time = deltaTime > 0 ? duration : 0;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime > 0 ? 1 : - 1
					} );

				} else {

					// keep running

					if ( pending === 1 ) {

						// entering the last round

						const atStart = deltaTime < 0;
						this._setEndings( atStart, ! atStart, pingPong );

					} else {

						this._setEndings( false, false, pingPong );

					}

					this._loopCount = loopCount;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'loop', action: this, loopDelta: loopDelta
					} );

				}

			} else {

				this.time = time;

			}

			if ( pingPong && ( loopCount & 1 ) === 1 ) {

				// invert time for the "pong round"

				return duration - time;

			}

		}

		return time;

	}

	_setEndings( atStart, atEnd, pingPong ) {

		const settings = this._interpolantSettings;

		if ( pingPong ) {

			settings.endingStart = ZeroSlopeEnding;
			settings.endingEnd = ZeroSlopeEnding;

		} else {

			// assuming for LoopOnce atStart == atEnd == true

			if ( atStart ) {

				settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingStart = WrapAroundEnding;

			}

			if ( atEnd ) {

				settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingEnd 	 = WrapAroundEnding;

			}

		}

	}

	_scheduleFading( duration, weightNow, weightThen ) {

		const mixer = this._mixer, now = mixer.time;
		let interpolant = this._weightInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._weightInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		values[ 0 ] = weightNow;
		times[ 1 ] = now + duration;
		values[ 1 ] = weightThen;

		return this;

	}

}

class AnimationMixer extends EventDispatcher {

	constructor( root ) {

		super();

		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;
		this.time = 0;
		this.timeScale = 1.0;

	}

	_bindAction( action, prototypeAction ) {

		const root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName;

		let bindingsByName = bindingsByRoot[ rootUuid ];

		if ( bindingsByName === undefined ) {

			bindingsByName = {};
			bindingsByRoot[ rootUuid ] = bindingsByName;

		}

		for ( let i = 0; i !== nTracks; ++ i ) {

			const track = tracks[ i ],
				trackName = track.name;

			let binding = bindingsByName[ trackName ];

			if ( binding !== undefined ) {

				bindings[ i ] = binding;

			} else {

				binding = bindings[ i ];

				if ( binding !== undefined ) {

					// existing binding, make sure the cache knows

					if ( binding._cacheIndex === null ) {

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

					}

					continue;

				}

				const path = prototypeAction && prototypeAction.
					_propertyBindings[ i ].binding.parsedPath;

				binding = new PropertyMixer(
					PropertyBinding.create( root, trackName, path ),
					track.ValueTypeName, track.getValueSize() );

				++ binding.referenceCount;
				this._addInactiveBinding( binding, rootUuid, trackName );

				bindings[ i ] = binding;

			}

			interpolants[ i ].resultBuffer = binding.buffer;

		}

	}

	_activateAction( action ) {

		if ( ! this._isActiveAction( action ) ) {

			if ( action._cacheIndex === null ) {

				// this action has been forgotten by the cache, but the user
				// appears to be still using it -> rebind

				const rootUuid = ( action._localRoot || this._root ).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[ clipUuid ];

				this._bindAction( action,
					actionsForClip && actionsForClip.knownActions[ 0 ] );

				this._addInactiveAction( action, clipUuid, rootUuid );

			}

			const bindings = action._propertyBindings;

			// increment reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( binding.useCount ++ === 0 ) {

					this._lendBinding( binding );
					binding.saveOriginalState();

				}

			}

			this._lendAction( action );

		}

	}

	_deactivateAction( action ) {

		if ( this._isActiveAction( action ) ) {

			const bindings = action._propertyBindings;

			// decrement reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( -- binding.useCount === 0 ) {

					binding.restoreOriginalState();
					this._takeBackBinding( binding );

				}

			}

			this._takeBackAction( action );

		}

	}

	// Memory manager

	_initMemoryManager() {

		this._actions = []; // 'nActiveActions' followed by inactive ones
		this._nActiveActions = 0;

		this._actionsByClip = {};
		// inside:
		// {
		// 	knownActions: Array< AnimationAction > - used as prototypes
		// 	actionByRoot: AnimationAction - lookup
		// }


		this._bindings = []; // 'nActiveBindings' followed by inactive ones
		this._nActiveBindings = 0;

		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		this._controlInterpolants = []; // same game as above
		this._nActiveControlInterpolants = 0;

		const scope = this;

		this.stats = {

			actions: {
				get total() {

					return scope._actions.length;

				},
				get inUse() {

					return scope._nActiveActions;

				}
			},
			bindings: {
				get total() {

					return scope._bindings.length;

				},
				get inUse() {

					return scope._nActiveBindings;

				}
			},
			controlInterpolants: {
				get total() {

					return scope._controlInterpolants.length;

				},
				get inUse() {

					return scope._nActiveControlInterpolants;

				}
			}

		};

	}

	// Memory management for AnimationAction objects

	_isActiveAction( action ) {

		const index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;

	}

	_addInactiveAction( action, clipUuid, rootUuid ) {

		const actions = this._actions,
			actionsByClip = this._actionsByClip;

		let actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip === undefined ) {

			actionsForClip = {

				knownActions: [ action ],
				actionByRoot: {}

			};

			action._byClipCacheIndex = 0;

			actionsByClip[ clipUuid ] = actionsForClip;

		} else {

			const knownActions = actionsForClip.knownActions;

			action._byClipCacheIndex = knownActions.length;
			knownActions.push( action );

		}

		action._cacheIndex = actions.length;
		actions.push( action );

		actionsForClip.actionByRoot[ rootUuid ] = action;

	}

	_removeInactiveAction( action ) {

		const actions = this._actions,
			lastInactiveAction = actions[ actions.length - 1 ],
			cacheIndex = action._cacheIndex;

		lastInactiveAction._cacheIndex = cacheIndex;
		actions[ cacheIndex ] = lastInactiveAction;
		actions.pop();

		action._cacheIndex = null;


		const clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ],
			knownActionsForClip = actionsForClip.knownActions,

			lastKnownAction =
				knownActionsForClip[ knownActionsForClip.length - 1 ],

			byClipCacheIndex = action._byClipCacheIndex;

		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		knownActionsForClip.pop();

		action._byClipCacheIndex = null;


		const actionByRoot = actionsForClip.actionByRoot,
			rootUuid = ( action._localRoot || this._root ).uuid;

		delete actionByRoot[ rootUuid ];

		if ( knownActionsForClip.length === 0 ) {

			delete actionsByClip[ clipUuid ];

		}

		this._removeInactiveBindingsForAction( action );

	}

	_removeInactiveBindingsForAction( action ) {

		const bindings = action._propertyBindings;

		for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

			const binding = bindings[ i ];

			if ( -- binding.referenceCount === 0 ) {

				this._removeInactiveBinding( binding );

			}

		}

	}

	_lendAction( action ) {

		// [ active actions |  inactive actions  ]
		// [  active actions >| inactive actions ]
		//                 s        a
		//                  <-swap->
		//                 a        s

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			lastActiveIndex = this._nActiveActions ++,

			firstInactiveAction = actions[ lastActiveIndex ];

		action._cacheIndex = lastActiveIndex;
		actions[ lastActiveIndex ] = action;

		firstInactiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = firstInactiveAction;

	}

	_takeBackAction( action ) {

		// [  active actions  | inactive actions ]
		// [ active actions |< inactive actions  ]
		//        a        s
		//         <-swap->
		//        s        a

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			firstInactiveIndex = -- this._nActiveActions,

			lastActiveAction = actions[ firstInactiveIndex ];

		action._cacheIndex = firstInactiveIndex;
		actions[ firstInactiveIndex ] = action;

		lastActiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = lastActiveAction;

	}

	// Memory management for PropertyMixer objects

	_addInactiveBinding( binding, rootUuid, trackName ) {

		const bindingsByRoot = this._bindingsByRootAndName,
			bindings = this._bindings;

		let bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName === undefined ) {

			bindingByName = {};
			bindingsByRoot[ rootUuid ] = bindingByName;

		}

		bindingByName[ trackName ] = binding;

		binding._cacheIndex = bindings.length;
		bindings.push( binding );

	}

	_removeInactiveBinding( binding ) {

		const bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			lastInactiveBinding = bindings[ bindings.length - 1 ],
			cacheIndex = binding._cacheIndex;

		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[ cacheIndex ] = lastInactiveBinding;
		bindings.pop();

		delete bindingByName[ trackName ];

		if ( Object.keys( bindingByName ).length === 0 ) {

			delete bindingsByRoot[ rootUuid ];

		}

	}

	_lendBinding( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			lastActiveIndex = this._nActiveBindings ++,

			firstInactiveBinding = bindings[ lastActiveIndex ];

		binding._cacheIndex = lastActiveIndex;
		bindings[ lastActiveIndex ] = binding;

		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = firstInactiveBinding;

	}

	_takeBackBinding( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			firstInactiveIndex = -- this._nActiveBindings,

			lastActiveBinding = bindings[ firstInactiveIndex ];

		binding._cacheIndex = firstInactiveIndex;
		bindings[ firstInactiveIndex ] = binding;

		lastActiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = lastActiveBinding;

	}


	// Memory management of Interpolants for weight and time scale

	_lendControlInterpolant() {

		const interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants ++;

		let interpolant = interpolants[ lastActiveIndex ];

		if ( interpolant === undefined ) {

			interpolant = new LinearInterpolant(
				new Float32Array( 2 ), new Float32Array( 2 ),
				1, this._controlInterpolantsResultBuffer );

			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[ lastActiveIndex ] = interpolant;

		}

		return interpolant;

	}

	_takeBackControlInterpolant( interpolant ) {

		const interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,

			firstInactiveIndex = -- this._nActiveControlInterpolants,

			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[ firstInactiveIndex ] = interpolant;

		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[ prevIndex ] = lastActiveInterpolant;

	}

	// return an action for a clip optionally using a custom root target
	// object (this method allocates a lot of dynamic memory in case a
	// previously unknown clip/root combination is specified)
	clipAction( clip, optionalRoot, blendMode ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid;

		let clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;

		const clipUuid = clipObject !== null ? clipObject.uuid : clip;

		const actionsForClip = this._actionsByClip[ clipUuid ];
		let prototypeAction = null;

		if ( blendMode === undefined ) {

			if ( clipObject !== null ) {

				blendMode = clipObject.blendMode;

			} else {

				blendMode = NormalAnimationBlendMode;

			}

		}

		if ( actionsForClip !== undefined ) {

			const existingAction = actionsForClip.actionByRoot[ rootUuid ];

			if ( existingAction !== undefined && existingAction.blendMode === blendMode ) {

				return existingAction;

			}

			// we know the clip, so we don't have to parse all
			// the bindings again but can just copy
			prototypeAction = actionsForClip.knownActions[ 0 ];

			// also, take the clip from the prototype action
			if ( clipObject === null )
				clipObject = prototypeAction._clip;

		}

		// clip must be known when specified via string
		if ( clipObject === null ) return null;

		// allocate all resources required to run it
		const newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );

		this._bindAction( newAction, prototypeAction );

		// and make the action known to the memory manager
		this._addInactiveAction( newAction, clipUuid, rootUuid );

		return newAction;

	}

	// get an existing action
	existingAction( clip, optionalRoot ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
				AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			return actionsForClip.actionByRoot[ rootUuid ] || null;

		}

		return null;

	}

	// deactivates all previously scheduled actions
	stopAllAction() {

		const actions = this._actions,
			nActions = this._nActiveActions;

		for ( let i = nActions - 1; i >= 0; -- i ) {

			actions[ i ].stop();

		}

		return this;

	}

	// advance the time and update apply the animation
	update( deltaTime ) {

		deltaTime *= this.timeScale;

		const actions = this._actions,
			nActions = this._nActiveActions,

			time = this.time += deltaTime,
			timeDirection = Math.sign( deltaTime ),

			accuIndex = this._accuIndex ^= 1;

		// run active actions

		for ( let i = 0; i !== nActions; ++ i ) {

			const action = actions[ i ];

			action._update( time, deltaTime, timeDirection, accuIndex );

		}

		// update scene graph

		const bindings = this._bindings,
			nBindings = this._nActiveBindings;

		for ( let i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].apply( accuIndex );

		}

		return this;

	}

	// Allows you to seek to a specific time in an animation.
	setTime( timeInSeconds ) {

		this.time = 0; // Zero out time attribute for AnimationMixer object;
		for ( let i = 0; i < this._actions.length; i ++ ) {

			this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

		}

		return this.update( timeInSeconds ); // Update used to set exact time. Returns "this" AnimationMixer object.

	}

	// return this mixer's root target object
	getRoot() {

		return this._root;

	}

	// free all resources specific to a particular clip
	uncacheClip( clip ) {

		const actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			// note: just calling _removeInactiveAction would mess up the
			// iteration state and also require updating the state we can
			// just throw away

			const actionsToRemove = actionsForClip.knownActions;

			for ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				const action = actionsToRemove[ i ];

				this._deactivateAction( action );

				const cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[ actions.length - 1 ];

				action._cacheIndex = null;
				action._byClipCacheIndex = null;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				this._removeInactiveBindingsForAction( action );

			}

			delete actionsByClip[ clipUuid ];

		}

	}

	// free all resources specific to a particular root target object
	uncacheRoot( root ) {

		const rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;

		for ( const clipUuid in actionsByClip ) {

			const actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				action = actionByRoot[ rootUuid ];

			if ( action !== undefined ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

		const bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName !== undefined ) {

			for ( const trackName in bindingByName ) {

				const binding = bindingByName[ trackName ];
				binding.restoreOriginalState();
				this._removeInactiveBinding( binding );

			}

		}

	}

	// remove a targeted clip from the cache
	uncacheAction( clip, optionalRoot ) {

		const action = this.existingAction( clip, optionalRoot );

		if ( action !== null ) {

			this._deactivateAction( action );
			this._removeInactiveAction( action );

		}

	}

}

AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array( 1 );

class Uniform {

	constructor( value ) {

		if ( typeof value === 'string' ) {

			console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
			value = arguments[ 1 ];

		}

		this.value = value;

	}

	clone() {

		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

	}

}

function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

	InterleavedBuffer.call( this, array, stride );

	this.meshPerAttribute = meshPerAttribute || 1;

}

InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

	constructor: InstancedInterleavedBuffer,

	isInstancedInterleavedBuffer: true,

	copy: function ( source ) {

		InterleavedBuffer.prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	},

	clone: function ( data ) {

		const ib = InterleavedBuffer.prototype.clone.call( this, data );

		ib.meshPerAttribute = this.meshPerAttribute;

		return ib;

	},

	toJSON: function ( data ) {

		const json = InterleavedBuffer.prototype.toJSON.call( this, data );

		json.isInstancedInterleavedBuffer = true;
		json.meshPerAttribute = this.meshPerAttribute;

		return json;

	}

} );

function GLBufferAttribute( buffer, type, itemSize, elementSize, count ) {

	this.buffer = buffer;
	this.type = type;
	this.itemSize = itemSize;
	this.elementSize = elementSize;
	this.count = count;

	this.version = 0;

}

Object.defineProperty( GLBufferAttribute.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

Object.assign( GLBufferAttribute.prototype, {

	isGLBufferAttribute: true,

	setBuffer: function ( buffer ) {

		this.buffer = buffer;

		return this;

	},

	setType: function ( type, elementSize ) {

		this.type = type;
		this.elementSize = elementSize;

		return this;

	},

	setItemSize: function ( itemSize ) {

		this.itemSize = itemSize;

		return this;

	},

	setCount: function ( count ) {

		this.count = count;

		return this;

	},

} );

function Raycaster( origin, direction, near = 0, far = Infinity ) {

	this.ray = new Ray( origin, direction );
	// direction is assumed to be normalized (for accurate distance calculations)

	this.near = near;
	this.far = far;
	this.camera = null;
	this.layers = new Layers();

	this.params = {
		Mesh: {},
		Line: { threshold: 1 },
		LOD: {},
		Points: { threshold: 1 },
		Sprite: {}
	};

	Object.defineProperties( this.params, {
		PointCloud: {
			get: function () {

				console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
				return this.Points;

			}
		}
	} );

}

function ascSort( a, b ) {

	return a.distance - b.distance;

}

function intersectObject( object, raycaster, intersects, recursive ) {

	if ( object.layers.test( raycaster.layers ) ) {

		object.raycast( raycaster, intersects );

	}

	if ( recursive === true ) {

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			intersectObject( children[ i ], raycaster, intersects, true );

		}

	}

}

Object.assign( Raycaster.prototype, {

	set: function ( origin, direction ) {

		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set( origin, direction );

	},

	setFromCamera: function ( coords, camera ) {

		if ( camera && camera.isPerspectiveCamera ) {

			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
			this.camera = camera;

		} else if ( camera && camera.isOrthographicCamera ) {

			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
			this.camera = camera;

		} else {

			console.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );

		}

	},

	intersectObject: function ( object, recursive = false, intersects = [] ) {

		intersectObject( object, this, intersects, recursive );

		intersects.sort( ascSort );

		return intersects;

	},

	intersectObjects: function ( objects, recursive = false, intersects = [] ) {

		for ( let i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects, recursive );

		}

		intersects.sort( ascSort );

		return intersects;

	}

} );

/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */

class Spherical {

	constructor( radius = 1, phi = 0, theta = 0 ) {

		this.radius = radius;
		this.phi = phi; // polar angle
		this.theta = theta; // azimuthal angle

		return this;

	}

	set( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

		return this;

	}

	copy( other ) {

		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;

		return this;

	}

	// restrict phi to be betwee EPS and PI-EPS
	makeSafe() {

		const EPS = 0.000001;
		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + y * y + z * z );

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( x, z );
			this.phi = Math.acos( MathUtils.clamp( y / this.radius, - 1, 1 ) );

		}

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */

class Cylindrical {

	constructor( radius = 1, theta = 0, y = 0 ) {

		this.radius = radius; // distance from the origin to a point in the x-z plane
		this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
		this.y = y; // height above the x-z plane

		return this;

	}

	set( radius, theta, y ) {

		this.radius = radius;
		this.theta = theta;
		this.y = y;

		return this;

	}

	copy( other ) {

		this.radius = other.radius;
		this.theta = other.theta;
		this.y = other.y;

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + z * z );
		this.theta = Math.atan2( x, z );
		this.y = y;

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$4 = /*@__PURE__*/ new Vector2();

class Box2 {

	constructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$4.copy( size ).multiplyScalar( 0.5 );
		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = + Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	}

	getCenter( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .getCenter() target is now required' );
			target = new Vector2();

		}

		return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .getSize() target is now required' );
			target = new Vector2();

		}

		return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .getParameter() target is now required' );
			target = new Vector2();

		}

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	}

	intersectsBox( box ) {

		// using 4 splitting planes to rule out intersections

		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

	}

	clampPoint( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .clampPoint() target is now required' );
			target = new Vector2();

		}

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		const clampedPoint = _vector$4.copy( point ).clamp( this.min, this.max );
		return clampedPoint.sub( point ).length();

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

Box2.prototype.isBox2 = true;

const _startP = /*@__PURE__*/ new Vector3();
const _startEnd = /*@__PURE__*/ new Vector3();

class Line3 {

	constructor( start = new Vector3(), end = new Vector3() ) {

		this.start = start;
		this.end = end;

	}

	set( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	}

	copy( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	}

	getCenter( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .getCenter() target is now required' );
			target = new Vector3();

		}

		return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	}

	delta( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .delta() target is now required' );
			target = new Vector3();

		}

		return target.subVectors( this.end, this.start );

	}

	distanceSq() {

		return this.start.distanceToSquared( this.end );

	}

	distance() {

		return this.start.distanceTo( this.end );

	}

	at( t, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .at() target is now required' );
			target = new Vector3();

		}

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	closestPointToPointParameter( point, clampToLine ) {

		_startP.subVectors( point, this.start );
		_startEnd.subVectors( this.end, this.start );

		const startEnd2 = _startEnd.dot( _startEnd );
		const startEnd_startP = _startEnd.dot( _startP );

		let t = startEnd_startP / startEnd2;

		if ( clampToLine ) {

			t = MathUtils.clamp( t, 0, 1 );

		}

		return t;

	}

	closestPointToPoint( point, clampToLine, target ) {

		const t = this.closestPointToPointParameter( point, clampToLine );

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );
			target = new Vector3();

		}

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	applyMatrix4( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	}

	equals( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

function ImmediateRenderObject( material ) {

	Object3D.call( this );

	this.material = material;
	this.render = function ( /* renderCallback */ ) {};

	this.hasPositions = false;
	this.hasNormals = false;
	this.hasColors = false;
	this.hasUvs = false;

	this.positionArray = null;
	this.normalArray = null;
	this.colorArray = null;
	this.uvArray = null;

	this.count = 0;

}

ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

ImmediateRenderObject.prototype.isImmediateRenderObject = true;

const _vector$3 = /*@__PURE__*/ new Vector3();

class SpotLightHelper extends Object3D {

	constructor( light, color ) {

		super();
		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		const geometry = new BufferGeometry();

		const positions = [
			0, 0, 0, 	0, 0, 1,
			0, 0, 0, 	1, 0, 1,
			0, 0, 0,	- 1, 0, 1,
			0, 0, 0, 	0, 1, 1,
			0, 0, 0, 	0, - 1, 1
		];

		for ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

			const p1 = ( i / l ) * Math.PI * 2;
			const p2 = ( j / l ) * Math.PI * 2;

			positions.push(
				Math.cos( p1 ), Math.sin( p1 ), 1,
				Math.cos( p2 ), Math.sin( p2 ), 1
			);

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

		this.cone = new LineSegments( geometry, material );
		this.add( this.cone );

		this.update();

	}

	dispose() {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	}

	update() {

		this.light.updateMatrixWorld();

		const coneLength = this.light.distance ? this.light.distance : 1000;
		const coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		_vector$3.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( _vector$3 );

		if ( this.color !== undefined ) {

			this.cone.material.color.set( this.color );

		} else {

			this.cone.material.color.copy( this.light.color );

		}

	}

}

const _vector$2 = /*@__PURE__*/ new Vector3();
const _boneMatrix = /*@__PURE__*/ new Matrix4();
const _matrixWorldInv = /*@__PURE__*/ new Matrix4();


class SkeletonHelper extends LineSegments {

	constructor( object ) {

		const bones = getBoneList( object );

		const geometry = new BufferGeometry();

		const vertices = [];
		const colors = [];

		const color1 = new Color( 0, 0, 1 );
		const color2 = new Color( 0, 1, 0 );

		for ( let i = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				vertices.push( 0, 0, 0 );
				vertices.push( 0, 0, 0 );
				colors.push( color1.r, color1.g, color1.b );
				colors.push( color2.r, color2.g, color2.b );

			}

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );

		super( geometry, material );

		this.type = 'SkeletonHelper';
		this.isSkeletonHelper = true;

		this.root = object;
		this.bones = bones;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	}

	updateMatrixWorld( force ) {

		const bones = this.bones;

		const geometry = this.geometry;
		const position = geometry.getAttribute( 'position' );

		_matrixWorldInv.copy( this.root.matrixWorld ).invert();

		for ( let i = 0, j = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );
				_vector$2.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j, _vector$2.x, _vector$2.y, _vector$2.z );

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );
				_vector$2.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j + 1, _vector$2.x, _vector$2.y, _vector$2.z );

				j += 2;

			}

		}

		geometry.getAttribute( 'position' ).needsUpdate = true;

		super.updateMatrixWorld( force );

	}

}


function getBoneList( object ) {

	const boneList = [];

	if ( object && object.isBone ) {

		boneList.push( object );

	}

	for ( let i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

	}

	return boneList;

}

class PointLightHelper extends Mesh {

	constructor( light, sphereSize, color ) {

		const geometry = new SphereGeometry( sphereSize, 4, 2 );
		const material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );

		super( geometry, material );

		this.light = light;
		this.light.updateMatrixWorld();

		this.color = color;

		this.type = 'PointLightHelper';

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();


		/*
	// TODO: delete this comment?
	const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
	const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	const d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

	update() {

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color );

		}

		/*
		const d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	}

}

const _vector$1 = /*@__PURE__*/ new Vector3();
const _color1 = /*@__PURE__*/ new Color();
const _color2 = /*@__PURE__*/ new Color();

class HemisphereLightHelper extends Object3D {

	constructor( light, size, color ) {

		super();
		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		const geometry = new OctahedronGeometry( size );
		geometry.rotateY( Math.PI * 0.5 );

		this.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );
		if ( this.color === undefined ) this.material.vertexColors = true;

		const position = geometry.getAttribute( 'position' );
		const colors = new Float32Array( position.count * 3 );

		geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );

		this.add( new Mesh( geometry, this.material ) );

		this.update();

	}

	dispose() {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	}

	update() {

		const mesh = this.children[ 0 ];

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			const colors = mesh.geometry.getAttribute( 'color' );

			_color1.copy( this.light.color );
			_color2.copy( this.light.groundColor );

			for ( let i = 0, l = colors.count; i < l; i ++ ) {

				const color = ( i < ( l / 2 ) ) ? _color1 : _color2;

				colors.setXYZ( i, color.r, color.g, color.b );

			}

			colors.needsUpdate = true;

		}

		mesh.lookAt( _vector$1.setFromMatrixPosition( this.light.matrixWorld ).negate() );

	}

}

class GridHelper extends LineSegments {

	constructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new Color( color1 );
		color2 = new Color( color2 );

		const center = divisions / 2;
		const step = size / divisions;
		const halfSize = size / 2;

		const vertices = [], colors = [];

		for ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

			vertices.push( - halfSize, 0, k, halfSize, 0, k );
			vertices.push( k, 0, - halfSize, k, 0, halfSize );

			const color = i === center ? color1 : color2;

			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;

		}

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'GridHelper';

	}

}

class PolarGridHelper extends LineSegments {

	constructor( radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new Color( color1 );
		color2 = new Color( color2 );

		const vertices = [];
		const colors = [];

		// create the radials

		for ( let i = 0; i <= radials; i ++ ) {

			const v = ( i / radials ) * ( Math.PI * 2 );

			const x = Math.sin( v ) * radius;
			const z = Math.cos( v ) * radius;

			vertices.push( 0, 0, 0 );
			vertices.push( x, 0, z );

			const color = ( i & 1 ) ? color1 : color2;

			colors.push( color.r, color.g, color.b );
			colors.push( color.r, color.g, color.b );

		}

		// create the circles

		for ( let i = 0; i <= circles; i ++ ) {

			const color = ( i & 1 ) ? color1 : color2;

			const r = radius - ( radius / circles * i );

			for ( let j = 0; j < divisions; j ++ ) {

				// first vertex

				let v = ( j / divisions ) * ( Math.PI * 2 );

				let x = Math.sin( v ) * r;
				let z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

				// second vertex

				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

			}

		}

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'PolarGridHelper';

	}

}

const _v1 = /*@__PURE__*/ new Vector3();
const _v2 = /*@__PURE__*/ new Vector3();
const _v3 = /*@__PURE__*/ new Vector3();

class DirectionalLightHelper extends Object3D {

	constructor( light, size, color ) {

		super();
		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		if ( size === undefined ) size = 1;

		let geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( [
			- size, size, 0,
			size, size, 0,
			size, - size, 0,
			- size, - size, 0,
			- size, size, 0
		], 3 ) );

		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

		this.lightPlane = new Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

		this.targetLine = new Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	}

	dispose() {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();

	}

	update() {

		_v1.setFromMatrixPosition( this.light.matrixWorld );
		_v2.setFromMatrixPosition( this.light.target.matrixWorld );
		_v3.subVectors( _v2, _v1 );

		this.lightPlane.lookAt( _v2 );

		if ( this.color !== undefined ) {

			this.lightPlane.material.color.set( this.color );
			this.targetLine.material.color.set( this.color );

		} else {

			this.lightPlane.material.color.copy( this.light.color );
			this.targetLine.material.color.copy( this.light.color );

		}

		this.targetLine.lookAt( _v2 );
		this.targetLine.scale.z = _v3.length();

	}

}

const _vector = /*@__PURE__*/ new Vector3();
const _camera = /*@__PURE__*/ new Camera();

/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

class CameraHelper extends LineSegments {

	constructor( camera ) {

		const geometry = new BufferGeometry();
		const material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );

		const vertices = [];
		const colors = [];

		const pointMap = {};

		// colors

		const colorFrustum = new Color( 0xffaa00 );
		const colorCone = new Color( 0xff0000 );
		const colorUp = new Color( 0x00aaff );
		const colorTarget = new Color( 0xffffff );
		const colorCross = new Color( 0x333333 );

		// near

		addLine( 'n1', 'n2', colorFrustum );
		addLine( 'n2', 'n4', colorFrustum );
		addLine( 'n4', 'n3', colorFrustum );
		addLine( 'n3', 'n1', colorFrustum );

		// far

		addLine( 'f1', 'f2', colorFrustum );
		addLine( 'f2', 'f4', colorFrustum );
		addLine( 'f4', 'f3', colorFrustum );
		addLine( 'f3', 'f1', colorFrustum );

		// sides

		addLine( 'n1', 'f1', colorFrustum );
		addLine( 'n2', 'f2', colorFrustum );
		addLine( 'n3', 'f3', colorFrustum );
		addLine( 'n4', 'f4', colorFrustum );

		// cone

		addLine( 'p', 'n1', colorCone );
		addLine( 'p', 'n2', colorCone );
		addLine( 'p', 'n3', colorCone );
		addLine( 'p', 'n4', colorCone );

		// up

		addLine( 'u1', 'u2', colorUp );
		addLine( 'u2', 'u3', colorUp );
		addLine( 'u3', 'u1', colorUp );

		// target

		addLine( 'c', 't', colorTarget );
		addLine( 'p', 'c', colorCross );

		// cross

		addLine( 'cn1', 'cn2', colorCross );
		addLine( 'cn3', 'cn4', colorCross );

		addLine( 'cf1', 'cf2', colorCross );
		addLine( 'cf3', 'cf4', colorCross );

		function addLine( a, b, color ) {

			addPoint( a, color );
			addPoint( b, color );

		}

		function addPoint( id, color ) {

			vertices.push( 0, 0, 0 );
			colors.push( color.r, color.g, color.b );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		super( geometry, material );

		this.type = 'CameraHelper';

		this.camera = camera;
		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

	}

	update() {

		const geometry = this.geometry;
		const pointMap = this.pointMap;

		const w = 1, h = 1;

		// we need just camera projection matrix inverse
		// world matrix must be identity

		_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );

		// center / target

		setPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );
		setPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );

		// near

		setPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );
		setPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );
		setPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );
		setPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );

		// far

		setPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );
		setPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );
		setPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );
		setPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );

		// up

		setPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );
		setPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );
		setPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );

		// cross

		setPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );
		setPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );
		setPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );
		setPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );

		setPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );
		setPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );
		setPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );
		setPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );

		geometry.getAttribute( 'position' ).needsUpdate = true;

	}

}


function setPoint( point, pointMap, geometry, camera, x, y, z ) {

	_vector.set( x, y, z ).unproject( camera );

	const points = pointMap[ point ];

	if ( points !== undefined ) {

		const position = geometry.getAttribute( 'position' );

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			position.setXYZ( points[ i ], _vector.x, _vector.y, _vector.z );

		}

	}

}

const _box = /*@__PURE__*/ new Box3();

class BoxHelper extends LineSegments {

	constructor( object, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		const positions = new Float32Array( 8 * 3 );

		const geometry = new BufferGeometry();
		geometry.setIndex( new BufferAttribute( indices, 1 ) );
		geometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.object = object;
		this.type = 'BoxHelper';

		this.matrixAutoUpdate = false;

		this.update();

	}

	update( object ) {

		if ( object !== undefined ) {

			console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

		}

		if ( this.object !== undefined ) {

			_box.setFromObject( this.object );

		}

		if ( _box.isEmpty() ) return;

		const min = _box.min;
		const max = _box.max;

		/*
			5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		const position = this.geometry.attributes.position;
		const array = position.array;

		array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
		array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
		array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
		array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();


	}

	setFromObject( object ) {

		this.object = object;
		this.update();

		return this;

	}

	copy( source ) {

		LineSegments.prototype.copy.call( this, source );

		this.object = source.object;

		return this;

	}

}

class Box3Helper extends LineSegments {

	constructor( box, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

		const positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

		const geometry = new BufferGeometry();

		geometry.setIndex( new BufferAttribute( indices, 1 ) );

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.box = box;

		this.type = 'Box3Helper';

		this.geometry.computeBoundingSphere();

	}

	updateMatrixWorld( force ) {

		const box = this.box;

		if ( box.isEmpty() ) return;

		box.getCenter( this.position );

		box.getSize( this.scale );

		this.scale.multiplyScalar( 0.5 );

		super.updateMatrixWorld( force );

	}

}

class PlaneHelper extends Line {

	constructor( plane, size = 1, hex = 0xffff00 ) {

		const color = hex;

		const positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.type = 'PlaneHelper';

		this.plane = plane;

		this.size = size;

		const positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

		const geometry2 = new BufferGeometry();
		geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );

	}

	updateMatrixWorld( force ) {

		let scale = - this.plane.constant;

		if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter

		this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

		this.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

		this.lookAt( this.plane.normal );

		super.updateMatrixWorld( force );

	}

}

const _axis = /*@__PURE__*/ new Vector3();
let _lineGeometry, _coneGeometry;

class ArrowHelper extends Object3D {

	// dir is assumed to be normalized

	constructor( dir = new Vector3( 0, 0, 1 ), origin = new Vector3( 0, 0, 0 ), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

		super();

		this.type = 'ArrowHelper';

		if ( _lineGeometry === undefined ) {

			_lineGeometry = new BufferGeometry();
			_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

			_coneGeometry = new CylinderGeometry( 0, 0.5, 1, 5, 1 );
			_coneGeometry.translate( 0, - 0.5, 0 );

		}

		this.position.copy( origin );

		this.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

	setDirection( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			_axis.set( dir.z, 0, - dir.x ).normalize();

			const radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( _axis, radians );

		}

	}

	setLength( length, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

		this.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458
		this.line.updateMatrix();

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	}

	setColor( color ) {

		this.line.material.color.set( color );
		this.cone.material.color.set( color );

	}

	copy( source ) {

		super.copy( source, false );

		this.line.copy( source.line );
		this.cone.copy( source.cone );

		return this;

	}

}

class AxesHelper extends LineSegments {

	constructor( size = 1 ) {

		const vertices = [
			0, 0, 0,	size, 0, 0,
			0, 0, 0,	0, size, 0,
			0, 0, 0,	0, 0, size
		];

		const colors = [
			1, 0, 0,	1, 0.6, 0,
			0, 1, 0,	0.6, 1, 0,
			0, 0, 1,	0, 0.6, 1
		];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'AxesHelper';

	}

}

const _floatView = new Float32Array( 1 );
const _int32View = new Int32Array( _floatView.buffer );

const DataUtils = {

	// Converts float32 to float16 (stored as uint16 value).

	toHalfFloat: function ( val ) {

		// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410

		/* This method is faster than the OpenEXR implementation (very often
		* used, eg. in Ogre), with the additional benefit of rounding, inspired
		* by James Tursa?s half-precision code. */

		_floatView[ 0 ] = val;
		const x = _int32View[ 0 ];

		let bits = ( x >> 16 ) & 0x8000; /* Get the sign */
		let m = ( x >> 12 ) & 0x07ff; /* Keep one extra bit for rounding */
		const e = ( x >> 23 ) & 0xff; /* Using int is faster here */

		/* If zero, or denormal, or exponent underflows too much for a denormal
			* half, return signed zero. */
		if ( e < 103 ) return bits;

		/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
		if ( e > 142 ) {

			bits |= 0x7c00;
			/* If exponent was 0xff and one mantissa bit was set, it means NaN,
						* not Inf, so make sure we set one mantissa bit too. */
			bits |= ( ( e == 255 ) ? 0 : 1 ) && ( x & 0x007fffff );
			return bits;

		}

		/* If exponent underflows but not too much, return a denormal */
		if ( e < 113 ) {

			m |= 0x0800;
			/* Extra rounding may overflow and set mantissa to 0 and exponent
				* to 1, which is OK. */
			bits |= ( m >> ( 114 - e ) ) + ( ( m >> ( 113 - e ) ) & 1 );
			return bits;

		}

		bits |= ( ( e - 112 ) << 10 ) | ( m >> 1 );
		/* Extra rounding. An overflow will set mantissa to 0 and increment
			* the exponent, which is OK. */
		bits += m & 1;
		return bits;

	}

};

const LOD_MIN = 4;
const LOD_MAX = 8;
const SIZE_MAX = Math.pow( 2, LOD_MAX );

// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;

const ENCODINGS = {
	[ LinearEncoding ]: 0,
	[ sRGBEncoding ]: 1,
	[ RGBEEncoding ]: 2,
	[ RGBM7Encoding ]: 3,
	[ RGBM16Encoding ]: 4,
	[ RGBDEncoding ]: 5,
	[ GammaEncoding ]: 6
};

const backgroundMaterial = new MeshBasicMaterial( {
	side: BackSide,
	depthWrite: false,
	depthTest: false,
} );
const backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
const { _lodPlanes, _sizeLods, _sigmas } = /*@__PURE__*/ _createPlanes();
const _clearColor = /*@__PURE__*/ new Color();
let _oldTarget = null;

// Golden Ratio
const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
const INV_PHI = 1 / PHI;

// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [
	/*@__PURE__*/ new Vector3( 1, 1, 1 ),
	/*@__PURE__*/ new Vector3( - 1, 1, 1 ),
	/*@__PURE__*/ new Vector3( 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
	/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
	/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
	/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ) ];

/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/

function convertLinearToRGBE( color ) {

	const maxComponent = Math.max( color.r, color.g, color.b );
	const fExp = Math.min( Math.max( Math.ceil( Math.log2( maxComponent ) ), - 128.0 ), 127.0 );
	color.multiplyScalar( Math.pow( 2.0, - fExp ) );

	const alpha = ( fExp + 128.0 ) / 255.0;
	return alpha;

}

class PMREMGenerator {

	constructor( renderer ) {

		this._renderer = renderer;
		this._pingPongRenderTarget = null;

		this._blurMaterial = _getBlurShader( MAX_SAMPLES );
		this._equirectShader = null;
		this._cubemapShader = null;

		this._compileMaterial( this._blurMaterial );

	}

	/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */
	fromScene( scene, sigma = 0, near = 0.1, far = 100 ) {

		_oldTarget = this._renderer.getRenderTarget();
		const cubeUVRenderTarget = this._allocateTargets();

		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );
		if ( sigma > 0 ) {

			this._blur( cubeUVRenderTarget, 0, 0, sigma );

		}

		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromEquirectangular( equirectangular ) {

		return this._fromTexture( equirectangular );

	}

	/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromCubemap( cubemap ) {

		return this._fromTexture( cubemap );

	}

	/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileCubemapShader() {

		if ( this._cubemapShader === null ) {

			this._cubemapShader = _getCubemapShader();
			this._compileMaterial( this._cubemapShader );

		}

	}

	/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileEquirectangularShader() {

		if ( this._equirectShader === null ) {

			this._equirectShader = _getEquirectShader();
			this._compileMaterial( this._equirectShader );

		}

	}

	/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */
	dispose() {

		this._blurMaterial.dispose();

		if ( this._cubemapShader !== null ) this._cubemapShader.dispose();
		if ( this._equirectShader !== null ) this._equirectShader.dispose();

		for ( let i = 0; i < _lodPlanes.length; i ++ ) {

			_lodPlanes[ i ].dispose();

		}

	}

	// private interface

	_cleanup( outputTarget ) {

		this._pingPongRenderTarget.dispose();
		this._renderer.setRenderTarget( _oldTarget );
		outputTarget.scissorTest = false;
		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

	}

	_fromTexture( texture ) {

		_oldTarget = this._renderer.getRenderTarget();
		const cubeUVRenderTarget = this._allocateTargets( texture );
		this._textureToCubeUV( texture, cubeUVRenderTarget );
		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	_allocateTargets( texture ) { // warning: null texture is valid

		const params = {
			magFilter: NearestFilter,
			minFilter: NearestFilter,
			generateMipmaps: false,
			type: UnsignedByteType,
			format: RGBEFormat,
			encoding: _isLDR( texture ) ? texture.encoding : RGBEEncoding,
			depthBuffer: false
		};

		const cubeUVRenderTarget = _createRenderTarget( params );
		cubeUVRenderTarget.depthBuffer = texture ? false : true;
		this._pingPongRenderTarget = _createRenderTarget( params );
		return cubeUVRenderTarget;

	}

	_compileMaterial( material ) {

		const tmpMesh = new Mesh( _lodPlanes[ 0 ], material );
		this._renderer.compile( tmpMesh, _flatCamera );

	}

	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

		const fov = 90;
		const aspect = 1;
		const cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
		const upSign = [ 1, - 1, 1, 1, 1, 1 ];
		const forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];
		const renderer = this._renderer;

		const originalAutoClear = renderer.autoClear;
		const outputEncoding = renderer.outputEncoding;
		const toneMapping = renderer.toneMapping;
		renderer.getClearColor( _clearColor );

		renderer.toneMapping = NoToneMapping;
		renderer.outputEncoding = LinearEncoding;
		renderer.autoClear = false;

		let useSolidColor = false;
		const background = scene.background;
		if ( background ) {

			if ( background.isColor ) {

				backgroundMaterial.color.copy( background ).convertSRGBToLinear();
				scene.background = null;

				const alpha = convertLinearToRGBE( backgroundMaterial.color );
				backgroundMaterial.opacity = alpha;
				useSolidColor = true;

			}

		} else {

			backgroundMaterial.color.copy( _clearColor ).convertSRGBToLinear();

			const alpha = convertLinearToRGBE( backgroundMaterial.color );
			backgroundMaterial.opacity = alpha;
			useSolidColor = true;

		}


		for ( let i = 0; i < 6; i ++ ) {

			const col = i % 3;
			if ( col == 0 ) {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

			} else if ( col == 1 ) {

				cubeCamera.up.set( 0, 0, upSign[ i ] );
				cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

			} else {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

			}

			_setViewport( cubeUVRenderTarget,
				col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX );
			renderer.setRenderTarget( cubeUVRenderTarget );

			if ( useSolidColor ) {

				renderer.render( backgroundBox, cubeCamera );

			}

			renderer.render( scene, cubeCamera );

		}

		renderer.toneMapping = toneMapping;
		renderer.outputEncoding = outputEncoding;
		renderer.autoClear = originalAutoClear;

	}

	_textureToCubeUV( texture, cubeUVRenderTarget ) {

		const renderer = this._renderer;

		if ( texture.isCubeTexture ) {

			if ( this._cubemapShader == null ) {

				this._cubemapShader = _getCubemapShader();

			}

		} else {

			if ( this._equirectShader == null ) {

				this._equirectShader = _getEquirectShader();

			}

		}

		const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
		const mesh = new Mesh( _lodPlanes[ 0 ], material );

		const uniforms = material.uniforms;

		uniforms[ 'envMap' ].value = texture;

		if ( ! texture.isCubeTexture ) {

			uniforms[ 'texelSize' ].value.set( 1.0 / texture.image.width, 1.0 / texture.image.height );

		}

		uniforms[ 'inputEncoding' ].value = ENCODINGS[ texture.encoding ];
		uniforms[ 'outputEncoding' ].value = ENCODINGS[ cubeUVRenderTarget.texture.encoding ];

		_setViewport( cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX );

		renderer.setRenderTarget( cubeUVRenderTarget );
		renderer.render( mesh, _flatCamera );

	}

	_applyPMREM( cubeUVRenderTarget ) {

		const renderer = this._renderer;
		const autoClear = renderer.autoClear;
		renderer.autoClear = false;

		for ( let i = 1; i < TOTAL_LODS; i ++ ) {

			const sigma = Math.sqrt( _sigmas[ i ] * _sigmas[ i ] - _sigmas[ i - 1 ] * _sigmas[ i - 1 ] );

			const poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];

			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

		}

		renderer.autoClear = autoClear;

	}

	/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */
	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

		const pingPongRenderTarget = this._pingPongRenderTarget;

		this._halfBlur(
			cubeUVRenderTarget,
			pingPongRenderTarget,
			lodIn,
			lodOut,
			sigma,
			'latitudinal',
			poleAxis );

		this._halfBlur(
			pingPongRenderTarget,
			cubeUVRenderTarget,
			lodOut,
			lodOut,
			sigma,
			'longitudinal',
			poleAxis );

	}

	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

		const renderer = this._renderer;
		const blurMaterial = this._blurMaterial;

		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

			console.error(
				'blur direction must be either latitudinal or longitudinal!' );

		}

		// Number of standard deviations at which to cut off the discrete approximation.
		const STANDARD_DEVIATIONS = 3;

		const blurMesh = new Mesh( _lodPlanes[ lodOut ], blurMaterial );
		const blurUniforms = blurMaterial.uniforms;

		const pixels = _sizeLods[ lodIn ] - 1;
		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
		const sigmaPixels = sigmaRadians / radiansPerPixel;
		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

		if ( samples > MAX_SAMPLES ) {

			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

		}

		const weights = [];
		let sum = 0;

		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

			const x = i / sigmaPixels;
			const weight = Math.exp( - x * x / 2 );
			weights.push( weight );

			if ( i == 0 ) {

				sum += weight;

			} else if ( i < samples ) {

				sum += 2 * weight;

			}

		}

		for ( let i = 0; i < weights.length; i ++ ) {

			weights[ i ] = weights[ i ] / sum;

		}

		blurUniforms[ 'envMap' ].value = targetIn.texture;
		blurUniforms[ 'samples' ].value = samples;
		blurUniforms[ 'weights' ].value = weights;
		blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

		if ( poleAxis ) {

			blurUniforms[ 'poleAxis' ].value = poleAxis;

		}

		blurUniforms[ 'dTheta' ].value = radiansPerPixel;
		blurUniforms[ 'mipInt' ].value = LOD_MAX - lodIn;
		blurUniforms[ 'inputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];
		blurUniforms[ 'outputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];

		const outputSize = _sizeLods[ lodOut ];
		const x = 3 * Math.max( 0, SIZE_MAX - 2 * outputSize );
		const y = ( lodOut === 0 ? 0 : 2 * SIZE_MAX ) + 2 * outputSize * ( lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0 );

		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
		renderer.setRenderTarget( targetOut );
		renderer.render( blurMesh, _flatCamera );

	}

}

function _isLDR( texture ) {

	if ( texture === undefined || texture.type !== UnsignedByteType ) return false;

	return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;

}

function _createPlanes() {

	const _lodPlanes = [];
	const _sizeLods = [];
	const _sigmas = [];

	let lod = LOD_MAX;

	for ( let i = 0; i < TOTAL_LODS; i ++ ) {

		const sizeLod = Math.pow( 2, lod );
		_sizeLods.push( sizeLod );
		let sigma = 1.0 / sizeLod;

		if ( i > LOD_MAX - LOD_MIN ) {

			sigma = EXTRA_LOD_SIGMA[ i - LOD_MAX + LOD_MIN - 1 ];

		} else if ( i == 0 ) {

			sigma = 0;

		}

		_sigmas.push( sigma );

		const texelSize = 1.0 / ( sizeLod - 1 );
		const min = - texelSize / 2;
		const max = 1 + texelSize / 2;
		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

		const cubeFaces = 6;
		const vertices = 6;
		const positionSize = 3;
		const uvSize = 2;
		const faceIndexSize = 1;

		const position = new Float32Array( positionSize * vertices * cubeFaces );
		const uv = new Float32Array( uvSize * vertices * cubeFaces );
		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

		for ( let face = 0; face < cubeFaces; face ++ ) {

			const x = ( face % 3 ) * 2 / 3 - 1;
			const y = face > 2 ? 0 : - 1;
			const coordinates = [
				x, y, 0,
				x + 2 / 3, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y + 1, 0
			];
			position.set( coordinates, positionSize * vertices * face );
			uv.set( uv1, uvSize * vertices * face );
			const fill = [ face, face, face, face, face, face ];
			faceIndex.set( fill, faceIndexSize * vertices * face );

		}

		const planes = new BufferGeometry();
		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
		_lodPlanes.push( planes );

		if ( lod > LOD_MIN ) {

			lod --;

		}

	}

	return { _lodPlanes, _sizeLods, _sigmas };

}

function _createRenderTarget( params ) {

	const cubeUVRenderTarget = new WebGLRenderTarget( 3 * SIZE_MAX, 3 * SIZE_MAX, params );
	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;

}

function _setViewport( target, x, y, width, height ) {

	target.viewport.set( x, y, width, height );
	target.scissor.set( x, y, width, height );

}

function _getBlurShader( maxSamples ) {

	const weights = new Float32Array( maxSamples );
	const poleAxis = new Vector3( 0, 1, 0 );
	const shaderMaterial = new RawShaderMaterial( {

		name: 'SphericalGaussianBlur',

		defines: { 'n': maxSamples },

		uniforms: {
			'envMap': { value: null },
			'samples': { value: 1 },
			'weights': { value: weights },
			'latitudinal': { value: false },
			'dTheta': { value: 0 },
			'mipInt': { value: 0 },
			'poleAxis': { value: poleAxis },
			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${ _getEncodings() }

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getEquirectShader() {

	const texelSize = new Vector2( 1, 1 );
	const shaderMaterial = new RawShaderMaterial( {

		name: 'EquirectangularToCubeUV',

		uniforms: {
			'envMap': { value: null },
			'texelSize': { value: texelSize },
			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${ _getEncodings() }

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getCubemapShader() {

	const shaderMaterial = new RawShaderMaterial( {

		name: 'CubemapToCubeUV',

		uniforms: {
			'envMap': { value: null },
			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${ _getEncodings() }

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getCommonVertexShader() {

	return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

}

function _getEncodings() {

	return /* glsl */`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;

}

const LineStrip = 0;
const LinePieces = 1;
const NoColors = 0;
const FaceColors = 1;
const VertexColors = 2;

function MeshFaceMaterial( materials ) {

	console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
	return materials;

}

function MultiMaterial( materials = [] ) {

	console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
	materials.isMultiMaterial = true;
	materials.materials = materials;
	materials.clone = function () {

		return materials.slice();

	};

	return materials;

}

function PointCloud( geometry, material ) {

	console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
	return new Points( geometry, material );

}

function Particle( material ) {

	console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
	return new Sprite( material );

}

function ParticleSystem( geometry, material ) {

	console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
	return new Points( geometry, material );

}

function PointCloudMaterial( parameters ) {

	console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function ParticleBasicMaterial( parameters ) {

	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function ParticleSystemMaterial( parameters ) {

	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function Vertex( x, y, z ) {

	console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
	return new Vector3( x, y, z );

}

//

function DynamicBufferAttribute( array, itemSize ) {

	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.' );
	return new BufferAttribute( array, itemSize ).setUsage( DynamicDrawUsage );

}

function Int8Attribute( array, itemSize ) {

	console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
	return new Int8BufferAttribute( array, itemSize );

}

function Uint8Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
	return new Uint8BufferAttribute( array, itemSize );

}

function Uint8ClampedAttribute( array, itemSize ) {

	console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
	return new Uint8ClampedBufferAttribute( array, itemSize );

}

function Int16Attribute( array, itemSize ) {

	console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
	return new Int16BufferAttribute( array, itemSize );

}

function Uint16Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
	return new Uint16BufferAttribute( array, itemSize );

}

function Int32Attribute( array, itemSize ) {

	console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
	return new Int32BufferAttribute( array, itemSize );

}

function Uint32Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
	return new Uint32BufferAttribute( array, itemSize );

}

function Float32Attribute( array, itemSize ) {

	console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
	return new Float32BufferAttribute( array, itemSize );

}

function Float64Attribute( array, itemSize ) {

	console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
	return new Float64BufferAttribute( array, itemSize );

}

//

Curve.create = function ( construct, getPoint ) {

	console.log( 'THREE.Curve.create() has been deprecated' );

	construct.prototype = Object.create( Curve.prototype );
	construct.prototype.constructor = construct;
	construct.prototype.getPoint = getPoint;

	return construct;

};

//

Path.prototype.fromPoints = function ( points ) {

	console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
	return this.setFromPoints( points );

};

//

function AxisHelper( size ) {

	console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
	return new AxesHelper( size );

}

function BoundingBoxHelper( object, color ) {

	console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
	return new BoxHelper( object, color );

}

function EdgesHelper( object, hex ) {

	console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
	return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

}

GridHelper.prototype.setColors = function () {

	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

};

SkeletonHelper.prototype.update = function () {

	console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

};

function WireframeHelper( object, hex ) {

	console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
	return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

}

//

Loader.prototype.extractUrlBase = function ( url ) {

	console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
	return LoaderUtils.extractUrlBase( url );

};

Loader.Handlers = {

	add: function ( /* regex, loader */ ) {

		console.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );

	},

	get: function ( /* file */ ) {

		console.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );

	}

};

function XHRLoader( manager ) {

	console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
	return new FileLoader( manager );

}

function BinaryTextureLoader( manager ) {

	console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
	return new DataTextureLoader( manager );

}

//

Box2.prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

Box2.prototype.empty = function () {

	console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
	return this.isEmpty();

};

Box2.prototype.isIntersectionBox = function ( box ) {

	console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
	return this.intersectsBox( box );

};

Box2.prototype.size = function ( optionalTarget ) {

	console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
	return this.getSize( optionalTarget );

};

//

Box3.prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

Box3.prototype.empty = function () {

	console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
	return this.isEmpty();

};

Box3.prototype.isIntersectionBox = function ( box ) {

	console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
	return this.intersectsBox( box );

};

Box3.prototype.isIntersectionSphere = function ( sphere ) {

	console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
	return this.intersectsSphere( sphere );

};

Box3.prototype.size = function ( optionalTarget ) {

	console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
	return this.getSize( optionalTarget );

};

//

Sphere.prototype.empty = function () {

	console.warn( 'THREE.Sphere: .empty() has been renamed to .isEmpty().' );
	return this.isEmpty();

};

//

Frustum.prototype.setFromMatrix = function ( m ) {

	console.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );
	return this.setFromProjectionMatrix( m );

};

//

Line3.prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

//

MathUtils.random16 = function () {

	console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
	return Math.random();

};

MathUtils.nearestPowerOfTwo = function ( value ) {

	console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
	return MathUtils.floorPowerOfTwo( value );

};

MathUtils.nextPowerOfTwo = function ( value ) {

	console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
	return MathUtils.ceilPowerOfTwo( value );

};

//

Matrix3.prototype.flattenToArrayOffset = function ( array, offset ) {

	console.warn( 'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
	return this.toArray( array, offset );

};

Matrix3.prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
	return vector.applyMatrix3( this );

};

Matrix3.prototype.multiplyVector3Array = function ( /* a */ ) {

	console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

};

Matrix3.prototype.applyToBufferAttribute = function ( attribute ) {

	console.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );
	return attribute.applyMatrix3( this );

};

Matrix3.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

	console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

};

Matrix3.prototype.getInverse = function ( matrix ) {

	console.warn( 'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
	return this.copy( matrix ).invert();

};

//

Matrix4.prototype.extractPosition = function ( m ) {

	console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
	return this.copyPosition( m );

};

Matrix4.prototype.flattenToArrayOffset = function ( array, offset ) {

	console.warn( 'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
	return this.toArray( array, offset );

};

Matrix4.prototype.getPosition = function () {

	console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
	return new Vector3().setFromMatrixColumn( this, 3 );

};

Matrix4.prototype.setRotationFromQuaternion = function ( q ) {

	console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
	return this.makeRotationFromQuaternion( q );

};

Matrix4.prototype.multiplyToArray = function () {

	console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

};

Matrix4.prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	return vector.applyMatrix4( this );

};

Matrix4.prototype.multiplyVector4 = function ( vector ) {

	console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	return vector.applyMatrix4( this );

};

Matrix4.prototype.multiplyVector3Array = function ( /* a */ ) {

	console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

};

Matrix4.prototype.rotateAxis = function ( v ) {

	console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
	v.transformDirection( this );

};

Matrix4.prototype.crossVector = function ( vector ) {

	console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	return vector.applyMatrix4( this );

};

Matrix4.prototype.translate = function () {

	console.error( 'THREE.Matrix4: .translate() has been removed.' );

};

Matrix4.prototype.rotateX = function () {

	console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

};

Matrix4.prototype.rotateY = function () {

	console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

};

Matrix4.prototype.rotateZ = function () {

	console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

};

Matrix4.prototype.rotateByAxis = function () {

	console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

};

Matrix4.prototype.applyToBufferAttribute = function ( attribute ) {

	console.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );
	return attribute.applyMatrix4( this );

};

Matrix4.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

	console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

};

Matrix4.prototype.makeFrustum = function ( left, right, bottom, top, near, far ) {

	console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
	return this.makePerspective( left, right, top, bottom, near, far );

};

Matrix4.prototype.getInverse = function ( matrix ) {

	console.warn( 'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
	return this.copy( matrix ).invert();

};

//

Plane.prototype.isIntersectionLine = function ( line ) {

	console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
	return this.intersectsLine( line );

};

//

Quaternion.prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
	return vector.applyQuaternion( this );

};

Quaternion.prototype.inverse = function ( ) {

	console.warn( 'THREE.Quaternion: .inverse() has been renamed to invert().' );
	return this.invert();

};

//

Ray.prototype.isIntersectionBox = function ( box ) {

	console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
	return this.intersectsBox( box );

};

Ray.prototype.isIntersectionPlane = function ( plane ) {

	console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
	return this.intersectsPlane( plane );

};

Ray.prototype.isIntersectionSphere = function ( sphere ) {

	console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
	return this.intersectsSphere( sphere );

};

//

Triangle.prototype.area = function () {

	console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
	return this.getArea();

};

Triangle.prototype.barycoordFromPoint = function ( point, target ) {

	console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
	return this.getBarycoord( point, target );

};

Triangle.prototype.midpoint = function ( target ) {

	console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
	return this.getMidpoint( target );

};

Triangle.prototypenormal = function ( target ) {

	console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
	return this.getNormal( target );

};

Triangle.prototype.plane = function ( target ) {

	console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
	return this.getPlane( target );

};

Triangle.barycoordFromPoint = function ( point, a, b, c, target ) {

	console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
	return Triangle.getBarycoord( point, a, b, c, target );

};

Triangle.normal = function ( a, b, c, target ) {

	console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
	return Triangle.getNormal( a, b, c, target );

};

//

Shape.prototype.extractAllPoints = function ( divisions ) {

	console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
	return this.extractPoints( divisions );

};

Shape.prototype.extrude = function ( options ) {

	console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
	return new ExtrudeGeometry( this, options );

};

Shape.prototype.makeGeometry = function ( options ) {

	console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
	return new ShapeGeometry( this, options );

};

//

Vector2.prototype.fromAttribute = function ( attribute, index, offset ) {

	console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	return this.fromBufferAttribute( attribute, index, offset );

};

Vector2.prototype.distanceToManhattan = function ( v ) {

	console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
	return this.manhattanDistanceTo( v );

};

Vector2.prototype.lengthManhattan = function () {

	console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
	return this.manhattanLength();

};

//

Vector3.prototype.setEulerFromRotationMatrix = function () {

	console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

};

Vector3.prototype.setEulerFromQuaternion = function () {

	console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

};

Vector3.prototype.getPositionFromMatrix = function ( m ) {

	console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
	return this.setFromMatrixPosition( m );

};

Vector3.prototype.getScaleFromMatrix = function ( m ) {

	console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
	return this.setFromMatrixScale( m );

};

Vector3.prototype.getColumnFromMatrix = function ( index, matrix ) {

	console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
	return this.setFromMatrixColumn( matrix, index );

};

Vector3.prototype.applyProjection = function ( m ) {

	console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
	return this.applyMatrix4( m );

};

Vector3.prototype.fromAttribute = function ( attribute, index, offset ) {

	console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	return this.fromBufferAttribute( attribute, index, offset );

};

Vector3.prototype.distanceToManhattan = function ( v ) {

	console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
	return this.manhattanDistanceTo( v );

};

Vector3.prototype.lengthManhattan = function () {

	console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
	return this.manhattanLength();

};

//

Vector4.prototype.fromAttribute = function ( attribute, index, offset ) {

	console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	return this.fromBufferAttribute( attribute, index, offset );

};

Vector4.prototype.lengthManhattan = function () {

	console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
	return this.manhattanLength();

};

//

Object3D.prototype.getChildByName = function ( name ) {

	console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
	return this.getObjectByName( name );

};

Object3D.prototype.renderDepth = function () {

	console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

};

Object3D.prototype.translate = function ( distance, axis ) {

	console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
	return this.translateOnAxis( axis, distance );

};

Object3D.prototype.getWorldRotation = function () {

	console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

};

Object3D.prototype.applyMatrix = function ( matrix ) {

	console.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );
	return this.applyMatrix4( matrix );

};

Object.defineProperties( Object3D.prototype, {

	eulerOrder: {
		get: function () {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			return this.rotation.order;

		},
		set: function ( value ) {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			this.rotation.order = value;

		}
	},
	useQuaternion: {
		get: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},
		set: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		}
	}

} );

Mesh.prototype.setDrawMode = function () {

	console.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

};

Object.defineProperties( Mesh.prototype, {

	drawMode: {
		get: function () {

			console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );
			return TrianglesDrawMode;

		},
		set: function () {

			console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

		}
	}

} );

SkinnedMesh.prototype.initBones = function () {

	console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );

};

Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {

	get: function () {

		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
		return this.arcLengthDivisions;

	},
	set: function ( value ) {

		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
		this.arcLengthDivisions = value;

	}

} );

//

PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

	console.warn( 'THREE.PerspectiveCamera.setLens is deprecated. ' +
			'Use .setFocalLength and .filmGauge for a photographic setup.' );

	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
	this.setFocalLength( focalLength );

};

//

Object.defineProperties( Light.prototype, {
	onlyShadow: {
		set: function () {

			console.warn( 'THREE.Light: .onlyShadow has been removed.' );

		}
	},
	shadowCameraFov: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
			this.shadow.camera.fov = value;

		}
	},
	shadowCameraLeft: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
			this.shadow.camera.left = value;

		}
	},
	shadowCameraRight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
			this.shadow.camera.right = value;

		}
	},
	shadowCameraTop: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
			this.shadow.camera.top = value;

		}
	},
	shadowCameraBottom: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
			this.shadow.camera.bottom = value;

		}
	},
	shadowCameraNear: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
			this.shadow.camera.near = value;

		}
	},
	shadowCameraFar: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
			this.shadow.camera.far = value;

		}
	},
	shadowCameraVisible: {
		set: function () {

			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

		}
	},
	shadowBias: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
			this.shadow.bias = value;

		}
	},
	shadowDarkness: {
		set: function () {

			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

		}
	},
	shadowMapWidth: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
			this.shadow.mapSize.width = value;

		}
	},
	shadowMapHeight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
			this.shadow.mapSize.height = value;

		}
	}
} );

//

Object.defineProperties( BufferAttribute.prototype, {

	length: {
		get: function () {

			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
			return this.array.length;

		}
	},
	dynamic: {
		get: function () {

			console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			return this.usage === DynamicDrawUsage;

		},
		set: function ( /* value */ ) {

			console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			this.setUsage( DynamicDrawUsage );

		}
	}

} );

BufferAttribute.prototype.setDynamic = function ( value ) {

	console.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );
	this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
	return this;

};

BufferAttribute.prototype.copyIndicesArray = function ( /* indices */ ) {

	console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

},

BufferAttribute.prototype.setArray = function ( /* array */ ) {

	console.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

};

//

BufferGeometry.prototype.addIndex = function ( index ) {

	console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
	this.setIndex( index );

};

BufferGeometry.prototype.addAttribute = function ( name, attribute ) {

	console.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );

	if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

		console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

		return this.setAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

	}

	if ( name === 'index' ) {

		console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
		this.setIndex( attribute );

		return this;

	}

	return this.setAttribute( name, attribute );

};

BufferGeometry.prototype.addDrawCall = function ( start, count, indexOffset ) {

	if ( indexOffset !== undefined ) {

		console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

	}

	console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
	this.addGroup( start, count );

};

BufferGeometry.prototype.clearDrawCalls = function () {

	console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
	this.clearGroups();

};

BufferGeometry.prototype.computeOffsets = function () {

	console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

};

BufferGeometry.prototype.removeAttribute = function ( name ) {

	console.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );

	return this.deleteAttribute( name );

};

BufferGeometry.prototype.applyMatrix = function ( matrix ) {

	console.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );
	return this.applyMatrix4( matrix );

};

Object.defineProperties( BufferGeometry.prototype, {

	drawcalls: {
		get: function () {

			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
			return this.groups;

		}
	},
	offsets: {
		get: function () {

			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
			return this.groups;

		}
	}

} );

Object.defineProperties( InstancedBufferGeometry.prototype, {

	maxInstancedCount: {
		get: function () {

			console.warn( 'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.' );
			return this.instanceCount;

		},
		set: function ( value ) {

			console.warn( 'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.' );
			this.instanceCount = value;

		}
	}

} );

Object.defineProperties( Raycaster.prototype, {

	linePrecision: {
		get: function () {

			console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
			return this.params.Line.threshold;

		},
		set: function ( value ) {

			console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
			this.params.Line.threshold = value;

		}
	}

} );

Object.defineProperties( InterleavedBuffer.prototype, {

	dynamic: {
		get: function () {

			console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
			return this.usage === DynamicDrawUsage;

		},
		set: function ( value ) {

			console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
			this.setUsage( value );

		}
	}

} );

InterleavedBuffer.prototype.setDynamic = function ( value ) {

	console.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );
	this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
	return this;

};

InterleavedBuffer.prototype.setArray = function ( /* array */ ) {

	console.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

};

//

ExtrudeGeometry.prototype.getArrays = function () {

	console.error( 'THREE.ExtrudeGeometry: .getArrays() has been removed.' );

};

ExtrudeGeometry.prototype.addShapeList = function () {

	console.error( 'THREE.ExtrudeGeometry: .addShapeList() has been removed.' );

};

ExtrudeGeometry.prototype.addShape = function () {

	console.error( 'THREE.ExtrudeGeometry: .addShape() has been removed.' );

};

//

Scene.prototype.dispose = function () {

	console.error( 'THREE.Scene: .dispose() has been removed.' );

};

//

Uniform.prototype.onUpdate = function () {

	console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
	return this;

};

//

Object.defineProperties( Material.prototype, {

	wrapAround: {
		get: function () {

			console.warn( 'THREE.Material: .wrapAround has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Material: .wrapAround has been removed.' );

		}
	},

	overdraw: {
		get: function () {

			console.warn( 'THREE.Material: .overdraw has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Material: .overdraw has been removed.' );

		}
	},

	wrapRGB: {
		get: function () {

			console.warn( 'THREE.Material: .wrapRGB has been removed.' );
			return new Color();

		}
	},

	shading: {
		get: function () {

			console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

		},
		set: function ( value ) {

			console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
			this.flatShading = ( value === FlatShading );

		}
	},

	stencilMask: {
		get: function () {

			console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			return this.stencilFuncMask;

		},
		set: function ( value ) {

			console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			this.stencilFuncMask = value;

		}
	}

} );

Object.defineProperties( MeshPhysicalMaterial.prototype, {

	transparency: {
		get: function () {

			console.warn( 'THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.' );
			return this.transmission;

		},
		set: function ( value ) {

			console.warn( 'THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.' );
			this.transmission = value;

		}
	}

} );

Object.defineProperties( ShaderMaterial.prototype, {

	derivatives: {
		get: function () {

			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			return this.extensions.derivatives;

		},
		set: function ( value ) {

			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			this.extensions.derivatives = value;

		}
	}

} );

//

WebGLRenderer.prototype.clearTarget = function ( renderTarget, color, depth, stencil ) {

	console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
	this.setRenderTarget( renderTarget );
	this.clear( color, depth, stencil );

};

WebGLRenderer.prototype.animate = function ( callback ) {

	console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
	this.setAnimationLoop( callback );

};

WebGLRenderer.prototype.getCurrentRenderTarget = function () {

	console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
	return this.getRenderTarget();

};

WebGLRenderer.prototype.getMaxAnisotropy = function () {

	console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
	return this.capabilities.getMaxAnisotropy();

};

WebGLRenderer.prototype.getPrecision = function () {

	console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
	return this.capabilities.precision;

};

WebGLRenderer.prototype.resetGLState = function () {

	console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
	return this.state.reset();

};

WebGLRenderer.prototype.supportsFloatTextures = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
	return this.extensions.get( 'OES_texture_float' );

};

WebGLRenderer.prototype.supportsHalfFloatTextures = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
	return this.extensions.get( 'OES_texture_half_float' );

};

WebGLRenderer.prototype.supportsStandardDerivatives = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
	return this.extensions.get( 'OES_standard_derivatives' );

};

WebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
	return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

};

WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
	return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

};

WebGLRenderer.prototype.supportsBlendMinMax = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
	return this.extensions.get( 'EXT_blend_minmax' );

};

WebGLRenderer.prototype.supportsVertexTextures = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
	return this.capabilities.vertexTextures;

};

WebGLRenderer.prototype.supportsInstancedArrays = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
	return this.extensions.get( 'ANGLE_instanced_arrays' );

};

WebGLRenderer.prototype.enableScissorTest = function ( boolean ) {

	console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
	this.setScissorTest( boolean );

};

WebGLRenderer.prototype.initMaterial = function () {

	console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

};

WebGLRenderer.prototype.addPrePlugin = function () {

	console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

};

WebGLRenderer.prototype.addPostPlugin = function () {

	console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

};

WebGLRenderer.prototype.updateShadowMap = function () {

	console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

};

WebGLRenderer.prototype.setFaceCulling = function () {

	console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

};

WebGLRenderer.prototype.allocTextureUnit = function () {

	console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );

};

WebGLRenderer.prototype.setTexture = function () {

	console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );

};

WebGLRenderer.prototype.setTexture2D = function () {

	console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );

};

WebGLRenderer.prototype.setTextureCube = function () {

	console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );

};

WebGLRenderer.prototype.getActiveMipMapLevel = function () {

	console.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' );
	return this.getActiveMipmapLevel();

};

Object.defineProperties( WebGLRenderer.prototype, {

	shadowMapEnabled: {
		get: function () {

			return this.shadowMap.enabled;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
			this.shadowMap.enabled = value;

		}
	},
	shadowMapType: {
		get: function () {

			return this.shadowMap.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
			this.shadowMap.type = value;

		}
	},
	shadowMapCullFace: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function ( /* value */ ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

		}
	},
	context: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );
			return this.getContext();

		}
	},
	vr: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );
			return this.xr;

		}
	},
	gammaInput: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );
			return false;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );

		}
	},
	gammaOutput: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			return false;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			this.outputEncoding = ( value === true ) ? sRGBEncoding : LinearEncoding;

		}
	},
	toneMappingWhitePoint: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );
			return 1.0;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );

		}
	},

} );

Object.defineProperties( WebGLShadowMap.prototype, {

	cullFace: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function ( /* cullFace */ ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

		}
	},
	renderReverseSided: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

		}
	},
	renderSingleSided: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

		}
	}

} );

function WebGLRenderTargetCube( width, height, options ) {

	console.warn( 'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).' );
	return new WebGLCubeRenderTarget( width, options );

}

//

Object.defineProperties( WebGLRenderTarget.prototype, {

	wrapS: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			return this.texture.wrapS;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			this.texture.wrapS = value;

		}
	},
	wrapT: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			return this.texture.wrapT;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			this.texture.wrapT = value;

		}
	},
	magFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			return this.texture.magFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			this.texture.magFilter = value;

		}
	},
	minFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			return this.texture.minFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			this.texture.minFilter = value;

		}
	},
	anisotropy: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			return this.texture.anisotropy;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			this.texture.anisotropy = value;

		}
	},
	offset: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			return this.texture.offset;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			this.texture.offset = value;

		}
	},
	repeat: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			return this.texture.repeat;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			this.texture.repeat = value;

		}
	},
	format: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			return this.texture.format;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			this.texture.format = value;

		}
	},
	type: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			return this.texture.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			this.texture.type = value;

		}
	},
	generateMipmaps: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			return this.texture.generateMipmaps;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			this.texture.generateMipmaps = value;

		}
	}

} );

//

Audio.prototype.load = function ( file ) {

	console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
	const scope = this;
	const audioLoader = new AudioLoader();
	audioLoader.load( file, function ( buffer ) {

		scope.setBuffer( buffer );

	} );
	return this;

};


AudioAnalyser.prototype.getData = function () {

	console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
	return this.getFrequencyData();

};

//

CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

	console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
	return this.update( renderer, scene );

};

CubeCamera.prototype.clear = function ( renderer, color, depth, stencil ) {

	console.warn( 'THREE.CubeCamera: .clear() is now .renderTarget.clear().' );
	return this.renderTarget.clear( renderer, color, depth, stencil );

};

ImageUtils.crossOrigin = undefined;

ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {

	console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

	const loader = new TextureLoader();
	loader.setCrossOrigin( this.crossOrigin );

	const texture = loader.load( url, onLoad, undefined, onError );

	if ( mapping ) texture.mapping = mapping;

	return texture;

};

ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {

	console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

	const loader = new CubeTextureLoader();
	loader.setCrossOrigin( this.crossOrigin );

	const texture = loader.load( urls, onLoad, undefined, onError );

	if ( mapping ) texture.mapping = mapping;

	return texture;

};

ImageUtils.loadCompressedTexture = function () {

	console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

};

ImageUtils.loadCompressedTextureCube = function () {

	console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

};

//

function CanvasRenderer() {

	console.error( 'THREE.CanvasRenderer has been removed' );

}

//

function JSONLoader() {

	console.error( 'THREE.JSONLoader has been removed.' );

}

//

const SceneUtils = {

	createMultiMaterialObject: function ( /* geometry, materials */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	},

	detach: function ( /* child, parent, scene */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	},

	attach: function ( /* child, scene, parent */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	}

};

//

function LensFlare() {

	console.error( 'THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js' );

}

if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

	/* eslint-disable no-undef */
	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
		revision: REVISION,
	} } ) );
	/* eslint-enable no-undef */

}

if ( typeof window !== 'undefined' ) {

	if ( window.__THREE__ ) {

		console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

	} else {

		window.__THREE__ = REVISION;

	}

}




/***/ }),

/***/ "8c0b":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "8c14":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return evaluateString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return evaluateObject; });
/* harmony import */ var json5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7b00");
/* harmony import */ var json5__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(json5__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var map_anything__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("9ed5");


/**
 * Tries to evaluate a string with `eval()` and if failed with `json5.parse()`.
 *
 * @export
 * @param {string} str
 * @returns {*}
 */

function evaluateString(str) {
  try {
    if (str[0] === '{' && str[str.length - 1] === '}') {
      return json5__WEBPACK_IMPORTED_MODULE_0___default.a.parse(str);
    }

    var evaluated = eval(str);
    return evaluated;
  } catch (error) {
    try {
      return json5__WEBPACK_IMPORTED_MODULE_0___default.a.parse(str);
    } catch (error) {}
  }
}
/**
 * Tries to evaluate an object with all stringified values
 *
 * @export
 * @param {object} obj
 * @returns {object}
 */

function evaluateObject(obj) {
  return Object(map_anything__WEBPACK_IMPORTED_MODULE_1__[/* mapObject */ "a"])(obj, evaluateString);
}

/***/ }),

/***/ "8c42":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ca22");
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("9869");
/* harmony import */ var _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("0fb0");
/* harmony import */ var _utils_slot_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("a4b3");




/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_1__["default"].extend({
  name: 'QPage',
  mixins: [_mixins_listeners_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]],
  inject: {
    pageContainer: {
      default() {
        console.error('QPage needs to be child of QPageContainer');
      }

    },
    layout: {}
  },
  props: {
    padding: Boolean,
    styleFn: Function
  },
  computed: {
    style() {
      const offset = (this.layout.header.space === true ? this.layout.header.size : 0) + (this.layout.footer.space === true ? this.layout.footer.size : 0);

      if (typeof this.styleFn === 'function') {
        const height = this.layout.container === true ? this.layout.containerHeight : this.$q.screen.height;
        return this.styleFn(offset, height);
      }

      return {
        minHeight: this.layout.container === true ? this.layout.containerHeight - offset + 'px' : this.$q.screen.height === 0 ? `calc(100vh - ${offset}px)` : this.$q.screen.height - offset + 'px'
      };
    },

    classes() {
      if (this.padding === true) {
        return 'q-layout-padding';
      }
    }

  },

  render(h) {
    return h('main', {
      staticClass: 'q-page',
      style: this.style,
      class: this.classes,
      on: _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.qListeners)
    }, Object(_utils_slot_js__WEBPACK_IMPORTED_MODULE_3__[/* slot */ "c"])(this, 'default'));
  }

}));

/***/ }),

/***/ "8d0f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// `Symbol.prototype.description` getter
// https://tc39.es/ecma262/#sec-symbol.prototype.description

var $ = __webpack_require__("6b1d");
var DESCRIPTORS = __webpack_require__("d4cb");
var global = __webpack_require__("f498");
var has = __webpack_require__("f1a7");
var isObject = __webpack_require__("7526");
var defineProperty = __webpack_require__("abdf").f;
var copyConstructorProperties = __webpack_require__("b634");

var NativeSymbol = global.Symbol;

if (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;

  var symbolToString = symbolPrototype.toString;
  var native = String(NativeSymbol('test')) == 'Symbol(test)';
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  $({ global: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}


/***/ }),

/***/ "8fa9":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("7526");
var setPrototypeOf = __webpack_require__("c1a2");

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    typeof (NewTarget = dummy.constructor) == 'function' &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ "9007":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function (fn, wait = 250, immediate) {
  let timeout;

  function debounced()
  /* ...args */
  {
    const args = arguments;

    const later = () => {
      timeout = void 0;

      if (immediate !== true) {
        fn.apply(this, args);
      }
    };

    clearTimeout(timeout);

    if (immediate === true && timeout === void 0) {
      fn.apply(this, args);
    }

    timeout = setTimeout(later, wait);
  }

  debounced.cancel = () => {
    clearTimeout(timeout);
  };

  return debounced;
});

/***/ }),

/***/ "9057":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("6b1d");
var flattenIntoArray = __webpack_require__("e369");
var toObject = __webpack_require__("37d1");
var toLength = __webpack_require__("b495");
var aFunction = __webpack_require__("8697");
var arraySpeciesCreate = __webpack_require__("6a86");

// `Array.prototype.flatMap` method
// https://tc39.es/ecma262/#sec-array.prototype.flatmap
$({ target: 'Array', proto: true }, {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A;
    aFunction(callbackfn);
    A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return A;
  }
});


/***/ }),

/***/ "9163":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return propToPropSchema; });
/* harmony import */ var is_what__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7dfd");
/* harmony import */ var _evaluateString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("8c14");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }



/**
 * @typedef PropDescriptor
 * @type {{
  type?: { name: string; func?: boolean }
  description?: string
  required?: boolean
  defaultValue?: { value: string; func?: boolean }
  tags?: { [title: string]: BlockTag[] }
  values?: string[]
  name: string
}}
 */

function parseExample(example) {
  return "`".concat(example, "`");
}
/**
 * @param {PropDescriptor} vueDocgenProp
 * @returns {{categories: string[], schema: object}} BlitzForm schema blueprint
 */


function propToPropSchema(vueDocgenProp) {
  if (process && process.env && false) console.log("vueDocgenProp \u2192 ", vueDocgenProp); // get the documentation I want to use from the vueDocgenProp

  var required = vueDocgenProp.required,
      description = vueDocgenProp.description,
      _vueDocgenProp$type = vueDocgenProp.type,
      type = _vueDocgenProp$type === void 0 ? {
    name: 'any'
  } : _vueDocgenProp$type,
      _vueDocgenProp$defaul = vueDocgenProp.defaultValue,
      defaultValueInfo = _vueDocgenProp$defaul === void 0 ? {} : _vueDocgenProp$defaul,
      _vueDocgenProp$values = vueDocgenProp.values,
      values = _vueDocgenProp$values === void 0 ? [] : _vueDocgenProp$values,
      _vueDocgenProp$tags = vueDocgenProp.tags,
      customTags = _vueDocgenProp$tags === void 0 ? {} : _vueDocgenProp$tags,
      propName = vueDocgenProp.name,
      _vueDocgenProp$proper = vueDocgenProp.properties,
      properties = _vueDocgenProp$proper === void 0 ? [] : _vueDocgenProp$proper; // format the top level tags

  var types = Object(is_what__WEBPACK_IMPORTED_MODULE_0__[/* isString */ "d"])(type.name) ? type.name.split('|').map(function (s) {
    return s.trim();
  }) : ['any'];

  function typeIs(_type) {
    var propType = types[0];
    var yes = propType === _type && types.length === 1;
    if (yes) return yes;

    if (_type === 'object') {
      return propType[0] === '{' && propType[propType.length - 1] === '}';
    }

    return yes;
  } // get the documentation I want to use from the custom tags


  var _typeTags = customTags.type || [];

  var typeTags = _typeTags.map(function (t) {
    return t.type.name;
  });

  var _inheritedProp = customTags.inheritedProp || [{
    description: false
  }];

  var inheritedProp = _inheritedProp[0].description;

  var _examples = customTags.example || [];

  var _categories = customTags.category || (!inheritedProp ? [{
    description: 'general'
  }] : [{
    description: 'inheritedProp'
  }]); // format the custom tags for usage


  var examples = _examples.map(function (e) {
    return e.description;
  });

  var categories = _categories.map(function (c) {
    return c.description;
  });

  var isSlot = categories.includes('slots');
  var isEvent = categories.includes('events');
  var isMethod = categories.includes('methods'); // whatever the prop is, default to an 'input'

  var component = isSlot || isEvent || isMethod ? undefined : 'PlanetarInput';
  var subLabel = description;
  var options, disable, parseInput, parseValue, autogrow, debounce, span, emitValue, inputType, defaultValue;
  var fieldClasses = [];

  if (typeTags.length && !isEvent) {
    subLabel += "\n\nType: `".concat(typeTags[0], "`");
  }

  if (!typeTags.length && types.length && !isEvent) {
    subLabel += "\n\nType: `".concat(types.join(', '), "`");
  }

  if (properties.length && isEvent) {
    subLabel += "\n\nParams:";
    properties.forEach(function (_ref) {
      var description = _ref.description,
          name = _ref.name,
          type = _ref.type;
      subLabel += "\n- **".concat(name, "**").concat(description ? ' - ' : '').concat(description || '', "<br />Type: `").concat(type.names.join(' | '), "`");
    });
  }

  defaultValue = defaultValueInfo.value;
  var requiresNewline = defaultValueInfo && defaultValueInfo.value && defaultValueInfo.value.includes('\n');

  if (requiresNewline) {
    inputType = 'textarea';
    autogrow = true;
  }

  var _df = Object(_evaluateString__WEBPACK_IMPORTED_MODULE_1__[/* evaluateString */ "b"])(defaultValueInfo.value); // If it has a default, write it in the description


  if (!Object(is_what__WEBPACK_IMPORTED_MODULE_0__[/* isUndefined */ "e"])(_df)) {
    if (requiresNewline) {
      subLabel += "\n\nDefault:\n```\n".concat(defaultValueInfo.value, "\n```");
    } else {
      subLabel += "\n\nDefault: `".concat(defaultValueInfo.value, "`");
    }
  } // if the prop is a Boolean, show this as a 'toggle'


  if (types.includes('boolean') || typeTags.length && typeTags.includes('boolean')) {
    component = 'PlanetarToggle';
    defaultValue = eval(defaultValue);
  } // if it's a Number field


  if (typeIs('number')) {
    inputType = 'number';
    parseInput = Number;
  }

  var valuesCalculated = values.length ? values.map(JSON.stringify) : typeTags.length ? typeTags[0].split('|').map(function (t) {
    return t.trim();
  }).filter(function (t) {
    return t[0] === "'" && t[t.length - 1] === "'";
  }) : []; // if the prop has a fixed set of possible values, show this as an 'option'

  var propHasValues = Object(is_what__WEBPACK_IMPORTED_MODULE_0__[/* isArray */ "a"])(valuesCalculated) && valuesCalculated.length > 1;

  if (propHasValues) {
    component = 'PlanetarSelect';
    options = valuesCalculated;
  } // Create a special input for defining arrays and/or objects


  if (typeIs('array') || typeIs('object') || typeIs('function') || Object(is_what__WEBPACK_IMPORTED_MODULE_0__[/* isArray */ "a"])(types) && ['array', 'object'].some(function (t) {
    return types.includes(t);
  }) && types.length === 2) {
    debounce = 500;
    autogrow = true;
  }

  if (examples.length) {
    var examplesParsed = examples.length === 1 ? parseExample(examples[0]) : examples.map(function (e) {
      return "\n- ".concat(parseExample(e));
    }).join('');
    subLabel += "\n\nExample".concat(examples.length === 1 ? '' : 's', ": ").concat(examplesParsed);
  } // remove any "undefined" from the string


  if (subLabel) subLabel = subLabel.replace('undefined\n\n', ''); // Create the blueprint for the prop

  var schema = {
    required: required,
    id: propName,
    component: component,
    type: inputType,
    label: propName,
    subLabel: subLabel,
    inheritedProp: inheritedProp,
    options: options,
    disable: disable,
    parseInput: parseInput,
    parseValue: parseValue,
    autogrow: autogrow,
    fieldClasses: fieldClasses,
    debounce: debounce,
    span: span,
    emitValue: emitValue,
    // if the prop is `true` by default, set to true
    defaultValue: defaultValue,
    // defaults
    hasMarkdown: true,
    isCode: true
  }; // remove undefined

  var schemaNoUndefined = Object.entries(schema).reduce(function (carry, _ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
        key = _ref3[0],
        value = _ref3[1];

    if (value === undefined) return carry;
    return Object.assign({}, carry, _defineProperty({}, key, value));
  }, {});
  return {
    categories: categories,
    schema: schemaNoUndefined
  };
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("07d9")))

/***/ }),

/***/ "918c":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("f498");
var DOMIterables = __webpack_require__("130d");
var ArrayIteratorMethods = __webpack_require__("9531");
var createNonEnumerableProperty = __webpack_require__("5b12");
var wellKnownSymbol = __webpack_require__("7d53");

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
}


/***/ }),

/***/ "9324":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("5428");

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ "9531":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__("378c");
var addToUnscopables = __webpack_require__("ed2b");
var Iterators = __webpack_require__("5bb7");
var InternalStateModule = __webpack_require__("cdcd");
var defineIterator = __webpack_require__("2df4");

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "95b2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// TODO: Remove from `core-js@4` since it's moved to entry points
__webpack_require__("2aa5");
var redefine = __webpack_require__("b8ba");
var fails = __webpack_require__("72df");
var wellKnownSymbol = __webpack_require__("7d53");
var createNonEnumerableProperty = __webpack_require__("5b12");

var SPECIES = wellKnownSymbol('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = (function () {
  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
  return 'a'.replace(/./, '$0') === '$0';
})();

var REPLACE = wellKnownSymbol('replace');
// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }
  return false;
})();

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  // eslint-disable-next-line regexp/no-empty-group -- required for testing
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

module.exports = function (KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () { execCalled = true; return null; };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !(
      REPLACE_SUPPORTS_NAMED_GROUPS &&
      REPLACE_KEEPS_$0 &&
      !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    )) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === RegExp.prototype.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
        }
        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
      }
      return { done: false };
    }, {
      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];

    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return regexMethod.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return regexMethod.call(string, this); }
    );
  }

  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
};


/***/ }),

/***/ "9618":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "9869":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * Vue.js v2.6.12
 * (c) 2014-2020 Evan You
 * Released under the MIT License.
 */
/*  */

var emptyObject = Object.freeze({});

// These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive.
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    // $flow-disable-line
    typeof value === 'symbol' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

/**
 * Get the raw type string of a value, e.g., [object Object].
 */
var _toString = Object.prototype.toString;

function toRawType (value) {
  return _toString.call(value).slice(8, -1)
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

function isPromise (val) {
  return (
    isDef(val) &&
    typeof val.then === 'function' &&
    typeof val.catch === 'function'
  )
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if an attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array.
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether an object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
});

/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */
function polyfillBind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }

  boundFn._length = fn.length;
  return boundFn
}

function nativeBind (fn, ctx) {
  return fn.bind(ctx)
}

var bind = Function.prototype.bind
  ? nativeBind
  : polyfillBind;

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */
var identity = function (_) { return _; };

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime()
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */
function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured',
  'serverPrefetch'
];

/*  */



var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "production" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "production" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */
var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = new RegExp(("[^" + (unicodeRegExp.source) + ".$_\\d]"));
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = /*@__PURE__*/(function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = (noop); // work around flow check
var formatComponentName = (noop);

if (false) { var repeat, classify, classifyRE, hasConsole; }

/*  */

var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  if (false) {}
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
Dep.target = null;
var targetStack = [];

function pushTarget (target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget () {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    vnode.children && vnode.children.slice(),
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);

var methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;

function toggleObserving (value) {
  shouldObserve = value;
}

/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1 (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (false) {}
      // #7981: for accessor properties without setter
      if (getter && !setter) { return }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if (false
  ) {}
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
     false && false;
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if (false
  ) {}
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
     false && false;
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (false) {}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;

  var keys = hasSymbol
    ? Reflect.ownKeys(from)
    : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    // in case the object is already observed...
    if (key === '__ob__') { continue }
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (
      toVal !== fromVal &&
      isPlainObject(toVal) &&
      isPlainObject(fromVal)
    ) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm, vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm, vm)
        : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
       false && false;

      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  var res = childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal;
  return res
    ? dedupeHooks(res)
    : res
}

function dedupeHooks (hooks) {
  var res = [];
  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }
  return res
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (
  parentVal,
  childVal,
  vm,
  key
) {
  var res = Object.create(parentVal || null);
  if (childVal) {
     false && false;
    return extend(res, childVal)
  } else {
    return res
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (
  parentVal,
  childVal,
  vm,
  key
) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (false) {}
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal,
  childVal,
  vm,
  key
) {
  if (childVal && "production" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName (name) {
  if (!new RegExp(("^[a-zA-Z][\\-\\.0-9_" + (unicodeRegExp.source) + "]*$")).test(name)) {
    warn(
      'Invalid component name: "' + name + '". Component names ' +
      'should conform to valid custom element name in html5 specification.'
    );
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn(
      'Do not use built-in or reserved HTML elements as component ' +
      'id: ' + name
    );
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options, vm) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (false) {}
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  } else if (false) {}
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options, vm) {
  var inject = options.inject;
  if (!inject) { return }
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val };
    }
  } else if (false) {}
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];
      if (typeof def$$1 === 'function') {
        dirs[key] = { bind: def$$1, update: def$$1 };
      }
    }
  }
}

function assertObjectType (name, value, vm) {
  if (!isPlainObject(value)) {
    warn(
      "Invalid value for option \"" + name + "\": expected an Object, " +
      "but got " + (toRawType(value)) + ".",
      vm
    );
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (false) {}

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);

  // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (false) {}
  return res
}

/*  */



function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // boolean casting
  var booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  if (
    false
  ) {}
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (false) {}
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  if (!valid) {
    warn(
      getInvalidTypeMessage(name, value, expectedTypes),
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType (value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ''
}

function isSameType (a, b) {
  return getType(a) === getType(b)
}

function getTypeIndex (type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1
  }
  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i
    }
  }
  return -1
}

function getInvalidTypeMessage (name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." +
    " Expected " + (expectedTypes.map(capitalize).join(', '));
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType);
  // check if we need to specify expected value
  if (expectedTypes.length === 1 &&
      isExplicable(expectedType) &&
      !isBoolean(expectedType, receivedType)) {
    message += " with value " + expectedValue;
  }
  message += ", got " + receivedType + " ";
  // check if we need to specify received value
  if (isExplicable(receivedType)) {
    message += "with value " + receivedValue + ".";
  }
  return message
}

function styleValue (value, type) {
  if (type === 'String') {
    return ("\"" + value + "\"")
  } else if (type === 'Number') {
    return ("" + (Number(value)))
  } else {
    return ("" + value)
  }
}

function isExplicable (value) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })
}

function isBoolean () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })
}

/*  */

function handleError (err, vm, info) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  // See: https://github.com/vuejs/vuex/issues/1505
  pushTarget();
  try {
    if (vm) {
      var cur = vm;
      while ((cur = cur.$parent)) {
        var hooks = cur.$options.errorCaptured;
        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;
              if (capture) { return }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }
    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}

function invokeWithErrorHandling (
  handler,
  context,
  args,
  vm,
  info
) {
  var res;
  try {
    res = args ? handler.apply(context, args) : handler.call(context);
    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
      // issue #9511
      // avoid catch triggering multiple times when nested calls
      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }
  return res
}

function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }
  logError(err, vm, info);
}

function logError (err, vm, info) {
  if (false) {}
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err
  }
}

/*  */

var isUsingMicroTask = false;

var callbacks = [];
var pending = false;

function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).
var timerFunc;

// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  timerFunc = function () {
    p.then(flushCallbacks);
    // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) { setTimeout(noop); }
  };
  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (
  isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });
  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };
  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Technically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick (cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    timerFunc();
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    })
  }
}

/*  */

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (false) { var getHandler, hasHandler, isBuiltInModifier, hasProxy, warnReservedPrefix, warnNonPresent, allowedGlobals; }

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse (val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

var mark;
var measure;

if (false) { var perf; }

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns, vm) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler")
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  createOnceHandler,
  vm
) {
  var name, def$$1, cur, old, event;
  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
       false && false;
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }
      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }
      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (false) { var keyInLowerCase; }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]).text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (false) {} else {
        defineReactive$$1(vm, key, result[key]);
      }
    });
    toggleObserving(true);
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
      ? Reflect.ownKeys(inject)
      : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      // #6574 in case the inject object is observed...
      if (key === '__ob__') { continue }
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault;
        } else if (false) {}
      }
    }
    return result
  }
}

/*  */



/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  if (!children || !children.length) {
    return {}
  }
  var slots = {};
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) &&
      data && data.slot != null
    ) {
      var name = data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots
}

function isWhitespace (node) {
  return (node.isComment && !node.asyncFactory) || node.text === ' '
}

/*  */

function normalizeScopedSlots (
  slots,
  normalSlots,
  prevSlots
) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;
  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized
  } else if (
    isStable &&
    prevSlots &&
    prevSlots !== emptyObject &&
    key === prevSlots.$key &&
    !hasNormalSlots &&
    !prevSlots.$hasNormal
  ) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots
  } else {
    res = {};
    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  }
  // expose normal slots on scopedSlots
  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  }
  // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error
  if (slots && Object.isExtensible(slots)) {
    (slots)._normalized = res;
  }
  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res)
      ? [res] // single vnode
      : normalizeChildren(res);
    return res && (
      res.length === 0 ||
      (res.length === 1 && res[0].isComment) // #9658
    ) ? undefined
      : res
  };
  // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.
  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }
  return normalized
}

function proxyNormalSlot(slots, key) {
  return function () { return slots[key]; }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();
      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }
  if (!isDef(ret)) {
    ret = [];
  }
  (ret)._isVList = true;
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      if (false) {}
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || fallback;
  } else {
    nodes = this.$slots[name] || fallback;
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

function isKeyNotMatch (expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1
  } else {
    return expect !== actual
  }
}

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInKeyCode,
  eventKeyName,
  builtInKeyName
) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName)
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode)
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
       false && false;
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        var camelizedKey = camelize(key);
        var hyphenatedKey = hyphenate(key);
        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.
  if (tree && !isInFor) {
    return tree
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = this.$options.staticRenderFns[index].call(
    this._renderProxy,
    null,
    this // for render fns generated for functional component templates
  );
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
       false && false;
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data
}

/*  */

function resolveScopedSlots (
  fns, // see flow/vnode
  res,
  // the following are added in 2.6
  hasDynamicKeys,
  contentHashKey
) {
  res = res || { $stable: !hasDynamicKeys };
  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];
    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }
      res[slot.key] = slot.fn;
    }
  }
  if (contentHashKey) {
    (res).$key = contentHashKey;
  }
  return res
}

/*  */

function bindDynamicKeys (baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];
    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if (false) {}
  }
  return baseObj
}

// helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.
function prependModifier (value, symbol) {
  return typeof value === 'string' ? symbol + value : value
}

/*  */

function installRenderHelpers (target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}

/*  */

function FunctionalRenderContext (
  data,
  props,
  children,
  parent,
  Ctor
) {
  var this$1 = this;

  var options = Ctor.options;
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm;
  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent);
    // $flow-disable-line
    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent;
    // $flow-disable-line
    parent = parent._original;
  }
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(
        data.scopedSlots,
        this$1.$slots = resolveSlots(children, parent)
      );
    }
    return this$1.$slots
  };

  Object.defineProperty(this, 'scopedSlots', ({
    enumerable: true,
    get: function get () {
      return normalizeScopedSlots(data.scopedSlots, this.slots())
    }
  }));

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode
    };
  } else {
    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  contextVm,
  children
) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }

  var renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  );

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);
    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }
    return res
  }
}

function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  if (false) {}
  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }
  return clone
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

/*  */

/*  */

/*  */

// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (vnode, hydrating) {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (false) {}
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // install component management hooks onto the placeholder node
  installComponentHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );

  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options)
}

function installComponentHooks (data) {
  var hooks = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1 (f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };
  merged._merged = true;
  return merged
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input'
  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;
  if (isDef(existing)) {
    if (
      Array.isArray(existing)
        ? existing.indexOf(callback) === -1
        : existing !== callback
    ) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
     false && false;
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if (false
  ) {}
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if (false) {}
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) { applyNS(vnode, ns); }
    if (isDef(data)) { registerDeepBindings(data); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (
        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
        applyNS(child, ns, force);
      }
    }
  }
}

// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings (data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }
  if (isObject(data.class)) {
    traverse(data.class);
  }
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (false) {} else {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, null, true);
  }
}

var currentRenderingInstance = null;

function renderMixin (Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(
        _parentVnode.data.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      );
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (false) {} else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    }
    // if the returned array contains only a single node, allow it
    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (false) {}
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };
}

/*  */

function ensureCtor (comp, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  var owner = currentRenderingInstance;
  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner);
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (owner && !isDef(factory.owners)) {
    var owners = factory.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null

    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        (owners[i]).$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;
        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }
        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });

    var reject = once(function (reason) {
       false && false;
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading = setTimeout(function () {
              timerLoading = null;
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function () {
            timerTimeout = null;
            if (isUndef(factory.resolved)) {
              reject(
                 false
                  ? (undefined)
                  : null
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn) {
  target.$on(event, fn);
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function createOnceHandler (event, fn) {
  var _target = target;
  return function onceHandler () {
    var res = fn.apply(null, arguments);
    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  }
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (!fn) {
      vm._events[event] = null;
      return vm
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (false) { var lowerCaseEvent; }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";
      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }
    return vm
  };
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  }
}

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    restoreActiveInstance();
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (false) {}
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (false) {} else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, {
    before: function before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  if (false) {}

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.

  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.
  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(
    (newScopedSlots && !newScopedSlots.$stable) ||
    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)
  );

  // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.
  var needsForceUpdate = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    hasDynamicScopedSlot
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?
      props[key] = validateProp(key, propOptions, propsData, vm);
    }
    toggleObserving(true);
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners);

  // resolve slots + force update if has children
  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (false) {}
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
  popTarget();
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (false) {}
  waiting = flushing = false;
}

// Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.
var currentFlushTimestamp = 0;

// Async edge case fix requires storing an event listener's attach timestamp.
var getNow = Date.now;

// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)
if (inBrowser && !isIE) {
  var performance = window.performance;
  if (
    performance &&
    typeof performance.now === 'function' &&
    getNow() > document.createEvent('Event').timeStamp
  ) {
    // if the event timestamp, although evaluated AFTER the Date.now(), is
    // smaller than it, it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listener timestamps as
    // well.
    getNow = function () { return performance.now(); };
  }
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    if (watcher.before) {
      watcher.before();
    }
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (false) {}
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;

      if (false) {}
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */



var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options,
  isRenderWatcher
) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  false
    ? undefined
    : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = noop;
       false && false;
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
  var i = this.deps.length;
  while (i--) {
    var dep = this.deps[i];
    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
  var i = this.deps.length;
  while (i--) {
    this.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this.deps[i].removeSub(this);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (false) { var hyphenatedKey; } else {
      defineReactive$$1(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  toggleObserving(true);
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
     false && false;
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (false) {}
    if (props && hasOwn(props, key)) {
       false && false;
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();
  try {
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if (false) {}

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (false) {}
  }
}

function defineComputed (
  target,
  key,
  userDef
) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }
  if (false) {}
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function createGetterInvoker(fn) {
  return function computedGetter () {
    return fn.call(this, this)
  }
}

function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (false) {}
    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}

function initWatch (vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  expOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  if (false) {}
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, ("callback for immediate watcher \"" + (watcher.expression) + "\""));
      }
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

var uid$3 = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$3++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (false) {}

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    if (false) {} else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (false) {}

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = latest[key];
    }
  }
  return modified
}

function Vue (options) {
  if (false
  ) {}
  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if (false) {}

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (false) {}
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */



function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry (
  cache,
  key,
  keys,
  current
) {
  var cached$$1 = cache[key];
  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created: function created () {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed () {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },

  mounted: function mounted () {
    var this$1 = this;

    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) { return matches(val, name); });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) { return !matches(val, name); });
    });
  },

  render: function render () {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
        // not included
        (include && (!name || !matches(include, name))) ||
        // excluded
        (exclude && name && matches(exclude, name))
      ) {
        return vnode
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }
    return vnode || (slot && slot[0])
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  if (false) {}
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  // 2.6 explicit observable API
  Vue.observable = function (obj) {
    observe(obj);
    return obj
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});

Vue.version = '2.6.12';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false'
    ? 'false'
    // allow arbitrary string value for contenteditable
    : key === 'contenteditable' && isValidContentEditableValue(value)
      ? value
      : 'true'
};

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,translate,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
  }
}

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
       false && false;
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setStyleScope (node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
};

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!isDef(key)) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove$$1 () {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1 (vnode, inVPre) {
    return (
      !inVPre &&
      !vnode.ns &&
      !(
        config.ignoredElements.length &&
        config.ignoredElements.some(function (ignore) {
          return isRegExp(ignore)
            ? ignore.test(vnode.tag)
            : ignore === vnode.tag
        })
      ) &&
      config.isUnknownElement(vnode.tag)
    )
  }

  var creatingElmInVPre = 0;

  function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (false) {}

      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (false) {}
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (false) {}
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      i !== vnode.fnContext &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    if (false) {}

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys (children) {
    var seenKeys = {};
    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn(
            ("Duplicate keys detected: '" + key + "'. This may cause an update error."),
            vnode.context
          );
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld (node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) { return i }
    }
  }

  function patchVnode (
    oldVnode,
    vnode,
    insertedVnodeQueue,
    ownerArray,
    index,
    removeOnly
  ) {
    if (oldVnode === vnode) {
      return
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (false) {}
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).
  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || (data && data.pre);
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true
    }
    // assert node match
    if (false) {}
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (false
              ) {}
              return false
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (false
              ) {}
              return false
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || (
        !isUnknownElement$$1(vnode, inVPre) &&
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else if (false) {}
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm);

        // create new node
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        );

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    // $flow-disable-line
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  // $flow-disable-line
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}

var baseModules = [
  ref,
  directives
];

/*  */

function updateAttrs (oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED'
        ? 'true'
        : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr (el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.
    /* istanbul ignore if */
    if (
      isIE && !isIE9 &&
      el.tagName === 'TEXTAREA' &&
      key === 'placeholder' && value !== '' && !el.__ieph
    ) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };
      el.addEventListener('input', blocker);
      // $flow-disable-line
      el.__ieph = true; /* IE placeholder patched */
    }
    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

/*  */

/*  */

/*  */

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1 (event, handler, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler () {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  }
}

// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.
var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1 (
  name,
  handler,
  capture,
  passive
) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;
    handler = original._wrapper = function (e) {
      if (
        // no bubbling, should always fire.
        // this is just a safety net in case event.timeStamp is unreliable in
        // certain weird environments...
        e.target === e.currentTarget ||
        // event is fired after handler attachment
        e.timeStamp >= attachedTimestamp ||
        // bail for environments that have buggy event.timeStamp implementations
        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
        // #9681 QtWebEngine event.timeStamp is negative value
        e.timeStamp <= 0 ||
        // #9448 bail if event is fired in another document in a multi-page
        // electron/nw.js app, since event.timeStamp will be using a different
        // starting reference
        e.target.ownerDocument !== document
      ) {
        return original.apply(this, arguments)
      }
    };
  }
  target$1.addEventListener(
    name,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  );
}

function remove$2 (
  name,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(
    name,
    handler._wrapper || handler,
    capture
  );
}

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

var svgContainer;

function updateDOMProps (oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (!(key in props)) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value' && elm.tagName !== 'PROGRESS') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;
      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }
      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else if (
      // skip the update if old and new VDOM state is the same.
      // `value` is handled separately because the DOM value may be temporarily
      // out of sync with VDOM state due to focus, composition and modifiers.
      // This  #4521 by skipping the unnecessary `checked` update.
      cur !== oldProps[key]
    ) {
      // some property updates can throw
      // e.g. `value` on <progress> w/ non-finite value
      try {
        elm[key] = cur;
      } catch (e) {}
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (elm, checkVal) {
  return (!elm.composing && (
    elm.tagName === 'OPTION' ||
    isNotInFocusAndDirty(elm, checkVal) ||
    isDirtyWithModifiers(elm, checkVal)
  ))
}

function isNotInFocusAndDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try { notInFocus = document.activeElement !== elm; } catch (e) {}
  return notInFocus && elm.value !== checkVal
}

function isDirtyWithModifiers (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal)
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim()
    }
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (
        childNode && childNode.data &&
        (styleData = normalizeStyleData(childNode.data))
      ) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in emptyStyle)) {
    return prop
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

var whitespaceRE = /\s+/;

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition (def$$1) {
  if (!def$$1) {
    return
  }
  /* istanbul ignore else */
  if (typeof def$$1 === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
  ? window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : setTimeout
  : /* istanbul ignore next */ function (fn) { return fn(); };

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  // JSDOM may return undefined for transition properties
  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors
function toMs (s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    context = transitionNode.context;
    transitionNode = transitionNode.parent;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if (false) {}

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);
      if (!cb.cancelled) {
        addTransitionClass(el, toClass);
        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm()
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb)) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if (false) {}

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (isUndef(fn)) {
    return false
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted (el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd);
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },

  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple
          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected (el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
     false && false;
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption (value, options) {
  return options.every(function (o) { return !looseEqual(o, value); })
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) { return }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (!value === !oldValue) { return }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: directive,
  show: show
};

/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    })
  }
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };

var isVShowDirective = function (d) { return d.name === 'show'; };

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(isNotTextNode);
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if (false) {}

    var mode = this.mode;

    // warn invalid mode
    if (false
    ) {}

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild) &&
      // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild
        }
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
};

/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  beforeMount: function beforeMount () {
    var this$1 = this;

    var update = this._update;
    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1);
      // force removing pass
      this$1.__patch__(
        this$1._vnode,
        this$1.kept,
        false, // hydrating
        true // removeOnly (!important, avoids unnecessary moves)
      );
      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else if (false) { var name, opts; }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (e && e.target !== el) {
            return
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
};

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else if (
        false
      ) {}
    }
    if (false
    ) {}
  }, 0);
}

/*  */

/* harmony default export */ __webpack_exports__["default"] = (Vue);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("7d15")))

/***/ }),

/***/ "98f3":
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__("8697");
var toObject = __webpack_require__("37d1");
var IndexedObject = __webpack_require__("83a6");
var toLength = __webpack_require__("b495");

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction(callbackfn);
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

module.exports = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};


/***/ }),

/***/ "9951":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("72df");
var whitespaces = __webpack_require__("fbf7");

var non = '\u200B\u0085\u180E';

// check that a method works with the correct list
// of whitespaces and has a correct name
module.exports = function (METHOD_NAME) {
  return fails(function () {
    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
  });
};


/***/ }),

/***/ "9a0f":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("8bb2");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "9ac9":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return listenOpts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return noop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return leftClick; });
/* unused harmony export middleClick */
/* unused harmony export rightClick */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return position; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getEventPath; });
/* unused harmony export getMouseWheelDistance */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return stop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return prevent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return stopAndPrevent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return stopAndPreventClick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return preventDraggable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addEvt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return cleanEvt; });
/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("918c");
/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_0__);

const listenOpts = {
  hasPassive: false,
  passiveCapture: true,
  notPassiveCapture: true
};

try {
  var opts = Object.defineProperty({}, 'passive', {
    get() {
      Object.assign(listenOpts, {
        hasPassive: true,
        passive: {
          passive: true
        },
        notPassive: {
          passive: false
        },
        passiveCapture: {
          passive: true,
          capture: true
        },
        notPassiveCapture: {
          passive: false,
          capture: true
        }
      });
    }

  });
  window.addEventListener('qtest', null, opts);
  window.removeEventListener('qtest', null, opts);
} catch (e) {}

function noop() {}
function leftClick(e) {
  return e.button === 0;
}
function middleClick(e) {
  return e.button === 1;
}
function rightClick(e) {
  return e.button === 2;
}
function position(e) {
  if (e.touches && e.touches[0]) {
    e = e.touches[0];
  } else if (e.changedTouches && e.changedTouches[0]) {
    e = e.changedTouches[0];
  } else if (e.targetTouches && e.targetTouches[0]) {
    e = e.targetTouches[0];
  }

  return {
    top: e.clientY,
    left: e.clientX
  };
}
function getEventPath(e) {
  if (e.path) {
    return e.path;
  }

  if (e.composedPath) {
    return e.composedPath();
  }

  const path = [];
  let el = e.target;

  while (el) {
    path.push(el);

    if (el.tagName === 'HTML') {
      path.push(document);
      path.push(window);
      return path;
    }

    el = el.parentElement;
  }
} // Reasonable defaults

const LINE_HEIGHT = 40,
      PAGE_HEIGHT = 800;
function getMouseWheelDistance(e) {
  let x = e.deltaX,
      y = e.deltaY;

  if ((x || y) && e.deltaMode) {
    const multiplier = e.deltaMode === 1 ? LINE_HEIGHT : PAGE_HEIGHT;
    x *= multiplier;
    y *= multiplier;
  }

  if (e.shiftKey && !x) {
    [y, x] = [x, y];
  }

  return {
    x,
    y
  };
}
function stop(e) {
  e.stopPropagation();
}
function prevent(e) {
  e.cancelable !== false && e.preventDefault();
}
function stopAndPrevent(e) {
  e.cancelable !== false && e.preventDefault();
  e.stopPropagation();
}
function stopAndPreventClick(evt) {
  stopAndPrevent(evt);

  if (evt.type === 'mousedown') {
    const handler = e => {
      e.target === evt.target && stopAndPrevent(e);
      document.removeEventListener('click', handler, listenOpts.notPassiveCapture);
    };

    document.addEventListener('click', handler, listenOpts.notPassiveCapture);
  }
}
function preventDraggable(el, status) {
  if (el === void 0 || status === true && el.__dragPrevented === true) {
    return;
  }

  const fn = status === true ? el => {
    el.__dragPrevented = true;
    el.addEventListener('dragstart', prevent, listenOpts.notPassiveCapture);
  } : el => {
    delete el.__dragPrevented;
    el.removeEventListener('dragstart', prevent, listenOpts.notPassiveCapture);
  };
  el.querySelectorAll('a, img').forEach(fn);
}
function create(name, {
  bubbles = false,
  cancelable = false
} = {}) {
  try {
    return new CustomEvent(name, {
      bubbles,
      cancelable
    });
  } catch (e) {
    // IE doesn't support `new Event()`, so...
    const evt = document.createEvent('Event');
    evt.initEvent(name, bubbles, cancelable);
    return evt;
  }
}
function addEvt(ctx, targetName, events) {
  const name = `__q_${targetName}_evt`;
  ctx[name] = ctx[name] !== void 0 ? ctx[name].concat(events) : events;
  events.forEach(evt => {
    evt[0].addEventListener(evt[1], ctx[evt[2]], listenOpts[evt[3]]);
  });
}
function cleanEvt(ctx, targetName) {
  const name = `__q_${targetName}_evt`;

  if (ctx[name] !== void 0) {
    ctx[name].forEach(evt => {
      evt[0].removeEventListener(evt[1], ctx[evt[2]], listenOpts[evt[3]]);
    });
    ctx[name] = void 0;
  }
}
/*
 * also update /types/utils/event.d.ts
 */

/* unused harmony default export */ var _unused_webpack_default_export = ({
  listenOpts,
  leftClick,
  middleClick,
  rightClick,
  position,
  getEventPath,
  getMouseWheelDistance,
  stop,
  prevent,
  stopAndPrevent,
  preventDraggable,
  create
});

/***/ }),

/***/ "9b70":
/***/ (function(module, exports, __webpack_require__) {

var objectWithoutPropertiesLoose = __webpack_require__("2dd1");

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

module.exports = _objectWithoutProperties;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "9b9f":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ExampleCard_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("f04f");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ExampleCard_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ExampleCard_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "9c21":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export camelCase */
/* unused harmony export capitalCase */
/* unused harmony export constantCase */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return kebabCase; });
/* unused harmony export lowerCase */
/* unused harmony export pascalCase */
/* unused harmony export pathCase */
/* unused harmony export snakeCase */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return spaceCase; });
/* unused harmony export upperCase */
// Latin-1 Supplement
// upper case ranges
// [--]
// lower case ranges
// [--]
/**
 * A string.match function that will return an array of "string parts"
 *
 * @param {string} string
 * @returns {string[]}
 */
function splitOnSpecialChars(string) {
    return string.match(/^[a-z--]+|[A-Z--][a-z--]+|[a-z--]+|[0-9]+|[A-Z--]+(?![a-z--])/g);
}
/**
 * A string.match function that will return an array of "string parts"
 *
 * @param {string} string
 * @returns {string[]}
 */
function getParts(string, noSpecialChars) {
    if (noSpecialChars === void 0) { noSpecialChars = false; }
    var target = string.trim().normalize('NFC');
    var parts = target.includes(' ') ? target.split(' ').filter(Boolean) : splitOnSpecialChars(target);
    return noSpecialChars ? parts.map(function (part) { return part.normalize('NFD').replace(/[^a-zA-Z0-9]/g, ''); }) : parts;
}
/**
 * Capitalises a single word
 *
 * @export
 * @param {string} string the word
 * @returns {string} the word with the first character in uppercase and the rest in lowercase
 */
function capitaliseWord(string) {
    return string[0].toUpperCase() + string.slice(1).toLowerCase();
}

var noSpecialChars = true;
/**
 * converts strings to camelCase
 *
 * @export
 * @param {string} string
 * @returns {string} in camelCase
 */
function camelCase(string) {
    return getParts(string, noSpecialChars).reduce(function (result, match, index) {
        return index === 0 ? match.toLowerCase() : result + capitaliseWord(match);
    }, '');
}
/**
 * converts strings to PascalCase
 *
 * @export
 * @param {string} string
 * @returns {string} in PascalCase
 */
function pascalCase(string) {
    return getParts(string, noSpecialChars).reduce(function (result, match) {
        return result + capitaliseWord(match);
    }, '');
}
/**
 * converts strings to kebab-case
 *
 * @export
 * @param {string} string
 * @returns {string} in kebab-case
 */
function kebabCase(string) {
    return getParts(string, noSpecialChars)
        .join('-')
        .toLowerCase();
}
/**
 * converts strings to snake_case
 *
 * @export
 * @param {string} string
 * @returns {string} in snake_case
 */
function snakeCase(string) {
    return getParts(string, noSpecialChars)
        .join('_')
        .toLowerCase();
}
/**
 * converts strings to CONSTANT_CASE
 *
 * @export
 * @param {string} string
 * @returns {string} in CONSTANT_CASE
 */
function constantCase(string) {
    return getParts(string, noSpecialChars)
        .join('_')
        .toUpperCase();
}
/**
 * converts strings to path/case
 *
 * @export
 * @param {string} string
 * @returns {string} in path/case
 */
function pathCase(string) {
    return getParts(string).join('/');
}
/**
 * converts strings to space case (will add spaces but not change casing)
 *
 * @export
 * @param {string} string
 * @returns {string} in path case
 */
function spaceCase(string) {
    return getParts(string).join(' ');
}
/**
 * converts strings to Capital Case (with spaces)
 *
 * @export
 * @param {string} string
 * @returns {string} in Capital Case (with spaces)
 */
function capitalCase(string) {
    return getParts(string)
        .reduce(function (result, match) {
        return result + " " + capitaliseWord(match);
    }, '')
        .trim();
}
/**
 * converts strings to lower case (with spaces)
 *
 * @export
 * @param {string} string
 * @returns {string} in lower case (with spaces)
 */
function lowerCase(string) {
    return getParts(string)
        .join(' ')
        .toLowerCase();
}
/**
 * converts strings to UPPER CASE (with spaces)
 *
 * @export
 * @param {string} string
 * @returns {string} in UPPER CASE (with spaces)
 */
function upperCase(string) {
    return getParts(string)
        .join(' ')
        .toUpperCase();
}




/***/ }),

/***/ "9c36":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("157c");
var isObject = __webpack_require__("7526");
var newPromiseCapability = __webpack_require__("881c");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "9cbe":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@babel/runtime/helpers/objectSpread2.js
var objectSpread2 = __webpack_require__("ca22");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2);

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue/dist/vue.runtime.esm.js
var vue_runtime_esm = __webpack_require__("9869");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/size.js
var size = __webpack_require__("d578");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/listeners.js
var listeners = __webpack_require__("0fb0");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/spinner/spinner-mixin.js


/* harmony default export */ var spinner_mixin = ({
  mixins: [listeners["a" /* default */]],
  props: {
    color: String,
    size: {
      type: [Number, String],
      default: '1em'
    }
  },
  computed: {
    cSize() {
      return this.size in size["c" /* sizes */] ? `${size["c" /* sizes */][this.size]}px` : this.size;
    },

    classes() {
      if (this.color) {
        return `text-${this.color}`;
      }
    }

  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/spinner/QSpinner.js



/* harmony default export */ var QSpinner = __webpack_exports__["a"] = (vue_runtime_esm["default"].extend({
  name: 'QSpinner',
  mixins: [spinner_mixin],
  props: {
    thickness: {
      type: Number,
      default: 5
    }
  },

  render(h) {
    return h('svg', {
      staticClass: 'q-spinner q-spinner-mat',
      class: this.classes,
      on: objectSpread2_default()({}, this.qListeners),
      attrs: {
        focusable: 'false'
        /* needed for IE11 */
        ,
        'width': this.cSize,
        'height': this.cSize,
        'viewBox': '25 25 50 50'
      }
    }, [h('circle', {
      staticClass: 'path',
      attrs: {
        'cx': '50',
        'cy': '50',
        'r': '20',
        'fill': 'none',
        'stroke': 'currentColor',
        'stroke-width': this.thickness,
        'stroke-miterlimit': '10'
      }
    })]);
  }

}));

/***/ }),

/***/ "9d01":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  methods: {
    __nextTick(fn) {
      this.__tickFn = fn;
    },

    __prepareTick() {
      if (this.__tickFn !== void 0) {
        const fn = this.__tickFn;
        this.$nextTick(() => {
          if (this.__tickFn === fn) {
            this.__tickFn();

            this.__tickFn = void 0;
          }
        });
      }
    },

    __clearTick() {
      this.__tickFn = void 0;
    },

    __setTimeout(fn, delay) {
      clearTimeout(this.__timer);
      this.__timer = setTimeout(fn, delay);
    },

    __clearTimeout() {
      clearTimeout(this.__timer);
    }

  },

  beforeDestroy() {
    this.__tickFn = void 0;
    clearTimeout(this.__timer);
  }

});

/***/ }),

/***/ "9d47":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ PlanetarAnchor; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ PlanetarInput; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ PlanetarList; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ PlanetarSelect; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ PlanetarTabs; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ PlanetarToggle; });

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarAnchor.vue?vue&type=template&id=6f2ce1fe&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('a',_vm._g({class:['planetar-anchor', _vm.external ? '_external' : ''],attrs:{"href":_vm.href,"target":_vm.external ? '_blank' : '',"rel":_vm.external ? 'noopener noreferrer' : ''}},_vm.$listeners),[_vm._t("default",[_vm._v(_vm._s(_vm.content))]),(_vm.external)?_c('svg',{staticClass:"_svg q-ml-sm",attrs:{"xmlns":"http://www.w3.org/2000/svg","aria-hidden":"true","x":"0px","y":"0px","viewBox":"0 0 100 100","width":"15","height":"15"}},[_c('path',{attrs:{"fill":"currentColor","d":"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),_c('polygon',{attrs:{"fill":"currentColor","points":"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]):_vm._e()],2)}
var staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarAnchor.vue?vue&type=template&id=6f2ce1fe&

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarAnchor.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ var PlanetarAnchorvue_type_script_lang_js_ = ({
  name: 'PlanetarAnchor',
  props: {
    content: {
      type: String,
      required: true
    },
    href: {
      type: String
    },
    external: {
      type: Boolean,
      default: false
    }
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarAnchor.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_PlanetarAnchorvue_type_script_lang_js_ = (PlanetarAnchorvue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarAnchor.vue?vue&type=style&index=0&lang=css&
var PlanetarAnchorvue_type_style_index_0_lang_css_ = __webpack_require__("1351");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__("2be6");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/color/QColor.js + 3 modules
var QColor = __webpack_require__("dfd0");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/runtime.auto-import.js
var runtime_auto_import = __webpack_require__("e279");
var runtime_auto_import_default = /*#__PURE__*/__webpack_require__.n(runtime_auto_import);

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarAnchor.vue






/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  components_PlanetarAnchorvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var PlanetarAnchor = (component.exports);


runtime_auto_import_default()(component, 'components', {QColor: QColor["a" /* default */]});

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarInput.vue?vue&type=template&id=5150ee5d&scoped=true&
var PlanetarInputvue_type_template_id_5150ee5d_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('QInput',_vm._g(_vm._b({class:['planetar-input', _vm.isCode ? '_is-code' : ''],scopedSlots:_vm._u([(_vm.isSearch)?{key:"append",fn:function(){return [_c('QIcon',{staticClass:"c-blue-zodiac"},[_c('svg',{staticClass:"feather feather-search",attrs:{"xmlns":"http://www.w3.org/2000/svg","width":"24","height":"24","viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"}},[_c('circle',{attrs:{"cx":"11","cy":"11","r":"8"}}),_c('line',{attrs:{"x1":"21","y1":"21","x2":"16.65","y2":"16.65"}})])])]},proxy:true}:null],null,true)},'QInput',_vm.propsToPass,false),_vm.$listeners))}
var PlanetarInputvue_type_template_id_5150ee5d_scoped_true_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarInput.vue?vue&type=template&id=5150ee5d&scoped=true&

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/input/QInput.js + 2 modules
var QInput = __webpack_require__("bc74");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/icon/QIcon.js
var QIcon = __webpack_require__("34ff");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarInput.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
;
/**
 * This is the main input field. Uses <QInput /> under the hood.
 */

/* harmony default export */ var PlanetarInputvue_type_script_lang_js_ = ({
  name: 'PlanetarInput',
  components: {
    QInput: QInput["a" /* default */],
    QIcon: QIcon["a" /* default */]
  },
  props: {
    /**
     * When `true` it will have a dark background.
     * @category state
     * @type {boolean}
     */
    isCode: {
      type: Boolean
    },

    /**
     * When `true`, shows a search icon.
     * @category content
     * @category state
     * @type {boolean}
     */
    isSearch: {
      type: Boolean
    }
  },
  computed: {
    propsToPass: function propsToPass() {
      var $attrs = this.$attrs,
          isSearch = this.isSearch;
      var type = isSearch ? 'search' : $attrs.type;
      var outlined = true;
      var dense = true;
      return Object.assign({}, $attrs, {
        type: type,
        outlined: outlined,
        dense: dense
      });
    }
  },
  methods: {}
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarInput.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_PlanetarInputvue_type_script_lang_js_ = (PlanetarInputvue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarInput.vue?vue&type=style&index=0&lang=css&
var PlanetarInputvue_type_style_index_0_lang_css_ = __webpack_require__("352f");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarInput.vue?vue&type=style&index=1&id=5150ee5d&scoped=true&lang=css&
var PlanetarInputvue_type_style_index_1_id_5150ee5d_scoped_true_lang_css_ = __webpack_require__("632a");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/field/QField.js + 2 modules
var QField = __webpack_require__("b693");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarInput.vue







/* normalize component */

var PlanetarInput_component = Object(componentNormalizer["a" /* default */])(
  components_PlanetarInputvue_type_script_lang_js_,
  PlanetarInputvue_type_template_id_5150ee5d_scoped_true_render,
  PlanetarInputvue_type_template_id_5150ee5d_scoped_true_staticRenderFns,
  false,
  null,
  "5150ee5d",
  null
  
)

/* harmony default export */ var PlanetarInput = (PlanetarInput_component.exports);



runtime_auto_import_default()(PlanetarInput_component, 'components', {QField: QField["a" /* default */],QColor: QColor["a" /* default */]});

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarList.vue?vue&type=template&id=4f0db4a2&scoped=true&
var PlanetarListvue_type_template_id_4f0db4a2_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('QList',_vm._b({staticClass:"planetar-list"},'QList',_vm.propsToPass,false),_vm._l((_vm.items),function(item){return _c('QItem',{key:item.name,class:[
      '_item',
      item.isDivider ? '_is-divider' : '',
      item.name === _vm.value ? '_is-active' : '' ],attrs:{"clickable":!item.isDivider},on:{"click":function () { return _vm.$emit('input', item.name); }}},[_c('QItemSection',[_vm._v(_vm._s(item.name))]),(item.tag)?_c('QItemSection',{attrs:{"side":""}},[_c('QBadge',{attrs:{"color":"sail"}},[_vm._v(_vm._s(item.tag))])],1):_vm._e()],1)}),1)}
var PlanetarListvue_type_template_id_4f0db4a2_scoped_true_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarList.vue?vue&type=template&id=4f0db4a2&scoped=true&

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@babel/runtime/helpers/objectSpread2.js
var objectSpread2 = __webpack_require__("ca22");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2);

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue/dist/vue.runtime.esm.js
var vue_runtime_esm = __webpack_require__("9869");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/dark.js
var dark = __webpack_require__("87b2");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/listeners.js
var listeners = __webpack_require__("0fb0");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/slot.js
var slot = __webpack_require__("a4b3");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/item/QList.js





/* harmony default export */ var QList = (vue_runtime_esm["default"].extend({
  name: 'QList',
  mixins: [listeners["a" /* default */], dark["a" /* default */]],
  props: {
    bordered: Boolean,
    dense: Boolean,
    separator: Boolean,
    padding: Boolean
  },
  computed: {
    classes() {
      return 'q-list' + (this.bordered === true ? ' q-list--bordered' : '') + (this.dense === true ? ' q-list--dense' : '') + (this.separator === true ? ' q-list--separator' : '') + (this.isDark === true ? ' q-list--dark' : '') + (this.padding === true ? ' q-list--padding' : '');
    }

  },

  render(h) {
    return h('div', {
      class: this.classes,
      on: objectSpread2_default()({}, this.qListeners)
    }, Object(slot["c" /* slot */])(this, 'default'));
  }

}));
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/item/QItem.js + 1 modules
var QItem = __webpack_require__("ac9b");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/item/QItemSection.js
var QItemSection = __webpack_require__("66dc");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/badge/QBadge.js




/* harmony default export */ var QBadge = (vue_runtime_esm["default"].extend({
  name: 'QBadge',
  mixins: [listeners["a" /* default */]],
  props: {
    color: String,
    textColor: String,
    floating: Boolean,
    transparent: Boolean,
    multiLine: Boolean,
    outline: Boolean,
    rounded: Boolean,
    label: [Number, String],
    align: {
      type: String,
      validator: v => ['top', 'middle', 'bottom'].includes(v)
    }
  },
  computed: {
    style() {
      if (this.align !== void 0) {
        return {
          verticalAlign: this.align
        };
      }
    },

    classes() {
      const text = this.outline === true ? this.color || this.textColor : this.textColor;
      return 'q-badge flex inline items-center no-wrap' + ` q-badge--${this.multiLine === true ? 'multi' : 'single'}-line` + (this.outline === true ? ' q-badge--outline' : this.color !== void 0 ? ` bg-${this.color}` : '') + (text !== void 0 ? ` text-${text}` : '') + (this.floating === true ? ' q-badge--floating' : '') + (this.rounded === true ? ' q-badge--rounded' : '') + (this.transparent === true ? ' q-badge--transparent' : '');
    },

    attrs() {
      return {
        role: 'alert',
        'aria-label': this.label
      };
    }

  },

  render(h) {
    return h('div', {
      style: this.style,
      class: this.classes,
      attrs: this.attrs,
      on: objectSpread2_default()({}, this.qListeners)
    }, this.label !== void 0 ? [this.label] : Object(slot["c" /* slot */])(this, 'default'));
  }

}));
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarList.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
;
/* harmony default export */ var PlanetarListvue_type_script_lang_js_ = ({
  name: 'PlanetarList',
  components: {
    QList: QList,
    QItem: QItem["a" /* default */],
    QItemSection: QItemSection["a" /* default */],
    QBadge: QBadge
  },
  props: {
    /**
     * @type {{ name: string, tag?: string, isDivider?: boolean }[]}
     */
    items: {
      type: Array,
      required: true
    },

    /**
     * Must be used with v-model!
     */
    value: {
      type: String,
      default: ''
    }
  },
  computed: {
    propsToPass: function propsToPass() {
      var $attrs = this.$attrs;
      return Object.assign({}, $attrs);
    }
  },
  methods: {}
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarList.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_PlanetarListvue_type_script_lang_js_ = (PlanetarListvue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarList.vue?vue&type=style&index=0&lang=css&
var PlanetarListvue_type_style_index_0_lang_css_ = __webpack_require__("4c21");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarList.vue?vue&type=style&index=1&id=4f0db4a2&scoped=true&lang=css&
var PlanetarListvue_type_style_index_1_id_4f0db4a2_scoped_true_lang_css_ = __webpack_require__("9ed8");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarList.vue







/* normalize component */

var PlanetarList_component = Object(componentNormalizer["a" /* default */])(
  components_PlanetarListvue_type_script_lang_js_,
  PlanetarListvue_type_template_id_4f0db4a2_scoped_true_render,
  PlanetarListvue_type_template_id_4f0db4a2_scoped_true_staticRenderFns,
  false,
  null,
  "4f0db4a2",
  null
  
)

/* harmony default export */ var PlanetarList = (PlanetarList_component.exports);


runtime_auto_import_default()(PlanetarList_component, 'components', {QColor: QColor["a" /* default */]});

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarSelect.vue?vue&type=template&id=422ead2a&scoped=true&
var PlanetarSelectvue_type_template_id_422ead2a_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('QSelect',_vm._g(_vm._b({staticClass:"planetar-select"},'QSelect',_vm.propsToPass,false),_vm.$listeners))}
var PlanetarSelectvue_type_template_id_422ead2a_scoped_true_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarSelect.vue?vue&type=template&id=422ead2a&scoped=true&

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/select/QSelect.js + 7 modules
var QSelect = __webpack_require__("3946");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarSelect.vue?vue&type=script&lang=js&
//
//
//
//
;
/* harmony default export */ var PlanetarSelectvue_type_script_lang_js_ = ({
  name: 'PlanetarSelect',
  components: {
    QSelect: QSelect["a" /* default */]
  },
  props: {},
  computed: {
    propsToPass: function propsToPass() {
      var $attrs = this.$attrs;
      var outlined = true;
      var dense = true;
      return Object.assign({}, $attrs, {
        outlined: outlined,
        dense: dense
      });
    }
  },
  methods: {}
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarSelect.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_PlanetarSelectvue_type_script_lang_js_ = (PlanetarSelectvue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarSelect.vue?vue&type=style&index=0&lang=css&
var PlanetarSelectvue_type_style_index_0_lang_css_ = __webpack_require__("8548");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarSelect.vue?vue&type=style&index=1&id=422ead2a&scoped=true&lang=css&
var PlanetarSelectvue_type_style_index_1_id_422ead2a_scoped_true_lang_css_ = __webpack_require__("48c4");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarSelect.vue







/* normalize component */

var PlanetarSelect_component = Object(componentNormalizer["a" /* default */])(
  components_PlanetarSelectvue_type_script_lang_js_,
  PlanetarSelectvue_type_template_id_422ead2a_scoped_true_render,
  PlanetarSelectvue_type_template_id_422ead2a_scoped_true_staticRenderFns,
  false,
  null,
  "422ead2a",
  null
  
)

/* harmony default export */ var PlanetarSelect = (PlanetarSelect_component.exports);



runtime_auto_import_default()(PlanetarSelect_component, 'components', {QField: QField["a" /* default */],QColor: QColor["a" /* default */]});

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarTabs.vue?vue&type=template&id=49ae7236&scoped=true&
var PlanetarTabsvue_type_template_id_49ae7236_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"planetar-tabs"},[_c('QTabs',{staticClass:"bg-stone c-grey-3 _top",attrs:{"dense":"","active-color":"primary","indicator-color":"stone","align":"left","narrow-indicator":""},model:{value:(_vm.activeTabIndex),callback:function ($$v) {_vm.activeTabIndex=$$v},expression:"activeTabIndex"}},_vm._l((_vm.tabLabels),function(label,index){return _c('QTab',{key:label + index,attrs:{"name":index,"label":label,"no-caps":""}})}),1),_c('QTabPanels',_vm._g(_vm._b({staticClass:"_bottom",attrs:{"animated":""},model:{value:(_vm.activeTabIndex),callback:function ($$v) {_vm.activeTabIndex=$$v},expression:"activeTabIndex"}},'QTabPanels',_vm.propsToPass,false),_vm.$listeners),_vm._l((_vm.tabLabels),function(label,index){return _c('QTabPanel',{key:label + index,staticClass:"no-padding full-height",attrs:{"name":index}},[_vm._t(index)],2)}),1)],1)}
var PlanetarTabsvue_type_template_id_49ae7236_scoped_true_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarTabs.vue?vue&type=template&id=49ae7236&scoped=true&

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/tabs/QTabs.js
var QTabs = __webpack_require__("4776");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/tabs/QTab.js
var QTab = __webpack_require__("dd08");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/tab-panels/QTabPanels.js
var QTabPanels = __webpack_require__("1411");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/tab-panels/QTabPanel.js
var QTabPanel = __webpack_require__("1d98");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarTabs.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
;
/**
 * This is the main input field.
 */

/* harmony default export */ var PlanetarTabsvue_type_script_lang_js_ = ({
  name: 'PlanetarTabs',
  components: {
    QTabs: QTabs["a" /* default */],
    QTab: QTab["a" /* default */],
    QTabPanels: QTabPanels["a" /* default */],
    QTabPanel: QTabPanel["a" /* default */]
  },
  props: {
    /**
     * The labels of the tabs.
     * @category content
     * @type {string[]}
     * @example ['First Tab', 'Second Tab']
     */
    tabLabels: {
      type: Array,
      default: function _default() {
        return [];
      },
      required: true
    },

    /**
     * The tab which should be opened initially. Can be used with `.sync`
     * @category content
     * @type {string}
     */
    activeTab: {
      type: String
    }
  },
  data: function data() {
    var _this = this;

    var i = this.tabLabels.findIndex(function (label) {
      return label === _this.activeTab;
    });
    var activeTabIndexInner = Math.max(0, i);
    return {
      activeTabIndexInner: activeTabIndexInner
    };
  },
  computed: {
    activeTabIndex: {
      get: function get() {
        return this.activeTabIndexInner;
      },
      set: function set(newIndex) {
        this.activeTabIndexInner = newIndex;
        var activeTab = this.tabLabels[newIndex];
        this.$emit('update:active-tab', activeTab);
      }
    },
    propsToPass: function propsToPass() {
      var $attrs = this.$attrs;
      return Object.assign({}, $attrs);
    }
  },
  methods: {}
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarTabs.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_PlanetarTabsvue_type_script_lang_js_ = (PlanetarTabsvue_type_script_lang_js_); 
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarTabs.vue?vue&type=style&index=0&lang=css&
var PlanetarTabsvue_type_style_index_0_lang_css_ = __webpack_require__("7584");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarTabs.vue?vue&type=style&index=1&id=49ae7236&scoped=true&lang=css&
var PlanetarTabsvue_type_style_index_1_id_49ae7236_scoped_true_lang_css_ = __webpack_require__("4919");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarTabs.vue







/* normalize component */

var PlanetarTabs_component = Object(componentNormalizer["a" /* default */])(
  components_PlanetarTabsvue_type_script_lang_js_,
  PlanetarTabsvue_type_template_id_49ae7236_scoped_true_render,
  PlanetarTabsvue_type_template_id_49ae7236_scoped_true_staticRenderFns,
  false,
  null,
  "49ae7236",
  null
  
)

/* harmony default export */ var PlanetarTabs = (PlanetarTabs_component.exports);
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarToggle.vue?vue&type=template&id=6e89975a&
var PlanetarTogglevue_type_template_id_6e89975a_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('QToggle',_vm._g(_vm._b({staticClass:"planetar-toggle"},'QToggle',_vm.propsToPass,false),_vm.$listeners))}
var PlanetarTogglevue_type_template_id_6e89975a_staticRenderFns = []


// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarToggle.vue?vue&type=template&id=6e89975a&

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/toggle/QToggle.js
var QToggle = __webpack_require__("3d3c");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.transform-quasar-imports.js!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/babel-loader/lib??ref--2-0!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@quasar/app/lib/webpack/loader.auto-import-client.js?kebab!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue-loader/lib??vue-loader-options!/Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarToggle.vue?vue&type=script&lang=js&
//
//
//
//
;
/* harmony default export */ var PlanetarTogglevue_type_script_lang_js_ = ({
  name: 'PlanetarToggle',
  components: {
    QToggle: QToggle["a" /* default */]
  },
  props: {
    readonly: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    propsToPass: function propsToPass() {
      var $attrs = this.$attrs,
          readonly = this.readonly;
      return Object.assign({
        disable: readonly
      }, $attrs);
    }
  },
  methods: {}
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarToggle.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_PlanetarTogglevue_type_script_lang_js_ = (PlanetarTogglevue_type_script_lang_js_); 
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/components/PlanetarToggle.vue





/* normalize component */

var PlanetarToggle_component = Object(componentNormalizer["a" /* default */])(
  components_PlanetarTogglevue_type_script_lang_js_,
  PlanetarTogglevue_type_template_id_6e89975a_render,
  PlanetarTogglevue_type_template_id_6e89975a_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var PlanetarToggle = (PlanetarToggle_component.exports);
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@planetar/atoms/dist/index.js







/* harmony default export */ var dist = __webpack_exports__["g"] = ({
  install: function install(Vue) {
    Vue.component(PlanetarAnchor.name, PlanetarAnchor);
    Vue.component(PlanetarInput.name, PlanetarInput);
    Vue.component(PlanetarList.name, PlanetarList);
    Vue.component(PlanetarSelect.name, PlanetarSelect);
    Vue.component(PlanetarTabs.name, PlanetarTabs);
    Vue.component(PlanetarToggle.name, PlanetarToggle);
  }
});

/***/ }),

/***/ "9ed5":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return mapObject; });
/**
 * Map each value of an object with provided function, just like `Array.map`
 *
 * @template T
 * @param {T} target
 * @param {(value: T, propName: keyof T, array: T[keyof T][]) => any} mapFunction
 * @returns {Record<string, any>}
 */
function mapObject(target, mapFunction) {
    return Object.entries(target).reduce(function (carry, _a, index, array) {
        var key = _a[0], value = _a[1];
        carry[key] = mapFunction(value, key, array);
        return carry;
    }, {});
}




/***/ }),

/***/ "9ed8":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarList_vue_vue_type_style_index_1_id_4f0db4a2_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7850");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarList_vue_vue_type_style_index_1_id_4f0db4a2_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_PlanetarList_vue_vue_type_style_index_1_id_4f0db4a2_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "9f9b":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/* **********************************************
     Begin prism-core.js
********************************************** */

/// <reference lib="WebWorker"/>

var _self = (typeof window !== 'undefined')
	? window   // if in browser
	: (
		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
		? self // if in worker
		: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */
var Prism = (function (_self){

// Private helper vars
var lang = /\blang(?:uage)?-([\w-]+)\b/i;
var uniqueId = 0;


var _ = {
	/**
	 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
	 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
	 * additional languages or plugins yourself.
	 *
	 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
	 *
	 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
	 * empty Prism object into the global scope before loading the Prism script like this:
	 *
	 * ```js
	 * window.Prism = window.Prism || {};
	 * Prism.manual = true;
	 * // add a new <script> to load Prism's script
	 * ```
	 *
	 * @default false
	 * @type {boolean}
	 * @memberof Prism
	 * @public
	 */
	manual: _self.Prism && _self.Prism.manual,
	disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

	/**
	 * A namespace for utility methods.
	 *
	 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
	 * change or disappear at any time.
	 *
	 * @namespace
	 * @memberof Prism
	 */
	util: {
		encode: function encode(tokens) {
			if (tokens instanceof Token) {
				return new Token(tokens.type, encode(tokens.content), tokens.alias);
			} else if (Array.isArray(tokens)) {
				return tokens.map(encode);
			} else {
				return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
			}
		},

		/**
		 * Returns the name of the type of the given value.
		 *
		 * @param {any} o
		 * @returns {string}
		 * @example
		 * type(null)      === 'Null'
		 * type(undefined) === 'Undefined'
		 * type(123)       === 'Number'
		 * type('foo')     === 'String'
		 * type(true)      === 'Boolean'
		 * type([1, 2])    === 'Array'
		 * type({})        === 'Object'
		 * type(String)    === 'Function'
		 * type(/abc+/)    === 'RegExp'
		 */
		type: function (o) {
			return Object.prototype.toString.call(o).slice(8, -1);
		},

		/**
		 * Returns a unique number for the given object. Later calls will still return the same number.
		 *
		 * @param {Object} obj
		 * @returns {number}
		 */
		objId: function (obj) {
			if (!obj['__id']) {
				Object.defineProperty(obj, '__id', { value: ++uniqueId });
			}
			return obj['__id'];
		},

		/**
		 * Creates a deep clone of the given object.
		 *
		 * The main intended use of this function is to clone language definitions.
		 *
		 * @param {T} o
		 * @param {Record<number, any>} [visited]
		 * @returns {T}
		 * @template T
		 */
		clone: function deepClone(o, visited) {
			visited = visited || {};

			var clone, id;
			switch (_.util.type(o)) {
				case 'Object':
					id = _.util.objId(o);
					if (visited[id]) {
						return visited[id];
					}
					clone = /** @type {Record<string, any>} */ ({});
					visited[id] = clone;

					for (var key in o) {
						if (o.hasOwnProperty(key)) {
							clone[key] = deepClone(o[key], visited);
						}
					}

					return /** @type {any} */ (clone);

				case 'Array':
					id = _.util.objId(o);
					if (visited[id]) {
						return visited[id];
					}
					clone = [];
					visited[id] = clone;

					(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {
						clone[i] = deepClone(v, visited);
					});

					return /** @type {any} */ (clone);

				default:
					return o;
			}
		},

		/**
		 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
		 *
		 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
		 *
		 * @param {Element} element
		 * @returns {string}
		 */
		getLanguage: function (element) {
			while (element && !lang.test(element.className)) {
				element = element.parentElement;
			}
			if (element) {
				return (element.className.match(lang) || [, 'none'])[1].toLowerCase();
			}
			return 'none';
		},

		/**
		 * Returns the script element that is currently executing.
		 *
		 * This does __not__ work for line script element.
		 *
		 * @returns {HTMLScriptElement | null}
		 */
		currentScript: function () {
			if (typeof document === 'undefined') {
				return null;
			}
			if ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {
				return /** @type {any} */ (document.currentScript);
			}

			// IE11 workaround
			// we'll get the src of the current script by parsing IE11's error stack trace
			// this will not work for inline scripts

			try {
				throw new Error();
			} catch (err) {
				// Get file src url from stack. Specifically works with the format of stack traces in IE.
				// A stack will look like this:
				//
				// Error
				//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
				//    at Global code (http://localhost/components/prism-core.js:606:1)

				var src = (/at [^(\r\n]*\((.*):.+:.+\)$/i.exec(err.stack) || [])[1];
				if (src) {
					var scripts = document.getElementsByTagName('script');
					for (var i in scripts) {
						if (scripts[i].src == src) {
							return scripts[i];
						}
					}
				}
				return null;
			}
		},

		/**
		 * Returns whether a given class is active for `element`.
		 *
		 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
		 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
		 * given class is just the given class with a `no-` prefix.
		 *
		 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
		 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
		 * ancestors have the given class or the negated version of it, then the default activation will be returned.
		 *
		 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
		 * version of it, the class is considered active.
		 *
		 * @param {Element} element
		 * @param {string} className
		 * @param {boolean} [defaultActivation=false]
		 * @returns {boolean}
		 */
		isActive: function (element, className, defaultActivation) {
			var no = 'no-' + className;

			while (element) {
				var classList = element.classList;
				if (classList.contains(className)) {
					return true;
				}
				if (classList.contains(no)) {
					return false;
				}
				element = element.parentElement;
			}
			return !!defaultActivation;
		}
	},

	/**
	 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
	 *
	 * @namespace
	 * @memberof Prism
	 * @public
	 */
	languages: {
		/**
		 * Creates a deep copy of the language with the given id and appends the given tokens.
		 *
		 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
		 * will be overwritten at its original position.
		 *
		 * ## Best practices
		 *
		 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
		 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
		 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
		 *
		 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
		 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
		 *
		 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
		 * @param {Grammar} redef The new tokens to append.
		 * @returns {Grammar} The new language created.
		 * @public
		 * @example
		 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
		 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
		 *     // at its original position
		 *     'comment': { ... },
		 *     // CSS doesn't have a 'color' token, so this token will be appended
		 *     'color': /\b(?:red|green|blue)\b/
		 * });
		 */
		extend: function (id, redef) {
			var lang = _.util.clone(_.languages[id]);

			for (var key in redef) {
				lang[key] = redef[key];
			}

			return lang;
		},

		/**
		 * Inserts tokens _before_ another token in a language definition or any other grammar.
		 *
		 * ## Usage
		 *
		 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
		 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
		 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
		 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
		 * this:
		 *
		 * ```js
		 * Prism.languages.markup.style = {
		 *     // token
		 * };
		 * ```
		 *
		 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
		 * before existing tokens. For the CSS example above, you would use it like this:
		 *
		 * ```js
		 * Prism.languages.insertBefore('markup', 'cdata', {
		 *     'style': {
		 *         // token
		 *     }
		 * });
		 * ```
		 *
		 * ## Special cases
		 *
		 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
		 * will be ignored.
		 *
		 * This behavior can be used to insert tokens after `before`:
		 *
		 * ```js
		 * Prism.languages.insertBefore('markup', 'comment', {
		 *     'comment': Prism.languages.markup.comment,
		 *     // tokens after 'comment'
		 * });
		 * ```
		 *
		 * ## Limitations
		 *
		 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
		 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
		 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
		 * deleting properties which is necessary to insert at arbitrary positions.
		 *
		 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
		 * Instead, it will create a new object and replace all references to the target object with the new one. This
		 * can be done without temporarily deleting properties, so the iteration order is well-defined.
		 *
		 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
		 * you hold the target object in a variable, then the value of the variable will not change.
		 *
		 * ```js
		 * var oldMarkup = Prism.languages.markup;
		 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
		 *
		 * assert(oldMarkup !== Prism.languages.markup);
		 * assert(newMarkup === Prism.languages.markup);
		 * ```
		 *
		 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
		 * object to be modified.
		 * @param {string} before The key to insert before.
		 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
		 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
		 * object to be modified.
		 *
		 * Defaults to `Prism.languages`.
		 * @returns {Grammar} The new grammar object.
		 * @public
		 */
		insertBefore: function (inside, before, insert, root) {
			root = root || /** @type {any} */ (_.languages);
			var grammar = root[inside];
			/** @type {Grammar} */
			var ret = {};

			for (var token in grammar) {
				if (grammar.hasOwnProperty(token)) {

					if (token == before) {
						for (var newToken in insert) {
							if (insert.hasOwnProperty(newToken)) {
								ret[newToken] = insert[newToken];
							}
						}
					}

					// Do not insert token which also occur in insert. See #1525
					if (!insert.hasOwnProperty(token)) {
						ret[token] = grammar[token];
					}
				}
			}

			var old = root[inside];
			root[inside] = ret;

			// Update references in other language definitions
			_.languages.DFS(_.languages, function(key, value) {
				if (value === old && key != inside) {
					this[key] = ret;
				}
			});

			return ret;
		},

		// Traverse a language definition with Depth First Search
		DFS: function DFS(o, callback, type, visited) {
			visited = visited || {};

			var objId = _.util.objId;

			for (var i in o) {
				if (o.hasOwnProperty(i)) {
					callback.call(o, i, o[i], type || i);

					var property = o[i],
					    propertyType = _.util.type(property);

					if (propertyType === 'Object' && !visited[objId(property)]) {
						visited[objId(property)] = true;
						DFS(property, callback, null, visited);
					}
					else if (propertyType === 'Array' && !visited[objId(property)]) {
						visited[objId(property)] = true;
						DFS(property, callback, i, visited);
					}
				}
			}
		}
	},

	plugins: {},

	/**
	 * This is the most high-level function in Prisms API.
	 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
	 * each one of them.
	 *
	 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
	 *
	 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
	 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
	 * @memberof Prism
	 * @public
	 */
	highlightAll: function(async, callback) {
		_.highlightAllUnder(document, async, callback);
	},

	/**
	 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
	 * {@link Prism.highlightElement} on each one of them.
	 *
	 * The following hooks will be run:
	 * 1. `before-highlightall`
	 * 2. `before-all-elements-highlight`
	 * 3. All hooks of {@link Prism.highlightElement} for each element.
	 *
	 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
	 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
	 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
	 * @memberof Prism
	 * @public
	 */
	highlightAllUnder: function(container, async, callback) {
		var env = {
			callback: callback,
			container: container,
			selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
		};

		_.hooks.run('before-highlightall', env);

		env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

		_.hooks.run('before-all-elements-highlight', env);

		for (var i = 0, element; element = env.elements[i++];) {
			_.highlightElement(element, async === true, env.callback);
		}
	},

	/**
	 * Highlights the code inside a single element.
	 *
	 * The following hooks will be run:
	 * 1. `before-sanity-check`
	 * 2. `before-highlight`
	 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
	 * 4. `before-insert`
	 * 5. `after-highlight`
	 * 6. `complete`
	 *
	 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
	 * the element's language.
	 *
	 * @param {Element} element The element containing the code.
	 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
	 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
	 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
	 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
	 *
	 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
	 * asynchronous highlighting to work. You can build your own bundle on the
	 * [Download page](https://prismjs.com/download.html).
	 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
	 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
	 * @memberof Prism
	 * @public
	 */
	highlightElement: function(element, async, callback) {
		// Find language
		var language = _.util.getLanguage(element);
		var grammar = _.languages[language];

		// Set language on the element, if not present
		element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

		// Set language on the parent, for styling
		var parent = element.parentElement;
		if (parent && parent.nodeName.toLowerCase() === 'pre') {
			parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
		}

		var code = element.textContent;

		var env = {
			element: element,
			language: language,
			grammar: grammar,
			code: code
		};

		function insertHighlightedCode(highlightedCode) {
			env.highlightedCode = highlightedCode;

			_.hooks.run('before-insert', env);

			env.element.innerHTML = env.highlightedCode;

			_.hooks.run('after-highlight', env);
			_.hooks.run('complete', env);
			callback && callback.call(env.element);
		}

		_.hooks.run('before-sanity-check', env);

		if (!env.code) {
			_.hooks.run('complete', env);
			callback && callback.call(env.element);
			return;
		}

		_.hooks.run('before-highlight', env);

		if (!env.grammar) {
			insertHighlightedCode(_.util.encode(env.code));
			return;
		}

		if (async && _self.Worker) {
			var worker = new Worker(_.filename);

			worker.onmessage = function(evt) {
				insertHighlightedCode(evt.data);
			};

			worker.postMessage(JSON.stringify({
				language: env.language,
				code: env.code,
				immediateClose: true
			}));
		}
		else {
			insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
		}
	},

	/**
	 * Low-level function, only use if you know what youre doing. It accepts a string of text as input
	 * and the language definitions to use, and returns a string with the HTML produced.
	 *
	 * The following hooks will be run:
	 * 1. `before-tokenize`
	 * 2. `after-tokenize`
	 * 3. `wrap`: On each {@link Token}.
	 *
	 * @param {string} text A string with the code to be highlighted.
	 * @param {Grammar} grammar An object containing the tokens to use.
	 *
	 * Usually a language definition like `Prism.languages.markup`.
	 * @param {string} language The name of the language definition passed to `grammar`.
	 * @returns {string} The highlighted HTML.
	 * @memberof Prism
	 * @public
	 * @example
	 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
	 */
	highlight: function (text, grammar, language) {
		var env = {
			code: text,
			grammar: grammar,
			language: language
		};
		_.hooks.run('before-tokenize', env);
		env.tokens = _.tokenize(env.code, env.grammar);
		_.hooks.run('after-tokenize', env);
		return Token.stringify(_.util.encode(env.tokens), env.language);
	},

	/**
	 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
	 * and the language definitions to use, and returns an array with the tokenized code.
	 *
	 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
	 *
	 * This method could be useful in other contexts as well, as a very crude parser.
	 *
	 * @param {string} text A string with the code to be highlighted.
	 * @param {Grammar} grammar An object containing the tokens to use.
	 *
	 * Usually a language definition like `Prism.languages.markup`.
	 * @returns {TokenStream} An array of strings and tokens, a token stream.
	 * @memberof Prism
	 * @public
	 * @example
	 * let code = `var foo = 0;`;
	 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
	 * tokens.forEach(token => {
	 *     if (token instanceof Prism.Token && token.type === 'number') {
	 *         console.log(`Found numeric literal: ${token.content}`);
	 *     }
	 * });
	 */
	tokenize: function(text, grammar) {
		var rest = grammar.rest;
		if (rest) {
			for (var token in rest) {
				grammar[token] = rest[token];
			}

			delete grammar.rest;
		}

		var tokenList = new LinkedList();
		addAfter(tokenList, tokenList.head, text);

		matchGrammar(text, tokenList, grammar, tokenList.head, 0);

		return toArray(tokenList);
	},

	/**
	 * @namespace
	 * @memberof Prism
	 * @public
	 */
	hooks: {
		all: {},

		/**
		 * Adds the given callback to the list of callbacks for the given hook.
		 *
		 * The callback will be invoked when the hook it is registered for is run.
		 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
		 *
		 * One callback function can be registered to multiple hooks and the same hook multiple times.
		 *
		 * @param {string} name The name of the hook.
		 * @param {HookCallback} callback The callback function which is given environment variables.
		 * @public
		 */
		add: function (name, callback) {
			var hooks = _.hooks.all;

			hooks[name] = hooks[name] || [];

			hooks[name].push(callback);
		},

		/**
		 * Runs a hook invoking all registered callbacks with the given environment variables.
		 *
		 * Callbacks will be invoked synchronously and in the order in which they were registered.
		 *
		 * @param {string} name The name of the hook.
		 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
		 * @public
		 */
		run: function (name, env) {
			var callbacks = _.hooks.all[name];

			if (!callbacks || !callbacks.length) {
				return;
			}

			for (var i=0, callback; callback = callbacks[i++];) {
				callback(env);
			}
		}
	},

	Token: Token
};
_self.Prism = _;


// Typescript note:
// The following can be used to import the Token type in JSDoc:
//
//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

/**
 * Creates a new token.
 *
 * @param {string} type See {@link Token#type type}
 * @param {string | TokenStream} content See {@link Token#content content}
 * @param {string|string[]} [alias] The alias(es) of the token.
 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
 * @class
 * @global
 * @public
 */
function Token(type, content, alias, matchedStr) {
	/**
	 * The type of the token.
	 *
	 * This is usually the key of a pattern in a {@link Grammar}.
	 *
	 * @type {string}
	 * @see GrammarToken
	 * @public
	 */
	this.type = type;
	/**
	 * The strings or tokens contained by this token.
	 *
	 * This will be a token stream if the pattern matched also defined an `inside` grammar.
	 *
	 * @type {string | TokenStream}
	 * @public
	 */
	this.content = content;
	/**
	 * The alias(es) of the token.
	 *
	 * @type {string|string[]}
	 * @see GrammarToken
	 * @public
	 */
	this.alias = alias;
	// Copy of the full string this token was created from
	this.length = (matchedStr || '').length | 0;
}

/**
 * A token stream is an array of strings and {@link Token Token} objects.
 *
 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
 * them.
 *
 * 1. No adjacent strings.
 * 2. No empty strings.
 *
 *    The only exception here is the token stream that only contains the empty string and nothing else.
 *
 * @typedef {Array<string | Token>} TokenStream
 * @global
 * @public
 */

/**
 * Converts the given token or token stream to an HTML representation.
 *
 * The following hooks will be run:
 * 1. `wrap`: On each {@link Token}.
 *
 * @param {string | Token | TokenStream} o The token or token stream to be converted.
 * @param {string} language The name of current language.
 * @returns {string} The HTML representation of the token or token stream.
 * @memberof Token
 * @static
 */
Token.stringify = function stringify(o, language) {
	if (typeof o == 'string') {
		return o;
	}
	if (Array.isArray(o)) {
		var s = '';
		o.forEach(function (e) {
			s += stringify(e, language);
		});
		return s;
	}

	var env = {
		type: o.type,
		content: stringify(o.content, language),
		tag: 'span',
		classes: ['token', o.type],
		attributes: {},
		language: language
	};

	var aliases = o.alias;
	if (aliases) {
		if (Array.isArray(aliases)) {
			Array.prototype.push.apply(env.classes, aliases);
		} else {
			env.classes.push(aliases);
		}
	}

	_.hooks.run('wrap', env);

	var attributes = '';
	for (var name in env.attributes) {
		attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
	}

	return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
};

/**
 * @param {RegExp} pattern
 * @param {number} pos
 * @param {string} text
 * @param {boolean} lookbehind
 * @returns {RegExpExecArray | null}
 */
function matchPattern(pattern, pos, text, lookbehind) {
	pattern.lastIndex = pos;
	var match = pattern.exec(text);
	if (match && lookbehind && match[1]) {
		// change the match to remove the text matched by the Prism lookbehind group
		var lookbehindLength = match[1].length;
		match.index += lookbehindLength;
		match[0] = match[0].slice(lookbehindLength);
	}
	return match;
}

/**
 * @param {string} text
 * @param {LinkedList<string | Token>} tokenList
 * @param {any} grammar
 * @param {LinkedListNode<string | Token>} startNode
 * @param {number} startPos
 * @param {RematchOptions} [rematch]
 * @returns {void}
 * @private
 *
 * @typedef RematchOptions
 * @property {string} cause
 * @property {number} reach
 */
function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
	for (var token in grammar) {
		if (!grammar.hasOwnProperty(token) || !grammar[token]) {
			continue;
		}

		var patterns = grammar[token];
		patterns = Array.isArray(patterns) ? patterns : [patterns];

		for (var j = 0; j < patterns.length; ++j) {
			if (rematch && rematch.cause == token + ',' + j) {
				return;
			}

			var patternObj = patterns[j],
				inside = patternObj.inside,
				lookbehind = !!patternObj.lookbehind,
				greedy = !!patternObj.greedy,
				alias = patternObj.alias;

			if (greedy && !patternObj.pattern.global) {
				// Without the global flag, lastIndex won't work
				var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
				patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
			}

			/** @type {RegExp} */
			var pattern = patternObj.pattern || patternObj;

			for ( // iterate the token list and keep track of the current token/string position
				var currentNode = startNode.next, pos = startPos;
				currentNode !== tokenList.tail;
				pos += currentNode.value.length, currentNode = currentNode.next
			) {

				if (rematch && pos >= rematch.reach) {
					break;
				}

				var str = currentNode.value;

				if (tokenList.length > text.length) {
					// Something went terribly wrong, ABORT, ABORT!
					return;
				}

				if (str instanceof Token) {
					continue;
				}

				var removeCount = 1; // this is the to parameter of removeBetween
				var match;

				if (greedy) {
					match = matchPattern(pattern, pos, text, lookbehind);
					if (!match) {
						break;
					}

					var from = match.index;
					var to = match.index + match[0].length;
					var p = pos;

					// find the node that contains the match
					p += currentNode.value.length;
					while (from >= p) {
						currentNode = currentNode.next;
						p += currentNode.value.length;
					}
					// adjust pos (and p)
					p -= currentNode.value.length;
					pos = p;

					// the current node is a Token, then the match starts inside another Token, which is invalid
					if (currentNode.value instanceof Token) {
						continue;
					}

					// find the last node which is affected by this match
					for (
						var k = currentNode;
						k !== tokenList.tail && (p < to || typeof k.value === 'string');
						k = k.next
					) {
						removeCount++;
						p += k.value.length;
					}
					removeCount--;

					// replace with the new match
					str = text.slice(pos, p);
					match.index -= pos;
				} else {
					match = matchPattern(pattern, 0, str, lookbehind);
					if (!match) {
						continue;
					}
				}

				var from = match.index,
					matchStr = match[0],
					before = str.slice(0, from),
					after = str.slice(from + matchStr.length);

				var reach = pos + str.length;
				if (rematch && reach > rematch.reach) {
					rematch.reach = reach;
				}

				var removeFrom = currentNode.prev;

				if (before) {
					removeFrom = addAfter(tokenList, removeFrom, before);
					pos += before.length;
				}

				removeRange(tokenList, removeFrom, removeCount);

				var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
				currentNode = addAfter(tokenList, removeFrom, wrapped);

				if (after) {
					addAfter(tokenList, currentNode, after);
				}

				if (removeCount > 1) {
					// at least one Token object was removed, so we have to do some rematching
					// this can only happen if the current pattern is greedy
					matchGrammar(text, tokenList, grammar, currentNode.prev, pos, {
						cause: token + ',' + j,
						reach: reach
					});
				}
			}
		}
	}
}

/**
 * @typedef LinkedListNode
 * @property {T} value
 * @property {LinkedListNode<T> | null} prev The previous node.
 * @property {LinkedListNode<T> | null} next The next node.
 * @template T
 * @private
 */

/**
 * @template T
 * @private
 */
function LinkedList() {
	/** @type {LinkedListNode<T>} */
	var head = { value: null, prev: null, next: null };
	/** @type {LinkedListNode<T>} */
	var tail = { value: null, prev: head, next: null };
	head.next = tail;

	/** @type {LinkedListNode<T>} */
	this.head = head;
	/** @type {LinkedListNode<T>} */
	this.tail = tail;
	this.length = 0;
}

/**
 * Adds a new node with the given value to the list.
 * @param {LinkedList<T>} list
 * @param {LinkedListNode<T>} node
 * @param {T} value
 * @returns {LinkedListNode<T>} The added node.
 * @template T
 */
function addAfter(list, node, value) {
	// assumes that node != list.tail && values.length >= 0
	var next = node.next;

	var newNode = { value: value, prev: node, next: next };
	node.next = newNode;
	next.prev = newNode;
	list.length++;

	return newNode;
}
/**
 * Removes `count` nodes after the given node. The given node will not be removed.
 * @param {LinkedList<T>} list
 * @param {LinkedListNode<T>} node
 * @param {number} count
 * @template T
 */
function removeRange(list, node, count) {
	var next = node.next;
	for (var i = 0; i < count && next !== list.tail; i++) {
		next = next.next;
	}
	node.next = next;
	next.prev = node;
	list.length -= i;
}
/**
 * @param {LinkedList<T>} list
 * @returns {T[]}
 * @template T
 */
function toArray(list) {
	var array = [];
	var node = list.head.next;
	while (node !== list.tail) {
		array.push(node.value);
		node = node.next;
	}
	return array;
}


if (!_self.document) {
	if (!_self.addEventListener) {
		// in Node.js
		return _;
	}

	if (!_.disableWorkerMessageHandler) {
		// In worker
		_self.addEventListener('message', function (evt) {
			var message = JSON.parse(evt.data),
				lang = message.language,
				code = message.code,
				immediateClose = message.immediateClose;

			_self.postMessage(_.highlight(code, _.languages[lang], lang));
			if (immediateClose) {
				_self.close();
			}
		}, false);
	}

	return _;
}

// Get current script and highlight
var script = _.util.currentScript();

if (script) {
	_.filename = script.src;

	if (script.hasAttribute('data-manual')) {
		_.manual = true;
	}
}

function highlightAutomaticallyCallback() {
	if (!_.manual) {
		_.highlightAll();
	}
}

if (!_.manual) {
	// If the document state is "loading", then we'll use DOMContentLoaded.
	// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
	// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
	// might take longer one animation frame to execute which can create a race condition where only some plugins have
	// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
	// See https://github.com/PrismJS/prism/issues/2102
	var readyState = document.readyState;
	if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
		document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
	} else {
		if (window.requestAnimationFrame) {
			window.requestAnimationFrame(highlightAutomaticallyCallback);
		} else {
			window.setTimeout(highlightAutomaticallyCallback, 16);
		}
	}
}

return _;

})(_self);

if ( true && module.exports) {
	module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof global !== 'undefined') {
	global.Prism = Prism;
}

// some additional documentation/types

/**
 * The expansion of a simple `RegExp` literal to support additional properties.
 *
 * @typedef GrammarToken
 * @property {RegExp} pattern The regular expression of the token.
 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
 * @property {boolean} [greedy=false] Whether the token is greedy.
 * @property {string|string[]} [alias] An optional alias or list of aliases.
 * @property {Grammar} [inside] The nested grammar of this token.
 *
 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
 *
 * This can be used to make nested and even recursive language definitions.
 *
 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
 * each another.
 * @global
 * @public
*/

/**
 * @typedef Grammar
 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
 * @global
 * @public
 */

/**
 * A function which will invoked after an element was successfully highlighted.
 *
 * @callback HighlightCallback
 * @param {Element} element The element successfully highlighted.
 * @returns {void}
 * @global
 * @public
*/

/**
 * @callback HookCallback
 * @param {Object<string, any>} env The environment variables of the hook.
 * @returns {void}
 * @global
 * @public
 */


/* **********************************************
     Begin prism-markup.js
********************************************** */

Prism.languages.markup = {
	'comment': /<!--[\s\S]*?-->/,
	'prolog': /<\?[\s\S]+?\?>/,
	'doctype': {
		// https://www.w3.org/TR/xml/#NT-doctypedecl
		pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
		greedy: true,
		inside: {
			'internal-subset': {
				pattern: /(\[)[\s\S]+(?=\]>$)/,
				lookbehind: true,
				greedy: true,
				inside: null // see below
			},
			'string': {
				pattern: /"[^"]*"|'[^']*'/,
				greedy: true
			},
			'punctuation': /^<!|>$|[[\]]/,
			'doctype-tag': /^DOCTYPE/,
			'name': /[^\s<>'"]+/
		}
	},
	'cdata': /<!\[CDATA\[[\s\S]*?]]>/i,
	'tag': {
		pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
		greedy: true,
		inside: {
			'tag': {
				pattern: /^<\/?[^\s>\/]+/,
				inside: {
					'punctuation': /^<\/?/,
					'namespace': /^[^\s>\/:]+:/
				}
			},
			'attr-value': {
				pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
				inside: {
					'punctuation': [
						{
							pattern: /^=/,
							alias: 'attr-equals'
						},
						/"|'/
					]
				}
			},
			'punctuation': /\/?>/,
			'attr-name': {
				pattern: /[^\s>\/]+/,
				inside: {
					'namespace': /^[^\s>\/:]+:/
				}
			}

		}
	},
	'entity': [
		{
			pattern: /&[\da-z]{1,8};/i,
			alias: 'named-entity'
		},
		/&#x?[\da-f]{1,8};/i
	]
};

Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
	Prism.languages.markup['entity'];
Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function (env) {

	if (env.type === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;/, '&');
	}
});

Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
	/**
	 * Adds an inlined language to markup.
	 *
	 * An example of an inlined language is CSS with `<style>` tags.
	 *
	 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addInlined('style', 'css');
	 */
	value: function addInlined(tagName, lang) {
		var includedCdataInside = {};
		includedCdataInside['language-' + lang] = {
			pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
			lookbehind: true,
			inside: Prism.languages[lang]
		};
		includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

		var inside = {
			'included-cdata': {
				pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
				inside: includedCdataInside
			}
		};
		inside['language-' + lang] = {
			pattern: /[\s\S]+/,
			inside: Prism.languages[lang]
		};

		var def = {};
		def[tagName] = {
			pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),
			lookbehind: true,
			greedy: true,
			inside: inside
		};

		Prism.languages.insertBefore('markup', 'cdata', def);
	}
});

Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;

Prism.languages.xml = Prism.languages.extend('markup', {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;


/* **********************************************
     Begin prism-css.js
********************************************** */

(function (Prism) {

	var string = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;

	Prism.languages.css = {
		'comment': /\/\*[\s\S]*?\*\//,
		'atrule': {
			pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
			inside: {
				'rule': /^@[\w-]+/,
				'selector-function-argument': {
					pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
					lookbehind: true,
					alias: 'selector'
				},
				'keyword': {
					pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
					lookbehind: true
				}
				// See rest below
			}
		},
		'url': {
			// https://drafts.csswg.org/css-values-3/#urls
			pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
			greedy: true,
			inside: {
				'function': /^url/i,
				'punctuation': /^\(|\)$/,
				'string': {
					pattern: RegExp('^' + string.source + '$'),
					alias: 'url'
				}
			}
		},
		'selector': RegExp('[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
		'string': {
			pattern: string,
			greedy: true
		},
		'property': /(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
		'important': /!important\b/i,
		'function': /[-a-z0-9]+(?=\()/i,
		'punctuation': /[(){};:,]/
	};

	Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

	var markup = Prism.languages.markup;
	if (markup) {
		markup.tag.addInlined('style', 'css');

		Prism.languages.insertBefore('inside', 'attr-value', {
			'style-attr': {
				pattern: /(^|["'\s])style\s*=\s*(?:"[^"]*"|'[^']*')/i,
				lookbehind: true,
				inside: {
					'attr-value': {
						pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
						inside: {
							'style': {
								pattern: /(["'])[\s\S]+(?=["']$)/,
								lookbehind: true,
								alias: 'language-css',
								inside: Prism.languages.css
							},
							'punctuation': [
								{
									pattern: /^=/,
									alias: 'attr-equals'
								},
								/"|'/
							]
						}
					},
					'attr-name': /^style/i
				}
			}
		}, markup.tag);
	}

}(Prism));


/* **********************************************
     Begin prism-clike.js
********************************************** */

Prism.languages.clike = {
	'comment': [
		{
			pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
			lookbehind: true,
			greedy: true
		},
		{
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true,
			greedy: true
		}
	],
	'string': {
		pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'class-name': {
		pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i,
		lookbehind: true,
		inside: {
			'punctuation': /[.\\]/
		}
	},
	'keyword': /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
	'boolean': /\b(?:true|false)\b/,
	'function': /\w+(?=\()/,
	'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
	'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
	'punctuation': /[{}[\];(),.:]/
};


/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism.languages.javascript = Prism.languages.extend('clike', {
	'class-name': [
		Prism.languages.clike['class-name'],
		{
			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:prototype|constructor))/,
			lookbehind: true
		}
	],
	'keyword': [
		{
			pattern: /((?:^|})\s*)(?:catch|finally)\b/,
			lookbehind: true
		},
		{
			pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|(?:get|set)(?=\s*[\[$\w\xA0-\uFFFF])|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
			lookbehind: true
		},
	],
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
	'number': /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
	'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});

Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
		lookbehind: true,
		greedy: true,
		inside: {
			'regex-source': {
				pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
				lookbehind: true,
				alias: 'language-regex',
				inside: Prism.languages.regex
			},
			'regex-flags': /[a-z]+$/,
			'regex-delimiter': /^\/|\/$/
		}
	},
	// This must be declared before keyword because we use "function" inside the look-forward
	'function-variable': {
		pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
		alias: 'function'
	},
	'parameter': [
		{
			pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
			inside: Prism.languages.javascript
		},
		{
			pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
			lookbehind: true,
			inside: Prism.languages.javascript
		}
	],
	'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});

Prism.languages.insertBefore('javascript', 'string', {
	'template-string': {
		pattern: /`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}|(?!\${)[^\\`])*`/,
		greedy: true,
		inside: {
			'template-punctuation': {
				pattern: /^`|`$/,
				alias: 'string'
			},
			'interpolation': {
				pattern: /((?:^|[^\\])(?:\\{2})*)\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/,
				lookbehind: true,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\${|}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	}
});

if (Prism.languages.markup) {
	Prism.languages.markup.tag.addInlined('script', 'javascript');
}

Prism.languages.js = Prism.languages.javascript;


/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function () {
	if (typeof self === 'undefined' || !self.Prism || !self.document) {
		return;
	}

	// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
	if (!Element.prototype.matches) {
		Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
	}

	var Prism = window.Prism;

	var LOADING_MESSAGE = 'Loading';
	var FAILURE_MESSAGE = function (status, message) {
		return ' Error ' + status + ' while fetching file: ' + message;
	};
	var FAILURE_EMPTY_MESSAGE = ' Error: File does not exist or is empty';

	var EXTENSIONS = {
		'js': 'javascript',
		'py': 'python',
		'rb': 'ruby',
		'ps1': 'powershell',
		'psm1': 'powershell',
		'sh': 'bash',
		'bat': 'batch',
		'h': 'c',
		'tex': 'latex'
	};

	var STATUS_ATTR = 'data-src-status';
	var STATUS_LOADING = 'loading';
	var STATUS_LOADED = 'loaded';
	var STATUS_FAILED = 'failed';

	var SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '="' + STATUS_LOADED + '"])'
		+ ':not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';

	var lang = /\blang(?:uage)?-([\w-]+)\b/i;

	/**
	 * Sets the Prism `language-xxxx` or `lang-xxxx` class to the given language.
	 *
	 * @param {HTMLElement} element
	 * @param {string} language
	 * @returns {void}
	 */
	function setLanguageClass(element, language) {
		var className = element.className;
		className = className.replace(lang, ' ') + ' language-' + language;
		element.className = className.replace(/\s+/g, ' ').trim();
	}


	Prism.hooks.add('before-highlightall', function (env) {
		env.selector += ', ' + SELECTOR;
	});

	Prism.hooks.add('before-sanity-check', function (env) {
		var pre = /** @type {HTMLPreElement} */ (env.element);
		if (pre.matches(SELECTOR)) {
			env.code = ''; // fast-path the whole thing and go to complete

			pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading

			// add code element with loading message
			var code = pre.appendChild(document.createElement('CODE'));
			code.textContent = LOADING_MESSAGE;

			var src = pre.getAttribute('data-src');

			var language = env.language;
			if (language === 'none') {
				// the language might be 'none' because there is no language set;
				// in this case, we want to use the extension as the language
				var extension = (/\.(\w+)$/.exec(src) || [, 'none'])[1];
				language = EXTENSIONS[extension] || extension;
			}

			// set language classes
			setLanguageClass(code, language);
			setLanguageClass(pre, language);

			// preload the language
			var autoloader = Prism.plugins.autoloader;
			if (autoloader) {
				autoloader.loadLanguages(language);
			}

			// load file
			var xhr = new XMLHttpRequest();
			xhr.open('GET', src, true);
			xhr.onreadystatechange = function () {
				if (xhr.readyState == 4) {
					if (xhr.status < 400 && xhr.responseText) {
						// mark as loaded
						pre.setAttribute(STATUS_ATTR, STATUS_LOADED);

						// highlight code
						code.textContent = xhr.responseText;
						Prism.highlightElement(code);

					} else {
						// mark as failed
						pre.setAttribute(STATUS_ATTR, STATUS_FAILED);

						if (xhr.status >= 400) {
							code.textContent = FAILURE_MESSAGE(xhr.status, xhr.statusText);
						} else {
							code.textContent = FAILURE_EMPTY_MESSAGE;
						}
					}
				}
			};
			xhr.send(null);
		}
	});

	Prism.plugins.fileHighlight = {
		/**
		 * Executes the File Highlight plugin for all matching `pre` elements under the given container.
		 *
		 * Note: Elements which are already loaded or currently loading will not be touched by this method.
		 *
		 * @param {ParentNode} [container=document]
		 */
		highlight: function highlight(container) {
			var elements = (container || document).querySelectorAll(SELECTOR);

			for (var i = 0, element; element = elements[i++];) {
				Prism.highlightElement(element);
			}
		}
	};

	var logged = false;
	/** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */
	Prism.fileHighlight = function () {
		if (!logged) {
			console.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');
			logged = true;
		}
		Prism.plugins.fileHighlight.highlight.apply(this, arguments);
	}

})();

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("7d15")))

/***/ }),

/***/ "9fad":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "a03e":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("5428");
var getOwnPropertyNamesModule = __webpack_require__("65d0");
var getOwnPropertySymbolsModule = __webpack_require__("2402");
var anObject = __webpack_require__("157c");

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "a0d5":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("07d9")))

/***/ }),

/***/ "a114":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export humanStorageSize */
/* unused harmony export capitalize */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return between; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return normalizeToInterval; });
/* unused harmony export pad */
const units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];
function humanStorageSize(bytes) {
  let u = 0;

  while (parseInt(bytes, 10) >= 1024 && u < units.length - 1) {
    bytes /= 1024;
    ++u;
  }

  return `${bytes.toFixed(1)}${units[u]}`;
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function between(v, min, max) {
  return max <= min ? min : Math.min(max, Math.max(min, v));
}
function normalizeToInterval(v, min, max) {
  if (max <= min) {
    return min;
  }

  const size = max - min + 1;
  let index = min + (v - min) % size;

  if (index < min) {
    index = size + index;
  }

  return index === 0 ? 0 : index; // fix for (-a % a) => -0
}
function pad(v, length = 2, char = '0') {
  if (v === void 0 || v === null) {
    return v;
  }

  const val = '' + v;
  return val.length >= length ? val : new Array(length - val.length + 1).join(char) + val;
}
/* unused harmony default export */ var _unused_webpack_default_export = ({
  humanStorageSize,
  capitalize,
  between,
  normalizeToInterval,
  pad
});

/***/ }),

/***/ "a4b3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return slot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return uniqueSlot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return mergeSlot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return mergeSlotSafely; });
function slot(vm, slotName, otherwise) {
  return vm.$scopedSlots[slotName] !== void 0 ? vm.$scopedSlots[slotName]() : otherwise;
}
function uniqueSlot(vm, slotName, otherwise) {
  return vm.$scopedSlots[slotName] !== void 0 ? vm.$scopedSlots[slotName]().slice() : otherwise;
}
/**
 * Source definitely exists,
 * so it's merged with the possible slot
 */

function mergeSlot(source, vm, slotName) {
  return vm.$scopedSlots[slotName] !== void 0 ? source.concat(vm.$scopedSlots[slotName]()) : source;
}
/**
 * Merge with possible slot,
 * even if source might not exist
 */

function mergeSlotSafely(source, vm, slotName) {
  if (vm.$scopedSlots[slotName] === void 0) {
    return source;
  }

  const slot = vm.$scopedSlots[slotName]();
  return source !== void 0 ? source.concat(slot) : slot;
}

/***/ }),

/***/ "a680":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ComponentGallery_vue_vue_type_style_index_0_id_d25a87ce_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("b3b6");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ComponentGallery_vue_vue_type_style_index_0_id_d25a87ce_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ComponentGallery_vue_vue_type_style_index_0_id_d25a87ce_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "a9dd":
/***/ (function(module, exports, __webpack_require__) {

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = __webpack_require__("ed2b");

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('flatMap');


/***/ }),

/***/ "aaba":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("157c");

module.exports = function (iterator) {
  var returnMethod = iterator['return'];
  if (returnMethod !== undefined) {
    return anObject(returnMethod.call(iterator)).value;
  }
};


/***/ }),

/***/ "aaf2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var NATIVE_ARRAY_BUFFER = __webpack_require__("bd10");
var DESCRIPTORS = __webpack_require__("d4cb");
var global = __webpack_require__("f498");
var isObject = __webpack_require__("7526");
var has = __webpack_require__("f1a7");
var classof = __webpack_require__("da06");
var createNonEnumerableProperty = __webpack_require__("5b12");
var redefine = __webpack_require__("b8ba");
var defineProperty = __webpack_require__("abdf").f;
var getPrototypeOf = __webpack_require__("0e39");
var setPrototypeOf = __webpack_require__("c1a2");
var wellKnownSymbol = __webpack_require__("7d53");
var uid = __webpack_require__("1d8a");

var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var isPrototypeOf = ObjectPrototype.isPrototypeOf;

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQIRED = false;
var NAME;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var BigIntArrayConstructorsList = {
  BigInt64Array: 8,
  BigUint64Array: 8
};

var isView = function isView(it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return klass === 'DataView'
    || has(TypedArrayConstructorsList, klass)
    || has(BigIntArrayConstructorsList, klass);
};

var isTypedArray = function (it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return has(TypedArrayConstructorsList, klass)
    || has(BigIntArrayConstructorsList, klass);
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (setPrototypeOf) {
    if (isPrototypeOf.call(TypedArray, C)) return C;
  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
      return C;
    }
  } throw TypeError('Target is not a typed array constructor');
};

var exportTypedArrayMethod = function (KEY, property, forced) {
  if (!DESCRIPTORS) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
      delete TypedArrayConstructor.prototype[KEY];
    }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    redefine(TypedArrayPrototype, KEY, forced ? property
      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
  }
};

var exportTypedArrayStaticMethod = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS) return;
  if (setPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global[ARRAY];
      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
        delete TypedArrayConstructor[KEY];
      }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY] || property);
      } catch (error) { /* empty */ }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      redefine(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow -- safe
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQIRED = true;
  defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function () {
    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
  } });
  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {
    createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
  }
}

module.exports = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportTypedArrayMethod: exportTypedArrayMethod,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};


/***/ }),

/***/ "abdf":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("d4cb");
var IE8_DOM_DEFINE = __webpack_require__("7c3f");
var anObject = __webpack_require__("157c");
var toPrimitive = __webpack_require__("083f");

// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "abfd":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__("157c");

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "ac9b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@babel/runtime/helpers/objectSpread2.js
var objectSpread2 = __webpack_require__("ca22");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2);

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue/dist/vue.runtime.esm.js
var vue_runtime_esm = __webpack_require__("9869");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/dark.js
var dark = __webpack_require__("87b2");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/tag.js
var tag = __webpack_require__("5cad");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.string.replace.js
var es_string_replace = __webpack_require__("32f5");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/router-link.js

const routerLinkProps = {
  to: [String, Object],
  exact: Boolean,
  append: Boolean,
  replace: Boolean,
  activeClass: String,
  exactActiveClass: String,
  disable: Boolean
};
const RouterLinkMixin = {
  props: routerLinkProps,
  computed: {
    hasRouterLink() {
      return this.disable !== true && this.to !== void 0 && this.to !== null && this.to !== '';
    },

    routerLinkProps() {
      return {
        to: this.to,
        exact: this.exact,
        append: this.append,
        replace: this.replace,
        activeClass: this.activeClass || 'q-router-link--active',
        exactActiveClass: this.exactActiveClass || 'q-router-link--exact-active',
        event: this.disable === true ? [] : void 0
      };
    }

  }
};
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/listeners.js
var listeners = __webpack_require__("0fb0");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/slot.js
var slot = __webpack_require__("a4b3");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("9ac9");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/key-composition.js
var key_composition = __webpack_require__("1b63");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/item/QItem.js









/* harmony default export */ var QItem = __webpack_exports__["a"] = (vue_runtime_esm["default"].extend({
  name: 'QItem',
  mixins: [dark["a" /* default */], RouterLinkMixin, tag["a" /* default */], listeners["a" /* default */]],
  props: {
    active: Boolean,
    clickable: Boolean,
    dense: Boolean,
    insetLevel: Number,
    tabindex: [String, Number],
    focused: Boolean,
    manualFocus: Boolean
  },
  computed: {
    isActionable() {
      return this.clickable === true || this.hasRouterLink === true || this.tag === 'a' || this.tag === 'label';
    },

    isClickable() {
      return this.disable !== true && this.isActionable === true;
    },

    classes() {
      return {
        'q-item--clickable q-link cursor-pointer': this.isClickable,
        'q-focusable q-hoverable': this.isClickable === true && this.manualFocus === false,
        'q-manual-focusable': this.isClickable === true && this.manualFocus === true,
        'q-manual-focusable--focused': this.isClickable === true && this.focused === true,
        'q-item--dense': this.dense,
        'q-item--dark': this.isDark,
        'q-item--active': this.active,
        [this.activeClass]: this.active === true && this.hasRouterLink !== true && this.activeClass !== void 0,
        'disabled': this.disable
      };
    },

    style() {
      if (this.insetLevel !== void 0) {
        const dir = this.$q.lang.rtl === true ? 'Right' : 'Left';
        return {
          ['padding' + dir]: 16 + this.insetLevel * 56 + 'px'
        };
      }
    },

    onEvents() {
      return objectSpread2_default()(objectSpread2_default()({}, this.qListeners), {}, {
        click: this.__onClick,
        keyup: this.__onKeyup
      });
    }

  },
  methods: {
    __getContent(h) {
      const child = Object(slot["d" /* uniqueSlot */])(this, 'default', []);
      this.isClickable === true && child.unshift(h('div', {
        staticClass: 'q-focus-helper',
        attrs: {
          tabindex: -1
        },
        ref: 'blurTarget'
      }));
      return child;
    },

    __onClick(e) {
      if (this.isClickable === true) {
        if (this.$refs.blurTarget !== void 0) {
          if (e.qKeyEvent !== true && document.activeElement === this.$el) {
            this.$refs.blurTarget.focus();
          } else if (document.activeElement === this.$refs.blurTarget) {
            this.$el.focus();
          }
        }

        this.$emit('click', e);
      }
    },

    __onKeyup(e) {
      if (this.isClickable === true && Object(key_composition["a" /* isKeyCode */])(e, 13) === true) {
        Object(utils_event["l" /* stopAndPrevent */])(e); // for ripple

        e.qKeyEvent = true; // for click trigger

        const evt = new MouseEvent('click', e);
        evt.qKeyEvent = true;
        this.$el.dispatchEvent(evt);
      }

      this.$emit('keyup', e);
    }

  },

  render(h) {
    const data = {
      staticClass: 'q-item q-item-type row no-wrap',
      class: this.classes,
      style: this.style,
      [this.hasRouterLink === true ? 'nativeOn' : 'on']: this.onEvents
    };

    if (this.isClickable === true) {
      data.attrs = {
        tabindex: this.tabindex || '0'
      };
    } else if (this.isActionable === true) {
      data.attrs = {
        'aria-disabled': 'true'
      };
    }

    if (this.hasRouterLink === true) {
      data.tag = 'a';
      data.props = this.routerLinkProps;
      return h('router-link', data, this.__getContent(h));
    }

    return h(this.tag, data, this.__getContent(h));
  }

}));

/***/ }),

/***/ "b17e":
/***/ (function(module, exports) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "b190":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/dom.js
var dom = __webpack_require__("3230");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("9ac9");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/key-composition.js
var key_composition = __webpack_require__("1b63");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/plugins/Platform.js
var Platform = __webpack_require__("5094");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/throttle.js
var throttle = __webpack_require__("f96b");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/install.js + 3 modules
var install = __webpack_require__("7cad");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/directives/Ripple.js







function showRipple(evt, el, ctx, forceCenter) {
  ctx.modifiers.stop === true && Object(utils_event["k" /* stop */])(evt);
  const color = ctx.modifiers.color;
  let center = ctx.modifiers.center;
  center = center === true || forceCenter === true;
  const node = document.createElement('span'),
        innerNode = document.createElement('span'),
        pos = Object(utils_event["h" /* position */])(evt),
        {
    left,
    top,
    width,
    height
  } = el.getBoundingClientRect(),
        diameter = Math.sqrt(width * width + height * height),
        radius = diameter / 2,
        centerX = `${(width - diameter) / 2}px`,
        x = center ? centerX : `${pos.left - left - radius}px`,
        centerY = `${(height - diameter) / 2}px`,
        y = center ? centerY : `${pos.top - top - radius}px`;
  innerNode.className = 'q-ripple__inner';
  Object(dom["b" /* css */])(innerNode, {
    height: `${diameter}px`,
    width: `${diameter}px`,
    transform: `translate3d(${x},${y},0) scale3d(.2,.2,1)`,
    opacity: 0
  });
  node.className = `q-ripple${color ? ' text-' + color : ''}`;
  node.setAttribute('dir', 'ltr');
  node.appendChild(innerNode);
  el.appendChild(node);

  const abort = () => {
    node.remove();
    clearTimeout(timer);
  };

  ctx.abort.push(abort);
  let timer = setTimeout(() => {
    innerNode.classList.add('q-ripple__inner--enter');
    innerNode.style.transform = `translate3d(${centerX},${centerY},0) scale3d(1,1,1)`;
    innerNode.style.opacity = 0.2;
    timer = setTimeout(() => {
      innerNode.classList.remove('q-ripple__inner--enter');
      innerNode.classList.add('q-ripple__inner--leave');
      innerNode.style.opacity = 0;
      timer = setTimeout(() => {
        node.remove();
        ctx.abort.splice(ctx.abort.indexOf(abort), 1);
      }, 275);
    }, 250);
  }, 50);
}

function updateModifiers(ctx, {
  modifiers,
  value,
  arg
}) {
  const cfg = Object.assign({}, install["a" /* $q */].config.ripple, modifiers, value);
  ctx.modifiers = {
    early: cfg.early === true,
    stop: cfg.stop === true,
    center: cfg.center === true,
    color: cfg.color || arg,
    keyCodes: [].concat(cfg.keyCodes || 13)
  };
}

function destroy(el) {
  const ctx = el.__qripple;

  if (ctx !== void 0) {
    ctx.abort.forEach(fn => {
      fn();
    });
    Object(utils_event["b" /* cleanEvt */])(ctx, 'main');
    delete el._qripple;
  }
}

/* harmony default export */ var Ripple = ({
  name: 'ripple',

  inserted(el, binding) {
    if (el.__qripple !== void 0) {
      destroy(el);
      el.__qripple_destroyed = true;
    }

    const ctx = {
      enabled: binding.value !== false,
      modifiers: {},
      abort: [],

      start(evt) {
        if (ctx.enabled === true && evt.qSkipRipple !== true && ( // on ENTER in form IE emits a PointerEvent with negative client cordinates
        Platform["a" /* client */].is.ie !== true || evt.clientX >= 0) && (ctx.modifiers.early === true ? ['mousedown', 'touchstart'].includes(evt.type) === true : evt.type === 'click')) {
          showRipple(evt, el, ctx, evt.qKeyEvent === true);
        }
      },

      keystart: Object(throttle["a" /* default */])(evt => {
        if (ctx.enabled === true && evt.qSkipRipple !== true && Object(key_composition["a" /* isKeyCode */])(evt, ctx.modifiers.keyCodes) === true && evt.type === `key${ctx.modifiers.early === true ? 'down' : 'up'}`) {
          showRipple(evt, el, ctx, true);
        }
      }, 300)
    };
    updateModifiers(ctx, binding);
    el.__qripple = ctx;
    Object(utils_event["a" /* addEvt */])(ctx, 'main', [[el, 'mousedown', 'start', 'passive'], [el, 'touchstart', 'start', 'passive'], [el, 'click', 'start', 'passive'], [el, 'keydown', 'keystart', 'passive'], [el, 'keyup', 'keystart', 'passive']]);
  },

  update(el, binding) {
    const ctx = el.__qripple;

    if (ctx !== void 0 && binding.oldValue !== binding.value) {
      ctx.enabled = binding.value !== false;

      if (ctx.enabled === true && Object(binding.value) === binding.value) {
        updateModifiers(ctx, binding);
      }
    }
  },

  unbind(el) {
    if (el.__qripple_destroyed === void 0) {
      destroy(el);
    } else {
      delete el.__qripple_destroyed;
    }
  }

});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/ripple.js

/* harmony default export */ var ripple = __webpack_exports__["a"] = ({
  directives: {
    Ripple: Ripple
  },
  props: {
    ripple: {
      type: [Boolean, Object],
      default: true
    }
  }
});

/***/ }),

/***/ "b203":
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__("b8ba");

module.exports = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ "b257":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("6b1d");
var fails = __webpack_require__("72df");
var ArrayBufferModule = __webpack_require__("cf50");
var anObject = __webpack_require__("157c");
var toAbsoluteIndex = __webpack_require__("9a0f");
var toLength = __webpack_require__("b495");
var speciesConstructor = __webpack_require__("433a");

var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var nativeArrayBufferSlice = ArrayBuffer.prototype.slice;

var INCORRECT_SLICE = fails(function () {
  return !new ArrayBuffer(2).slice(1, undefined).byteLength;
});

// `ArrayBuffer.prototype.slice` method
// https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice
$({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
  slice: function slice(start, end) {
    if (nativeArrayBufferSlice !== undefined && end === undefined) {
      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
    }
    var length = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = new (speciesConstructor(this, ArrayBuffer))(toLength(fin - first));
    var viewSource = new DataView(this);
    var viewTarget = new DataView(result);
    var index = 0;
    while (first < fin) {
      viewTarget.setUint8(index++, viewSource.getUint8(first++));
    } return result;
  }
});


/***/ }),

/***/ "b3b6":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "b495":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("8bb2");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "b4af":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@babel/runtime/helpers/objectSpread2.js
var objectSpread2 = __webpack_require__("ca22");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2);

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue/dist/vue.runtime.esm.js
var vue_runtime_esm = __webpack_require__("9869");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/plugins/Platform.js
var Platform = __webpack_require__("5094");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/scroll.js
var utils_scroll = __webpack_require__("8047");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("9ac9");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/scroll-observer/QScrollObserver.js



const {
  passive
} = utils_event["f" /* listenOpts */];
/* harmony default export */ var QScrollObserver = (vue_runtime_esm["default"].extend({
  name: 'QScrollObserver',
  props: {
    debounce: [String, Number],
    horizontal: Boolean,
    scrollTarget: {
      default: void 0
    }
  },
  render: utils_event["g" /* noop */],

  // eslint-disable-line
  data() {
    return {
      pos: 0,
      dir: this.horizontal === true ? 'right' : 'down',
      dirChanged: false,
      dirChangePos: 0
    };
  },

  watch: {
    scrollTarget() {
      this.__unconfigureScrollTarget();

      this.__configureScrollTarget();
    }

  },
  methods: {
    getPosition() {
      return {
        position: this.pos,
        direction: this.dir,
        directionChanged: this.dirChanged,
        inflexionPosition: this.dirChangePos
      };
    },

    trigger(immediately) {
      if (immediately === true || this.debounce === 0 || this.debounce === '0') {
        this.__emit();
      } else if (!this.timer) {
        this.timer = this.debounce ? setTimeout(this.__emit, this.debounce) : requestAnimationFrame(this.__emit);
      }
    },

    __emit() {
      const fn = this.horizontal === true ? utils_scroll["b" /* getHorizontalScrollPosition */] : utils_scroll["c" /* getScrollPosition */];
      const pos = Math.max(0, fn(this.__scrollTarget)),
            delta = pos - this.pos,
            dir = this.horizontal === true ? delta < 0 ? 'left' : 'right' : delta < 0 ? 'up' : 'down';
      this.dirChanged = this.dir !== dir;

      if (this.dirChanged) {
        this.dir = dir;
        this.dirChangePos = this.pos;
      }

      this.timer = null;
      this.pos = pos;
      this.$emit('scroll', this.getPosition());
    },

    __configureScrollTarget() {
      this.__scrollTarget = Object(utils_scroll["d" /* getScrollTarget */])(this.$el.parentNode, this.scrollTarget);

      this.__scrollTarget.addEventListener('scroll', this.trigger, passive);

      this.trigger(true);
    },

    __unconfigureScrollTarget() {
      if (this.__scrollTarget !== void 0) {
        this.__scrollTarget.removeEventListener('scroll', this.trigger, passive);

        this.__scrollTarget = void 0;
      }
    }

  },

  mounted() {
    this.__configureScrollTarget();
  },

  beforeDestroy() {
    clearTimeout(this.timer);
    cancelAnimationFrame(this.timer);

    this.__unconfigureScrollTarget();
  }

}));
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/resize-observer/QResizeObserver.js + 1 modules
var QResizeObserver = __webpack_require__("df4a");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/listeners.js
var listeners = __webpack_require__("0fb0");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/slot.js
var slot = __webpack_require__("a4b3");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/cache.js
var cache = __webpack_require__("6459");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/layout/QLayout.js









/* harmony default export */ var QLayout = __webpack_exports__["a"] = (vue_runtime_esm["default"].extend({
  name: 'QLayout',
  mixins: [listeners["a" /* default */]],

  provide() {
    return {
      layout: this
    };
  },

  props: {
    container: Boolean,
    view: {
      type: String,
      default: 'hhh lpr fff',
      validator: v => /^(h|l)h(h|r) lpr (f|l)f(f|r)$/.test(v.toLowerCase())
    }
  },

  data() {
    return {
      // page related
      height: this.$q.screen.height,
      width: this.container === true ? 0 : this.$q.screen.width,
      // container only prop
      containerHeight: 0,
      scrollbarWidth: Platform["g" /* onSSR */] === true ? 0 : Object(utils_scroll["e" /* getScrollbarWidth */])(),
      header: {
        size: 0,
        offset: 0,
        space: false
      },
      right: {
        size: 300,
        offset: 0,
        space: false
      },
      footer: {
        size: 0,
        offset: 0,
        space: false
      },
      left: {
        size: 300,
        offset: 0,
        space: false
      },
      scroll: {
        position: 0,
        direction: 'down'
      }
    };
  },

  computed: {
    rows() {
      const rows = this.view.toLowerCase().split(' ');
      return {
        top: rows[0].split(''),
        middle: rows[1].split(''),
        bottom: rows[2].split('')
      };
    },

    style() {
      return this.container === true ? null : {
        minHeight: this.$q.screen.height + 'px'
      };
    },

    // used by container only
    targetStyle() {
      if (this.scrollbarWidth !== 0) {
        return {
          [this.$q.lang.rtl === true ? 'left' : 'right']: `${this.scrollbarWidth}px`
        };
      }
    },

    targetChildStyle() {
      if (this.scrollbarWidth !== 0) {
        return {
          [this.$q.lang.rtl === true ? 'right' : 'left']: 0,
          [this.$q.lang.rtl === true ? 'left' : 'right']: `-${this.scrollbarWidth}px`,
          width: `calc(100% + ${this.scrollbarWidth}px)`
        };
      }
    },

    totalWidth() {
      return this.width + this.scrollbarWidth;
    },

    classes() {
      return 'q-layout q-layout--' + (this.container === true ? 'containerized' : 'standard');
    }

  },

  created() {
    this.instances = {};
  },

  render(h) {
    const layout = h('div', {
      class: this.classes,
      style: this.style,
      on: objectSpread2_default()({}, this.qListeners)
    }, Object(slot["a" /* mergeSlot */])([h(QScrollObserver, {
      on: Object(cache["b" /* default */])(this, 'scroll', {
        scroll: this.__onPageScroll
      })
    }), h(QResizeObserver["a" /* default */], {
      on: Object(cache["b" /* default */])(this, 'resizeOut', {
        resize: this.__onPageResize
      })
    })], this, 'default'));
    return this.container === true ? h('div', {
      staticClass: 'q-layout-container overflow-hidden'
    }, [h(QResizeObserver["a" /* default */], {
      on: Object(cache["b" /* default */])(this, 'resizeIn', {
        resize: this.__onContainerResize
      })
    }), h('div', {
      staticClass: 'absolute-full',
      style: this.targetStyle
    }, [h('div', {
      staticClass: 'scroll',
      style: this.targetChildStyle
    }, [layout])])]) : layout;
  },

  methods: {
    __animate() {
      if (this.timer !== void 0) {
        clearTimeout(this.timer);
      } else {
        document.body.classList.add('q-body--layout-animate');
      }

      this.timer = setTimeout(() => {
        document.body.classList.remove('q-body--layout-animate');
        this.timer = void 0;
      }, 150);
    },

    __onPageScroll(data) {
      if (this.container === true || document.qScrollPrevented !== true) {
        this.scroll = data;
      }

      this.qListeners.scroll !== void 0 && this.$emit('scroll', data);
    },

    __onPageResize({
      height,
      width
    }) {
      let resized = false;

      if (this.height !== height) {
        resized = true;
        this.height = height;

        if (this.qListeners['scroll-height'] !== void 0) {
          this.$emit('scroll-height', height);
        }

        this.__updateScrollbarWidth();
      }

      if (this.width !== width) {
        resized = true;
        this.width = width;
      }

      if (resized === true && this.qListeners.resize !== void 0) {
        this.$emit('resize', {
          height,
          width
        });
      }
    },

    __onContainerResize({
      height
    }) {
      if (this.containerHeight !== height) {
        this.containerHeight = height;

        this.__updateScrollbarWidth();
      }
    },

    __updateScrollbarWidth() {
      if (this.container === true) {
        const width = this.height > this.containerHeight ? Object(utils_scroll["e" /* getScrollbarWidth */])() : 0;

        if (this.scrollbarWidth !== width) {
          this.scrollbarWidth = width;
        }
      }
    }

  }
}));

/***/ }),

/***/ "b506":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("6b1d");
var aFunction = __webpack_require__("8697");
var toObject = __webpack_require__("37d1");
var fails = __webpack_require__("72df");
var arrayMethodIsStrict = __webpack_require__("7f8a");

var test = [];
var nativeSort = test.sort;

// IE8-
var FAILS_ON_UNDEFINED = fails(function () {
  test.sort(undefined);
});
// V8 bug
var FAILS_ON_NULL = fails(function () {
  test.sort(null);
});
// Old WebKit
var STRICT_METHOD = arrayMethodIsStrict('sort');

var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD;

// `Array.prototype.sort` method
// https://tc39.es/ecma262/#sec-array.prototype.sort
$({ target: 'Array', proto: true, forced: FORCED }, {
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? nativeSort.call(toObject(this))
      : nativeSort.call(toObject(this), aFunction(comparefn));
  }
});


/***/ }),

/***/ "b55a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("6b1d");
var $trim = __webpack_require__("61ad").trim;
var forcedStringTrimMethod = __webpack_require__("9951");

// `String.prototype.trim` method
// https://tc39.es/ecma262/#sec-string.prototype.trim
$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
  trim: function trim() {
    return $trim(this);
  }
});


/***/ }),

/***/ "b578":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("157c");
var isArrayIteratorMethod = __webpack_require__("c965");
var toLength = __webpack_require__("b495");
var bind = __webpack_require__("2117");
var getIteratorMethod = __webpack_require__("0446");
var iteratorClose = __webpack_require__("aaba");

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && result instanceof Result) return result;
      } return new Result(false);
    }
    iterator = iterFn.call(iterable);
  }

  next = iterator.next;
  while (!(step = next.call(iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator);
      throw error;
    }
    if (typeof result == 'object' && result && result instanceof Result) return result;
  } return new Result(false);
};


/***/ }),

/***/ "b634":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("f1a7");
var ownKeys = __webpack_require__("a03e");
var getOwnPropertyDescriptorModule = __webpack_require__("185a");
var definePropertyModule = __webpack_require__("abdf");

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ "b693":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@babel/runtime/helpers/objectSpread2.js
var objectSpread2 = __webpack_require__("ca22");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2);

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue/dist/vue.runtime.esm.js
var vue_runtime_esm = __webpack_require__("9869");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/plugins/Platform.js
var Platform = __webpack_require__("5094");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/icon/QIcon.js
var QIcon = __webpack_require__("34ff");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/spinner/QSpinner.js + 1 modules
var QSpinner = __webpack_require__("9cbe");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.promise.js
var es_promise = __webpack_require__("26d3");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/web.dom-collections.iterator.js
var web_dom_collections_iterator = __webpack_require__("918c");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/patterns.js
var patterns = __webpack_require__("86a3");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/validate.js



const lazyRulesValues = [true, false, 'ondemand'];
/* harmony default export */ var validate = ({
  props: {
    value: {},
    error: {
      type: Boolean,
      default: null
    },
    errorMessage: String,
    noErrorIcon: Boolean,
    rules: Array,
    reactiveRules: Boolean,
    lazyRules: {
      type: [Boolean, String],
      validator: v => lazyRulesValues.includes(v)
    }
  },

  data() {
    return {
      isDirty: null,
      innerError: false,
      innerErrorMessage: void 0
    };
  },

  watch: {
    value() {
      this.__validateIfNeeded();
    },

    disable(val) {
      val === true && this.resetValidation();
    },

    reactiveRules: {
      handler(val) {
        if (val === true) {
          if (this.unwatchRules === void 0) {
            this.unwatchRules = this.$watch('rules', () => {
              this.__validateIfNeeded(true);
            });
          }
        } else if (this.unwatchRules !== void 0) {
          this.unwatchRules();
          this.unwatchRules = void 0;
        }
      },

      immediate: true
    },

    focused(focused) {
      if (this.lazyRules !== 'ondemand') {
        if (focused === true) {
          if (this.isDirty === null) {
            this.isDirty = false;
          }
        } else if (this.isDirty === false && this.hasRules === true) {
          this.isDirty = true;
          this.validate();
        }
      }
    }

  },
  computed: {
    hasRules() {
      return this.rules !== void 0 && this.rules !== null && this.rules.length > 0;
    },

    hasError() {
      return this.error === true || this.innerError === true;
    },

    computedErrorMessage() {
      return typeof this.errorMessage === 'string' && this.errorMessage.length > 0 ? this.errorMessage : this.innerErrorMessage;
    }

  },

  mounted() {
    this.validateIndex = 0;
  },

  beforeDestroy() {
    this.unwatchRules !== void 0 && this.unwatchRules();
  },

  methods: {
    resetValidation() {
      this.validateIndex++;
      this.innerLoading = false;
      this.isDirty = null;
      this.innerError = false;
      this.innerErrorMessage = void 0;
    },

    /*
     * Return value
     *   - true (validation succeeded)
     *   - false (validation failed)
     *   - Promise (pending async validation)
     */
    validate(val = this.value) {
      if (this.hasRules !== true) {
        return true;
      }

      this.validateIndex++;

      if (this.innerLoading !== true && this.lazyRules !== true) {
        this.isDirty = true;
      }

      const update = (err, msg) => {
        if (this.innerError !== err) {
          this.innerError = err;
        }

        const m = msg || void 0;

        if (this.innerErrorMessage !== m) {
          this.innerErrorMessage = m;
        }

        if (this.innerLoading !== false) {
          this.innerLoading = false;
        }
      };

      const promises = [];

      for (let i = 0; i < this.rules.length; i++) {
        const rule = this.rules[i];
        let res;

        if (typeof rule === 'function') {
          res = rule(val);
        } else if (typeof rule === 'string' && patterns["a" /* testPattern */][rule] !== void 0) {
          res = patterns["a" /* testPattern */][rule](val);
        }

        if (res === false || typeof res === 'string') {
          update(true, res);
          return false;
        } else if (res !== true && res !== void 0) {
          promises.push(res);
        }
      }

      if (promises.length === 0) {
        update(false);
        return true;
      }

      if (this.innerLoading !== true) {
        this.innerLoading = true;
      }

      const index = this.validateIndex;
      return Promise.all(promises).then(res => {
        if (index !== this.validateIndex) {
          return true;
        }

        if (res === void 0 || Array.isArray(res) === false || res.length === 0) {
          update(false);
          return true;
        }

        const msg = res.find(r => r === false || typeof r === 'string');
        update(msg !== void 0, msg);
        return msg === void 0;
      }, e => {
        if (index === this.validateIndex) {
          console.error(e);
          update(true);
          return false;
        }

        return true;
      });
    },

    __validateIfNeeded(changedRules) {
      if (this.hasRules === true && this.lazyRules !== 'ondemand' && (this.isDirty === true || this.lazyRules !== true && changedRules !== true)) {
        this.validate();
      }
    }

  }
});
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/dark.js
var dark = __webpack_require__("87b2");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/attrs.js
var attrs = __webpack_require__("ffad");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/slot.js
var slot = __webpack_require__("a4b3");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.array-buffer.slice.js
var es_array_buffer_slice = __webpack_require__("b257");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.typed-array.uint8-array.js
var es_typed_array_uint8_array = __webpack_require__("5a6a");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/uid.js



/**
 * Based on the work of https://github.com/jchook/uuid-random
 */
let buf,
    bufIdx = 0;
const hexBytes = new Array(256); // Pre-calculate toString(16) for speed

for (let i = 0; i < 256; i++) {
  hexBytes[i] = (i + 0x100).toString(16).substr(1);
} // Use best available PRNG


const randomBytes = (() => {
  // Node & Browser support
  const lib = typeof crypto !== 'undefined' ? crypto : typeof window !== 'undefined' ? window.msCrypto // IE11
  : void 0;

  if (lib !== void 0) {
    if (lib.randomBytes !== void 0) {
      return lib.randomBytes;
    }

    if (lib.getRandomValues !== void 0) {
      return n => {
        var bytes = new Uint8Array(n);
        lib.getRandomValues(bytes);
        return bytes;
      };
    }
  }

  return n => {
    const r = [];

    for (let i = n; i > 0; i--) {
      r.push(Math.floor(Math.random() * 256));
    }

    return r;
  };
})(); // Buffer random numbers for speed
// Reduce memory usage by decreasing this number (min 16)
// or improve speed by increasing this number (try 16384)


const BUFFER_SIZE = 4096;
/* harmony default export */ var uid = (function () {
  // Buffer some random bytes for speed
  if (buf === void 0 || bufIdx + 16 > BUFFER_SIZE) {
    bufIdx = 0;
    buf = randomBytes(BUFFER_SIZE);
  }

  const b = Array.prototype.slice.call(buf, bufIdx, bufIdx += 16);
  b[6] = b[6] & 0x0f | 0x40;
  b[8] = b[8] & 0x3f | 0x80;
  return hexBytes[b[0]] + hexBytes[b[1]] + hexBytes[b[2]] + hexBytes[b[3]] + '-' + hexBytes[b[4]] + hexBytes[b[5]] + '-' + hexBytes[b[6]] + hexBytes[b[7]] + '-' + hexBytes[b[8]] + hexBytes[b[9]] + '-' + hexBytes[b[10]] + hexBytes[b[11]] + hexBytes[b[12]] + hexBytes[b[13]] + hexBytes[b[14]] + hexBytes[b[15]];
});
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("9ac9");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/field/QField.js












function getTargetUid(val) {
  return val === void 0 ? `f_${uid()}` : val;
}

/* harmony default export */ var QField = __webpack_exports__["a"] = (vue_runtime_esm["default"].extend({
  name: 'QField',
  mixins: [dark["a" /* default */], validate, attrs["b" /* default */]],
  inheritAttrs: false,
  props: {
    label: String,
    stackLabel: Boolean,
    hint: String,
    hideHint: Boolean,
    prefix: String,
    suffix: String,
    labelColor: String,
    color: String,
    bgColor: String,
    filled: Boolean,
    outlined: Boolean,
    borderless: Boolean,
    standout: [Boolean, String],
    square: Boolean,
    loading: Boolean,
    labelSlot: Boolean,
    bottomSlots: Boolean,
    hideBottomSpace: Boolean,
    rounded: Boolean,
    dense: Boolean,
    itemAligned: Boolean,
    counter: Boolean,
    clearable: Boolean,
    clearIcon: String,
    disable: Boolean,
    readonly: Boolean,
    autofocus: Boolean,
    for: String,
    maxlength: [Number, String],
    maxValues: [Number, String] // private, do not add to JSON; internally needed by QSelect

  },

  data() {
    return {
      focused: false,
      targetUid: getTargetUid(this.for),
      // used internally by validation for QInput
      // or menu handling for QSelect
      innerLoading: false
    };
  },

  watch: {
    for(val) {
      // don't transform targetUid into a computed
      // prop as it will break SSR
      this.targetUid = getTargetUid(val);
    }

  },
  computed: {
    editable() {
      return this.disable !== true && this.readonly !== true;
    },

    hasValue() {
      const value = this.__getControl === void 0 ? this.value : this.innerValue;
      return value !== void 0 && value !== null && ('' + value).length > 0;
    },

    computedCounter() {
      if (this.counter !== false) {
        const len = typeof this.value === 'string' || typeof this.value === 'number' ? ('' + this.value).length : Array.isArray(this.value) === true ? this.value.length : 0;
        const max = this.maxlength !== void 0 ? this.maxlength : this.maxValues;
        return len + (max !== void 0 ? ' / ' + max : '');
      }
    },

    floatingLabel() {
      return this.stackLabel === true || this.focused === true || (this.inputValue !== void 0 && this.hideSelected === true ? this.inputValue.length > 0 : this.hasValue === true) || this.displayValue !== void 0 && this.displayValue !== null && ('' + this.displayValue).length > 0;
    },

    shouldRenderBottom() {
      return this.bottomSlots === true || this.hint !== void 0 || this.hasRules === true || this.counter === true || this.error !== null;
    },

    classes() {
      return {
        [this.fieldClass]: this.fieldClass !== void 0,
        [`q-field--${this.styleType}`]: true,
        'q-field--rounded': this.rounded,
        'q-field--square': this.square,
        'q-field--focused': this.focused === true,
        'q-field--highlighted': this.focused === true || this.hasError === true,
        'q-field--float': this.floatingLabel,
        'q-field--labeled': this.hasLabel,
        'q-field--dense': this.dense,
        'q-field--item-aligned q-item-type': this.itemAligned,
        'q-field--dark': this.isDark,
        'q-field--auto-height': this.__getControl === void 0,
        'q-field--with-bottom': this.hideBottomSpace !== true && this.shouldRenderBottom === true,
        'q-field--error': this.hasError,
        'q-field--readonly': this.readonly === true && this.disable !== true,
        [this.disable === true ? 'q-field--disabled' : 'q-validation-component']: true
      };
    },

    styleType() {
      if (this.filled === true) {
        return 'filled';
      }

      if (this.outlined === true) {
        return 'outlined';
      }

      if (this.borderless === true) {
        return 'borderless';
      }

      if (this.standout) {
        return 'standout';
      }

      return 'standard';
    },

    contentClass() {
      const cls = [];

      if (this.hasError === true) {
        cls.push('text-negative');
      } else if (typeof this.standout === 'string' && this.standout.length > 0 && this.focused === true) {
        return this.standout;
      } else if (this.color !== void 0) {
        cls.push('text-' + this.color);
      }

      if (this.bgColor !== void 0) {
        cls.push(`bg-${this.bgColor}`);
      }

      return cls;
    },

    hasLabel() {
      return this.labelSlot === true || this.label !== void 0;
    },

    labelClass() {
      if (this.labelColor !== void 0 && this.hasError !== true) {
        return 'text-' + this.labelColor;
      }
    },

    controlSlotScope() {
      return {
        id: this.targetUid,
        field: this.$el,
        editable: this.editable,
        focused: this.focused,
        floatingLabel: this.floatingLabel,
        value: this.value,
        emitValue: this.__emitValue
      };
    },

    attrs() {
      const attrs = {
        for: this.targetUid
      };

      if (this.disable === true) {
        attrs['aria-disabled'] = 'true';
      } else if (this.readonly === true) {
        attrs['aria-readonly'] = 'true';
      }

      return attrs;
    }

  },
  methods: {
    focus() {
      if (this.showPopup !== void 0) {
        this.showPopup();
        return;
      }

      this.__focus();
    },

    blur() {
      const el = document.activeElement; // IE can have null document.activeElement

      if (el !== null && this.$el.contains(el)) {
        el.blur();
      }
    },

    __focus() {
      const el = document.activeElement;
      let target = this.$refs.target; // IE can have null document.activeElement

      if (target !== void 0 && (el === null || el.id !== this.targetUid)) {
        target.hasAttribute('tabindex') === true || (target = target.querySelector('[tabindex]'));
        target !== null && target !== el && target.focus();
      }
    },

    __getContent(h) {
      const node = [];
      this.$scopedSlots.prepend !== void 0 && node.push(h('div', {
        staticClass: 'q-field__prepend q-field__marginal row no-wrap items-center',
        key: 'prepend',
        on: this.slotsEvents
      }, this.$scopedSlots.prepend()));
      node.push(h('div', {
        staticClass: 'q-field__control-container col relative-position row no-wrap q-anchor--skip'
      }, this.__getControlContainer(h)));
      this.$scopedSlots.append !== void 0 && node.push(h('div', {
        staticClass: 'q-field__append q-field__marginal row no-wrap items-center',
        key: 'append',
        on: this.slotsEvents
      }, this.$scopedSlots.append()));
      this.hasError === true && this.noErrorIcon === false && node.push(this.__getInnerAppendNode(h, 'error', [h(QIcon["a" /* default */], {
        props: {
          name: this.$q.iconSet.field.error,
          color: 'negative'
        }
      })]));

      if (this.loading === true || this.innerLoading === true) {
        node.push(this.__getInnerAppendNode(h, 'inner-loading-append', this.$scopedSlots.loading !== void 0 ? this.$scopedSlots.loading() : [h(QSpinner["a" /* default */], {
          props: {
            color: this.color
          }
        })]));
      } else if (this.clearable === true && this.hasValue === true && this.editable === true) {
        node.push(this.__getInnerAppendNode(h, 'inner-clearable-append', [h(QIcon["a" /* default */], {
          staticClass: 'q-field__focusable-action',
          props: {
            tag: 'button',
            name: this.clearIcon || this.$q.iconSet.field.clear
          },
          attrs: {
            tabindex: 0,
            type: 'button'
          },
          on: this.clearableEvents
        })]));
      }

      this.__getInnerAppend !== void 0 && node.push(this.__getInnerAppendNode(h, 'inner-append', this.__getInnerAppend(h)));
      this.__getControlChild !== void 0 && node.push(this.__getControlChild(h));
      return node;
    },

    __getControlContainer(h) {
      const node = [];
      this.prefix !== void 0 && this.prefix !== null && node.push(h('div', {
        staticClass: 'q-field__prefix no-pointer-events row items-center'
      }, [this.prefix]));

      if (this.hasShadow === true && this.__getShadowControl !== void 0) {
        node.push(this.__getShadowControl(h));
      }

      if (this.__getControl !== void 0) {
        node.push(this.__getControl(h));
      } // internal usage only:
      else if (this.$scopedSlots.rawControl !== void 0) {
          node.push(this.$scopedSlots.rawControl());
        } else if (this.$scopedSlots.control !== void 0) {
          node.push(h('div', {
            ref: 'target',
            staticClass: 'q-field__native row',
            attrs: objectSpread2_default()(objectSpread2_default()({}, this.qAttrs), {}, {
              'data-autofocus': this.autofocus
            })
          }, this.$scopedSlots.control(this.controlSlotScope)));
        }

      this.hasLabel === true && node.push(h('div', {
        staticClass: 'q-field__label no-pointer-events absolute ellipsis',
        class: this.labelClass
      }, [Object(slot["c" /* slot */])(this, 'label', this.label)]));
      this.suffix !== void 0 && this.suffix !== null && node.push(h('div', {
        staticClass: 'q-field__suffix no-pointer-events row items-center'
      }, [this.suffix]));
      return node.concat(this.__getDefaultSlot !== void 0 ? this.__getDefaultSlot(h) : Object(slot["c" /* slot */])(this, 'default'));
    },

    __getBottom(h) {
      let msg, key;

      if (this.hasError === true) {
        if (this.computedErrorMessage !== void 0) {
          msg = [h('div', [this.computedErrorMessage])];
          key = this.computedErrorMessage;
        } else {
          msg = Object(slot["c" /* slot */])(this, 'error');
          key = 'q--slot-error';
        }
      } else if (this.hideHint !== true || this.focused === true) {
        if (this.hint !== void 0) {
          msg = [h('div', [this.hint])];
          key = this.hint;
        } else {
          msg = Object(slot["c" /* slot */])(this, 'hint');
          key = 'q--slot-hint';
        }
      }

      const hasCounter = this.counter === true || this.$scopedSlots.counter !== void 0;

      if (this.hideBottomSpace === true && hasCounter === false && msg === void 0) {
        return;
      }

      const main = h('div', {
        key,
        staticClass: 'q-field__messages col'
      }, msg);
      return h('div', {
        staticClass: 'q-field__bottom row items-start q-field__bottom--' + (this.hideBottomSpace !== true ? 'animated' : 'stale')
      }, [this.hideBottomSpace === true ? main : h('transition', {
        props: {
          name: 'q-transition--field-message'
        }
      }, [main]), hasCounter === true ? h('div', {
        staticClass: 'q-field__counter'
      }, this.$scopedSlots.counter !== void 0 ? this.$scopedSlots.counter() : [this.computedCounter]) : null]);
    },

    __getInnerAppendNode(h, key, content) {
      return content === null ? null : h('div', {
        staticClass: 'q-field__append q-field__marginal row no-wrap items-center q-anchor--skip',
        key
      }, content);
    },

    __onControlPopupShow(e) {
      e !== void 0 && Object(utils_event["k" /* stop */])(e);
      this.$emit('popup-show', e);
      this.hasPopupOpen = true;

      this.__onControlFocusin(e);
    },

    __onControlPopupHide(e) {
      e !== void 0 && Object(utils_event["k" /* stop */])(e);
      this.$emit('popup-hide', e);
      this.hasPopupOpen = false;

      this.__onControlFocusout(e);
    },

    __onControlFocusin(e) {
      if (this.editable === true && this.focused === false) {
        this.focused = true;
        this.$emit('focus', e);
      }
    },

    __onControlFocusout(e, then) {
      clearTimeout(this.focusoutTimer);
      this.focusoutTimer = setTimeout(() => {
        if (document.hasFocus() === true && (this.hasPopupOpen === true || this.$refs === void 0 || this.$refs.control === void 0 || this.$refs.control.contains(document.activeElement) !== false)) {
          return;
        }

        if (this.focused === true) {
          this.focused = false;
          this.$emit('blur', e);
        }

        then !== void 0 && then();
      });
    },

    __clearValue(e) {
      // prevent activating the field but keep focus on desktop
      Object(utils_event["l" /* stopAndPrevent */])(e);

      if (this.$q.platform.is.mobile !== true) {
        const el = this.$refs.target || this.$el;
        el.focus();
      } else if (this.$el.contains(document.activeElement) === true) {
        document.activeElement.blur();
      }

      if (this.type === 'file') {
        // do not let focus be triggered
        // as it will make the native file dialog
        // appear for another selection
        this.$refs.input.value = null;
      }

      this.$emit('input', null);
      this.$emit('clear', this.value);
      this.$nextTick(() => {
        this.resetValidation();

        if (this.lazyRules !== 'ondemand' && this.$q.platform.is.mobile !== true) {
          this.isDirty = false;
        }
      });
    },

    __emitValue(value) {
      this.$emit('input', value);
    }

  },

  render(h) {
    this.__onPreRender !== void 0 && this.__onPreRender();
    this.__onPostRender !== void 0 && this.$nextTick(this.__onPostRender);
    return h('label', {
      staticClass: 'q-field row no-wrap items-start',
      class: this.classes,
      attrs: this.attrs
    }, [this.$scopedSlots.before !== void 0 ? h('div', {
      staticClass: 'q-field__before q-field__marginal row no-wrap items-center',
      on: this.slotsEvents
    }, this.$scopedSlots.before()) : null, h('div', {
      staticClass: 'q-field__inner relative-position col self-stretch'
    }, [h('div', {
      ref: 'control',
      staticClass: 'q-field__control relative-position row no-wrap',
      class: this.contentClass,
      attrs: {
        tabindex: -1
      },
      on: this.controlEvents
    }, this.__getContent(h)), this.shouldRenderBottom === true ? this.__getBottom(h) : null]), this.$scopedSlots.after !== void 0 ? h('div', {
      staticClass: 'q-field__after q-field__marginal row no-wrap items-center',
      on: this.slotsEvents
    }, this.$scopedSlots.after()) : null]);
  },

  created() {
    this.__onPreRender !== void 0 && this.__onPreRender();
    this.slotsEvents = {
      click: utils_event["i" /* prevent */]
    };
    this.clearableEvents = {
      click: this.__clearValue
    };
    this.controlEvents = this.__getControlEvents !== void 0 ? this.__getControlEvents() : {
      focusin: this.__onControlFocusin,
      focusout: this.__onControlFocusout,
      'popup-show': this.__onControlPopupShow,
      'popup-hide': this.__onControlPopupHide
    };
  },

  mounted() {
    if (Platform["c" /* fromSSR */] === true && this.for === void 0) {
      this.targetUid = getTargetUid();
    }

    this.autofocus === true && this.focus();
  },

  beforeDestroy() {
    clearTimeout(this.focusoutTimer);
  }

}));

/***/ }),

/***/ "b7fb":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("8bb2");
var requireObjectCoercible = __webpack_require__("730c");

// `String.prototype.{ codePointAt, at }` methods implementation
var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING ? S.charAt(position) : first
        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ "b8ba":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("f498");
var createNonEnumerableProperty = __webpack_require__("5b12");
var has = __webpack_require__("f1a7");
var setGlobal = __webpack_require__("3e34");
var inspectSource = __webpack_require__("df6f");
var InternalStateModule = __webpack_require__("cdcd");

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var state;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) {
      createNonEnumerableProperty(value, 'name', key);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});


/***/ }),

/***/ "b99b":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("d4cb");
var definePropertyModule = __webpack_require__("abdf");
var anObject = __webpack_require__("157c");
var objectKeys = __webpack_require__("0c47");

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
  return O;
};


/***/ }),

/***/ "ba53":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("6b1d");
var flattenIntoArray = __webpack_require__("e369");
var toObject = __webpack_require__("37d1");
var toLength = __webpack_require__("b495");
var toInteger = __webpack_require__("8bb2");
var arraySpeciesCreate = __webpack_require__("6a86");

// `Array.prototype.flat` method
// https://tc39.es/ecma262/#sec-array.prototype.flat
$({ target: 'Array', proto: true }, {
  flat: function flat(/* depthArg = 1 */) {
    var depthArg = arguments.length ? arguments[0] : undefined;
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});


/***/ }),

/***/ "bb1b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return noRequiredPropExampleErrorMsg; });
var noRequiredPropExampleErrorMsg = "You **must** provide an example for all _required_ props to be able to generate an interactive preview!!\nEg.\n```js\nprops: {\n  /**\n   * @type {string[]}\n   * @example ['First Tab', 'Second Tab']\n   */\n  labels: { type: Array, required: true },\n}\n```";

/***/ }),

/***/ "bb7d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_CodeBlock_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5070");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_CodeBlock_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_CodeBlock_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "bc74":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@babel/runtime/helpers/objectSpread2.js
var objectSpread2 = __webpack_require__("ca22");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2);

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue/dist/vue.runtime.esm.js
var vue_runtime_esm = __webpack_require__("9869");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/field/QField.js + 2 modules
var QField = __webpack_require__("b693");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/form.js
var mixins_form = __webpack_require__("87c8");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.string.trim.js
var es_string_trim = __webpack_require__("b55a");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.array.reduce.js
var es_array_reduce = __webpack_require__("28eb");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("9ac9");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/cache.js
var cache = __webpack_require__("6459");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/file.js





function filterFiles(files, rejectedFiles, failedPropValidation, filterFn) {
  const acceptedFiles = [];
  files.forEach(file => {
    if (filterFn(file) === true) {
      acceptedFiles.push(file);
    } else {
      rejectedFiles.push({
        failedPropValidation,
        file
      });
    }
  });
  return acceptedFiles;
}

function stopAndPreventDrag(e) {
  e && e.dataTransfer && (e.dataTransfer.dropEffect = 'copy');
  Object(utils_event["l" /* stopAndPrevent */])(e);
}

/* harmony default export */ var file = ({
  props: {
    multiple: Boolean,
    accept: String,
    capture: String,
    maxFileSize: [Number, String],
    maxTotalSize: [Number, String],
    maxFiles: [Number, String],
    filter: Function
  },
  computed: {
    extensions() {
      if (this.accept !== void 0) {
        return this.accept.split(',').map(ext => {
          ext = ext.trim();

          if (ext === '*') {
            // support "*"
            return '*/';
          } else if (ext.endsWith('/*')) {
            // support "image/*" or "*/*"
            ext = ext.slice(0, ext.length - 1);
          }

          return ext.toUpperCase();
        });
      }
    },

    maxFilesNumber() {
      return parseInt(this.maxFiles, 10);
    },

    maxTotalSizeNumber() {
      return parseInt(this.maxTotalSize, 10);
    }

  },
  methods: {
    pickFiles(e) {
      if (this.editable) {
        const input = this.__getFileInput();

        input && input.click(e);
      }
    },

    addFiles(files) {
      if (this.editable && files) {
        this.__addFiles(null, files);
      }
    },

    __processFiles(e, filesToProcess, currentFileList, append) {
      let files = Array.from(filesToProcess || e.target.files);
      const rejectedFiles = [];

      const done = () => {
        if (rejectedFiles.length > 0) {
          this.$emit('rejected', rejectedFiles);
        }
      }; // filter file types


      if (this.accept !== void 0 && this.extensions.indexOf('*/') === -1) {
        files = filterFiles(files, rejectedFiles, 'accept', file => {
          return this.extensions.some(ext => file.type.toUpperCase().startsWith(ext) || file.name.toUpperCase().endsWith(ext));
        });

        if (files.length === 0) {
          return done();
        }
      } // filter max file size


      if (this.maxFileSize !== void 0) {
        const maxFileSize = parseInt(this.maxFileSize, 10);
        files = filterFiles(files, rejectedFiles, 'max-file-size', file => {
          return file.size <= maxFileSize;
        });

        if (files.length === 0) {
          return done();
        }
      } // Cordova/iOS allows selecting multiple files even when the
      // multiple attribute is not specified. We also normalize drag'n'dropped
      // files here:


      if (this.multiple !== true) {
        files = [files[0]];
      }

      if (this.maxTotalSize !== void 0) {
        let size = append === true ? currentFileList.reduce((total, file) => total + file.size, 0) : 0;
        files = filterFiles(files, rejectedFiles, 'max-total-size', file => {
          size += file.size;
          return size <= this.maxTotalSizeNumber;
        });

        if (files.length === 0) {
          return done();
        }
      } // do we have custom filter function?


      if (typeof this.filter === 'function') {
        const filteredFiles = this.filter(files);
        files = filterFiles(files, rejectedFiles, 'filter', file => {
          return filteredFiles.includes(file);
        });
      }

      if (this.maxFiles !== void 0) {
        let filesNumber = append === true ? currentFileList.length : 0;
        files = filterFiles(files, rejectedFiles, 'max-files', () => {
          filesNumber++;
          return filesNumber <= this.maxFilesNumber;
        });

        if (files.length === 0) {
          return done();
        }
      }

      done();

      if (files.length > 0) {
        return files;
      }
    },

    __onDragOver(e) {
      stopAndPreventDrag(e);
      this.dnd !== true && (this.dnd = true);
    },

    __onDragLeave(e) {
      Object(utils_event["l" /* stopAndPrevent */])(e);
      this.dnd = false;
    },

    __onDrop(e) {
      stopAndPreventDrag(e);
      const files = e.dataTransfer.files;

      if (files.length > 0) {
        this.__addFiles(null, files);
      }

      this.dnd = false;
    },

    __getDnd(h, type) {
      if (this.dnd === true) {
        return h('div', {
          staticClass: `q-${type}__dnd absolute-full`,
          on: Object(cache["b" /* default */])(this, 'dnd', {
            dragenter: stopAndPreventDrag,
            dragover: stopAndPreventDrag,
            dragleave: this.__onDragLeave,
            drop: this.__onDrop
          })
        });
      }
    }

  }
});
const FileValueMixin = {
  computed: {
    formDomProps() {
      if (this.type !== 'file') {
        return;
      }

      try {
        const dt = 'DataTransfer' in window ? new DataTransfer() : 'ClipboardEvent' in window ? new ClipboardEvent('').clipboardData : void 0;

        if (Object(this.value) === this.value) {
          ('length' in this.value ? Array.from(this.value) : [this.value]).forEach(file => {
            dt.items.add(file);
          });
        }

        return {
          files: dt.files
        };
      } catch (e) {
        return {
          files: void 0
        };
      }
    }

  }
};
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.string.replace.js
var es_string_replace = __webpack_require__("32f5");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/web.dom-collections.iterator.js
var web_dom_collections_iterator = __webpack_require__("918c");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/key-composition.js
var key_composition = __webpack_require__("1b63");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/mask.js


 // leave NAMED_MASKS at top of file (code referenced from docs)

const NAMED_MASKS = {
  date: '####/##/##',
  datetime: '####/##/## ##:##',
  time: '##:##',
  fulltime: '##:##:##',
  phone: '(###) ### - ####',
  card: '#### #### #### ####'
};
const TOKENS = {
  '#': {
    pattern: '[\\d]',
    negate: '[^\\d]'
  },
  S: {
    pattern: '[a-zA-Z]',
    negate: '[^a-zA-Z]'
  },
  N: {
    pattern: '[0-9a-zA-Z]',
    negate: '[^0-9a-zA-Z]'
  },
  A: {
    pattern: '[a-zA-Z]',
    negate: '[^a-zA-Z]',
    transform: v => v.toLocaleUpperCase()
  },
  a: {
    pattern: '[a-zA-Z]',
    negate: '[^a-zA-Z]',
    transform: v => v.toLocaleLowerCase()
  },
  X: {
    pattern: '[0-9a-zA-Z]',
    negate: '[^0-9a-zA-Z]',
    transform: v => v.toLocaleUpperCase()
  },
  x: {
    pattern: '[0-9a-zA-Z]',
    negate: '[^0-9a-zA-Z]',
    transform: v => v.toLocaleLowerCase()
  }
};
const KEYS = Object.keys(TOKENS);
KEYS.forEach(key => {
  TOKENS[key].regex = new RegExp(TOKENS[key].pattern);
});
const tokenRegexMask = new RegExp('\\\\([^.*+?^${}()|([\\]])|([.*+?^${}()|[\\]])|([' + KEYS.join('') + '])|(.)', 'g'),
      escRegex = /[.*+?^${}()|[\]\\]/g;
const MARKER = String.fromCharCode(1);
/* harmony default export */ var mask = ({
  props: {
    mask: String,
    reverseFillMask: Boolean,
    fillMask: [Boolean, String],
    unmaskedValue: Boolean
  },
  watch: {
    type() {
      this.__updateMaskInternals();
    },

    mask(v) {
      if (v !== void 0) {
        this.__updateMaskValue(this.innerValue, true);
      } else {
        const val = this.__unmask(this.innerValue);

        this.__updateMaskInternals();

        this.value !== val && this.$emit('input', val);
      }
    },

    fillMask() {
      this.hasMask === true && this.__updateMaskValue(this.innerValue, true);
    },

    reverseFillMask() {
      this.hasMask === true && this.__updateMaskValue(this.innerValue, true);
    },

    unmaskedValue() {
      this.hasMask === true && this.__updateMaskValue(this.innerValue);
    }

  },
  methods: {
    __getInitialMaskedValue() {
      this.__updateMaskInternals();

      if (this.hasMask === true) {
        const masked = this.__mask(this.__unmask(this.value));

        return this.fillMask !== false ? this.__fillWithMask(masked) : masked;
      }

      return this.value;
    },

    __getPaddedMaskMarked(size) {
      if (size < this.maskMarked.length) {
        return this.maskMarked.slice(-size);
      }

      let maskMarked = this.maskMarked,
          pad = '';
      const padPos = maskMarked.indexOf(MARKER);

      if (padPos > -1) {
        for (let i = size - maskMarked.length; i > 0; i--) {
          pad += MARKER;
        }

        maskMarked = maskMarked.slice(0, padPos) + pad + maskMarked.slice(padPos);
      }

      return maskMarked;
    },

    __updateMaskInternals() {
      this.hasMask = this.mask !== void 0 && this.mask.length > 0 && ['text', 'search', 'url', 'tel', 'password'].includes(this.type);

      if (this.hasMask === false) {
        this.computedUnmask = void 0;
        this.maskMarked = '';
        this.maskReplaced = '';
        return;
      }

      const computedMask = NAMED_MASKS[this.mask] === void 0 ? this.mask : NAMED_MASKS[this.mask],
            fillChar = typeof this.fillMask === 'string' && this.fillMask.length > 0 ? this.fillMask.slice(0, 1) : '_',
            fillCharEscaped = fillChar.replace(escRegex, '\\$&'),
            unmask = [],
            extract = [],
            mask = [];
      let firstMatch = this.reverseFillMask === true,
          unmaskChar = '',
          negateChar = '';
      computedMask.replace(tokenRegexMask, (_, char1, esc, token, char2) => {
        if (token !== void 0) {
          const c = TOKENS[token];
          mask.push(c);
          negateChar = c.negate;

          if (firstMatch === true) {
            extract.push('(?:' + negateChar + '+)?(' + c.pattern + '+)?(?:' + negateChar + '+)?(' + c.pattern + '+)?');
            firstMatch = false;
          }

          extract.push('(?:' + negateChar + '+)?(' + c.pattern + ')?');
        } else if (esc !== void 0) {
          unmaskChar = '\\' + (esc === '\\' ? '' : esc);
          mask.push(esc);
          unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?');
        } else {
          const c = char1 !== void 0 ? char1 : char2;
          unmaskChar = c === '\\' ? '\\\\\\\\' : c.replace(escRegex, '\\\\$&');
          mask.push(c);
          unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?');
        }
      });
      const unmaskMatcher = new RegExp('^' + unmask.join('') + '(' + (unmaskChar === '' ? '.' : '[^' + unmaskChar + ']') + '+)?' + '$'),
            extractLast = extract.length - 1,
            extractMatcher = extract.map((re, index) => {
        if (index === 0 && this.reverseFillMask === true) {
          return new RegExp('^' + fillCharEscaped + '*' + re);
        } else if (index === extractLast) {
          return new RegExp('^' + re + '(' + (negateChar === '' ? '.' : negateChar) + '+)?' + (this.reverseFillMask === true ? '$' : fillCharEscaped + '*'));
        }

        return new RegExp('^' + re);
      });
      this.computedMask = mask;

      this.computedUnmask = val => {
        const unmaskMatch = unmaskMatcher.exec(val);

        if (unmaskMatch !== null) {
          val = unmaskMatch.slice(1).join('');
        }

        const extractMatch = [],
              extractMatcherLength = extractMatcher.length;

        for (let i = 0, str = val; i < extractMatcherLength; i++) {
          const m = extractMatcher[i].exec(str);

          if (m === null) {
            break;
          }

          str = str.slice(m.shift().length);
          extractMatch.push(...m);
        }

        if (extractMatch.length > 0) {
          return extractMatch.join('');
        }

        return val;
      };

      this.maskMarked = mask.map(v => typeof v === 'string' ? v : MARKER).join('');
      this.maskReplaced = this.maskMarked.split(MARKER).join(fillChar);
    },

    __updateMaskValue(rawVal, updateMaskInternals, inputType) {
      const inp = this.$refs.input,
            end = inp.selectionEnd,
            endReverse = inp.value.length - end,
            unmasked = this.__unmask(rawVal); // Update here so unmask uses the original fillChar


      updateMaskInternals === true && this.__updateMaskInternals();

      const preMasked = this.__mask(unmasked),
            masked = this.fillMask !== false ? this.__fillWithMask(preMasked) : preMasked,
            changed = this.innerValue !== masked; // We want to avoid "flickering" so we set value immediately


      inp.value !== masked && (inp.value = masked);
      changed === true && (this.innerValue = masked);
      document.activeElement === inp && this.$nextTick(() => {
        if (masked === this.maskReplaced) {
          const cursor = this.reverseFillMask === true ? this.maskReplaced.length : 0;
          inp.setSelectionRange(cursor, cursor, 'forward');
          return;
        }

        if (inputType === 'insertFromPaste' && this.reverseFillMask !== true) {
          const cursor = end - 1;

          this.__moveCursorRight(inp, cursor, cursor);

          return;
        }

        if (['deleteContentBackward', 'deleteContentForward'].indexOf(inputType) > -1) {
          const cursor = this.reverseFillMask === true ? Math.max(0, masked.length - (masked === this.maskReplaced ? 0 : Math.min(preMasked.length, endReverse) + 1)) + 1 : end;
          inp.setSelectionRange(cursor, cursor, 'forward');
          return;
        }

        if (this.reverseFillMask === true) {
          if (changed === true) {
            const cursor = Math.max(0, masked.length - (masked === this.maskReplaced ? 0 : Math.min(preMasked.length, endReverse + 1)));

            this.__moveCursorRightReverse(inp, cursor, cursor);
          } else {
            const cursor = masked.length - endReverse;
            inp.setSelectionRange(cursor, cursor, 'backward');
          }
        } else {
          if (changed === true) {
            const cursor = Math.max(0, this.maskMarked.indexOf(MARKER), Math.min(preMasked.length, end) - 1);

            this.__moveCursorRight(inp, cursor, cursor);
          } else {
            const cursor = end - 1;

            this.__moveCursorRight(inp, cursor, cursor);
          }
        }
      });
      const val = this.unmaskedValue === true ? this.__unmask(masked) : masked;
      this.value !== val && this.__emitValue(val, true);
    },

    __moveCursorForPaste(inp, start, end) {
      const preMasked = this.__mask(this.__unmask(inp.value));

      start = Math.max(0, this.maskMarked.indexOf(MARKER), Math.min(preMasked.length, start));
      inp.setSelectionRange(start, end, 'forward');
    },

    __moveCursorLeft(inp, start, end, selection) {
      const noMarkBefore = this.maskMarked.slice(start - 1).indexOf(MARKER) === -1;
      let i = Math.max(0, start - 1);

      for (; i >= 0; i--) {
        if (this.maskMarked[i] === MARKER) {
          start = i;
          noMarkBefore === true && start++;
          break;
        }
      }

      if (i < 0 && this.maskMarked[start] !== void 0 && this.maskMarked[start] !== MARKER) {
        return this.__moveCursorRight(inp, 0, 0);
      }

      start >= 0 && inp.setSelectionRange(start, selection === true ? end : start, 'backward');
    },

    __moveCursorRight(inp, start, end, selection) {
      const limit = inp.value.length;
      let i = Math.min(limit, end + 1);

      for (; i <= limit; i++) {
        if (this.maskMarked[i] === MARKER) {
          end = i;
          break;
        } else if (this.maskMarked[i - 1] === MARKER) {
          end = i;
        }
      }

      if (i > limit && this.maskMarked[end - 1] !== void 0 && this.maskMarked[end - 1] !== MARKER) {
        return this.__moveCursorLeft(inp, limit, limit);
      }

      inp.setSelectionRange(selection ? start : end, end, 'forward');
    },

    __moveCursorLeftReverse(inp, start, end, selection) {
      const maskMarked = this.__getPaddedMaskMarked(inp.value.length);

      let i = Math.max(0, start - 1);

      for (; i >= 0; i--) {
        if (maskMarked[i - 1] === MARKER) {
          start = i;
          break;
        } else if (maskMarked[i] === MARKER) {
          start = i;

          if (i === 0) {
            break;
          }
        }
      }

      if (i < 0 && maskMarked[start] !== void 0 && maskMarked[start] !== MARKER) {
        return this.__moveCursorRightReverse(inp, 0, 0);
      }

      start >= 0 && inp.setSelectionRange(start, selection === true ? end : start, 'backward');
    },

    __moveCursorRightReverse(inp, start, end, selection) {
      const limit = inp.value.length,
            maskMarked = this.__getPaddedMaskMarked(limit),
            noMarkBefore = maskMarked.slice(0, end + 1).indexOf(MARKER) === -1;

      let i = Math.min(limit, end + 1);

      for (; i <= limit; i++) {
        if (maskMarked[i - 1] === MARKER) {
          end = i;
          end > 0 && noMarkBefore === true && end--;
          break;
        }
      }

      if (i > limit && maskMarked[end - 1] !== void 0 && maskMarked[end - 1] !== MARKER) {
        return this.__moveCursorLeftReverse(inp, limit, limit);
      }

      inp.setSelectionRange(selection === true ? start : end, end, 'forward');
    },

    __onMaskedKeydown(e) {
      if (Object(key_composition["c" /* shouldIgnoreKey */])(e) === true) {
        return;
      }

      const inp = this.$refs.input,
            start = inp.selectionStart,
            end = inp.selectionEnd;

      if (e.keyCode === 37 || e.keyCode === 39) {
        // Left / Right
        const fn = this['__moveCursor' + (e.keyCode === 39 ? 'Right' : 'Left') + (this.reverseFillMask === true ? 'Reverse' : '')];
        e.preventDefault();
        fn(inp, start, end, e.shiftKey);
      } else if (e.keyCode === 8 && // Backspace
      this.reverseFillMask !== true && start === end) {
        this.__moveCursorLeft(inp, start, end, true);
      } else if (e.keyCode === 46 && // Delete
      this.reverseFillMask === true && start === end) {
        this.__moveCursorRightReverse(inp, start, end, true);
      }

      this.$emit('keydown', e);
    },

    __mask(val) {
      if (val === void 0 || val === null || val === '') {
        return '';
      }

      if (this.reverseFillMask === true) {
        return this.__maskReverse(val);
      }

      const mask = this.computedMask;
      let valIndex = 0,
          output = '';

      for (let maskIndex = 0; maskIndex < mask.length; maskIndex++) {
        const valChar = val[valIndex],
              maskDef = mask[maskIndex];

        if (typeof maskDef === 'string') {
          output += maskDef;
          valChar === maskDef && valIndex++;
        } else if (valChar !== void 0 && maskDef.regex.test(valChar)) {
          output += maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar;
          valIndex++;
        } else {
          return output;
        }
      }

      return output;
    },

    __maskReverse(val) {
      const mask = this.computedMask,
            firstTokenIndex = this.maskMarked.indexOf(MARKER);
      let valIndex = val.length - 1,
          output = '';

      for (let maskIndex = mask.length - 1; maskIndex >= 0; maskIndex--) {
        const maskDef = mask[maskIndex];
        let valChar = val[valIndex];

        if (typeof maskDef === 'string') {
          output = maskDef + output;
          valChar === maskDef && valIndex--;
        } else if (valChar !== void 0 && maskDef.regex.test(valChar)) {
          do {
            output = (maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar) + output;
            valIndex--;
            valChar = val[valIndex]; // eslint-disable-next-line no-unmodified-loop-condition
          } while (firstTokenIndex === maskIndex && valChar !== void 0 && maskDef.regex.test(valChar));
        } else {
          return output;
        }
      }

      return output;
    },

    __unmask(val) {
      return typeof val !== 'string' || this.computedUnmask === void 0 ? typeof val === 'number' ? this.computedUnmask('' + val) : val : this.computedUnmask(val);
    },

    __fillWithMask(val) {
      if (this.maskReplaced.length - val.length <= 0) {
        return val;
      }

      return this.reverseFillMask === true && val.length > 0 ? this.maskReplaced.slice(0, -val.length) + val : val + this.maskReplaced.slice(val.length);
    }

  }
});
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/composition.js
var composition = __webpack_require__("c2ad");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/listeners.js
var listeners = __webpack_require__("0fb0");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/input/QInput.js









/* harmony default export */ var QInput = __webpack_exports__["a"] = (vue_runtime_esm["default"].extend({
  name: 'QInput',
  mixins: [QField["a" /* default */], mask, composition["a" /* default */], mixins_form["a" /* FormFieldMixin */], FileValueMixin, listeners["a" /* default */]],
  props: {
    value: {
      required: false
    },
    shadowText: String,
    type: {
      type: String,
      default: 'text'
    },
    debounce: [String, Number],
    autogrow: Boolean,
    // makes a textarea
    inputClass: [Array, String, Object],
    inputStyle: [Array, String, Object]
  },
  watch: {
    value(v) {
      if (this.hasMask === true) {
        if (this.stopValueWatcher === true) {
          this.stopValueWatcher = false;
          return;
        }

        this.__updateMaskValue(v);
      } else if (this.innerValue !== v) {
        this.innerValue = v;

        if (this.type === 'number' && this.hasOwnProperty('tempValue') === true) {
          if (this.typedNumber === true) {
            this.typedNumber = false;
          } else {
            delete this.tempValue;
          }
        }
      } // textarea only


      this.autogrow === true && this.$nextTick(this.__adjustHeight);
    },

    autogrow(autogrow) {
      // textarea only
      if (autogrow === true) {
        this.$nextTick(this.__adjustHeight);
      } // if it has a number of rows set respect it
      else if (this.qAttrs.rows > 0 && this.$refs.input !== void 0) {
          const inp = this.$refs.input;
          inp.style.height = 'auto';
        }
    },

    dense() {
      this.autogrow === true && this.$nextTick(this.__adjustHeight);
    }

  },

  data() {
    return {
      innerValue: this.__getInitialMaskedValue()
    };
  },

  computed: {
    isTextarea() {
      return this.type === 'textarea' || this.autogrow === true;
    },

    fieldClass() {
      return `q-${this.isTextarea === true ? 'textarea' : 'input'}` + (this.autogrow === true ? ' q-textarea--autogrow' : '');
    },

    hasShadow() {
      return this.type !== 'file' && typeof this.shadowText === 'string' && this.shadowText.length > 0;
    },

    onEvents() {
      const on = objectSpread2_default()(objectSpread2_default()({}, this.qListeners), {}, {
        input: this.__onInput,
        paste: this.__onPaste,
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        change: this.__onChange,
        blur: this.__onFinishEditing,
        focus: utils_event["k" /* stop */]
      });

      on.compositionstart = on.compositionupdate = on.compositionend = this.__onComposition;

      if (this.hasMask === true) {
        on.keydown = this.__onMaskedKeydown;
      }

      if (this.autogrow === true) {
        on.animationend = this.__adjustHeight;
      }

      return on;
    },

    inputAttrs() {
      const attrs = objectSpread2_default()(objectSpread2_default()({
        tabindex: 0,
        'data-autofocus': this.autofocus,
        rows: this.type === 'textarea' ? 6 : void 0,
        'aria-label': this.label,
        name: this.nameProp
      }, this.qAttrs), {}, {
        id: this.targetUid,
        type: this.type,
        maxlength: this.maxlength,
        disabled: this.disable === true,
        readonly: this.readonly === true
      });

      if (this.autogrow === true) {
        attrs.rows = 1;
      }

      return attrs;
    }

  },
  methods: {
    focus() {
      const el = document.activeElement;

      if (this.$refs.input !== void 0 && this.$refs.input !== el && ( // IE can have null document.activeElement
      el === null || el.id !== this.targetUid)) {
        this.$refs.input.focus();
      }
    },

    select() {
      this.$refs.input !== void 0 && this.$refs.input.select();
    },

    __onPaste(e) {
      if (this.hasMask === true && this.reverseFillMask !== true) {
        const inp = e.target;

        this.__moveCursorForPaste(inp, inp.selectionStart, inp.selectionEnd);
      }

      this.$emit('paste', e);
    },

    __onInput(e) {
      if (!e || !e.target || e.target.composing === true) {
        return;
      }

      if (this.type === 'file') {
        this.$emit('input', e.target.files);
        return;
      }

      const val = e.target.value;

      if (this.hasMask === true) {
        this.__updateMaskValue(val, false, e.inputType);
      } else {
        this.__emitValue(val);

        if (['text', 'search', 'url', 'tel', 'password'].includes(this.type) && e.target === document.activeElement) {
          const index = e.target.selectionEnd;
          index !== void 0 && this.$nextTick(() => {
            if (e.target === document.activeElement && val.indexOf(e.target.value) === 0) {
              e.target.setSelectionRange(index, index);
            }
          });
        }
      } // we need to trigger it immediately too,
      // to avoid "flickering"


      this.autogrow === true && this.__adjustHeight();
    },

    __emitValue(val, stopWatcher) {
      this.emitValueFn = () => {
        if (this.type !== 'number' && this.hasOwnProperty('tempValue') === true) {
          delete this.tempValue;
        }

        if (this.value !== val && this.emitCachedValue !== val) {
          this.emitCachedValue = val;
          stopWatcher === true && (this.stopValueWatcher = true);
          this.$emit('input', val);
          this.$nextTick(() => {
            this.emitCachedValue === val && (this.emitCachedValue = NaN);
          });
        }

        this.emitValueFn = void 0;
      };

      if (this.type === 'number') {
        this.typedNumber = true;
        this.tempValue = val;
      }

      if (this.debounce !== void 0) {
        clearTimeout(this.emitTimer);
        this.tempValue = val;
        this.emitTimer = setTimeout(this.emitValueFn, this.debounce);
      } else {
        this.emitValueFn();
      }
    },

    // textarea only
    __adjustHeight() {
      const inp = this.$refs.input;

      if (inp !== void 0) {
        const parentStyle = inp.parentNode.style; // reset height of textarea to a small size to detect the real height
        // but keep the total control size the same

        parentStyle.marginBottom = inp.scrollHeight - 1 + 'px';
        inp.style.height = '1px';
        inp.style.height = inp.scrollHeight + 'px';
        parentStyle.marginBottom = '';
      }
    },

    __onChange(e) {
      this.__onComposition(e);

      clearTimeout(this.emitTimer);
      this.emitValueFn !== void 0 && this.emitValueFn();
      this.$emit('change', e);
    },

    __onFinishEditing(e) {
      e !== void 0 && Object(utils_event["k" /* stop */])(e);
      clearTimeout(this.emitTimer);
      this.emitValueFn !== void 0 && this.emitValueFn();
      this.typedNumber = false;
      this.stopValueWatcher = false;
      delete this.tempValue; // we need to use setTimeout instead of this.$nextTick
      // to avoid a bug where focusout is not emitted for type date/time/week/...

      this.type !== 'file' && setTimeout(() => {
        if (this.$refs.input !== void 0) {
          this.$refs.input.value = this.innerValue !== void 0 ? this.innerValue : '';
        }
      });
    },

    __getCurValue() {
      return this.hasOwnProperty('tempValue') === true ? this.tempValue : this.innerValue !== void 0 ? this.innerValue : '';
    },

    __getShadowControl(h) {
      return h('div', {
        staticClass: 'q-field__native q-field__shadow absolute-bottom no-pointer-events' + (this.isTextarea === true ? '' : ' text-no-wrap')
      }, [h('span', {
        staticClass: 'invisible'
      }, this.__getCurValue()), h('span', this.shadowText)]);
    },

    __getControl(h) {
      return h(this.isTextarea === true ? 'textarea' : 'input', {
        ref: 'input',
        staticClass: 'q-field__native q-placeholder',
        style: this.inputStyle,
        class: this.inputClass,
        attrs: this.inputAttrs,
        on: this.onEvents,
        domProps: this.type !== 'file' ? {
          value: this.__getCurValue()
        } : this.formDomProps
      });
    }

  },

  created() {
    this.emitCachedValue = NaN;
  },

  mounted() {
    // textarea only
    this.autogrow === true && this.__adjustHeight();
  },

  beforeDestroy() {
    this.__onFinishEditing();
  }

}));

/***/ }),

/***/ "bd10":
/***/ (function(module, exports) {

// eslint-disable-next-line es/no-typed-arrays -- safe
module.exports = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';


/***/ }),

/***/ "be73":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ApiComponentExample_vue_vue_type_style_index_0_id_5526b82d_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("2746");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ApiComponentExample_vue_vue_type_style_index_0_id_5526b82d_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ApiComponentExample_vue_vue_type_style_index_0_id_5526b82d_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "be96":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "c053":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("6b1d");
var isArray = __webpack_require__("c6de");

var nativeReverse = [].reverse;
var test = [1, 2];

// `Array.prototype.reverse` method
// https://tc39.es/ecma262/#sec-array.prototype.reverse
// fix for Safari 12.0 bug
// https://bugs.webkit.org/show_bug.cgi?id=188794
$({ target: 'Array', proto: true, forced: String(test) === String(test.reverse()) }, {
  reverse: function reverse() {
    // eslint-disable-next-line no-self-assign -- dirty hack
    if (isArray(this)) this.length = this.length;
    return nativeReverse.call(this);
  }
});


/***/ }),

/***/ "c1a2":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-proto -- safe */
var anObject = __webpack_require__("157c");
var aPossiblePrototype = __webpack_require__("f3e4");

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "c29f":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_Markdown_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("047a");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_Markdown_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_Markdown_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "c2ad":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const isJapanese = /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/;
const isChinese = /(?:[\u3300-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\uFE30-\uFE4F]|[\uD840-\uD868\uD86A-\uD872][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD873[\uDC00-\uDEAF]|\uD87E[\uDC00-\uDE1F])/;
const isKorean = /[\u3131-\u314e\u314f-\u3163\uac00-\ud7a3]/;
/* harmony default export */ __webpack_exports__["a"] = ({
  methods: {
    __onComposition(e) {
      if (e.type === 'compositionend' || e.type === 'change') {
        if (e.target.composing !== true) {
          return;
        }

        e.target.composing = false;

        this.__onInput(e);
      } else if (e.type === 'compositionupdate') {
        if (typeof e.data === 'string' && isJapanese.test(e.data) === false && isChinese.test(e.data) === false && isKorean.test(e.data) === false) {
          e.target.composing = false;
        }
      } else {
        e.target.composing = true;
      }
    }

  }
});

/***/ }),

/***/ "c3cf":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/install.js + 3 modules
var install = __webpack_require__("7cad");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/package.json
var quasar_package = __webpack_require__("429f");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/lang.js
var lang = __webpack_require__("cfa7");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/icon-set.js
var icon_set = __webpack_require__("e57e");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@babel/runtime/helpers/objectSpread2.js
var objectSpread2 = __webpack_require__("ca22");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2);

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/ssr-update.js


const mixin = {
  mounted() {
    install["c" /* queues */].takeover.forEach(run => {
      run(this.$q);
    });
  }

};
/* harmony default export */ var ssr_update = (function (ctx) {
  if (ctx.ssr) {
    const q = objectSpread2_default()(objectSpread2_default()({}, install["a" /* $q */]), {}, {
      ssrContext: ctx.ssr
    });

    Object.assign(ctx.ssr, {
      Q_HEAD_TAGS: '',
      Q_BODY_ATTRS: '',
      Q_BODY_TAGS: ''
    });
    ctx.app.$q = ctx.ssr.$q = q;
    install["c" /* queues */].server.forEach(run => {
      run(q, ctx);
    });
  } else {
    const mixins = ctx.app.mixins || [];

    if (mixins.includes(mixin) === false) {
      ctx.app.mixins = mixins.concat(mixin);
    }
  }
});
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/vue-plugin.js





/* harmony default export */ var vue_plugin = __webpack_exports__["a"] = ({
  version: quasar_package["a" /* version */],
  install: install["b" /* default */],
  lang: lang["a" /* default */],
  iconSet: icon_set["a" /* default */],
  ssrUpdate: ssr_update
});

/***/ }),

/***/ "c465":
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
   true ? factory(exports, __webpack_require__("9869")) :
  undefined;
}(this, (function (exports, Vue) { 'use strict';

  Vue = Vue && Object.prototype.hasOwnProperty.call(Vue, 'default') ? Vue['default'] : Vue;

  var toString = function (x) { return Object.prototype.toString.call(x); };
  function isNative(Ctor) {
      return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
  }
  var hasSymbol = typeof Symbol !== 'undefined' &&
      isNative(Symbol) &&
      typeof Reflect !== 'undefined' &&
      isNative(Reflect.ownKeys);
  var noopFn = function (_) { return _; };
  var sharedPropertyDefinition = {
      enumerable: true,
      configurable: true,
      get: noopFn,
      set: noopFn,
  };
  function proxy(target, key, _a) {
      var get = _a.get, set = _a.set;
      sharedPropertyDefinition.get = get || noopFn;
      sharedPropertyDefinition.set = set || noopFn;
      Object.defineProperty(target, key, sharedPropertyDefinition);
  }
  function def(obj, key, val, enumerable) {
      Object.defineProperty(obj, key, {
          value: val,
          enumerable: !!enumerable,
          writable: true,
          configurable: true,
      });
  }
  function hasOwn(obj, key) {
      return Object.hasOwnProperty.call(obj, key);
  }
  function assert(condition, msg) {
      if (!condition)
          throw new Error("[vue-composition-api] " + msg);
  }
  function isArray(x) {
      return Array.isArray(x);
  }
  function isPlainObject(x) {
      return toString(x) === '[object Object]';
  }
  function isFunction(x) {
      return typeof x === 'function';
  }
  function warn(msg, vm) {
      Vue.util.warn(msg, vm);
  }
  function logError(err, vm, info) {
      {
          warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
      }
      if (typeof window !== 'undefined' && typeof console !== 'undefined') {
          console.error(err);
      }
      else {
          throw err;
      }
  }

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  var __assign = function() {
      __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };

  function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
          next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }

  function __read(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      }
      catch (error) { e = { error: error }; }
      finally {
          try {
              if (r && !r.done && (m = i["return"])) m.call(i);
          }
          finally { if (e) throw e.error; }
      }
      return ar;
  }

  function __spread() {
      for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
      return ar;
  }

  var currentVue = null;
  var currentVM = null;
  function getCurrentVue() {
      {
          assert(currentVue, "must call Vue.use(plugin) before using any function.");
      }
      return currentVue;
  }
  function setCurrentVue(vue) {
      currentVue = vue;
  }
  function getCurrentVM() {
      return currentVM;
  }
  function setCurrentVM(vm) {
      currentVM = vm;
  }

  function currentVMInFn(hook) {
      var vm = getCurrentVM();
      if ( !vm) {
          warn(hook + " is called when there is no active component instance to be " +
              "associated with. " +
              "Lifecycle injection APIs can only be used during execution of setup().");
      }
      return vm;
  }
  function defineComponentInstance(Ctor, options) {
      if (options === void 0) { options = {}; }
      var silent = Ctor.config.silent;
      Ctor.config.silent = true;
      var vm = new Ctor(options);
      Ctor.config.silent = silent;
      return vm;
  }
  function isComponentInstance(obj) {
      return currentVue && obj instanceof currentVue;
  }
  function createSlotProxy(vm, slotName) {
      return function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (!vm.$scopedSlots[slotName]) {
              return warn("slots." + slotName + "() got called outside of the \"render()\" scope", vm);
          }
          return vm.$scopedSlots[slotName].apply(vm, args);
      };
  }
  function resolveSlots(slots, normalSlots) {
      var res;
      if (!slots) {
          res = {};
      }
      else if (slots._normalized) {
          // fast path 1: child component re-render only, parent did not change
          return slots._normalized;
      }
      else {
          res = {};
          for (var key in slots) {
              if (slots[key] && key[0] !== '$') {
                  res[key] = true;
              }
          }
      }
      // expose normal slots on scopedSlots
      for (var key in normalSlots) {
          if (!(key in res)) {
              res[key] = true;
          }
      }
      return res;
  }

  function createSymbol(name) {
      return hasSymbol ? Symbol.for(name) : name;
  }
  var WatcherPreFlushQueueKey = createSymbol('vfa.key.preFlushQueue');
  var WatcherPostFlushQueueKey = createSymbol('vfa.key.postFlushQueue');
  var AccessControlIdentifierKey = createSymbol('vfa.key.accessControlIdentifier');
  var ReactiveIdentifierKey = createSymbol('vfa.key.reactiveIdentifier');
  var RawIdentifierKey = createSymbol('vfa.key.rawIdentifierKey');
  // must be a string, symbol key is ignored in reactive
  var RefKey = 'vfa.key.refKey';

  var RefImpl = /** @class */ (function () {
      function RefImpl(_a) {
          var get = _a.get, set = _a.set;
          proxy(this, 'value', {
              get: get,
              set: set,
          });
      }
      return RefImpl;
  }());
  function createRef(options) {
      // seal the ref, this could prevent ref from being observed
      // It's safe to seal the ref, since we really shouldn't extend it.
      // related issues: #79
      return Object.seal(new RefImpl(options));
  }
  function ref(raw) {
      var _a;
      if (isRef(raw)) {
          return raw;
      }
      var value = reactive((_a = {}, _a[RefKey] = raw, _a));
      return createRef({
          get: function () { return value[RefKey]; },
          set: function (v) { return (value[RefKey] = v); },
      });
  }
  function isRef(value) {
      return value instanceof RefImpl;
  }
  function unref(ref) {
      return isRef(ref) ? ref.value : ref;
  }
  function toRefs(obj) {
      if (!isPlainObject(obj))
          return obj;
      if ( !isReactive(obj)) {
          warn("toRefs() expects a reactive object but received a plain one.");
      }
      var ret = {};
      for (var key in obj) {
          ret[key] = toRef(obj, key);
      }
      return ret;
  }
  function toRef(object, key) {
      var v = object[key];
      if (isRef(v))
          return v;
      return createRef({
          get: function () { return object[key]; },
          set: function (v) { return (object[key] = v); },
      });
  }
  function shallowRef(raw) {
      var _a;
      if (isRef(raw)) {
          return raw;
      }
      var value = shallowReactive((_a = {}, _a[RefKey] = raw, _a));
      return createRef({
          get: function () { return value[RefKey]; },
          set: function (v) { return (value[RefKey] = v); },
      });
  }
  function triggerRef(value) {
      if (!isRef(value))
          return;
      value.value = value.value;
  }

  var AccessControlIdentifier = {};
  var ReactiveIdentifier = {};
  var RawIdentifier = {};
  function isRaw(obj) {
      return (hasOwn(obj, RawIdentifierKey) && obj[RawIdentifierKey] === RawIdentifier);
  }
  function isReactive(obj) {
      return (Object.isExtensible(obj) &&
          hasOwn(obj, ReactiveIdentifierKey) &&
          obj[ReactiveIdentifierKey] === ReactiveIdentifier);
  }
  /**
   * Proxing property access of target.
   * We can do unwrapping and other things here.
   */
  function setupAccessControl(target) {
      if (!isPlainObject(target) ||
          isRaw(target) ||
          Array.isArray(target) ||
          isRef(target) ||
          isComponentInstance(target)) {
          return;
      }
      if (hasOwn(target, AccessControlIdentifierKey) &&
          target[AccessControlIdentifierKey] === AccessControlIdentifier) {
          return;
      }
      if (Object.isExtensible(target)) {
          def(target, AccessControlIdentifierKey, AccessControlIdentifier);
      }
      var keys = Object.keys(target);
      for (var i = 0; i < keys.length; i++) {
          defineAccessControl(target, keys[i]);
      }
  }
  /**
   * Auto unwrapping when access property
   */
  function defineAccessControl(target, key, val) {
      if (key === '__ob__')
          return;
      var getter;
      var setter;
      var property = Object.getOwnPropertyDescriptor(target, key);
      if (property) {
          if (property.configurable === false) {
              return;
          }
          getter = property.get;
          setter = property.set;
          if ((!getter || setter) /* not only have getter */ &&
              arguments.length === 2) {
              val = target[key];
          }
      }
      setupAccessControl(val);
      Object.defineProperty(target, key, {
          enumerable: true,
          configurable: true,
          get: function getterHandler() {
              var value = getter ? getter.call(target) : val;
              // if the key is equal to RefKey, skip the unwrap logic
              if (key !== RefKey && isRef(value)) {
                  return value.value;
              }
              else {
                  return value;
              }
          },
          set: function setterHandler(newVal) {
              if (getter && !setter)
                  return;
              var value = getter ? getter.call(target) : val;
              // If the key is equal to RefKey, skip the unwrap logic
              // If and only if "value" is ref and "newVal" is not a ref,
              // the assignment should be proxied to "value" ref.
              if (key !== RefKey && isRef(value) && !isRef(newVal)) {
                  value.value = newVal;
              }
              else if (setter) {
                  setter.call(target, newVal);
              }
              else {
                  val = newVal;
              }
              setupAccessControl(newVal);
          },
      });
  }
  function observe(obj) {
      var Vue = getCurrentVue();
      var observed;
      if (Vue.observable) {
          observed = Vue.observable(obj);
      }
      else {
          var vm = defineComponentInstance(Vue, {
              data: {
                  $$state: obj,
              },
          });
          observed = vm._data.$$state;
      }
      return observed;
  }
  function shallowReactive(obj) {
      var e_1, _a;
      if ( !obj) {
          warn('"shallowReactive()" is called without provide an "object".');
          // @ts-ignore
          return;
      }
      if (!isPlainObject(obj) ||
          isReactive(obj) ||
          isRaw(obj) ||
          !Object.isExtensible(obj)) {
          return obj;
      }
      var observed = observe({});
      markReactive(observed, true);
      setupAccessControl(observed);
      var ob = observed.__ob__;
      var _loop_1 = function (key) {
          var val = obj[key];
          var getter;
          var setter;
          var property = Object.getOwnPropertyDescriptor(obj, key);
          if (property) {
              if (property.configurable === false) {
                  return "continue";
              }
              getter = property.get;
              setter = property.set;
              if ((!getter || setter) /* not only have getter */ &&
                  arguments_1.length === 2) {
                  val = obj[key];
              }
          }
          // setupAccessControl(val);
          Object.defineProperty(observed, key, {
              enumerable: true,
              configurable: true,
              get: function getterHandler() {
                  var value = getter ? getter.call(obj) : val;
                  ob.dep.depend();
                  return value;
              },
              set: function setterHandler(newVal) {
                  if (getter && !setter)
                      return;
                  if (setter) {
                      setter.call(obj, newVal);
                  }
                  else {
                      val = newVal;
                  }
                  ob.dep.notify();
              },
          });
      };
      var arguments_1 = arguments;
      try {
          for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
              var key = _c.value;
              _loop_1(key);
          }
      }
      catch (e_1_1) { e_1 = { error: e_1_1 }; }
      finally {
          try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          }
          finally { if (e_1) throw e_1.error; }
      }
      return observed;
  }
  function markReactive(target, shallow) {
      if (shallow === void 0) { shallow = false; }
      if (!isPlainObject(target) ||
          isRaw(target) ||
          Array.isArray(target) ||
          isRef(target) ||
          isComponentInstance(target)) {
          return;
      }
      if (hasOwn(target, ReactiveIdentifierKey) &&
          target[ReactiveIdentifierKey] === ReactiveIdentifier) {
          return;
      }
      if (Object.isExtensible(target)) {
          def(target, ReactiveIdentifierKey, ReactiveIdentifier);
      }
      if (shallow) {
          return;
      }
      var keys = Object.keys(target);
      for (var i = 0; i < keys.length; i++) {
          markReactive(target[keys[i]]);
      }
  }
  /**
   * Make obj reactivity
   */
  function reactive(obj) {
      if ( !obj) {
          warn('"reactive()" is called without provide an "object".');
          // @ts-ignore
          return;
      }
      if (!isPlainObject(obj) ||
          isReactive(obj) ||
          isRaw(obj) ||
          !Object.isExtensible(obj)) {
          return obj;
      }
      var observed = observe(obj);
      // def(obj, ReactiveIdentifierKey, ReactiveIdentifier);
      markReactive(obj);
      setupAccessControl(observed);
      return observed;
  }
  /**
   * Make sure obj can't be a reactive
   */
  function markRaw(obj) {
      if (!isPlainObject(obj) || !Object.isExtensible(obj)) {
          return obj;
      }
      // set the vue observable flag at obj
      def(obj, '__ob__', observe({}).__ob__);
      // mark as Raw
      def(obj, RawIdentifierKey, RawIdentifier);
      return obj;
  }
  function toRaw(observed) {
      if (isRaw(observe) || !Object.isExtensible(observed)) {
          return observed;
      }
      return observed.__ob__.value || observed;
  }

  function isUndef(v) {
      return v === undefined || v === null;
  }
  function isPrimitive(value) {
      return (typeof value === 'string' ||
          typeof value === 'number' ||
          // $flow-disable-line
          typeof value === 'symbol' ||
          typeof value === 'boolean');
  }
  function isValidArrayIndex(val) {
      var n = parseFloat(String(val));
      return n >= 0 && Math.floor(n) === n && isFinite(val);
  }
  /**
   * Set a property on an object. Adds the new property, triggers change
   * notification and intercept it's subsequent access if the property doesn't
   * already exist.
   */
  function set(target, key, val) {
      var Vue = getCurrentVue();
      var _a = Vue.util, warn = _a.warn, defineReactive = _a.defineReactive;
      if ( (isUndef(target) || isPrimitive(target))) {
          warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
      }
      if (isArray(target) && isValidArrayIndex(key)) {
          target.length = Math.max(target.length, key);
          target.splice(key, 1, val);
          return val;
      }
      if (key in target && !(key in Object.prototype)) {
          target[key] = val;
          return val;
      }
      var ob = target.__ob__;
      if (target._isVue || (ob && ob.vmCount)) {
          
              warn('Avoid adding reactive properties to a Vue instance or its root $data ' +
                  'at runtime - declare it upfront in the data option.');
          return val;
      }
      if (!ob) {
          target[key] = val;
          return val;
      }
      defineReactive(ob.value, key, val);
      // IMPORTANT: define access control before trigger watcher
      defineAccessControl(target, key, val);
      markReactive(ob.value[key]);
      ob.dep.notify();
      return val;
  }

  /**
   * Helper that recursively merges two data objects together.
   */
  function mergeData(from, to) {
      if (!from)
          return to;
      if (!to)
          return from;
      var key;
      var toVal;
      var fromVal;
      var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);
      for (var i = 0; i < keys.length; i++) {
          key = keys[i];
          // in case the object is already observed...
          if (key === '__ob__')
              continue;
          toVal = to[key];
          fromVal = from[key];
          if (!hasOwn(to, key)) {
              to[key] = fromVal;
          }
          else if (toVal !== fromVal &&
              isPlainObject(toVal) &&
              !isRef(toVal) &&
              isPlainObject(fromVal) &&
              !isRef(fromVal)) {
              mergeData(fromVal, toVal);
          }
      }
      return to;
  }
  function install(Vue, _install) {
      if (currentVue && currentVue === Vue) {
          {
              assert(false, 'already installed. Vue.use(plugin) should be called only once');
          }
          return;
      }
      Vue.config.optionMergeStrategies.setup = function (parent, child) {
          return function mergedSetupFn(props, context) {
              return mergeData(typeof parent === 'function' ? parent(props, context) || {} : undefined, typeof child === 'function' ? child(props, context) || {} : undefined);
          };
      };
      setCurrentVue(Vue);
      _install(Vue);
  }

  function set$1(vm, key, value) {
      var state = (vm.__secret_vfa_state__ = vm.__secret_vfa_state__ || {});
      state[key] = value;
  }
  function get(vm, key) {
      return (vm.__secret_vfa_state__ || {})[key];
  }
  var vmStateManager = {
      set: set$1,
      get: get,
  };

  function unwrapRefProxy(value, map) {
      var e_1, _a;
      if (map === void 0) { map = new WeakMap(); }
      if (map.has(value)) {
          return map.get(value);
      }
      if (isFunction(value) ||
          isArray(value) ||
          isReactive(value) ||
          !isPlainObject(value) ||
          !Object.isExtensible(value) ||
          isRef(value) ||
          isRaw(value)) {
          return value;
      }
      var obj = {};
      map.set(value, obj);
      // copy symbols over
      Object.getOwnPropertySymbols(value).forEach(function (s) { return (obj[s] = value[s]); });
      var _loop_1 = function (k) {
          var r = value[k];
          // don't process on falsy or raw
          if (!r || isRaw(r)) {
              obj[k] = r;
          }
          // if is a ref, create a proxy to retrieve the value,
          else if (isRef(r)) {
              var set = function (v) { return (r.value = v); };
              var get = function () { return r.value; };
              proxy(obj, k, { get: get, set: set });
          }
          else {
              obj[k] = unwrapRefProxy(r, map);
          }
      };
      try {
          for (var _b = __values(Object.keys(value)), _c = _b.next(); !_c.done; _c = _b.next()) {
              var k = _c.value;
              _loop_1(k);
          }
      }
      catch (e_1_1) { e_1 = { error: e_1_1 }; }
      finally {
          try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          }
          finally { if (e_1) throw e_1.error; }
      }
      return obj;
  }

  function asVmProperty(vm, propName, propValue) {
      var props = vm.$options.props;
      if (!(propName in vm) && !(props && hasOwn(props, propName))) {
          proxy(vm, propName, {
              get: function () { return propValue.value; },
              set: function (val) {
                  propValue.value = val;
              },
          });
          {
              // expose binding to Vue Devtool as a data property
              // delay this until state has been resolved to prevent repeated works
              vm.$nextTick(function () {
                  proxy(vm._data, propName, {
                      get: function () { return propValue.value; },
                      set: function (val) {
                          propValue.value = val;
                      },
                  });
              });
          }
      }
      else {
          if (props && hasOwn(props, propName)) {
              warn("The setup binding property \"" + propName + "\" is already declared as a prop.", vm);
          }
          else {
              warn("The setup binding property \"" + propName + "\" is already declared.", vm);
          }
      }
  }
  function updateTemplateRef(vm) {
      var rawBindings = vmStateManager.get(vm, 'rawBindings') || {};
      if (!rawBindings || !Object.keys(rawBindings).length)
          return;
      var refs = vm.$refs;
      var oldRefKeys = vmStateManager.get(vm, 'refs') || [];
      for (var index = 0; index < oldRefKeys.length; index++) {
          var key = oldRefKeys[index];
          var setupValue = rawBindings[key];
          if (!refs[key] && setupValue && isRef(setupValue)) {
              setupValue.value = null;
          }
      }
      var newKeys = Object.keys(refs);
      var validNewKeys = [];
      for (var index = 0; index < newKeys.length; index++) {
          var key = newKeys[index];
          var setupValue = rawBindings[key];
          if (refs[key] && setupValue && isRef(setupValue)) {
              setupValue.value = refs[key];
              validNewKeys.push(key);
          }
      }
      vmStateManager.set(vm, 'refs', validNewKeys);
  }
  function resolveScopedSlots(vm, slotsProxy) {
      var parentVode = vm.$options._parentVnode;
      if (!parentVode)
          return;
      var prevSlots = vmStateManager.get(vm, 'slots') || [];
      var curSlots = resolveSlots(parentVode.data.scopedSlots, vm.$slots);
      // remove staled slots
      for (var index = 0; index < prevSlots.length; index++) {
          var key = prevSlots[index];
          if (!curSlots[key]) {
              delete slotsProxy[key];
          }
      }
      // proxy fresh slots
      var slotNames = Object.keys(curSlots);
      for (var index = 0; index < slotNames.length; index++) {
          var key = slotNames[index];
          if (!slotsProxy[key]) {
              slotsProxy[key] = createSlotProxy(vm, key);
          }
      }
      vmStateManager.set(vm, 'slots', slotNames);
  }
  function activateCurrentInstance(vm, fn, onError) {
      var preVm = getCurrentVM();
      setCurrentVM(vm);
      try {
          return fn(vm);
      }
      catch (err) {
          if (onError) {
              onError(err);
          }
          else {
              throw err;
          }
      }
      finally {
          setCurrentVM(preVm);
      }
  }
  function mixin(Vue) {
      Vue.mixin({
          beforeCreate: functionApiInit,
          mounted: function () {
              updateTemplateRef(this);
          },
          updated: function () {
              updateTemplateRef(this);
          },
      });
      /**
       * Vuex init hook, injected into each instances init hooks list.
       */
      function functionApiInit() {
          var vm = this;
          var $options = vm.$options;
          var setup = $options.setup, render = $options.render;
          if (render) {
              // keep currentInstance accessible for createElement
              $options.render = function () {
                  var _this = this;
                  var args = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                      args[_i] = arguments[_i];
                  }
                  return activateCurrentInstance(vm, function () { return render.apply(_this, args); });
              };
          }
          if (!setup) {
              return;
          }
          if (typeof setup !== 'function') {
              {
                  warn('The "setup" option should be a function that returns a object in component definitions.', vm);
              }
              return;
          }
          var data = $options.data;
          // wrapper the data option, so we can invoke setup before data get resolved
          $options.data = function wrappedData() {
              initSetup(vm, vm.$props);
              return typeof data === 'function'
                  ? data.call(vm, vm)
                  : data || {};
          };
      }
      function initSetup(vm, props) {
          if (props === void 0) { props = {}; }
          var setup = vm.$options.setup;
          var ctx = createSetupContext(vm);
          // mark props as reactive
          markReactive(props);
          // resolve scopedSlots and slots to functions
          resolveScopedSlots(vm, ctx.slots);
          var binding;
          activateCurrentInstance(vm, function () {
              binding = setup(props, ctx);
          });
          if (!binding)
              return;
          if (isFunction(binding)) {
              // keep typescript happy with the binding type.
              var bindingFunc_1 = binding;
              // keep currentInstance accessible for createElement
              vm.$options.render = function () {
                  resolveScopedSlots(vm, ctx.slots);
                  return activateCurrentInstance(vm, function () { return bindingFunc_1(); });
              };
              return;
          }
          if (isPlainObject(binding)) {
              var bindingObj_1 = binding;
              vmStateManager.set(vm, 'rawBindings', binding);
              Object.keys(binding).forEach(function (name) {
                  var bindingValue = bindingObj_1[name];
                  // only make primitive value reactive
                  if (!isRef(bindingValue)) {
                      if (isReactive(bindingValue)) {
                          bindingValue = ref(bindingValue);
                      }
                      else {
                          // bind function to the vm, this will make `this` = vm
                          if (isFunction(bindingValue)) {
                              bindingValue = bindingValue.bind(vm);
                          }
                          // unwrap all ref properties
                          var unwrapped = unwrapRefProxy(bindingValue);
                          // mark the object as reactive
                          markReactive(unwrapped);
                          // a non-reactive should not don't get reactivity
                          bindingValue = ref(markRaw(unwrapped));
                      }
                  }
                  asVmProperty(vm, name, bindingValue);
              });
              return;
          }
          {
              assert(false, "\"setup\" must return a \"Object\" or a \"Function\", got \"" + Object.prototype.toString
                  .call(binding)
                  .slice(8, -1) + "\"");
          }
      }
      function createSetupContext(vm) {
          var ctx = {
              slots: {},
          };
          var props = [
              'root',
              'parent',
              'refs',
              'attrs',
              'listeners',
              'isServer',
              'ssrContext',
          ];
          var methodReturnVoid = ['emit'];
          props.forEach(function (key) {
              var _a;
              var targetKey;
              var srcKey;
              if (Array.isArray(key)) {
                  _a = __read(key, 2), targetKey = _a[0], srcKey = _a[1];
              }
              else {
                  targetKey = srcKey = key;
              }
              srcKey = "$" + srcKey;
              proxy(ctx, targetKey, {
                  get: function () { return vm[srcKey]; },
                  set: function () {
                      warn("Cannot assign to '" + targetKey + "' because it is a read-only property", vm);
                  },
              });
          });
          methodReturnVoid.forEach(function (key) {
              var srcKey = "$" + key;
              proxy(ctx, key, {
                  get: function () {
                      return function () {
                          var args = [];
                          for (var _i = 0; _i < arguments.length; _i++) {
                              args[_i] = arguments[_i];
                          }
                          var fn = vm[srcKey];
                          fn.apply(vm, args);
                      };
                  },
              });
          });
          return ctx;
      }
  }

  var nextTick = function nextTick() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
      }
      return currentVue === null || currentVue === void 0 ? void 0 : currentVue.nextTick.bind(this, args);
  };

  var fallbackCreateElement;
  var createElement = function createElement() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
      }
      if (!currentVM) {
          warn('`createElement()` has been called outside of render function.');
          if (!fallbackCreateElement) {
              fallbackCreateElement = defineComponentInstance(getCurrentVue())
                  .$createElement;
          }
          return fallbackCreateElement.apply(fallbackCreateElement, args);
      }
      return currentVM.$createElement.apply(currentVM, args);
  };

  // implementation, close to no-op
  function defineComponent(options) {
      return options;
  }
  var createComponent = (function (options) {
      {
          Vue.util.warn('`createComponent` has been renamed to `defineComponent`.');
      }
      return defineComponent(options);
  });

  var genName = function (name) { return "on" + (name[0].toUpperCase() + name.slice(1)); };
  function createLifeCycle(lifeCyclehook) {
      return function (callback) {
          var vm = currentVMInFn(genName(lifeCyclehook));
          if (vm) {
              injectHookOption(getCurrentVue(), vm, lifeCyclehook, callback);
          }
      };
  }
  function injectHookOption(Vue, vm, hook, val) {
      var options = vm.$options;
      var mergeFn = Vue.config.optionMergeStrategies[hook];
      options[hook] = mergeFn(options[hook], wrapHookCall(vm, val));
  }
  function wrapHookCall(vm, fn) {
      return function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          var preVm = getCurrentVM();
          setCurrentVM(vm);
          try {
              return fn.apply(void 0, __spread(args));
          }
          finally {
              setCurrentVM(preVm);
          }
      };
  }
  // export const onCreated = createLifeCycle('created');
  var onBeforeMount = createLifeCycle('beforeMount');
  var onMounted = createLifeCycle('mounted');
  var onBeforeUpdate = createLifeCycle('beforeUpdate');
  var onUpdated = createLifeCycle('updated');
  var onBeforeUnmount = createLifeCycle('beforeDestroy');
  var onUnmounted = createLifeCycle('destroyed');
  var onErrorCaptured = createLifeCycle('errorCaptured');
  var onActivated = createLifeCycle('activated');
  var onDeactivated = createLifeCycle('deactivated');
  var onServerPrefetch = createLifeCycle('serverPrefetch');

  var fallbackVM;
  function flushPreQueue() {
      flushQueue(this, WatcherPreFlushQueueKey);
  }
  function flushPostQueue() {
      flushQueue(this, WatcherPostFlushQueueKey);
  }
  function hasWatchEnv(vm) {
      return vm[WatcherPreFlushQueueKey] !== undefined;
  }
  function installWatchEnv(vm) {
      vm[WatcherPreFlushQueueKey] = [];
      vm[WatcherPostFlushQueueKey] = [];
      vm.$on('hook:beforeUpdate', flushPreQueue);
      vm.$on('hook:updated', flushPostQueue);
  }
  function getWatcherOption(options) {
      return __assign({
          immediate: false,
          deep: false,
          flush: 'post',
      }, options);
  }
  function getWatchEffectOption(options) {
      return __assign({
          immediate: true,
          deep: false,
          flush: 'post',
      }, options);
  }
  function getWatcherVM() {
      var vm = getCurrentVM();
      if (!vm) {
          if (!fallbackVM) {
              fallbackVM = defineComponentInstance(getCurrentVue());
          }
          vm = fallbackVM;
      }
      else if (!hasWatchEnv(vm)) {
          installWatchEnv(vm);
      }
      return vm;
  }
  function flushQueue(vm, key) {
      var queue = vm[key];
      for (var index = 0; index < queue.length; index++) {
          queue[index]();
      }
      queue.length = 0;
  }
  function queueFlushJob(vm, fn, mode) {
      // flush all when beforeUpdate and updated are not fired
      var fallbackFlush = function () {
          vm.$nextTick(function () {
              if (vm[WatcherPreFlushQueueKey].length) {
                  flushQueue(vm, WatcherPreFlushQueueKey);
              }
              if (vm[WatcherPostFlushQueueKey].length) {
                  flushQueue(vm, WatcherPostFlushQueueKey);
              }
          });
      };
      switch (mode) {
          case 'pre':
              fallbackFlush();
              vm[WatcherPreFlushQueueKey].push(fn);
              break;
          case 'post':
              fallbackFlush();
              vm[WatcherPostFlushQueueKey].push(fn);
              break;
          default:
              assert(false, "flush must be one of [\"post\", \"pre\", \"sync\"], but got " + mode);
              break;
      }
  }
  function createVueWatcher(vm, getter, callback, options) {
      var index = vm._watchers.length;
      // @ts-ignore: use undocumented options
      vm.$watch(getter, callback, {
          immediate: options.immediateInvokeCallback,
          deep: options.deep,
          lazy: options.noRun,
          sync: options.sync,
          before: options.before,
      });
      return vm._watchers[index];
  }
  // We have to monkeypatch the teardown function so Vue will run
  // runCleanup() when it tears down the watcher on unmmount.
  function patchWatcherTeardown(watcher, runCleanup) {
      var _teardown = watcher.teardown;
      watcher.teardown = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          _teardown.apply(watcher, args);
          runCleanup();
      };
  }
  function createWatcher(vm, source, cb, options) {
      var flushMode = options.flush;
      var isSync = flushMode === 'sync';
      var cleanup;
      var registerCleanup = function (fn) {
          cleanup = function () {
              try {
                  fn();
              }
              catch (error) {
                  logError(error, vm, 'onCleanup()');
              }
          };
      };
      // cleanup before running getter again
      var runCleanup = function () {
          if (cleanup) {
              cleanup();
              cleanup = null;
          }
      };
      var createScheduler = function (fn) {
          if (isSync ||
              /* without a current active instance, ignore pre|post mode */ vm ===
                  fallbackVM) {
              return fn;
          }
          return (function () {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
              }
              return queueFlushJob(vm, function () {
                  fn.apply(void 0, __spread(args));
              }, flushMode);
          });
      };
      // effect watch
      if (cb === null) {
          var running_1 = false;
          var getter_1 = function () {
              // preventing the watch callback being call in the same execution
              if (running_1) {
                  return;
              }
              try {
                  running_1 = true;
                  source(registerCleanup);
              }
              finally {
                  running_1 = false;
              }
          };
          var watcher_1 = createVueWatcher(vm, getter_1, noopFn, {
              deep: options.deep || false,
              sync: isSync,
              before: runCleanup,
          });
          patchWatcherTeardown(watcher_1, runCleanup);
          // enable the watcher update
          watcher_1.lazy = false;
          var originGet = watcher_1.get.bind(watcher_1);
          // always run watchEffect
          watcher_1.get = createScheduler(originGet);
          return function () {
              watcher_1.teardown();
          };
      }
      var deep = options.deep;
      var getter;
      if (Array.isArray(source)) {
          getter = function () { return source.map(function (s) { return (isRef(s) ? s.value : s()); }); };
      }
      else if (isRef(source)) {
          getter = function () { return source.value; };
      }
      else if (isReactive(source)) {
          getter = function () { return source; };
          deep = true;
      }
      else if (isFunction(source)) {
          getter = source;
      }
      else {
          getter = noopFn;
          warn("Invalid watch source: " + JSON.stringify(source) + ".\n      A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.", vm);
      }
      var applyCb = function (n, o) {
          // cleanup before running cb again
          runCleanup();
          cb(n, o, registerCleanup);
      };
      var callback = createScheduler(applyCb);
      if (options.immediate) {
          var originalCallbck_1 = callback;
          // `shiftCallback` is used to handle the first sync effect run.
          // The subsequent callbacks will redirect to `callback`.
          var shiftCallback_1 = function (n, o) {
              shiftCallback_1 = originalCallbck_1;
              applyCb(n, o);
          };
          callback = function (n, o) {
              shiftCallback_1(n, o);
          };
      }
      // @ts-ignore: use undocumented option "sync"
      var stop = vm.$watch(getter, callback, {
          immediate: options.immediate,
          deep: deep,
          sync: isSync,
      });
      // Once again, we have to hack the watcher for proper teardown
      var watcher = vm._watchers[vm._watchers.length - 1];
      patchWatcherTeardown(watcher, runCleanup);
      return function () {
          stop();
      };
  }
  function watchEffect(effect, options) {
      var opts = getWatchEffectOption(options);
      var vm = getWatcherVM();
      return createWatcher(vm, effect, null, opts);
  }
  // implementation
  function watch(source, cb, options) {
      var callback = null;
      if (typeof cb === 'function') {
          // source watch
          callback = cb;
      }
      else {
          // effect watch
          {
              warn("`watch(fn, options?)` signature has been moved to a separate API. " +
                  "Use `watchEffect(fn, options?)` instead. `watch` now only " +
                  "supports `watch(source, cb, options?) signature.");
          }
          options = cb;
          callback = null;
      }
      var opts = getWatcherOption(options);
      var vm = getWatcherVM();
      return createWatcher(vm, source, callback, opts);
  }

  // implement
  function computed(options) {
      var vm = getCurrentVM();
      var get, set;
      if (typeof options === 'function') {
          get = options;
      }
      else {
          get = options.get;
          set = options.set;
      }
      var computedHost = defineComponentInstance(getCurrentVue(), {
          computed: {
              $$state: {
                  get: get,
                  set: set,
              },
          },
      });
      vm && vm.$on('hook:destroyed', function () { return computedHost.$destroy(); });
      return createRef({
          get: function () { return computedHost.$$state; },
          set: function (v) {
              if ( !set) {
                  warn('Computed property was assigned to but it has no setter.', vm);
                  return;
              }
              computedHost.$$state = v;
          },
      });
  }

  var NOT_FOUND = {};
  function resolveInject(provideKey, vm) {
      var source = vm;
      while (source) {
          // @ts-ignore
          if (source._provided && hasOwn(source._provided, provideKey)) {
              //@ts-ignore
              return source._provided[provideKey];
          }
          source = source.$parent;
      }
      return NOT_FOUND;
  }
  function provide(key, value) {
      var vm = currentVMInFn('provide');
      if (!vm)
          return;
      if (!vm._provided) {
          var provideCache_1 = {};
          Object.defineProperty(vm, '_provided', {
              get: function () { return provideCache_1; },
              set: function (v) { return Object.assign(provideCache_1, v); },
          });
      }
      vm._provided[key] = value;
  }
  function inject(key, defaultValue) {
      if (!key) {
          return defaultValue;
      }
      var vm = getCurrentVM();
      if (vm) {
          var val = resolveInject(key, vm);
          if (val !== NOT_FOUND) {
              return val;
          }
          else {
              if (defaultValue === undefined && "development" !== 'production') {
                  warn("Injection \"" + String(key) + "\" not found", vm);
              }
              return defaultValue;
          }
      }
      else {
          warn("inject() can only be used inside setup() or functional components.");
      }
  }

  var VueCompositionAPI = {
      install: function (Vue) { return install(Vue, mixin); },
  };
  // auto install when using CDN
  if (typeof window !== 'undefined' && window.Vue) {
      window.Vue.use(VueCompositionAPI);
  }

  exports.computed = computed;
  exports.createComponent = createComponent;
  exports.createElement = createElement;
  exports.default = VueCompositionAPI;
  exports.defineComponent = defineComponent;
  exports.getCurrentInstance = getCurrentVM;
  exports.inject = inject;
  exports.isReactive = isReactive;
  exports.isRef = isRef;
  exports.markRaw = markRaw;
  exports.nextTick = nextTick;
  exports.onActivated = onActivated;
  exports.onBeforeMount = onBeforeMount;
  exports.onBeforeUnmount = onBeforeUnmount;
  exports.onBeforeUpdate = onBeforeUpdate;
  exports.onDeactivated = onDeactivated;
  exports.onErrorCaptured = onErrorCaptured;
  exports.onMounted = onMounted;
  exports.onServerPrefetch = onServerPrefetch;
  exports.onUnmounted = onUnmounted;
  exports.onUpdated = onUpdated;
  exports.provide = provide;
  exports.reactive = reactive;
  exports.ref = ref;
  exports.set = set;
  exports.shallowReactive = shallowReactive;
  exports.shallowRef = shallowRef;
  exports.toRaw = toRaw;
  exports.toRef = toRef;
  exports.toRefs = toRefs;
  exports.triggerRef = triggerRef;
  exports.unref = unref;
  exports.watch = watch;
  exports.watchEffect = watchEffect;

  Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "c607":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("f498");
var setGlobal = __webpack_require__("3e34");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ "c6de":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("6a61");

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(arg) {
  return classof(arg) == 'Array';
};


/***/ }),

/***/ "c8ed":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ca22");
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("9869");
/* harmony import */ var _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("5094");
/* harmony import */ var _resize_observer_QResizeObserver_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("df4a");
/* harmony import */ var _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("0fb0");
/* harmony import */ var _utils_slot_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("a4b3");
/* harmony import */ var _utils_event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("9ac9");
/* harmony import */ var _utils_cache_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("6459");








/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_1__["default"].extend({
  name: 'QFooter',
  mixins: [_mixins_listeners_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]],
  inject: {
    layout: {
      default() {
        console.error('QFooter needs to be child of QLayout');
      }

    }
  },
  props: {
    value: {
      type: Boolean,
      default: true
    },
    reveal: Boolean,
    bordered: Boolean,
    elevated: Boolean,
    heightHint: {
      type: [String, Number],
      default: 50
    }
  },

  data() {
    return {
      size: parseInt(this.heightHint, 10),
      revealed: true,
      windowHeight: _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_2__[/* onSSR */ "g"] || this.layout.container ? 0 : window.innerHeight
    };
  },

  watch: {
    value(val) {
      this.__update('space', val);

      this.__updateLocal('revealed', true);

      this.layout.__animate();
    },

    offset(val) {
      this.__update('offset', val);
    },

    reveal(val) {
      val === false && this.__updateLocal('revealed', this.value);
    },

    revealed(val) {
      this.layout.__animate();

      this.$emit('reveal', val);
    },

    'layout.scroll'() {
      this.__updateRevealed();
    },

    'layout.height'() {
      this.__updateRevealed();
    },

    size() {
      this.__updateRevealed();
    },

    '$q.screen.height'(val) {
      this.layout.container !== true && this.__updateLocal('windowHeight', val);
    }

  },
  computed: {
    fixed() {
      return this.reveal === true || this.layout.view.indexOf('F') > -1 || this.layout.container === true;
    },

    containerHeight() {
      return this.layout.container === true ? this.layout.containerHeight : this.windowHeight;
    },

    offset() {
      if (this.value !== true) {
        return 0;
      }

      if (this.fixed === true) {
        return this.revealed === true ? this.size : 0;
      }

      const offset = this.layout.scroll.position + this.containerHeight + this.size - this.layout.height;
      return offset > 0 ? offset : 0;
    },

    hidden() {
      return this.value !== true || this.fixed === true && this.revealed !== true;
    },

    revealOnFocus() {
      return this.value === true && this.hidden === true && this.reveal === true;
    },

    classes() {
      return (this.fixed === true ? 'fixed' : 'absolute') + '-bottom' + (this.bordered === true ? ' q-footer--bordered' : '') + (this.hidden === true ? ' q-footer--hidden' : '') + (this.value !== true ? ' q-layout--prevent-focus' : '') + (this.value !== true && this.fixed !== true ? ' hidden' : '');
    },

    style() {
      const view = this.layout.rows.bottom,
            css = {};

      if (view[0] === 'l' && this.layout.left.space === true) {
        css[this.$q.lang.rtl === true ? 'right' : 'left'] = `${this.layout.left.size}px`;
      }

      if (view[2] === 'r' && this.layout.right.space === true) {
        css[this.$q.lang.rtl === true ? 'left' : 'right'] = `${this.layout.right.size}px`;
      }

      return css;
    },

    onEvents() {
      return _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.qListeners), {}, {
        focusin: this.__onFocusin,
        input: _utils_event_js__WEBPACK_IMPORTED_MODULE_6__[/* stop */ "k"]
      });
    }

  },

  render(h) {
    const child = Object(_utils_slot_js__WEBPACK_IMPORTED_MODULE_5__[/* mergeSlot */ "a"])([h(_resize_observer_QResizeObserver_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], {
      props: {
        debounce: 0
      },
      on: Object(_utils_cache_js__WEBPACK_IMPORTED_MODULE_7__[/* default */ "b"])(this, 'resize', {
        resize: this.__onResize
      })
    })], this, 'default');
    this.elevated === true && child.push(h('div', {
      staticClass: 'q-layout__shadow absolute-full overflow-hidden no-pointer-events'
    }));
    return h('footer', {
      staticClass: 'q-footer q-layout__section--marginal',
      class: this.classes,
      style: this.style,
      on: this.onEvents
    }, child);
  },

  created() {
    this.layout.instances.footer = this;
    this.value === true && this.__update('size', this.size);

    this.__update('space', this.value);

    this.__update('offset', this.offset);
  },

  beforeDestroy() {
    if (this.layout.instances.footer === this) {
      this.layout.instances.footer = void 0;

      this.__update('size', 0);

      this.__update('offset', 0);

      this.__update('space', false);
    }
  },

  methods: {
    __onResize({
      height
    }) {
      this.__updateLocal('size', height);

      this.__update('size', height);
    },

    __update(prop, val) {
      if (this.layout.footer[prop] !== val) {
        this.layout.footer[prop] = val;
      }
    },

    __updateLocal(prop, val) {
      if (this[prop] !== val) {
        this[prop] = val;
      }
    },

    __updateRevealed() {
      if (this.reveal !== true) {
        return;
      }

      const {
        direction,
        position,
        inflexionPosition
      } = this.layout.scroll;

      this.__updateLocal('revealed', direction === 'up' || position - inflexionPosition < 100 || this.layout.height - this.containerHeight - position - this.size < 300);
    },

    __onFocusin(evt) {
      if (this.revealOnFocus === true) {
        this.__updateLocal('revealed', true);
      }

      this.$emit('focusin', evt);
    }

  }
}));

/***/ }),

/***/ "c918":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_BlitzMiniForm_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5736");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_BlitzMiniForm_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_BlitzMiniForm_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "c91c":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("f1a7");
var toIndexedObject = __webpack_require__("378c");
var indexOf = __webpack_require__("1f5e").indexOf;
var hiddenKeys = __webpack_require__("d687");

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "c965":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("7d53");
var Iterators = __webpack_require__("5bb7");

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ "ca22":
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__("2843");

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

module.exports = _objectSpread2;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "cab8":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  name: 'material-icons',
  type: {
    positive: 'check_circle',
    negative: 'warning',
    info: 'info',
    warning: 'priority_high'
  },
  arrow: {
    up: 'arrow_upward',
    right: 'arrow_forward',
    down: 'arrow_downward',
    left: 'arrow_back',
    dropdown: 'arrow_drop_down'
  },
  chevron: {
    left: 'chevron_left',
    right: 'chevron_right'
  },
  colorPicker: {
    spectrum: 'gradient',
    tune: 'tune',
    palette: 'style'
  },
  pullToRefresh: {
    icon: 'refresh'
  },
  carousel: {
    left: 'chevron_left',
    right: 'chevron_right',
    up: 'keyboard_arrow_up',
    down: 'keyboard_arrow_down',
    navigationIcon: 'lens'
  },
  chip: {
    remove: 'cancel',
    selected: 'check'
  },
  datetime: {
    arrowLeft: 'chevron_left',
    arrowRight: 'chevron_right',
    now: 'access_time',
    today: 'today'
  },
  editor: {
    bold: 'format_bold',
    italic: 'format_italic',
    strikethrough: 'strikethrough_s',
    underline: 'format_underlined',
    unorderedList: 'format_list_bulleted',
    orderedList: 'format_list_numbered',
    subscript: 'vertical_align_bottom',
    superscript: 'vertical_align_top',
    hyperlink: 'link',
    toggleFullscreen: 'fullscreen',
    quote: 'format_quote',
    left: 'format_align_left',
    center: 'format_align_center',
    right: 'format_align_right',
    justify: 'format_align_justify',
    print: 'print',
    outdent: 'format_indent_decrease',
    indent: 'format_indent_increase',
    removeFormat: 'format_clear',
    formatting: 'text_format',
    fontSize: 'format_size',
    align: 'format_align_left',
    hr: 'remove',
    undo: 'undo',
    redo: 'redo',
    heading: 'format_size',
    code: 'code',
    size: 'format_size',
    font: 'font_download',
    viewSource: 'code'
  },
  expansionItem: {
    icon: 'keyboard_arrow_down',
    denseIcon: 'arrow_drop_down'
  },
  fab: {
    icon: 'add',
    activeIcon: 'close'
  },
  field: {
    clear: 'cancel',
    error: 'error'
  },
  pagination: {
    first: 'first_page',
    prev: 'keyboard_arrow_left',
    next: 'keyboard_arrow_right',
    last: 'last_page'
  },
  rating: {
    icon: 'grade'
  },
  stepper: {
    done: 'check',
    active: 'edit',
    error: 'warning'
  },
  tabs: {
    left: 'chevron_left',
    right: 'chevron_right',
    up: 'keyboard_arrow_up',
    down: 'keyboard_arrow_down'
  },
  table: {
    arrowUp: 'arrow_upward',
    warning: 'warning',
    firstPage: 'first_page',
    prevPage: 'chevron_left',
    nextPage: 'chevron_right',
    lastPage: 'last_page'
  },
  tree: {
    icon: 'play_arrow'
  },
  uploader: {
    done: 'done',
    clear: 'clear',
    add: 'add_box',
    upload: 'cloud_upload',
    removeQueue: 'clear_all',
    removeUploaded: 'done_all'
  }
});

/***/ }),

/***/ "cdcd":
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__("7297");
var global = __webpack_require__("f498");
var isObject = __webpack_require__("7526");
var createNonEnumerableProperty = __webpack_require__("5b12");
var objectHas = __webpack_require__("f1a7");
var shared = __webpack_require__("c607");
var sharedKey = __webpack_require__("332c");
var hiddenKeys = __webpack_require__("d687");

var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    metadata.facade = it;
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "cdee":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "cf50":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("f498");
var DESCRIPTORS = __webpack_require__("d4cb");
var NATIVE_ARRAY_BUFFER = __webpack_require__("bd10");
var createNonEnumerableProperty = __webpack_require__("5b12");
var redefineAll = __webpack_require__("b203");
var fails = __webpack_require__("72df");
var anInstance = __webpack_require__("4cce");
var toInteger = __webpack_require__("8bb2");
var toLength = __webpack_require__("b495");
var toIndex = __webpack_require__("ff5c");
var IEEE754 = __webpack_require__("f028");
var getPrototypeOf = __webpack_require__("0e39");
var setPrototypeOf = __webpack_require__("c1a2");
var getOwnPropertyNames = __webpack_require__("65d0").f;
var defineProperty = __webpack_require__("abdf").f;
var arrayFill = __webpack_require__("29cd");
var setToStringTag = __webpack_require__("fa46");
var InternalStateModule = __webpack_require__("cdcd");

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer = global[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var $DataView = global[DATA_VIEW];
var $DataViewPrototype = $DataView && $DataView[PROTOTYPE];
var ObjectPrototype = Object.prototype;
var RangeError = global.RangeError;

var packIEEE754 = IEEE754.pack;
var unpackIEEE754 = IEEE754.unpack;

var packInt8 = function (number) {
  return [number & 0xFF];
};

var packInt16 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var unpackInt32 = function (buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packFloat32 = function (number) {
  return packIEEE754(number, 23, 4);
};

var packFloat64 = function (number) {
  return packIEEE754(number, 52, 8);
};

var addGetter = function (Constructor, key) {
  defineProperty(Constructor[PROTOTYPE], key, { get: function () { return getInternalState(this)[key]; } });
};

var get = function (view, count, index, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = bytes.slice(start, start + count);
  return isLittleEndian ? pack : pack.reverse();
};

var set = function (view, count, index, conversion, value, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = conversion(+value);
  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
};

if (!NATIVE_ARRAY_BUFFER) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    setInternalState(this, {
      bytes: arrayFill.call(new Array(byteLength), 0),
      byteLength: byteLength
    });
    if (!DESCRIPTORS) this.byteLength = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = getInternalState(buffer).byteLength;
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    setInternalState(this, {
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset
    });
    if (!DESCRIPTORS) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, 'byteLength');
    addGetter($DataView, 'buffer');
    addGetter($DataView, 'byteLength');
    addGetter($DataView, 'byteOffset');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
    }
  });
} else {
  /* eslint-disable no-new -- required for testing */
  if (!fails(function () {
    NativeArrayBuffer(1);
  }) || !fails(function () {
    new NativeArrayBuffer(-1);
  }) || fails(function () {
    new NativeArrayBuffer();
    new NativeArrayBuffer(1.5);
    new NativeArrayBuffer(NaN);
    return NativeArrayBuffer.name != ARRAY_BUFFER;
  })) {
  /* eslint-enable no-new -- required for testing */
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new NativeArrayBuffer(toIndex(length));
    };
    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];
    for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) {
        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
      }
    }
    ArrayBufferPrototype.constructor = $ArrayBuffer;
  }

  // WebKit bug - the same parent prototype for typed arrays and data view
  if (setPrototypeOf && getPrototypeOf($DataViewPrototype) !== ObjectPrototype) {
    setPrototypeOf($DataViewPrototype, ObjectPrototype);
  }

  // iOS Safari 7.x bug
  var testView = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataViewPrototype.setInt8;
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, { unsafe: true });
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);

module.exports = {
  ArrayBuffer: $ArrayBuffer,
  DataView: $DataView
};


/***/ }),

/***/ "cfa7":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ca22");
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("32f5");
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("9869");
/* harmony import */ var _lang_en_us_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("e9c4");
/* harmony import */ var _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("5094");






function getLocale() {
  if (_plugins_Platform_js__WEBPACK_IMPORTED_MODULE_4__[/* isSSR */ "f"] === true) {
    return;
  }

  const val = navigator.language || navigator.languages[0] || navigator.browserLanguage || navigator.userLanguage || navigator.systemLanguage;

  if (val) {
    return val.toLowerCase();
  }
}

/* harmony default export */ __webpack_exports__["a"] = ({
  getLocale,

  install($q, queues, lang) {
    const initialLang = lang || _lang_en_us_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"];

    this.set = (langObject = _lang_en_us_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], ssrContext) => {
      const lang = _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, langObject), {}, {
        rtl: langObject.rtl === true,
        getLocale
      });

      if (_plugins_Platform_js__WEBPACK_IMPORTED_MODULE_4__[/* isSSR */ "f"] === true) {
        if (ssrContext === void 0) {
          console.error('SSR ERROR: second param required: Quasar.lang.set(lang, ssrContext)');
          return;
        }

        const dir = lang.rtl === true ? 'rtl' : 'ltr';
        const attrs = `lang=${lang.isoName} dir=${dir}`;
        lang.set = ssrContext.$q.lang.set;
        ssrContext.Q_HTML_ATTRS = ssrContext.Q_PREV_LANG !== void 0 ? ssrContext.Q_HTML_ATTRS.replace(ssrContext.Q_PREV_LANG, attrs) : attrs;
        ssrContext.Q_PREV_LANG = attrs;
        ssrContext.$q.lang = lang;
      } else {
        if (_plugins_Platform_js__WEBPACK_IMPORTED_MODULE_4__[/* fromSSR */ "c"] === false) {
          const el = document.documentElement;
          el.setAttribute('dir', lang.rtl === true ? 'rtl' : 'ltr');
          el.setAttribute('lang', lang.isoName);
        }

        lang.set = this.set;
        $q.lang = this.props = lang;
        this.isoName = lang.isoName;
        this.nativeName = lang.nativeName;
      }
    };

    if (_plugins_Platform_js__WEBPACK_IMPORTED_MODULE_4__[/* isSSR */ "f"] === true) {
      queues.server.push((q, ctx) => {
        q.lang = {};

        q.lang.set = langObject => {
          this.set(langObject, ctx.ssr);
        };

        q.lang.set(initialLang);
      });
      this.isoName = initialLang.isoName;
      this.nativeName = initialLang.nativeName;
      this.props = initialLang;
    } else {
      vue__WEBPACK_IMPORTED_MODULE_2__["default"].util.defineReactive($q, 'lang', {});
      this.set(initialLang);
    }
  }

});

/***/ }),

/***/ "d054":
/***/ (function(module, exports, __webpack_require__) {

var bind = __webpack_require__("2117");
var IndexedObject = __webpack_require__("83a6");
var toObject = __webpack_require__("37d1");
var toLength = __webpack_require__("b495");
var arraySpeciesCreate = __webpack_require__("6a86");

var push = [].push;

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_OUT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push.call(target, value); // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push.call(target, value); // filterOut
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterOut` method
  // https://github.com/tc39/proposal-array-filtering
  filterOut: createMethod(7)
};


/***/ }),

/***/ "d197":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "d23a":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const alignMap = {
  left: 'start',
  center: 'center',
  right: 'end',
  between: 'between',
  around: 'around',
  evenly: 'evenly',
  stretch: 'stretch'
},
      alignValues = Object.keys(alignMap);
/* harmony default export */ __webpack_exports__["a"] = ({
  props: {
    align: {
      type: String,
      validator: v => alignValues.includes(v)
    }
  },
  computed: {
    alignClass() {
      const align = this.align === void 0 ? this.vertical === true ? 'stretch' : 'left' : this.align;
      return `${this.vertical === true ? 'items' : 'justify'}-${alignMap[align]}`;
    }

  }
});

/***/ }),

/***/ "d328":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-new -- required for testing */
var global = __webpack_require__("f498");
var fails = __webpack_require__("72df");
var checkCorrectnessOfIteration = __webpack_require__("3211");
var NATIVE_ARRAY_BUFFER_VIEWS = __webpack_require__("aaf2").NATIVE_ARRAY_BUFFER_VIEWS;

var ArrayBuffer = global.ArrayBuffer;
var Int8Array = global.Int8Array;

module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
  Int8Array(1);
}) || !fails(function () {
  new Int8Array(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array();
  new Int8Array(null);
  new Int8Array(1.5);
  new Int8Array(iterable);
}, true) || fails(function () {
  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
  return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
});


/***/ }),

/***/ "d4cb":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("72df");

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ "d578":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return sizes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getSizeMixin; });
const sizes = {
  xs: 18,
  sm: 24,
  md: 32,
  lg: 38,
  xl: 46
};
function getSizeMixin(sizes) {
  return {
    props: {
      size: String
    },
    computed: {
      sizeStyle() {
        if (this.size !== void 0) {
          return {
            fontSize: this.size in sizes ? `${sizes[this.size]}px` : this.size
          };
        }
      }

    }
  };
}
/* harmony default export */ __webpack_exports__["a"] = (getSizeMixin(sizes));

/***/ }),

/***/ "d604":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ApiCard_vue_vue_type_style_index_0_id_033691b6_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("be96");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ApiCard_vue_vue_type_style_index_0_id_033691b6_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ApiCard_vue_vue_type_style_index_0_id_033691b6_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "d687":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "da06":
/***/ (function(module, exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__("3cec");
var classofRaw = __webpack_require__("6a61");
var wellKnownSymbol = __webpack_require__("7d53");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};


/***/ }),

/***/ "db2e":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "dbe0":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "dc4e":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "dd08":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ca22");
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("9869");
/* harmony import */ var _icon_QIcon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("34ff");
/* harmony import */ var _mixins_ripple_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("b190");
/* harmony import */ var _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("0fb0");
/* harmony import */ var _utils_event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("9ac9");
/* harmony import */ var _utils_slot_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("a4b3");
/* harmony import */ var _utils_key_composition_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("1b63");








let uid = 0;
/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_1__["default"].extend({
  name: 'QTab',
  mixins: [_mixins_ripple_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]],
  inject: {
    tabs: {
      default() {
        console.error('QTab/QRouteTab components need to be child of QTabs');
      }

    },
    __activateTab: {},
    __recalculateScroll: {}
  },
  props: {
    icon: String,
    label: [Number, String],
    alert: [Boolean, String],
    alertIcon: String,
    name: {
      type: [Number, String],
      default: () => `t_${uid++}`
    },
    noCaps: Boolean,
    tabindex: [String, Number],
    disable: Boolean,
    contentClass: String
  },
  computed: {
    isActive() {
      return this.tabs.current === this.name;
    },

    classes() {
      return {
        [`q-tab--${this.isActive ? '' : 'in'}active`]: true,
        [`text-${this.tabs.activeColor}`]: this.isActive && this.tabs.activeColor,
        [`bg-${this.tabs.activeBgColor}`]: this.isActive && this.tabs.activeBgColor,
        'q-tab--full': this.icon && this.label && !this.tabs.inlineLabel,
        'q-tab--no-caps': this.noCaps === true || this.tabs.noCaps === true,
        'q-focusable q-hoverable cursor-pointer': !this.disable,
        disabled: this.disable
      };
    },

    innerClass() {
      return (this.tabs.inlineLabel === true ? 'row no-wrap q-tab__content--inline' : 'column') + (this.contentClass !== void 0 ? ` ${this.contentClass}` : '');
    },

    computedTabIndex() {
      return this.disable === true || this.isActive === true ? -1 : this.tabindex || 0;
    },

    onEvents() {
      return _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({
        input: _utils_event_js__WEBPACK_IMPORTED_MODULE_5__[/* stop */ "k"]
      }, this.qListeners), {}, {
        click: this.__activate,
        keyup: this.__onKeyup
      });
    },

    attrs() {
      const attrs = {
        tabindex: this.computedTabIndex,
        role: 'tab',
        'aria-selected': this.isActive
      };

      if (this.disable === true) {
        attrs['aria-disabled'] = 'true';
      }

      return attrs;
    }

  },
  methods: {
    __activate(e, keyboard) {
      keyboard !== true && this.$refs.blurTarget !== void 0 && this.$refs.blurTarget.focus();

      if (this.disable !== true) {
        this.qListeners.click !== void 0 && this.$emit('click', e);

        this.__activateTab(this.name);
      }
    },

    __onKeyup(e) {
      Object(_utils_key_composition_js__WEBPACK_IMPORTED_MODULE_7__[/* isKeyCode */ "a"])(e, 13) === true && this.__activate(e, true);
    },

    __getContent(h) {
      const narrow = this.tabs.narrowIndicator,
            content = [],
            indicator = h('div', {
        staticClass: 'q-tab__indicator',
        class: this.tabs.indicatorClass
      });
      this.icon !== void 0 && content.push(h(_icon_QIcon_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], {
        staticClass: 'q-tab__icon',
        props: {
          name: this.icon
        }
      }));
      this.label !== void 0 && content.push(h('div', {
        staticClass: 'q-tab__label'
      }, [this.label]));
      this.alert !== false && content.push(this.alertIcon !== void 0 ? h(_icon_QIcon_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"], {
        staticClass: 'q-tab__alert-icon',
        props: {
          color: this.alert !== true ? this.alert : void 0,
          name: this.alertIcon
        }
      }) : h('div', {
        staticClass: 'q-tab__alert',
        class: this.alert !== true ? `text-${this.alert}` : null
      }));
      narrow === true && content.push(indicator);
      const node = [h('div', {
        staticClass: 'q-focus-helper',
        attrs: {
          tabindex: -1
        },
        ref: 'blurTarget'
      }), h('div', {
        staticClass: 'q-tab__content self-stretch flex-center relative-position q-anchor--skip non-selectable',
        class: this.innerClass
      }, Object(_utils_slot_js__WEBPACK_IMPORTED_MODULE_6__[/* mergeSlot */ "a"])(content, this, 'default'))];
      narrow === false && node.push(indicator);
      return node;
    },

    __renderTab(h, tag, props) {
      const data = {
        staticClass: 'q-tab relative-position self-stretch flex flex-center text-center',
        class: this.classes,
        attrs: this.attrs,
        directives: this.ripple !== false && this.disable === true ? null : [{
          name: 'ripple',
          value: this.ripple
        }],
        [tag === 'div' ? 'on' : 'nativeOn']: this.onEvents
      };

      if (props !== void 0) {
        data.props = props;
      }

      return h(tag, data, this.__getContent(h));
    }

  },

  mounted() {
    this.__recalculateScroll();
  },

  beforeDestroy() {
    this.__recalculateScroll();
  },

  render(h) {
    return this.__renderTab(h, 'div');
  }

}));

/***/ }),

/***/ "df48":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ExampleSection_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("f8a5");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ExampleSection_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ExampleSection_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "df4a":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue/dist/vue.runtime.esm.js
var vue_runtime_esm = __webpack_require__("9869");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("9ac9");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/plugins/Platform.js
var Platform = __webpack_require__("5094");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/can-render.js
// using it to manage SSR rendering with best performance

/* harmony default export */ var can_render = ({
  data() {
    return {
      canRender: !Platform["g" /* onSSR */]
    };
  },

  mounted() {
    this.canRender === false && (this.canRender = true);
  }

});
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/cache.js
var cache = __webpack_require__("6459");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/resize-observer/QResizeObserver.js





/* harmony default export */ var QResizeObserver = __webpack_exports__["a"] = (vue_runtime_esm["default"].extend({
  name: 'QResizeObserver',
  mixins: [can_render],
  props: {
    debounce: {
      type: [String, Number],
      default: 100
    }
  },

  data() {
    return this.hasObserver === true ? {} : {
      url: this.$q.platform.is.ie === true ? null : 'about:blank'
    };
  },

  methods: {
    trigger(now) {
      if (now === true || this.debounce === 0 || this.debounce === '0') {
        this.__onResize();
      } else if (!this.timer) {
        this.timer = setTimeout(this.__onResize, this.debounce);
      }
    },

    __onResize() {
      this.timer = null;

      if (!this.$el || !this.$el.parentNode) {
        return;
      }

      const parent = this.$el.parentNode,
            size = {
        width: parent.offsetWidth,
        height: parent.offsetHeight
      };

      if (size.width === this.size.width && size.height === this.size.height) {
        return;
      }

      this.size = size;
      this.$emit('resize', this.size);
    },

    __cleanup() {
      if (this.curDocView !== void 0) {
        // iOS is fuzzy, need to check it first
        if (this.curDocView.removeEventListener !== void 0) {
          this.curDocView.removeEventListener('resize', this.trigger, utils_event["f" /* listenOpts */].passive);
        }

        this.curDocView = void 0;
      }
    },

    __onObjLoad() {
      this.__cleanup();

      if (this.$el.contentDocument) {
        this.curDocView = this.$el.contentDocument.defaultView;
        this.curDocView.addEventListener('resize', this.trigger, utils_event["f" /* listenOpts */].passive);
      }

      this.__onResize();
    }

  },

  render(h) {
    if (this.canRender === false || this.hasObserver === true) {
      return;
    }

    return h('object', {
      style: this.style,
      attrs: {
        tabindex: -1,
        // fix for Firefox
        type: 'text/html',
        data: this.url,
        'aria-hidden': 'true'
      },
      on: Object(cache["b" /* default */])(this, 'load', {
        load: this.__onObjLoad
      })
    });
  },

  beforeCreate() {
    this.size = {
      width: -1,
      height: -1
    };

    if (Platform["f" /* isSSR */] === true) {
      return;
    }

    this.hasObserver = typeof ResizeObserver !== 'undefined';

    if (this.hasObserver !== true) {
      this.style = `${this.$q.platform.is.ie ? 'visibility:hidden;' : ''}display:block;position:absolute;top:0;left:0;right:0;bottom:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1;`;
    }
  },

  mounted() {
    if (this.hasObserver === true) {
      this.observer = new ResizeObserver(this.trigger);
      this.observer.observe(this.$el.parentNode);

      this.__onResize();

      return;
    }

    if (this.$q.platform.is.ie === true) {
      this.url = 'about:blank';

      this.__onResize();
    } else {
      this.__onObjLoad();
    }
  },

  beforeDestroy() {
    clearTimeout(this.timer);

    if (this.hasObserver === true) {
      if (this.observer !== void 0 && this.$el.parentNode) {
        this.observer.unobserve(this.$el.parentNode);
      }

      return;
    }

    this.__cleanup();
  }

}));

/***/ }),

/***/ "df6f":
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__("c607");

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store.inspectSource != 'function') {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ "df8c":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("6a61");
var regexpExec = __webpack_require__("42c5");

// `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};



/***/ }),

/***/ "dfd0":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@babel/runtime/helpers/objectSpread2.js
var objectSpread2 = __webpack_require__("ca22");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2);

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.array.flat.js
var es_array_flat = __webpack_require__("ba53");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.string.replace.js
var es_string_replace = __webpack_require__("32f5");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue/dist/vue.runtime.esm.js
var vue_runtime_esm = __webpack_require__("9869");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/patterns.js
var patterns = __webpack_require__("86a3");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/throttle.js
var throttle = __webpack_require__("f96b");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/cache.js
var cache = __webpack_require__("6459");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("9ac9");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/colors.js
var colors = __webpack_require__("134d");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/dark.js
var dark = __webpack_require__("87b2");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/form.js
var mixins_form = __webpack_require__("87c8");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/listeners.js
var listeners = __webpack_require__("0fb0");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/plugins/Platform.js
var Platform = __webpack_require__("5094");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/touch.js
var touch = __webpack_require__("36df");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/selection.js
var selection = __webpack_require__("004f");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/directives/TouchPan.js





function getChanges(evt, ctx, isFinal) {
  const pos = Object(utils_event["h" /* position */])(evt);
  let dir,
      distX = pos.left - ctx.event.x,
      distY = pos.top - ctx.event.y,
      absX = Math.abs(distX),
      absY = Math.abs(distY);
  const direction = ctx.direction;

  if (direction.horizontal === true && direction.vertical !== true) {
    dir = distX < 0 ? 'left' : 'right';
  } else if (direction.horizontal !== true && direction.vertical === true) {
    dir = distY < 0 ? 'up' : 'down';
  } else if (direction.up === true && distY < 0) {
    dir = 'up';

    if (absX > absY) {
      if (direction.left === true && distX < 0) {
        dir = 'left';
      } else if (direction.right === true && distX > 0) {
        dir = 'right';
      }
    }
  } else if (direction.down === true && distY > 0) {
    dir = 'down';

    if (absX > absY) {
      if (direction.left === true && distX < 0) {
        dir = 'left';
      } else if (direction.right === true && distX > 0) {
        dir = 'right';
      }
    }
  } else if (direction.left === true && distX < 0) {
    dir = 'left';

    if (absX < absY) {
      if (direction.up === true && distY < 0) {
        dir = 'up';
      } else if (direction.down === true && distY > 0) {
        dir = 'down';
      }
    }
  } else if (direction.right === true && distX > 0) {
    dir = 'right';

    if (absX < absY) {
      if (direction.up === true && distY < 0) {
        dir = 'up';
      } else if (direction.down === true && distY > 0) {
        dir = 'down';
      }
    }
  }

  let synthetic = false;

  if (dir === void 0 && isFinal === false) {
    if (ctx.event.isFirst === true || ctx.event.lastDir === void 0) {
      return {};
    }

    dir = ctx.event.lastDir;
    synthetic = true;

    if (dir === 'left' || dir === 'right') {
      pos.left -= distX;
      absX = 0;
      distX = 0;
    } else {
      pos.top -= distY;
      absY = 0;
      distY = 0;
    }
  }

  return {
    synthetic,
    payload: {
      evt,
      touch: ctx.event.mouse !== true,
      mouse: ctx.event.mouse === true,
      position: pos,
      direction: dir,
      isFirst: ctx.event.isFirst,
      isFinal: isFinal === true,
      duration: Date.now() - ctx.event.time,
      distance: {
        x: absX,
        y: absY
      },
      offset: {
        x: distX,
        y: distY
      },
      delta: {
        x: pos.left - ctx.event.lastX,
        y: pos.top - ctx.event.lastY
      }
    }
  };
}

function destroy(el) {
  const ctx = el.__qtouchpan;

  if (ctx !== void 0) {
    // emit the end event when the directive is destroyed while active
    // this is only needed in TouchPan because the rest of the touch directives do not emit an end event
    // the condition is also checked in the start of function but we avoid the call
    ctx.event !== void 0 && ctx.end();
    Object(utils_event["b" /* cleanEvt */])(ctx, 'main');
    Object(utils_event["b" /* cleanEvt */])(ctx, 'temp');
    Platform["a" /* client */].is.firefox === true && Object(utils_event["j" /* preventDraggable */])(el, false);
    ctx.styleCleanup !== void 0 && ctx.styleCleanup();
    delete el.__qtouchpan;
  }
}

let uid = 0;
/* harmony default export */ var TouchPan = ({
  name: 'touch-pan',

  bind(el, {
    value,
    modifiers
  }) {
    if (el.__qtouchpan !== void 0) {
      destroy(el);
      el.__qtouchpan_destroyed = true;
    } // early return, we don't need to do anything


    if (modifiers.mouse !== true && Platform["a" /* client */].has.touch !== true) {
      return;
    }

    function handleEvent(evt, mouseEvent) {
      if (modifiers.mouse === true && mouseEvent === true) {
        Object(utils_event["l" /* stopAndPrevent */])(evt);
      } else {
        modifiers.stop === true && Object(utils_event["k" /* stop */])(evt);
        modifiers.prevent === true && Object(utils_event["i" /* prevent */])(evt);
      }
    }

    const ctx = {
      uid: 'qvtp_' + uid++,
      handler: value,
      modifiers,
      direction: Object(touch["a" /* getModifierDirections */])(modifiers),
      noop: utils_event["g" /* noop */],

      mouseStart(evt) {
        if (Object(touch["c" /* shouldStart */])(evt, ctx) && Object(utils_event["e" /* leftClick */])(evt)) {
          Object(utils_event["a" /* addEvt */])(ctx, 'temp', [[document, 'mousemove', 'move', 'notPassiveCapture'], [document, 'mouseup', 'end', 'passiveCapture']]);
          ctx.start(evt, true);
        }
      },

      touchStart(evt) {
        if (Object(touch["c" /* shouldStart */])(evt, ctx)) {
          const target = Object(touch["b" /* getTouchTarget */])(evt.target);
          Object(utils_event["a" /* addEvt */])(ctx, 'temp', [[target, 'touchmove', 'move', 'notPassiveCapture'], [target, 'touchcancel', 'end', 'passiveCapture'], [target, 'touchend', 'end', 'passiveCapture']]);
          ctx.start(evt);
        }
      },

      start(evt, mouseEvent) {
        Platform["a" /* client */].is.firefox === true && Object(utils_event["j" /* preventDraggable */])(el, true);
        ctx.lastEvt = evt;
        const pos = Object(utils_event["h" /* position */])(evt);
        /*
         * Stop propagation so possible upper v-touch-pan don't catch this as well;
         * If we're not the target (based on modifiers), we'll re-emit the event later
         */

        if (mouseEvent === true || modifiers.stop === true) {
          /*
           * are we directly switching to detected state?
           * clone event only otherwise
           */
          if (ctx.direction.all !== true && (mouseEvent !== true || ctx.direction.mouseAllDir !== true)) {
            const clone = evt.type.indexOf('mouse') > -1 ? new MouseEvent(evt.type, evt) : new TouchEvent(evt.type, evt);
            evt.defaultPrevented === true && Object(utils_event["i" /* prevent */])(clone);
            evt.cancelBubble === true && Object(utils_event["k" /* stop */])(clone);
            clone.qClonedBy = evt.qClonedBy === void 0 ? [ctx.uid] : evt.qClonedBy.concat(ctx.uid);
            clone.qKeyEvent = evt.qKeyEvent;
            clone.qClickOutside = evt.qClickOutside;
            ctx.initialEvent = {
              target: evt.target,
              event: clone
            };
          }

          Object(utils_event["k" /* stop */])(evt);
        }

        ctx.event = {
          x: pos.left,
          y: pos.top,
          time: Date.now(),
          mouse: mouseEvent === true,
          detected: false,
          isFirst: true,
          isFinal: false,
          lastX: pos.left,
          lastY: pos.top
        };
      },

      move(evt) {
        if (ctx.event === void 0) {
          return;
        }

        ctx.lastEvt = evt;
        const isMouseEvt = ctx.event.mouse === true;

        const start = () => {
          handleEvent(evt, isMouseEvt);

          if (modifiers.preserveCursor !== true) {
            document.documentElement.style.cursor = 'grabbing';
          }

          isMouseEvt === true && document.body.classList.add('no-pointer-events--children');
          document.body.classList.add('non-selectable');
          Object(selection["a" /* clearSelection */])();

          ctx.styleCleanup = withDelayedFn => {
            ctx.styleCleanup = void 0;

            if (modifiers.preserveCursor !== true) {
              document.documentElement.style.cursor = '';
            }

            document.body.classList.remove('non-selectable');

            if (isMouseEvt === true) {
              const remove = () => {
                document.body.classList.remove('no-pointer-events--children');
              };

              if (withDelayedFn !== void 0) {
                setTimeout(() => {
                  remove();
                  withDelayedFn();
                }, 50);
              } else {
                remove();
              }
            } else if (withDelayedFn !== void 0) {
              withDelayedFn();
            }
          };
        };

        if (ctx.event.detected === true) {
          ctx.event.isFirst !== true && handleEvent(evt, ctx.event.mouse);
          const {
            payload,
            synthetic
          } = getChanges(evt, ctx, false);

          if (payload !== void 0) {
            if (ctx.handler(payload) === false) {
              ctx.end(evt);
            } else {
              if (ctx.styleCleanup === void 0 && ctx.event.isFirst === true) {
                start();
              }

              ctx.event.lastX = payload.position.left;
              ctx.event.lastY = payload.position.top;
              ctx.event.lastDir = synthetic === true ? void 0 : payload.direction;
              ctx.event.isFirst = false;
            }
          }

          return;
        }

        if (ctx.direction.all === true || isMouseEvt === true && ctx.modifiers.mouseAllDir === true) {
          start();
          ctx.event.detected = true;
          ctx.move(evt);
          return;
        }

        const pos = Object(utils_event["h" /* position */])(evt),
              distX = pos.left - ctx.event.x,
              distY = pos.top - ctx.event.y,
              absX = Math.abs(distX),
              absY = Math.abs(distY);

        if (absX !== absY) {
          if (ctx.direction.horizontal === true && absX > absY || ctx.direction.vertical === true && absX < absY || ctx.direction.up === true && absX < absY && distY < 0 || ctx.direction.down === true && absX < absY && distY > 0 || ctx.direction.left === true && absX > absY && distX < 0 || ctx.direction.right === true && absX > absY && distX > 0) {
            ctx.event.detected = true;
            ctx.move(evt);
          } else {
            ctx.end(evt, true);
          }
        }
      },

      end(evt, abort) {
        if (ctx.event === void 0) {
          return;
        }

        Object(utils_event["b" /* cleanEvt */])(ctx, 'temp');
        Platform["a" /* client */].is.firefox === true && Object(utils_event["j" /* preventDraggable */])(el, false);

        if (abort === true) {
          ctx.styleCleanup !== void 0 && ctx.styleCleanup();

          if (ctx.event.detected !== true && ctx.initialEvent !== void 0) {
            ctx.initialEvent.target.dispatchEvent(ctx.initialEvent.event);
          }
        } else if (ctx.event.detected === true) {
          ctx.event.isFirst === true && ctx.handler(getChanges(evt === void 0 ? ctx.lastEvt : evt, ctx).payload);
          const {
            payload
          } = getChanges(evt === void 0 ? ctx.lastEvt : evt, ctx, true);

          const fn = () => {
            ctx.handler(payload);
          };

          if (ctx.styleCleanup !== void 0) {
            ctx.styleCleanup(fn);
          } else {
            fn();
          }
        }

        ctx.event = void 0;
        ctx.initialEvent = void 0;
        ctx.lastEvt = void 0;
      }

    };
    el.__qtouchpan = ctx;
    modifiers.mouse === true && Object(utils_event["a" /* addEvt */])(ctx, 'main', [[el, 'mousedown', 'mouseStart', `passive${modifiers.mouseCapture === true ? 'Capture' : ''}`]]);
    Platform["a" /* client */].has.touch === true && Object(utils_event["a" /* addEvt */])(ctx, 'main', [[el, 'touchstart', 'touchStart', `passive${modifiers.capture === true ? 'Capture' : ''}`], [el, 'touchmove', 'noop', 'notPassiveCapture']]);
  },

  update(el, {
    oldValue,
    value
  }) {
    const ctx = el.__qtouchpan;

    if (ctx !== void 0 && oldValue !== value) {
      typeof value !== 'function' && ctx.end();
      ctx.handler = value;
    }
  },

  unbind(el) {
    if (el.__qtouchpan_destroyed === void 0) {
      destroy(el);
    } else {
      delete el.__qtouchpan_destroyed;
    }
  }

});
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.array.reverse.js
var es_array_reverse = __webpack_require__("c053");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/core-js/modules/es.string.trim.js
var es_string_trim = __webpack_require__("b55a");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/format.js
var format = __webpack_require__("a114");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/slider/slider-utils.js






 // PGDOWN, LEFT, DOWN, PGUP, RIGHT, UP

const keyCodes = [34, 37, 40, 33, 39, 38];
function getRatio(evt, dragging, reverse, vertical) {
  const pos = Object(utils_event["h" /* position */])(evt),
        val = vertical === true ? Object(format["a" /* between */])((pos.top - dragging.top) / dragging.height, 0, 1) : Object(format["a" /* between */])((pos.left - dragging.left) / dragging.width, 0, 1);
  return reverse === true ? 1.0 - val : val;
}
function getModel(ratio, min, max, step, decimals) {
  let model = min + ratio * (max - min);

  if (step > 0) {
    const modulo = (model - min) % step;
    model += (Math.abs(modulo) >= step / 2 ? (modulo < 0 ? -1 : 1) * step : 0) - modulo;
  }

  if (decimals > 0) {
    model = parseFloat(model.toFixed(decimals));
  }

  return Object(format["a" /* between */])(model, min, max);
}
const SliderMixin = {
  mixins: [dark["a" /* default */], mixins_form["b" /* default */]],
  directives: {
    TouchPan: TouchPan
  },
  props: {
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    step: {
      type: Number,
      default: 1,
      validator: v => v >= 0
    },
    color: String,
    labelColor: String,
    labelTextColor: String,
    dense: Boolean,
    label: Boolean,
    labelAlways: Boolean,
    markers: Boolean,
    snap: Boolean,
    vertical: Boolean,
    reverse: Boolean,
    disable: Boolean,
    readonly: Boolean,
    tabindex: [String, Number],
    thumbPath: {
      type: String,
      default: 'M 4, 10 a 6,6 0 1,0 12,0 a 6,6 0 1,0 -12,0'
    }
  },

  data() {
    return {
      active: false,
      preventFocus: false,
      focus: false
    };
  },

  computed: {
    axis() {
      return this.vertical === true ? '--v' : '--h';
    },

    classes() {
      return `q-slider q-slider${this.axis} q-slider--${this.active === true ? '' : 'in'}active` + (this.isReversed === true ? ' q-slider--reversed' : '') + (this.color !== void 0 ? ` text-${this.color}` : '') + (this.disable === true ? ' disabled' : ' q-slider--enabled' + (this.editable === true ? ' q-slider--editable' : '')) + (this.focus === 'both' ? ' q-slider--focus' : '') + (this.label || this.labelAlways === true ? ' q-slider--label' : '') + (this.labelAlways === true ? ' q-slider--label-always' : '') + (this.isDark === true ? ' q-slider--dark' : '') + (this.dense === true ? ' q-slider--dense q-slider--dense' + this.axis : '');
    },

    editable() {
      return this.disable !== true && this.readonly !== true && this.min < this.max;
    },

    decimals() {
      return (String(this.step).trim('0').split('.')[1] || '').length;
    },

    computedStep() {
      return this.step === 0 ? 1 : this.step;
    },

    minMaxDiff() {
      return this.max - this.min;
    },

    markerStyle() {
      if (this.minMaxDiff !== 0) {
        const size = 100 * this.computedStep / this.minMaxDiff;
        return {
          backgroundSize: this.vertical === true ? '2px ' + size + '%' : size + '% 2px'
        };
      }
    },

    computedTabindex() {
      return this.editable === true ? this.tabindex || 0 : -1;
    },

    isReversed() {
      return this.vertical === true ? this.reverse === true : this.reverse !== (this.$q.lang.rtl === true);
    },

    positionProp() {
      if (this.vertical === true) {
        return this.isReversed === true ? 'bottom' : 'top';
      }

      return this.isReversed === true ? 'right' : 'left';
    },

    sizeProp() {
      return this.vertical === true ? 'height' : 'width';
    },

    orientation() {
      return this.vertical === true ? 'vertical' : 'horizontal';
    },

    attrs() {
      const attrs = {
        role: 'slider',
        'aria-valuemin': this.min,
        'aria-valuemax': this.max,
        'aria-orientation': this.orientation,
        'data-step': this.step
      };

      if (this.disable === true) {
        attrs['aria-disabled'] = 'true';
      } else if (this.readonly === true) {
        attrs['aria-readonly'] = 'true';
      }

      return attrs;
    },

    panDirectives() {
      return this.editable === true ? [{
        name: 'touch-pan',
        value: this.__pan,
        modifiers: {
          [this.orientation]: true,
          prevent: true,
          stop: true,
          mouse: true,
          mouseAllDir: true
        }
      }] : null;
    }

  },
  methods: {
    __getThumbSvg(h) {
      return h('svg', {
        staticClass: 'q-slider__thumb absolute',
        attrs: {
          focusable: 'false',

          /* needed for IE11 */
          viewBox: '0 0 20 20',
          width: '20',
          height: '20',
          'aria-hidden': 'true'
        }
      }, [h('path', {
        attrs: {
          d: this.thumbPath
        }
      })]);
    },

    __getPinStyle(percent, ratio) {
      if (this.vertical === true) {
        return {};
      }

      const offset = `${Math.ceil(20 * Math.abs(0.5 - ratio))}px`;
      return {
        pin: {
          transformOrigin: `${this.$q.lang.rtl === true ? offset : this.$q.platform.is.ie === true ? '100%' : `calc(100% - ${offset})`} 50%`
        },
        pinTextContainer: {
          [this.$q.lang.rtl === true ? 'left' : 'right']: `${percent * 100}%`,
          transform: `translateX(${Math.ceil((this.$q.lang.rtl === true ? -1 : 1) * 20 * percent)}px)`
        }
      };
    },

    __pan(event) {
      if (event.isFinal) {
        if (this.dragging !== void 0) {
          this.__updatePosition(event.evt); // only if touch, because we also have mousedown/up:


          event.touch === true && this.__updateValue(true);
          this.dragging = void 0;
          this.$emit('pan', 'end');
        }

        this.active = false;
      } else if (event.isFirst) {
        this.dragging = this.__getDragging(event.evt);

        this.__updatePosition(event.evt);

        this.__updateValue();

        this.active = true;
        this.$emit('pan', 'start');
      } else {
        this.__updatePosition(event.evt);

        this.__updateValue();
      }
    },

    __blur() {
      this.focus = false;
    },

    __activate(evt) {
      this.__updatePosition(evt, this.__getDragging(evt));

      this.__updateValue();

      this.preventFocus = true;
      this.active = true;
      document.addEventListener('mouseup', this.__deactivate, true);
    },

    __deactivate() {
      this.preventFocus = false;

      if (this.dragging === void 0) {
        this.active = false;
      }

      this.__updateValue(true);

      this.__blur();

      document.removeEventListener('mouseup', this.__deactivate, true);
    },

    __mobileClick(evt) {
      this.__updatePosition(evt, this.__getDragging(evt));

      this.__updateValue(true);
    },

    __keyup(evt) {
      if (keyCodes.includes(evt.keyCode)) {
        this.__updateValue(true);
      }
    }

  },

  beforeDestroy() {
    document.removeEventListener('mouseup', this.__deactivate, true);
  }

};
// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/slider/QSlider.js






/* harmony default export */ var QSlider = (vue_runtime_esm["default"].extend({
  name: 'QSlider',
  mixins: [SliderMixin],
  props: {
    value: {
      required: true,
      default: null,
      validator: v => typeof v === 'number' || v === null
    },
    labelValue: [String, Number]
  },

  data() {
    return {
      model: this.value === null ? this.min : this.value,
      curRatio: 0
    };
  },

  watch: {
    value(v) {
      this.model = v === null ? 0 : Object(format["a" /* between */])(v, this.min, this.max);
    },

    min(v) {
      this.model = Object(format["a" /* between */])(this.model, v, this.max);
    },

    max(v) {
      this.model = Object(format["a" /* between */])(this.model, this.min, v);
    }

  },
  computed: {
    ratio() {
      return this.active === true ? this.curRatio : this.modelRatio;
    },

    modelRatio() {
      return this.minMaxDiff === 0 ? 0 : (this.model - this.min) / this.minMaxDiff;
    },

    trackStyle() {
      return {
        [this.positionProp]: 0,
        [this.sizeProp]: `${100 * this.ratio}%`
      };
    },

    thumbStyle() {
      return {
        [this.positionProp]: `${100 * this.ratio}%`
      };
    },

    thumbClass() {
      if (this.preventFocus === false && this.focus === true) {
        return 'q-slider--focus';
      }
    },

    pinClass() {
      if (this.labelColor !== void 0) {
        return `text-${this.labelColor}`;
      }
    },

    pinTextClass() {
      return 'q-slider__pin-value-marker-text' + (this.labelTextColor !== void 0 ? ` text-${this.labelTextColor}` : '');
    },

    events() {
      if (this.editable === true) {
        return this.$q.platform.is.mobile === true ? {
          click: this.__mobileClick
        } : {
          mousedown: this.__activate,
          focus: this.__focus,
          blur: this.__blur,
          keydown: this.__keydown,
          keyup: this.__keyup
        };
      }
    },

    computedLabel() {
      return this.labelValue !== void 0 ? this.labelValue : this.model;
    },

    pinStyle() {
      const percent = this.reverse === true ? -this.ratio : this.ratio - 1;
      return this.__getPinStyle(percent, this.ratio);
    }

  },
  methods: {
    __updateValue(change) {
      if (this.model !== this.value) {
        this.$emit('input', this.model);
      }

      change === true && this.$emit('change', this.model);
    },

    __getDragging() {
      return this.$el.getBoundingClientRect();
    },

    __updatePosition(event, dragging = this.dragging) {
      const ratio = getRatio(event, dragging, this.isReversed, this.vertical);
      this.model = getModel(ratio, this.min, this.max, this.step, this.decimals);
      this.curRatio = this.snap !== true || this.step === 0 ? ratio : this.minMaxDiff === 0 ? 0 : (this.model - this.min) / this.minMaxDiff;
    },

    __focus() {
      this.focus = true;
    },

    __keydown(evt) {
      if (!keyCodes.includes(evt.keyCode)) {
        return;
      }

      Object(utils_event["l" /* stopAndPrevent */])(evt);
      const step = ([34, 33].includes(evt.keyCode) ? 10 : 1) * this.computedStep,
            offset = [34, 37, 40].includes(evt.keyCode) ? -step : step;
      this.model = Object(format["a" /* between */])(parseFloat((this.model + offset).toFixed(this.decimals)), this.min, this.max);

      this.__updateValue();
    }

  },

  render(h) {
    const child = [this.__getThumbSvg(h), h('div', {
      staticClass: 'q-slider__focus-ring'
    })];

    if (this.label === true || this.labelAlways === true) {
      child.push(h('div', {
        staticClass: `q-slider__pin q-slider__pin${this.axis} absolute`,
        style: this.pinStyle.pin,
        class: this.pinClass
      }, [h('div', {
        staticClass: `q-slider__pin-text-container q-slider__pin-text-container${this.axis}`,
        style: this.pinStyle.pinTextContainer
      }, [h('span', {
        staticClass: 'q-slider__pin-text',
        class: this.pinTextClass
      }, [this.computedLabel])])]), h('div', {
        staticClass: `q-slider__arrow q-slider__arrow${this.axis}`,
        class: this.pinClass
      }));
    }

    if (this.name !== void 0 && this.disable !== true) {
      this.__injectFormInput(child, 'push');
    }

    const track = [h('div', {
      staticClass: `q-slider__track q-slider__track${this.axis} absolute`,
      style: this.trackStyle
    })];
    this.markers === true && track.push(h('div', {
      staticClass: `q-slider__track-markers q-slider__track-markers${this.axis} absolute-full fit`,
      style: this.markerStyle
    }));
    return h('div', {
      staticClass: this.value === null ? ' q-slider--no-value' : '',
      attrs: objectSpread2_default()(objectSpread2_default()({}, this.attrs), {}, {
        'aria-valuenow': this.value,
        tabindex: this.computedTabindex
      }),
      class: this.classes,
      on: this.events,
      directives: this.panDirectives
    }, [h('div', {
      staticClass: `q-slider__track-container q-slider__track-container${this.axis} absolute`
    }, track), h('div', {
      staticClass: `q-slider__thumb-container q-slider__thumb-container${this.axis} absolute non-selectable`,
      class: this.thumbClass,
      style: this.thumbStyle
    }, child)]);
  }

}));
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/icon/QIcon.js
var QIcon = __webpack_require__("34ff");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/tabs/QTabs.js
var QTabs = __webpack_require__("4776");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/tabs/QTab.js
var QTab = __webpack_require__("dd08");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/tab-panels/QTabPanels.js
var QTabPanels = __webpack_require__("1411");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/tab-panels/QTabPanel.js
var QTabPanel = __webpack_require__("1d98");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/color/QColor.js



















const palette = ['rgb(255,204,204)', 'rgb(255,230,204)', 'rgb(255,255,204)', 'rgb(204,255,204)', 'rgb(204,255,230)', 'rgb(204,255,255)', 'rgb(204,230,255)', 'rgb(204,204,255)', 'rgb(230,204,255)', 'rgb(255,204,255)', 'rgb(255,153,153)', 'rgb(255,204,153)', 'rgb(255,255,153)', 'rgb(153,255,153)', 'rgb(153,255,204)', 'rgb(153,255,255)', 'rgb(153,204,255)', 'rgb(153,153,255)', 'rgb(204,153,255)', 'rgb(255,153,255)', 'rgb(255,102,102)', 'rgb(255,179,102)', 'rgb(255,255,102)', 'rgb(102,255,102)', 'rgb(102,255,179)', 'rgb(102,255,255)', 'rgb(102,179,255)', 'rgb(102,102,255)', 'rgb(179,102,255)', 'rgb(255,102,255)', 'rgb(255,51,51)', 'rgb(255,153,51)', 'rgb(255,255,51)', 'rgb(51,255,51)', 'rgb(51,255,153)', 'rgb(51,255,255)', 'rgb(51,153,255)', 'rgb(51,51,255)', 'rgb(153,51,255)', 'rgb(255,51,255)', 'rgb(255,0,0)', 'rgb(255,128,0)', 'rgb(255,255,0)', 'rgb(0,255,0)', 'rgb(0,255,128)', 'rgb(0,255,255)', 'rgb(0,128,255)', 'rgb(0,0,255)', 'rgb(128,0,255)', 'rgb(255,0,255)', 'rgb(245,0,0)', 'rgb(245,123,0)', 'rgb(245,245,0)', 'rgb(0,245,0)', 'rgb(0,245,123)', 'rgb(0,245,245)', 'rgb(0,123,245)', 'rgb(0,0,245)', 'rgb(123,0,245)', 'rgb(245,0,245)', 'rgb(214,0,0)', 'rgb(214,108,0)', 'rgb(214,214,0)', 'rgb(0,214,0)', 'rgb(0,214,108)', 'rgb(0,214,214)', 'rgb(0,108,214)', 'rgb(0,0,214)', 'rgb(108,0,214)', 'rgb(214,0,214)', 'rgb(163,0,0)', 'rgb(163,82,0)', 'rgb(163,163,0)', 'rgb(0,163,0)', 'rgb(0,163,82)', 'rgb(0,163,163)', 'rgb(0,82,163)', 'rgb(0,0,163)', 'rgb(82,0,163)', 'rgb(163,0,163)', 'rgb(92,0,0)', 'rgb(92,46,0)', 'rgb(92,92,0)', 'rgb(0,92,0)', 'rgb(0,92,46)', 'rgb(0,92,92)', 'rgb(0,46,92)', 'rgb(0,0,92)', 'rgb(46,0,92)', 'rgb(92,0,92)', 'rgb(255,255,255)', 'rgb(205,205,205)', 'rgb(178,178,178)', 'rgb(153,153,153)', 'rgb(127,127,127)', 'rgb(102,102,102)', 'rgb(76,76,76)', 'rgb(51,51,51)', 'rgb(25,25,25)', 'rgb(0,0,0)'];
/* harmony default export */ var QColor = __webpack_exports__["a"] = (vue_runtime_esm["default"].extend({
  name: 'QColor',
  mixins: [listeners["a" /* default */], dark["a" /* default */], mixins_form["b" /* default */]],
  directives: {
    TouchPan: TouchPan
  },
  props: {
    value: String,
    defaultValue: String,
    defaultView: {
      type: String,
      default: 'spectrum',
      validator: v => ['spectrum', 'tune', 'palette'].includes(v)
    },
    formatModel: {
      type: String,
      default: 'auto',
      validator: v => ['auto', 'hex', 'rgb', 'hexa', 'rgba'].includes(v)
    },
    palette: Array,
    noHeader: Boolean,
    noFooter: Boolean,
    square: Boolean,
    flat: Boolean,
    bordered: Boolean,
    disable: Boolean,
    readonly: Boolean
  },

  data() {
    return {
      topView: this.formatModel === 'auto' ? this.value === void 0 || this.value === null || this.value === '' || this.value.startsWith('#') ? 'hex' : 'rgb' : this.formatModel.startsWith('hex') ? 'hex' : 'rgb',
      view: this.defaultView,
      model: this.__parseModel(this.value || this.defaultValue)
    };
  },

  watch: {
    value(v) {
      const model = this.__parseModel(v || this.defaultValue);

      if (model.hex !== this.model.hex) {
        this.model = model;
      }
    },

    defaultValue(v) {
      if (!this.value && v) {
        const model = this.__parseModel(v);

        if (model.hex !== this.model.hex) {
          this.model = model;
        }
      }
    }

  },
  computed: {
    editable() {
      return this.disable !== true && this.readonly !== true;
    },

    forceHex() {
      return this.formatModel === 'auto' ? null : this.formatModel.indexOf('hex') > -1;
    },

    forceAlpha() {
      return this.formatModel === 'auto' ? null : this.formatModel.indexOf('a') > -1;
    },

    isHex() {
      return this.value === void 0 || this.value === null || this.value === '' || this.value.startsWith('#');
    },

    isOutputHex() {
      return this.forceHex !== null ? this.forceHex : this.isHex;
    },

    formAttrs() {
      return {
        type: 'hidden',
        name: this.name,
        value: this.model[this.isOutputHex === true ? 'hex' : 'rgb']
      };
    },

    hasAlpha() {
      if (this.forceAlpha !== null) {
        return this.forceAlpha;
      }

      return this.model.a !== void 0;
    },

    currentBgColor() {
      return {
        backgroundColor: this.model.rgb || '#000'
      };
    },

    headerClass() {
      const light = this.model.a !== void 0 && this.model.a < 65 ? true : Object(colors["d" /* luminosity */])(this.model) > 0.4;
      return `q-color-picker__header-content--${light ? 'light' : 'dark'}`;
    },

    spectrumStyle() {
      return {
        background: `hsl(${this.model.h},100%,50%)`
      };
    },

    spectrumPointerStyle() {
      return {
        top: `${100 - this.model.v}%`,
        [this.$q.lang.rtl === true ? 'right' : 'left']: `${this.model.s}%`
      };
    },

    computedPalette() {
      return this.palette !== void 0 && this.palette.length > 0 ? this.palette : palette;
    },

    classes() {
      return 'q-color-picker' + (this.bordered === true ? ' q-color-picker--bordered' : '') + (this.square === true ? ' q-color-picker--square no-border-radius' : '') + (this.flat === true ? ' q-color-picker--flat no-shadow' : '') + (this.disable === true ? ' disabled' : '') + (this.isDark === true ? ' q-color-picker--dark q-dark' : '');
    },

    attrs() {
      if (this.disable === true) {
        return {
          'aria-disabled': 'true'
        };
      }

      if (this.readonly === true) {
        return {
          'aria-readonly': 'true'
        };
      }
    }

  },

  created() {
    this.__spectrumChange = Object(throttle["a" /* default */])(this.__spectrumChange, 20);
  },

  render(h) {
    const child = [this.__getContent(h)];

    if (this.name !== void 0 && this.disable !== true) {
      this.__injectFormInput(child, 'push');
    }

    this.noHeader !== true && child.unshift(this.__getHeader(h));
    this.noFooter !== true && child.push(this.__getFooter(h));
    return h('div', {
      class: this.classes,
      attrs: this.attrs,
      on: objectSpread2_default()({}, this.qListeners)
    }, child);
  },

  methods: {
    __getHeader(h) {
      return h('div', {
        staticClass: 'q-color-picker__header relative-position overflow-hidden'
      }, [h('div', {
        staticClass: 'q-color-picker__header-bg absolute-full'
      }), h('div', {
        staticClass: 'q-color-picker__header-content absolute-full',
        class: this.headerClass,
        style: this.currentBgColor
      }, [h(QTabs["a" /* default */], {
        props: {
          value: this.topView,
          dense: true,
          align: 'justify'
        },
        on: Object(cache["b" /* default */])(this, 'topVTab', {
          input: val => {
            this.topView = val;
          }
        })
      }, [h(QTab["a" /* default */], {
        props: {
          label: 'HEX' + (this.hasAlpha === true ? 'A' : ''),
          name: 'hex',
          ripple: false
        }
      }), h(QTab["a" /* default */], {
        props: {
          label: 'RGB' + (this.hasAlpha === true ? 'A' : ''),
          name: 'rgb',
          ripple: false
        }
      })]), h('div', {
        staticClass: 'q-color-picker__header-banner row flex-center no-wrap'
      }, [h('input', {
        staticClass: 'fit',
        domProps: {
          value: this.model[this.topView]
        },
        attrs: this.editable !== true ? {
          readonly: true
        } : null,
        on: Object(cache["b" /* default */])(this, 'topIn', {
          input: evt => {
            this.__updateErrorIcon(this.__onEditorChange(evt) === true);
          },
          change: utils_event["k" /* stop */],
          blur: evt => {
            this.__onEditorChange(evt, true) === true && this.$forceUpdate();

            this.__updateErrorIcon(false);
          }
        })
      }), h(QIcon["a" /* default */], {
        ref: 'errorIcon',
        staticClass: 'q-color-picker__error-icon absolute no-pointer-events',
        props: {
          name: this.$q.iconSet.type.negative
        }
      })])])]);
    },

    __getContent(h) {
      return h(QTabPanels["a" /* default */], {
        props: {
          value: this.view,
          animated: true
        }
      }, [h(QTabPanel["a" /* default */], {
        staticClass: 'q-color-picker__spectrum-tab overflow-hidden',
        props: {
          name: 'spectrum'
        }
      }, this.__getSpectrumTab(h)), h(QTabPanel["a" /* default */], {
        staticClass: 'q-pa-md q-color-picker__tune-tab',
        props: {
          name: 'tune'
        }
      }, this.__getTuneTab(h)), h(QTabPanel["a" /* default */], {
        staticClass: 'q-color-picker__palette-tab',
        props: {
          name: 'palette'
        }
      }, this.__getPaletteTab(h))]);
    },

    __getFooter(h) {
      return h('div', {
        staticClass: 'q-color-picker__footer relative-position overflow-hidden'
      }, [h(QTabs["a" /* default */], {
        staticClass: 'absolute-full',
        props: {
          value: this.view,
          dense: true,
          align: 'justify'
        },
        on: Object(cache["b" /* default */])(this, 'ftIn', {
          input: val => {
            this.view = val;
          }
        })
      }, [h(QTab["a" /* default */], {
        props: {
          icon: this.$q.iconSet.colorPicker.spectrum,
          name: 'spectrum',
          ripple: false
        }
      }), h(QTab["a" /* default */], {
        props: {
          icon: this.$q.iconSet.colorPicker.tune,
          name: 'tune',
          ripple: false
        }
      }), h(QTab["a" /* default */], {
        props: {
          icon: this.$q.iconSet.colorPicker.palette,
          name: 'palette',
          ripple: false
        }
      })])]);
    },

    __getSpectrumTab(h) {
      const thumbPath = 'M5 5 h10 v10 h-10 v-10 z';
      return [h('div', {
        ref: 'spectrum',
        staticClass: 'q-color-picker__spectrum non-selectable relative-position cursor-pointer',
        style: this.spectrumStyle,
        class: {
          readonly: this.editable !== true
        },
        on: this.editable === true ? Object(cache["b" /* default */])(this, 'spectrT', {
          click: this.__spectrumClick,
          mousedown: this.__activate
        }) : null,
        directives: this.editable === true ? Object(cache["b" /* default */])(this, 'spectrDir', [{
          name: 'touch-pan',
          modifiers: {
            prevent: true,
            stop: true,
            mouse: true
          },
          value: this.__spectrumPan
        }]) : null
      }, [h('div', {
        style: {
          paddingBottom: '100%'
        }
      }), h('div', {
        staticClass: 'q-color-picker__spectrum-white absolute-full'
      }), h('div', {
        staticClass: 'q-color-picker__spectrum-black absolute-full'
      }), h('div', {
        staticClass: 'absolute',
        style: this.spectrumPointerStyle
      }, [this.model.hex !== void 0 ? h('div', {
        staticClass: 'q-color-picker__spectrum-circle'
      }) : null])]), h('div', {
        staticClass: 'q-color-picker__sliders'
      }, [h('div', {
        staticClass: 'q-color-picker__hue non-selectable'
      }, [h(QSlider, {
        props: {
          value: this.model.h,
          min: 0,
          max: 360,
          fillHandleAlways: true,
          readonly: this.editable !== true,
          thumbPath
        },
        on: Object(cache["b" /* default */])(this, 'hueSlide', {
          input: this.__onHueChange,
          change: val => this.__onHueChange(val, true)
        })
      })]), this.hasAlpha === true ? h('div', {
        staticClass: 'q-color-picker__alpha non-selectable'
      }, [h(QSlider, {
        props: {
          value: this.model.a,
          min: 0,
          max: 100,
          fillHandleAlways: true,
          readonly: this.editable !== true,
          thumbPath
        },
        on: Object(cache["b" /* default */])(this, 'alphaSlide', {
          input: value => this.__onNumericChange(value, 'a', 100),
          change: value => this.__onNumericChange(value, 'a', 100, void 0, true)
        })
      })]) : null])];
    },

    __getTuneTab(h) {
      const attrs = {
        inputmode: 'numeric',
        maxlength: 3,
        readonly: this.editable !== true
      };
      return [h('div', {
        staticClass: 'row items-center no-wrap'
      }, [h('div', ['R']), h(QSlider, {
        props: {
          value: this.model.r,
          min: 0,
          max: 255,
          color: 'red',
          dark: this.isDark,
          readonly: this.editable !== true
        },
        on: Object(cache["b" /* default */])(this, 'rSlide', {
          input: value => this.__onNumericChange(value, 'r', 255),
          change: value => this.__onNumericChange(value, 'r', 255, void 0, true)
        })
      }), h('input', {
        domProps: {
          value: this.model.r
        },
        attrs,
        on: Object(cache["b" /* default */])(this, 'rIn', {
          input: evt => this.__onNumericChange(evt.target.value, 'r', 255, evt),
          change: utils_event["k" /* stop */],
          blur: evt => this.__onNumericChange(evt.target.value, 'r', 255, evt, true)
        })
      })]), h('div', {
        staticClass: 'row items-center no-wrap'
      }, [h('div', ['G']), h(QSlider, {
        props: {
          value: this.model.g,
          min: 0,
          max: 255,
          color: 'green',
          dark: this.isDark,
          readonly: this.editable !== true
        },
        on: Object(cache["b" /* default */])(this, 'gSlide', {
          input: value => this.__onNumericChange(value, 'g', 255),
          change: value => this.__onNumericChange(value, 'g', 255, void 0, true)
        })
      }), h('input', {
        domProps: {
          value: this.model.g
        },
        attrs,
        on: Object(cache["b" /* default */])(this, 'gIn', {
          input: evt => this.__onNumericChange(evt.target.value, 'g', 255, evt),
          change: utils_event["k" /* stop */],
          blur: evt => this.__onNumericChange(evt.target.value, 'g', 255, evt, true)
        })
      })]), h('div', {
        staticClass: 'row items-center no-wrap'
      }, [h('div', ['B']), h(QSlider, {
        props: {
          value: this.model.b,
          min: 0,
          max: 255,
          color: 'blue',
          readonly: this.editable !== true,
          dark: this.isDark
        },
        on: Object(cache["b" /* default */])(this, 'bSlide', {
          input: value => this.__onNumericChange(value, 'b', 255),
          change: value => this.__onNumericChange(value, 'b', 255, void 0, true)
        })
      }), h('input', {
        domProps: {
          value: this.model.b
        },
        attrs,
        on: Object(cache["b" /* default */])(this, 'bIn', {
          input: evt => this.__onNumericChange(evt.target.value, 'b', 255, evt),
          change: utils_event["k" /* stop */],
          blur: evt => this.__onNumericChange(evt.target.value, 'b', 255, evt, true)
        })
      })]), this.hasAlpha === true ? h('div', {
        staticClass: 'row items-center no-wrap'
      }, [h('div', ['A']), h(QSlider, {
        props: {
          value: this.model.a,
          color: 'grey',
          readonly: this.editable !== true,
          dark: this.isDark
        },
        on: Object(cache["b" /* default */])(this, 'aSlide', {
          input: value => this.__onNumericChange(value, 'a', 100),
          change: value => this.__onNumericChange(value, 'a', 100, void 0, true)
        })
      }), h('input', {
        domProps: {
          value: this.model.a
        },
        attrs,
        on: Object(cache["b" /* default */])(this, 'aIn', {
          input: evt => this.__onNumericChange(evt.target.value, 'a', 100, evt),
          change: utils_event["k" /* stop */],
          blur: evt => this.__onNumericChange(evt.target.value, 'a', 100, evt, true)
        })
      })]) : null];
    },

    __getPaletteTab(h) {
      return [h('div', {
        staticClass: 'row items-center q-color-picker__palette-rows',
        class: this.editable === true ? 'q-color-picker__palette-rows--editable' : ''
      }, this.computedPalette.map(color => h('div', {
        staticClass: 'q-color-picker__cube col-auto',
        style: {
          backgroundColor: color
        },
        on: this.editable === true ? Object(cache["b" /* default */])(this, 'palette#' + color, {
          click: () => {
            this.__onPalettePick(color);
          }
        }) : null
      })))];
    },

    __onSpectrumChange(left, top, change) {
      const panel = this.$refs.spectrum;

      if (panel === void 0) {
        return;
      }

      const width = panel.clientWidth,
            height = panel.clientHeight,
            rect = panel.getBoundingClientRect();
      let x = Math.min(width, Math.max(0, left - rect.left));

      if (this.$q.lang.rtl === true) {
        x = width - x;
      }

      const y = Math.min(height, Math.max(0, top - rect.top)),
            s = Math.round(100 * x / width),
            v = Math.round(100 * Math.max(0, Math.min(1, -(y / height) + 1))),
            rgb = Object(colors["c" /* hsvToRgb */])({
        h: this.model.h,
        s,
        v,
        a: this.hasAlpha === true ? this.model.a : void 0
      });
      this.model.s = s;
      this.model.v = v;

      this.__update(rgb, change);
    },

    __onHueChange(h, change) {
      h = Math.round(h);
      const rgb = Object(colors["c" /* hsvToRgb */])({
        h,
        s: this.model.s,
        v: this.model.v,
        a: this.hasAlpha === true ? this.model.a : void 0
      });
      this.model.h = h;

      this.__update(rgb, change);
    },

    __onNumericChange(value, formatModel, max, evt, change) {
      evt !== void 0 && Object(utils_event["k" /* stop */])(evt);

      if (!/^[0-9]+$/.test(value)) {
        change === true && this.$forceUpdate();
        return;
      }

      const val = Math.floor(Number(value));

      if (val < 0 || val > max) {
        change === true && this.$forceUpdate();
        return;
      }

      const rgb = {
        r: formatModel === 'r' ? val : this.model.r,
        g: formatModel === 'g' ? val : this.model.g,
        b: formatModel === 'b' ? val : this.model.b,
        a: this.hasAlpha === true ? formatModel === 'a' ? val : this.model.a : void 0
      };

      if (formatModel !== 'a') {
        const hsv = Object(colors["f" /* rgbToHsv */])(rgb);
        this.model.h = hsv.h;
        this.model.s = hsv.s;
        this.model.v = hsv.v;
      }

      this.__update(rgb, change);

      if (evt !== void 0 && change !== true && evt.target.selectionEnd !== void 0) {
        const index = evt.target.selectionEnd;
        this.$nextTick(() => {
          evt.target.setSelectionRange(index, index);
        });
      }
    },

    __onEditorChange(evt, change) {
      let rgb;
      const inp = evt.target.value;
      Object(utils_event["k" /* stop */])(evt);

      if (this.topView === 'hex') {
        if (inp.length !== (this.hasAlpha === true ? 9 : 7) || !/^#[0-9A-Fa-f]+$/.test(inp)) {
          return true;
        }

        rgb = Object(colors["b" /* hexToRgb */])(inp);
      } else {
        let model;

        if (!inp.endsWith(')')) {
          return true;
        } else if (this.hasAlpha !== true && inp.startsWith('rgb(')) {
          model = inp.substring(4, inp.length - 1).split(',').map(n => parseInt(n, 10));

          if (model.length !== 3 || !/^rgb\([0-9]{1,3},[0-9]{1,3},[0-9]{1,3}\)$/.test(inp)) {
            return true;
          }
        } else if (this.hasAlpha === true && inp.startsWith('rgba(')) {
          model = inp.substring(5, inp.length - 1).split(',');

          if (model.length !== 4 || !/^rgba\([0-9]{1,3},[0-9]{1,3},[0-9]{1,3},(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/.test(inp)) {
            return true;
          }

          for (let i = 0; i < 3; i++) {
            const _v = parseInt(model[i], 10);

            if (_v < 0 || _v > 255) {
              return true;
            }

            model[i] = _v;
          }

          const v = parseFloat(model[3]);

          if (v < 0 || v > 1) {
            return true;
          }

          model[3] = v;
        } else {
          return true;
        }

        if (model[0] < 0 || model[0] > 255 || model[1] < 0 || model[1] > 255 || model[2] < 0 || model[2] > 255 || this.hasAlpha === true && (model[3] < 0 || model[3] > 1)) {
          return true;
        }

        rgb = {
          r: model[0],
          g: model[1],
          b: model[2],
          a: this.hasAlpha === true ? model[3] * 100 : void 0
        };
      }

      const hsv = Object(colors["f" /* rgbToHsv */])(rgb);
      this.model.h = hsv.h;
      this.model.s = hsv.s;
      this.model.v = hsv.v;

      this.__update(rgb, change);

      if (change !== true) {
        const index = evt.target.selectionEnd;
        this.$nextTick(() => {
          evt.target.setSelectionRange(index, index);
        });
      }
    },

    __onPalettePick(color) {
      const def = this.__parseModel(color);

      const rgb = {
        r: def.r,
        g: def.g,
        b: def.b,
        a: def.a
      };

      if (rgb.a === void 0) {
        rgb.a = this.model.a;
      }

      this.model.h = def.h;
      this.model.s = def.s;
      this.model.v = def.v;

      this.__update(rgb, true);
    },

    __update(rgb, change) {
      // update internally
      this.model.hex = Object(colors["e" /* rgbToHex */])(rgb);
      this.model.rgb = Object(colors["g" /* rgbToString */])(rgb);
      this.model.r = rgb.r;
      this.model.g = rgb.g;
      this.model.b = rgb.b;
      this.model.a = rgb.a;
      const value = this.model[this.isOutputHex === true ? 'hex' : 'rgb']; // emit new value

      this.$emit('input', value);
      change === true && this.$emit('change', value);
    },

    __updateErrorIcon(val) {
      // we MUST avoid vue triggering a render,
      // so manually changing this
      if (this.$refs.errorIcon !== void 0) {
        this.$refs.errorIcon.$el.style.opacity = val ? 1 : 0;
      }
    },

    __parseModel(v) {
      const forceAlpha = this.forceAlpha !== void 0 ? this.forceAlpha : this.formatModel === 'auto' ? null : this.formatModel.indexOf('a') > -1;

      if (typeof v !== 'string' || v.length === 0 || patterns["a" /* testPattern */].anyColor(v.replace(/ /g, '')) !== true) {
        return {
          h: 0,
          s: 0,
          v: 0,
          r: 0,
          g: 0,
          b: 0,
          a: forceAlpha === true ? 100 : void 0,
          hex: void 0,
          rgb: void 0
        };
      }

      const model = Object(colors["i" /* textToRgb */])(v);

      if (forceAlpha === true && model.a === void 0) {
        model.a = 100;
      }

      model.hex = Object(colors["e" /* rgbToHex */])(model);
      model.rgb = Object(colors["g" /* rgbToString */])(model);
      return Object.assign(model, Object(colors["f" /* rgbToHsv */])(model));
    },

    __spectrumPan(evt) {
      if (evt.isFinal) {
        this.__onSpectrumChange(evt.position.left, evt.position.top, true);
      } else {
        this.__spectrumChange(evt);
      }
    },

    // throttled in created()
    __spectrumChange(evt) {
      this.__onSpectrumChange(evt.position.left, evt.position.top);
    },

    __spectrumClick(evt) {
      this.__onSpectrumChange(evt.pageX - window.pageXOffset, evt.pageY - window.pageYOffset, true);
    },

    __activate(evt) {
      this.__onSpectrumChange(evt.pageX - window.pageXOffset, evt.pageY - window.pageYOffset);
    }

  }
}));

/***/ }),

/***/ "e01a":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("8bb2");

module.exports = function (it) {
  var result = toInteger(it);
  if (result < 0) throw RangeError("The argument can't be less than 0");
  return result;
};


/***/ }),

/***/ "e03e":
/***/ (function(module, exports, __webpack_require__) {

var userAgent = __webpack_require__("64e4");

module.exports = /(?:iphone|ipod|ipad).*applewebkit/i.test(userAgent);


/***/ }),

/***/ "e04d":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "e129":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ "e279":
/***/ (function(module, exports) {

/**
 * Quasar runtime for auto-importing
 * components or directives.
 *
 * Warning! This file does NOT get transpiled by Babel
 * but is included into the UI code.
 *
 * @param {component} Vue Component object
 * @param {type}      One of 'components' or 'directives'
 * @param {items}     Object containing components or directives
 */
module.exports = function qInstall (component, type, items) {
  var opt

  if (typeof component.exports === 'function') {
    opt = component.exports.extendOptions
    opt[type] = component.exports.options[type]
  }
  else {
    opt = component.options
  }

  if (opt[type] === void 0) {
    opt[type] = items
  }
  else {
    var target = opt[type]
    for (var i in items) {
      if (target[i] === void 0) {
        target[i] = items[i]
      }
    }
  }
}


/***/ }),

/***/ "e2a2":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return validatePosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return validateOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return parsePosition; });
/* unused harmony export validateCover */
/* unused harmony export getAnchorProps */
/* unused harmony export getTargetProps */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return setPosition; });
/* harmony import */ var _scroll_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("8047");
/* harmony import */ var _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("5094");


let vpLeft, vpTop;
function validatePosition(pos) {
  const parts = pos.split(' ');

  if (parts.length !== 2) {
    return false;
  }

  if (['top', 'center', 'bottom'].includes(parts[0]) !== true) {
    console.error('Anchor/Self position must start with one of top/center/bottom');
    return false;
  }

  if (['left', 'middle', 'right', 'start', 'end'].includes(parts[1]) !== true) {
    console.error('Anchor/Self position must end with one of left/middle/right/start/end');
    return false;
  }

  return true;
}
function validateOffset(val) {
  if (!val) {
    return true;
  }

  if (val.length !== 2) {
    return false;
  }

  if (typeof val[0] !== 'number' || typeof val[1] !== 'number') {
    return false;
  }

  return true;
}
const horizontalPos = {
  'start#ltr': 'left',
  'start#rtl': 'right',
  'end#ltr': 'right',
  'end#rtl': 'left'
};
['left', 'middle', 'right'].forEach(pos => {
  horizontalPos[`${pos}#ltr`] = pos;
  horizontalPos[`${pos}#rtl`] = pos;
});
function parsePosition(pos, rtl) {
  const parts = pos.split(' ');
  return {
    vertical: parts[0],
    horizontal: horizontalPos[`${parts[1]}#${rtl === true ? 'rtl' : 'ltr'}`]
  };
}
function validateCover(val) {
  if (val === true || val === false) {
    return true;
  }

  return validatePosition(val);
}
function getAnchorProps(el, offset) {
  let {
    top,
    left,
    right,
    bottom,
    width,
    height
  } = el.getBoundingClientRect();

  if (offset !== void 0) {
    top -= offset[1];
    left -= offset[0];
    bottom += offset[1];
    right += offset[0];
    width += offset[0];
    height += offset[1];
  }

  return {
    top,
    left,
    right,
    bottom,
    width,
    height,
    middle: left + (right - left) / 2,
    center: top + (bottom - top) / 2
  };
}
function getTargetProps(el) {
  return {
    top: 0,
    center: el.offsetHeight / 2,
    bottom: el.offsetHeight,
    left: 0,
    middle: el.offsetWidth / 2,
    right: el.offsetWidth
  };
} // cfg: { el, anchorEl, anchorOrigin, selfOrigin, offset, absoluteOffset, cover, fit, maxHeight, maxWidth }

function setPosition(cfg) {
  if (_plugins_Platform_js__WEBPACK_IMPORTED_MODULE_1__[/* client */ "a"].is.ios === true && window.visualViewport !== void 0) {
    // uses the q-position-engine CSS class
    const el = document.body.style;
    const {
      offsetLeft: left,
      offsetTop: top
    } = window.visualViewport;

    if (left !== vpLeft) {
      el.setProperty('--q-pe-left', left + 'px');
      vpLeft = left;
    }

    if (top !== vpTop) {
      el.setProperty('--q-pe-top', top + 'px');
      vpTop = top;
    }
  }

  let anchorProps; // scroll position might change
  // if max-height/-width changes, so we
  // need to restore it after we calculate
  // the new positioning

  const {
    scrollLeft,
    scrollTop
  } = cfg.el;

  if (cfg.absoluteOffset === void 0) {
    anchorProps = getAnchorProps(cfg.anchorEl, cfg.cover === true ? [0, 0] : cfg.offset);
  } else {
    const {
      top: anchorTop,
      left: anchorLeft
    } = cfg.anchorEl.getBoundingClientRect(),
          top = anchorTop + cfg.absoluteOffset.top,
          left = anchorLeft + cfg.absoluteOffset.left;
    anchorProps = {
      top,
      left,
      width: 1,
      height: 1,
      right: left + 1,
      center: top,
      middle: left,
      bottom: top + 1
    };
  }

  let elStyle = {
    maxHeight: cfg.maxHeight,
    maxWidth: cfg.maxWidth,
    visibility: 'visible'
  };

  if (cfg.fit === true || cfg.cover === true) {
    elStyle.minWidth = anchorProps.width + 'px';

    if (cfg.cover === true) {
      elStyle.minHeight = anchorProps.height + 'px';
    }
  }

  Object.assign(cfg.el.style, elStyle);
  const targetProps = getTargetProps(cfg.el),
        props = {
    top: anchorProps[cfg.anchorOrigin.vertical] - targetProps[cfg.selfOrigin.vertical],
    left: anchorProps[cfg.anchorOrigin.horizontal] - targetProps[cfg.selfOrigin.horizontal]
  };
  applyBoundaries(props, anchorProps, targetProps, cfg.anchorOrigin, cfg.selfOrigin);
  elStyle = {
    top: props.top + 'px',
    left: props.left + 'px'
  };

  if (props.maxHeight !== void 0) {
    elStyle.maxHeight = props.maxHeight + 'px';

    if (anchorProps.height > props.maxHeight) {
      elStyle.minHeight = elStyle.maxHeight;
    }
  }

  if (props.maxWidth !== void 0) {
    elStyle.maxWidth = props.maxWidth + 'px';

    if (anchorProps.width > props.maxWidth) {
      elStyle.minWidth = elStyle.maxWidth;
    }
  }

  Object.assign(cfg.el.style, elStyle); // restore scroll position

  if (cfg.el.scrollTop !== scrollTop) {
    cfg.el.scrollTop = scrollTop;
  }

  if (cfg.el.scrollLeft !== scrollLeft) {
    cfg.el.scrollLeft = scrollLeft;
  }
}

function applyBoundaries(props, anchorProps, targetProps, anchorOrigin, selfOrigin) {
  const currentHeight = targetProps.bottom,
        currentWidth = targetProps.right,
        margin = Object(_scroll_js__WEBPACK_IMPORTED_MODULE_0__[/* getScrollbarWidth */ "e"])(),
        innerHeight = window.innerHeight - margin,
        innerWidth = document.body.clientWidth;

  if (props.top < 0 || props.top + currentHeight > innerHeight) {
    if (selfOrigin.vertical === 'center') {
      props.top = anchorProps[anchorOrigin.vertical] > innerHeight / 2 ? Math.max(0, innerHeight - currentHeight) : 0;
      props.maxHeight = Math.min(currentHeight, innerHeight);
    } else if (anchorProps[anchorOrigin.vertical] > innerHeight / 2) {
      const anchorY = Math.min(innerHeight, anchorOrigin.vertical === 'center' ? anchorProps.center : anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.bottom : anchorProps.top);
      props.maxHeight = Math.min(currentHeight, anchorY);
      props.top = Math.max(0, anchorY - currentHeight);
    } else {
      props.top = Math.max(0, anchorOrigin.vertical === 'center' ? anchorProps.center : anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.top : anchorProps.bottom);
      props.maxHeight = Math.min(currentHeight, innerHeight - props.top);
    }
  }

  if (props.left < 0 || props.left + currentWidth > innerWidth) {
    props.maxWidth = Math.min(currentWidth, innerWidth);

    if (selfOrigin.horizontal === 'middle') {
      props.left = anchorProps[anchorOrigin.horizontal] > innerWidth / 2 ? Math.max(0, innerWidth - currentWidth) : 0;
    } else if (anchorProps[anchorOrigin.horizontal] > innerWidth / 2) {
      const anchorX = Math.min(innerWidth, anchorOrigin.horizontal === 'middle' ? anchorProps.middle : anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.right : anchorProps.left);
      props.maxWidth = Math.min(currentWidth, anchorX);
      props.left = Math.max(0, anchorX - props.maxWidth);
    } else {
      props.left = Math.max(0, anchorOrigin.horizontal === 'middle' ? anchorProps.middle : anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.left : anchorProps.right);
      props.maxWidth = Math.min(currentWidth, innerWidth - props.left);
    }
  }
}

/***/ }),

/***/ "e369":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray = __webpack_require__("c6de");
var toLength = __webpack_require__("b495");
var bind = __webpack_require__("2117");

// `FlattenIntoArray` abstract operation
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? bind(mapper, thisArg, 3) : false;
  var element;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      if (depth > 0 && isArray(element)) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
};

module.exports = flattenIntoArray;


/***/ }),

/***/ "e3f6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__("b7fb").charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.es/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};


/***/ }),

/***/ "e57e":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ca22");
/* harmony import */ var _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("9869");
/* harmony import */ var _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("5094");
/* harmony import */ var _icon_set_material_icons_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("cab8");




/* harmony default export */ __webpack_exports__["a"] = ({
  install($q, queues, iconSet) {
    const initialSet = iconSet || _icon_set_material_icons_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"];

    this.set = (setObject, ssrContext) => {
      const def = _Users_lucaban_ghq_github_com_CyCraft_pepicons_node_modules_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, setObject);

      if (_plugins_Platform_js__WEBPACK_IMPORTED_MODULE_2__[/* isSSR */ "f"] === true) {
        if (ssrContext === void 0) {
          console.error('SSR ERROR: second param required: Quasar.iconSet.set(iconSet, ssrContext)');
          return;
        }

        def.set = ssrContext.$q.iconSet.set;
        ssrContext.$q.iconSet = def;
      } else {
        def.set = this.set;
        $q.iconSet = def;
      }
    };

    if (_plugins_Platform_js__WEBPACK_IMPORTED_MODULE_2__[/* isSSR */ "f"] === true) {
      queues.server.push((q, ctx) => {
        q.iconSet = {};

        q.iconSet.set = setObject => {
          this.set(setObject, ctx.ssr);
        };

        q.iconSet.set(initialSet);
      });
    } else {
      vue__WEBPACK_IMPORTED_MODULE_1__["default"].util.defineReactive($q, 'iconMapFn', void 0);
      vue__WEBPACK_IMPORTED_MODULE_1__["default"].util.defineReactive($q, 'iconSet', {});
      this.set(initialSet);
    }
  }

});

/***/ }),

/***/ "e70b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SVGLoader; });
/* harmony import */ var _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("8bc7");


var SVGLoader = function ( manager ) {

	_build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Loader */ "k"].call( this, manager );

	// Default dots per inch
	this.defaultDPI = 90;

	// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'
	this.defaultUnit = 'px';

};

SVGLoader.prototype = Object.assign( Object.create( _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Loader */ "k"].prototype ), {

	constructor: SVGLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* FileLoader */ "f"]( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( text ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	},

	parse: function ( text ) {

		var scope = this;

		function parseNode( node, style ) {

			if ( node.nodeType !== 1 ) return;

			var transform = getNodeTransform( node );

			var traverseChildNodes = true;

			var path = null;

			switch ( node.nodeName ) {

				case 'svg':
					break;

				case 'style':
					parseCSSStylesheet( node );
					break;

				case 'g':
					style = parseStyle( node, style );
					break;

				case 'path':
					style = parseStyle( node, style );
					if ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );
					break;

				case 'rect':
					style = parseStyle( node, style );
					path = parseRectNode( node );
					break;

				case 'polygon':
					style = parseStyle( node, style );
					path = parsePolygonNode( node );
					break;

				case 'polyline':
					style = parseStyle( node, style );
					path = parsePolylineNode( node );
					break;

				case 'circle':
					style = parseStyle( node, style );
					path = parseCircleNode( node );
					break;

				case 'ellipse':
					style = parseStyle( node, style );
					path = parseEllipseNode( node );
					break;

				case 'line':
					style = parseStyle( node, style );
					path = parseLineNode( node );
					break;

				case 'defs':
					traverseChildNodes = false;
					break;

				case 'use':
					style = parseStyle( node, style );
					var usedNodeId = node.href.baseVal.substring( 1 );
					var usedNode = node.viewportElement.getElementById( usedNodeId );
					if ( usedNode ) {

						parseNode( usedNode, style );

					} else {

						console.warn( 'SVGLoader: \'use node\' references non-existent node id: ' + usedNodeId );

					}

					break;

				default:
					// console.log( node );

			}

			if ( path ) {

				if ( style.fill !== undefined && style.fill !== 'none' ) {

					path.color.setStyle( style.fill );

				}

				transformPath( path, currentTransform );

				paths.push( path );

				path.userData = { node: node, style: style };

			}

			if ( traverseChildNodes ) {

				var nodes = node.childNodes;

				for ( var i = 0; i < nodes.length; i ++ ) {

					parseNode( nodes[ i ], style );

				}

			}

			if ( transform ) {

				transformStack.pop();

				if ( transformStack.length > 0 ) {

					currentTransform.copy( transformStack[ transformStack.length - 1 ] );

				} else {

					currentTransform.identity();

				}

			}

		}

		function parsePathNode( node ) {

			var path = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* ShapePath */ "t"]();

			var point = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
			var control = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();

			var firstPoint = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
			var isFirstPoint = true;
			var doSetFirstPoint = false;

			var d = node.getAttribute( 'd' );

			// console.log( d );

			var commands = d.match( /[a-df-z][^a-df-z]*/ig );

			for ( var i = 0, l = commands.length; i < l; i ++ ) {

				var command = commands[ i ];

				var type = command.charAt( 0 );
				var data = command.substr( 1 ).trim();

				if ( isFirstPoint === true ) {

					doSetFirstPoint = true;
					isFirstPoint = false;

				}

				switch ( type ) {

					case 'M':
						var numbers = parseFloats( data );
						for ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {

							point.x = numbers[ j + 0 ];
							point.y = numbers[ j + 1 ];
							control.x = point.x;
							control.y = point.y;

							if ( j === 0 ) {

								path.moveTo( point.x, point.y );

							} else {

								path.lineTo( point.x, point.y );

							}

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'H':
						var numbers = parseFloats( data );

						for ( var j = 0, jl = numbers.length; j < jl; j ++ ) {

							point.x = numbers[ j ];
							control.x = point.x;
							control.y = point.y;
							path.lineTo( point.x, point.y );

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'V':
						var numbers = parseFloats( data );

						for ( var j = 0, jl = numbers.length; j < jl; j ++ ) {

							point.y = numbers[ j ];
							control.x = point.x;
							control.y = point.y;
							path.lineTo( point.x, point.y );

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'L':
						var numbers = parseFloats( data );

						for ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {

							point.x = numbers[ j + 0 ];
							point.y = numbers[ j + 1 ];
							control.x = point.x;
							control.y = point.y;
							path.lineTo( point.x, point.y );

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'C':
						var numbers = parseFloats( data );

						for ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {

							path.bezierCurveTo(
								numbers[ j + 0 ],
								numbers[ j + 1 ],
								numbers[ j + 2 ],
								numbers[ j + 3 ],
								numbers[ j + 4 ],
								numbers[ j + 5 ]
							);
							control.x = numbers[ j + 2 ];
							control.y = numbers[ j + 3 ];
							point.x = numbers[ j + 4 ];
							point.y = numbers[ j + 5 ];

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'S':
						var numbers = parseFloats( data );

						for ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {

							path.bezierCurveTo(
								getReflection( point.x, control.x ),
								getReflection( point.y, control.y ),
								numbers[ j + 0 ],
								numbers[ j + 1 ],
								numbers[ j + 2 ],
								numbers[ j + 3 ]
							);
							control.x = numbers[ j + 0 ];
							control.y = numbers[ j + 1 ];
							point.x = numbers[ j + 2 ];
							point.y = numbers[ j + 3 ];

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'Q':
						var numbers = parseFloats( data );

						for ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {

							path.quadraticCurveTo(
								numbers[ j + 0 ],
								numbers[ j + 1 ],
								numbers[ j + 2 ],
								numbers[ j + 3 ]
							);
							control.x = numbers[ j + 0 ];
							control.y = numbers[ j + 1 ];
							point.x = numbers[ j + 2 ];
							point.y = numbers[ j + 3 ];

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'T':
						var numbers = parseFloats( data );

						for ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {

							var rx = getReflection( point.x, control.x );
							var ry = getReflection( point.y, control.y );
							path.quadraticCurveTo(
								rx,
								ry,
								numbers[ j + 0 ],
								numbers[ j + 1 ]
							);
							control.x = rx;
							control.y = ry;
							point.x = numbers[ j + 0 ];
							point.y = numbers[ j + 1 ];

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'A':
						var numbers = parseFloats( data, [ 3, 4 ], 7 );

						for ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {

							// skip command if start point == end point
							if ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;

							var start = point.clone();
							point.x = numbers[ j + 5 ];
							point.y = numbers[ j + 6 ];
							control.x = point.x;
							control.y = point.y;
							parseArcCommand(
								path, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point
							);

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'm':
						var numbers = parseFloats( data );

						for ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {

							point.x += numbers[ j + 0 ];
							point.y += numbers[ j + 1 ];
							control.x = point.x;
							control.y = point.y;

							if ( j === 0 ) {

								path.moveTo( point.x, point.y );

							} else {

								path.lineTo( point.x, point.y );

							}

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'h':
						var numbers = parseFloats( data );

						for ( var j = 0, jl = numbers.length; j < jl; j ++ ) {

							point.x += numbers[ j ];
							control.x = point.x;
							control.y = point.y;
							path.lineTo( point.x, point.y );

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'v':
						var numbers = parseFloats( data );

						for ( var j = 0, jl = numbers.length; j < jl; j ++ ) {

							point.y += numbers[ j ];
							control.x = point.x;
							control.y = point.y;
							path.lineTo( point.x, point.y );

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'l':
						var numbers = parseFloats( data );

						for ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {

							point.x += numbers[ j + 0 ];
							point.y += numbers[ j + 1 ];
							control.x = point.x;
							control.y = point.y;
							path.lineTo( point.x, point.y );

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'c':
						var numbers = parseFloats( data );

						for ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {

							path.bezierCurveTo(
								point.x + numbers[ j + 0 ],
								point.y + numbers[ j + 1 ],
								point.x + numbers[ j + 2 ],
								point.y + numbers[ j + 3 ],
								point.x + numbers[ j + 4 ],
								point.y + numbers[ j + 5 ]
							);
							control.x = point.x + numbers[ j + 2 ];
							control.y = point.y + numbers[ j + 3 ];
							point.x += numbers[ j + 4 ];
							point.y += numbers[ j + 5 ];

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 's':
						var numbers = parseFloats( data );

						for ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {

							path.bezierCurveTo(
								getReflection( point.x, control.x ),
								getReflection( point.y, control.y ),
								point.x + numbers[ j + 0 ],
								point.y + numbers[ j + 1 ],
								point.x + numbers[ j + 2 ],
								point.y + numbers[ j + 3 ]
							);
							control.x = point.x + numbers[ j + 0 ];
							control.y = point.y + numbers[ j + 1 ];
							point.x += numbers[ j + 2 ];
							point.y += numbers[ j + 3 ];

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'q':
						var numbers = parseFloats( data );

						for ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {

							path.quadraticCurveTo(
								point.x + numbers[ j + 0 ],
								point.y + numbers[ j + 1 ],
								point.x + numbers[ j + 2 ],
								point.y + numbers[ j + 3 ]
							);
							control.x = point.x + numbers[ j + 0 ];
							control.y = point.y + numbers[ j + 1 ];
							point.x += numbers[ j + 2 ];
							point.y += numbers[ j + 3 ];

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 't':
						var numbers = parseFloats( data );

						for ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {

							var rx = getReflection( point.x, control.x );
							var ry = getReflection( point.y, control.y );
							path.quadraticCurveTo(
								rx,
								ry,
								point.x + numbers[ j + 0 ],
								point.y + numbers[ j + 1 ]
							);
							control.x = rx;
							control.y = ry;
							point.x = point.x + numbers[ j + 0 ];
							point.y = point.y + numbers[ j + 1 ];

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'a':
						var numbers = parseFloats( data, [ 3, 4 ], 7 );

						for ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {

							// skip command if no displacement
							if ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;

							var start = point.clone();
							point.x += numbers[ j + 5 ];
							point.y += numbers[ j + 6 ];
							control.x = point.x;
							control.y = point.y;
							parseArcCommand(
								path, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point
							);

							if ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );

						}

						break;

					case 'Z':
					case 'z':
						path.currentPath.autoClose = true;

						if ( path.currentPath.curves.length > 0 ) {

							// Reset point to beginning of Path
							point.copy( firstPoint );
							path.currentPath.currentPoint.copy( point );
							isFirstPoint = true;

						}

						break;

					default:
						console.warn( command );

				}

				// console.log( type, parseFloats( data ), parseFloats( data ).length  )

				doSetFirstPoint = false;

			}

			return path;

		}

		function parseCSSStylesheet( node ) {

			if ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;

			for ( var i = 0; i < node.sheet.cssRules.length; i ++ ) {

				var stylesheet = node.sheet.cssRules[ i ];

				if ( stylesheet.type !== 1 ) continue;

				var selectorList = stylesheet.selectorText
					.split( /,/gm )
					.filter( Boolean )
					.map( i => i.trim() );

				for ( var j = 0; j < selectorList.length; j ++ ) {

					stylesheets[ selectorList[ j ] ] = Object.assign(
						stylesheets[ selectorList[ j ] ] || {},
						stylesheet.style
					);

				}

			}

		}

		/**
		 * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
		 * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion
		 * From
		 * rx ry x-axis-rotation large-arc-flag sweep-flag x y
		 * To
		 * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation
		 */

		function parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {

			if ( rx == 0 || ry == 0 ) {

				// draw a line if either of the radii == 0
				path.lineTo( end.x, end.y );
				return;

			}

			x_axis_rotation = x_axis_rotation * Math.PI / 180;

			// Ensure radii are positive
			rx = Math.abs( rx );
			ry = Math.abs( ry );

			// Compute (x1', y1')
			var dx2 = ( start.x - end.x ) / 2.0;
			var dy2 = ( start.y - end.y ) / 2.0;
			var x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;
			var y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;

			// Compute (cx', cy')
			var rxs = rx * rx;
			var rys = ry * ry;
			var x1ps = x1p * x1p;
			var y1ps = y1p * y1p;

			// Ensure radii are large enough
			var cr = x1ps / rxs + y1ps / rys;

			if ( cr > 1 ) {

				// scale up rx,ry equally so cr == 1
				var s = Math.sqrt( cr );
				rx = s * rx;
				ry = s * ry;
				rxs = rx * rx;
				rys = ry * ry;

			}

			var dq = ( rxs * y1ps + rys * x1ps );
			var pq = ( rxs * rys - dq ) / dq;
			var q = Math.sqrt( Math.max( 0, pq ) );
			if ( large_arc_flag === sweep_flag ) q = - q;
			var cxp = q * rx * y1p / ry;
			var cyp = - q * ry * x1p / rx;

			// Step 3: Compute (cx, cy) from (cx', cy')
			var cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;
			var cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;

			// Step 4: Compute 1 and 
			var theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );
			var delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );

			path.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );

		}

		function svgAngle( ux, uy, vx, vy ) {

			var dot = ux * vx + uy * vy;
			var len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );
			var ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear
			if ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;
			return ang;

		}

		/*
		* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute
		* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough
		*/
		function parseRectNode( node ) {

			var x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );
			var y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );
			var rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );
			var ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );
			var w = parseFloatWithUnits( node.getAttribute( 'width' ) );
			var h = parseFloatWithUnits( node.getAttribute( 'height' ) );

			var path = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* ShapePath */ "t"]();
			path.moveTo( x + 2 * rx, y );
			path.lineTo( x + w - 2 * rx, y );
			if ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y, x + w, y, x + w, y + 2 * ry );
			path.lineTo( x + w, y + h - 2 * ry );
			if ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h );
			path.lineTo( x + 2 * rx, y + h );

			if ( rx !== 0 || ry !== 0 ) {

				path.bezierCurveTo( x, y + h, x, y + h, x, y + h - 2 * ry );

			}

			path.lineTo( x, y + 2 * ry );

			if ( rx !== 0 || ry !== 0 ) {

				path.bezierCurveTo( x, y, x, y, x + 2 * rx, y );

			}

			return path;

		}

		function parsePolygonNode( node ) {

			function iterator( match, a, b ) {

				var x = parseFloatWithUnits( a );
				var y = parseFloatWithUnits( b );

				if ( index === 0 ) {

					path.moveTo( x, y );

				} else {

					path.lineTo( x, y );

				}

				index ++;

			}

			var regex = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g;

			var path = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* ShapePath */ "t"]();

			var index = 0;

			node.getAttribute( 'points' ).replace( regex, iterator );

			path.currentPath.autoClose = true;

			return path;

		}

		function parsePolylineNode( node ) {

			function iterator( match, a, b ) {

				var x = parseFloatWithUnits( a );
				var y = parseFloatWithUnits( b );

				if ( index === 0 ) {

					path.moveTo( x, y );

				} else {

					path.lineTo( x, y );

				}

				index ++;

			}

			var regex = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g;

			var path = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* ShapePath */ "t"]();

			var index = 0;

			node.getAttribute( 'points' ).replace( regex, iterator );

			path.currentPath.autoClose = false;

			return path;

		}

		function parseCircleNode( node ) {

			var x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );
			var y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );
			var r = parseFloatWithUnits( node.getAttribute( 'r' ) || 0 );

			var subpath = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Path */ "o"]();
			subpath.absarc( x, y, r, 0, Math.PI * 2 );

			var path = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* ShapePath */ "t"]();
			path.subPaths.push( subpath );

			return path;

		}

		function parseEllipseNode( node ) {

			var x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );
			var y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );
			var rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );
			var ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );

			var subpath = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Path */ "o"]();
			subpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );

			var path = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* ShapePath */ "t"]();
			path.subPaths.push( subpath );

			return path;

		}

		function parseLineNode( node ) {

			var x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) || 0 );
			var y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) || 0 );
			var x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) || 0 );
			var y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) || 0 );

			var path = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* ShapePath */ "t"]();
			path.moveTo( x1, y1 );
			path.lineTo( x2, y2 );
			path.currentPath.autoClose = false;

			return path;

		}

		//

		function parseStyle( node, style ) {

			style = Object.assign( {}, style ); // clone style

			var stylesheetStyles = {};

			if ( node.hasAttribute( 'class' ) ) {

				var classSelectors = node.getAttribute( 'class' )
					.split( /\s/ )
					.filter( Boolean )
					.map( i => i.trim() );

				for ( var i = 0; i < classSelectors.length; i ++ ) {

					stylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );

				}

			}

			if ( node.hasAttribute( 'id' ) ) {

				stylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );

			}

			function addStyle( svgName, jsName, adjustFunction ) {

				if ( adjustFunction === undefined ) adjustFunction = function copy( v ) {

					if ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );

					return v;

				};

				if ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );
				if ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );
				if ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );

			}

			function clamp( v ) {

				return Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );

			}

			function positive( v ) {

				return Math.max( 0, parseFloatWithUnits( v ) );

			}

			addStyle( 'fill', 'fill' );
			addStyle( 'fill-opacity', 'fillOpacity', clamp );
			addStyle( 'opacity', 'opacity', clamp );
			addStyle( 'stroke', 'stroke' );
			addStyle( 'stroke-opacity', 'strokeOpacity', clamp );
			addStyle( 'stroke-width', 'strokeWidth', positive );
			addStyle( 'stroke-linejoin', 'strokeLineJoin' );
			addStyle( 'stroke-linecap', 'strokeLineCap' );
			addStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );
			addStyle( 'visibility', 'visibility' );

			return style;

		}

		// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes

		function getReflection( a, b ) {

			return a - ( b - a );

		}

		// from https://github.com/ppvg/svg-numbers (MIT License)

		function parseFloats( input, flags, stride ) {

			if ( typeof input !== 'string' ) {

				throw new TypeError( 'Invalid input: ' + typeof input );

			}

			// Character groups
			var RE = {
				SEPARATOR: /[ \t\r\n\,.\-+]/,
				WHITESPACE: /[ \t\r\n]/,
				DIGIT: /[\d]/,
				SIGN: /[-+]/,
				POINT: /\./,
				COMMA: /,/,
				EXP: /e/i,
				FLAGS: /[01]/
			};

			// States
			var SEP = 0;
			var INT = 1;
			var FLOAT = 2;
			var EXP = 3;

			var state = SEP;
			var seenComma = true;
			var result = [], number = '', exponent = '';

			function throwSyntaxError( current, i, partial ) {

				var error = new SyntaxError( 'Unexpected character "' + current + '" at index ' + i + '.' );
				error.partial = partial;
				throw error;

			}

			function newNumber() {

				if ( number !== '' ) {

					if ( exponent === '' ) result.push( Number( number ) );
					else result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) );

				}

				number = '';
				exponent = '';

			}

			var current, i = 0, length = input.length;
			for ( i = 0; i < length; i ++ ) {

				current = input[ i ];

				// check for flags
				if ( Array.isArray( flags ) && flags.includes( result.length % stride ) && RE.FLAGS.test( current ) ) {

					state = INT;
					number = current;
					newNumber();
					continue;

				}

				// parse until next number
				if ( state === SEP ) {

					// eat whitespace
					if ( RE.WHITESPACE.test( current ) ) {

						continue;

					}

					// start new number
					if ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) {

						state = INT;
						number = current;
						continue;

					}

					if ( RE.POINT.test( current ) ) {

						state = FLOAT;
						number = current;
						continue;

					}

					// throw on double commas (e.g. "1, , 2")
					if ( RE.COMMA.test( current ) ) {

						if ( seenComma ) {

							throwSyntaxError( current, i, result );

						}

						seenComma = true;

					}

				}

				// parse integer part
				if ( state === INT ) {

					if ( RE.DIGIT.test( current ) ) {

						number += current;
						continue;

					}

					if ( RE.POINT.test( current ) ) {

						number += current;
						state = FLOAT;
						continue;

					}

					if ( RE.EXP.test( current ) ) {

						state = EXP;
						continue;

					}

					// throw on double signs ("-+1"), but not on sign as separator ("-1-2")
					if ( RE.SIGN.test( current )
							&& number.length === 1
							&& RE.SIGN.test( number[ 0 ] ) ) {

						throwSyntaxError( current, i, result );

					}

				}

				// parse decimal part
				if ( state === FLOAT ) {

					if ( RE.DIGIT.test( current ) ) {

						number += current;
						continue;

					}

					if ( RE.EXP.test( current ) ) {

						state = EXP;
						continue;

					}

					// throw on double decimal points (e.g. "1..2")
					if ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) {

						throwSyntaxError( current, i, result );

					}

				}

				// parse exponent part
				if ( state === EXP ) {

					if ( RE.DIGIT.test( current ) ) {

						exponent += current;
						continue;

					}

					if ( RE.SIGN.test( current ) ) {

						if ( exponent === '' ) {

							exponent += current;
							continue;

						}

						if ( exponent.length === 1 && RE.SIGN.test( exponent ) ) {

							throwSyntaxError( current, i, result );

						}

					}

				}


				// end of number
				if ( RE.WHITESPACE.test( current ) ) {

					newNumber();
					state = SEP;
					seenComma = false;

				} else if ( RE.COMMA.test( current ) ) {

					newNumber();
					state = SEP;
					seenComma = true;

				} else if ( RE.SIGN.test( current ) ) {

					newNumber();
					state = INT;
					number = current;

				} else if ( RE.POINT.test( current ) ) {

					newNumber();
					state = FLOAT;
					number = current;

				} else {

					throwSyntaxError( current, i, result );

				}

			}

			// add the last number found (if any)
			newNumber();

			return result;

		}

		// Units

		var units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];

		// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)
		var unitConversion = {

			'mm': {
				'mm': 1,
				'cm': 0.1,
				'in': 1 / 25.4,
				'pt': 72 / 25.4,
				'pc': 6 / 25.4,
				'px': - 1
			},
			'cm': {
				'mm': 10,
				'cm': 1,
				'in': 1 / 2.54,
				'pt': 72 / 2.54,
				'pc': 6 / 2.54,
				'px': - 1
			},
			'in': {
				'mm': 25.4,
				'cm': 2.54,
				'in': 1,
				'pt': 72,
				'pc': 6,
				'px': - 1
			},
			'pt': {
				'mm': 25.4 / 72,
				'cm': 2.54 / 72,
				'in': 1 / 72,
				'pt': 1,
				'pc': 6 / 72,
				'px': - 1
			},
			'pc': {
				'mm': 25.4 / 6,
				'cm': 2.54 / 6,
				'in': 1 / 6,
				'pt': 72 / 6,
				'pc': 1,
				'px': - 1
			},
			'px': {
				'px': 1
			}

		};

		function parseFloatWithUnits( string ) {

			var theUnit = 'px';

			if ( typeof string === 'string' || string instanceof String ) {

				for ( var i = 0, n = units.length; i < n; i ++ ) {

					var u = units[ i ];

					if ( string.endsWith( u ) ) {

						theUnit = u;
						string = string.substring( 0, string.length - u.length );
						break;

					}

				}

			}

			var scale = undefined;

			if ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {

				// Conversion scale from  pixels to inches, then to default units

				scale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;

			} else {

				scale = unitConversion[ theUnit ][ scope.defaultUnit ];

				if ( scale < 0 ) {

					// Conversion scale to pixels

					scale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;

				}

			}

			return scale * parseFloat( string );

		}

		// Transforms

		function getNodeTransform( node ) {

			if ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {

				return null;

			}

			var transform = parseNodeTransform( node );

			if ( transformStack.length > 0 ) {

				transform.premultiply( transformStack[ transformStack.length - 1 ] );

			}

			currentTransform.copy( transform );
			transformStack.push( transform );

			return transform;

		}

		function parseNodeTransform( node ) {

			var transform = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Matrix3 */ "l"]();
			var currentTransform = tempTransform0;

			if ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {

				var tx = parseFloatWithUnits( node.getAttribute( 'x' ) );
				var ty = parseFloatWithUnits( node.getAttribute( 'y' ) );

				transform.translate( tx, ty );

			}

			if ( node.hasAttribute( 'transform' ) ) {

				var transformsTexts = node.getAttribute( 'transform' ).split( ')' );

				for ( var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {

					var transformText = transformsTexts[ tIndex ].trim();

					if ( transformText === '' ) continue;

					var openParPos = transformText.indexOf( '(' );
					var closeParPos = transformText.length;

					if ( openParPos > 0 && openParPos < closeParPos ) {

						var transformType = transformText.substr( 0, openParPos );

						var array = parseFloats( transformText.substr( openParPos + 1, closeParPos - openParPos - 1 ) );

						currentTransform.identity();

						switch ( transformType ) {

							case 'translate':

								if ( array.length >= 1 ) {

									var tx = array[ 0 ];
									var ty = tx;

									if ( array.length >= 2 ) {

										ty = array[ 1 ];

									}

									currentTransform.translate( tx, ty );

								}

								break;

							case 'rotate':

								if ( array.length >= 1 ) {

									var angle = 0;
									var cx = 0;
									var cy = 0;

									// Angle
									angle = - array[ 0 ] * Math.PI / 180;

									if ( array.length >= 3 ) {

										// Center x, y
										cx = array[ 1 ];
										cy = array[ 2 ];

									}

									// Rotate around center (cx, cy)
									tempTransform1.identity().translate( - cx, - cy );
									tempTransform2.identity().rotate( angle );
									tempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );
									tempTransform1.identity().translate( cx, cy );
									currentTransform.multiplyMatrices( tempTransform1, tempTransform3 );

								}

								break;

							case 'scale':

								if ( array.length >= 1 ) {

									var scaleX = array[ 0 ];
									var scaleY = scaleX;

									if ( array.length >= 2 ) {

										scaleY = array[ 1 ];

									}

									currentTransform.scale( scaleX, scaleY );

								}

								break;

							case 'skewX':

								if ( array.length === 1 ) {

									currentTransform.set(
										1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,
										0, 1, 0,
										0, 0, 1
									);

								}

								break;

							case 'skewY':

								if ( array.length === 1 ) {

									currentTransform.set(
										1, 0, 0,
										Math.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,
										0, 0, 1
									);

								}

								break;

							case 'matrix':

								if ( array.length === 6 ) {

									currentTransform.set(
										array[ 0 ], array[ 2 ], array[ 4 ],
										array[ 1 ], array[ 3 ], array[ 5 ],
										0, 0, 1
									);

								}

								break;

						}

					}

					transform.premultiply( currentTransform );

				}

			}

			return transform;

		}

		function transformPath( path, m ) {

			function transfVec2( v2 ) {

				tempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );

				v2.set( tempV3.x, tempV3.y );

			}

			var isRotated = isTransformRotated( m );

			var subPaths = path.subPaths;

			for ( var i = 0, n = subPaths.length; i < n; i ++ ) {

				var subPath = subPaths[ i ];
				var curves = subPath.curves;

				for ( var j = 0; j < curves.length; j ++ ) {

					var curve = curves[ j ];

					if ( curve.isLineCurve ) {

						transfVec2( curve.v1 );
						transfVec2( curve.v2 );

					} else if ( curve.isCubicBezierCurve ) {

						transfVec2( curve.v0 );
						transfVec2( curve.v1 );
						transfVec2( curve.v2 );
						transfVec2( curve.v3 );

					} else if ( curve.isQuadraticBezierCurve ) {

						transfVec2( curve.v0 );
						transfVec2( curve.v1 );
						transfVec2( curve.v2 );

					} else if ( curve.isEllipseCurve ) {

						if ( isRotated ) {

							console.warn( 'SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.' );

						}

						tempV2.set( curve.aX, curve.aY );
						transfVec2( tempV2 );
						curve.aX = tempV2.x;
						curve.aY = tempV2.y;

						curve.xRadius *= getTransformScaleX( m );
						curve.yRadius *= getTransformScaleY( m );

					}

				}

			}

		}

		function isTransformRotated( m ) {

			return m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;

		}

		function getTransformScaleX( m ) {

			var te = m.elements;
			return Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );

		}

		function getTransformScaleY( m ) {

			var te = m.elements;
			return Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );

		}

		//

		var paths = [];
		var stylesheets = {};

		var transformStack = [];

		var tempTransform0 = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Matrix3 */ "l"]();
		var tempTransform1 = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Matrix3 */ "l"]();
		var tempTransform2 = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Matrix3 */ "l"]();
		var tempTransform3 = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Matrix3 */ "l"]();
		var tempV2 = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
		var tempV3 = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector3 */ "w"]();

		var currentTransform = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Matrix3 */ "l"]();

		var xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml

		parseNode( xml.documentElement, {
			fill: '#000',
			fillOpacity: 1,
			strokeOpacity: 1,
			strokeWidth: 1,
			strokeLineJoin: 'miter',
			strokeLineCap: 'butt',
			strokeMiterLimit: 4
		} );

		var data = { paths: paths, xml: xml.documentElement };

		// console.log( paths );
		return data;

	}

} );

SVGLoader.createShapes = function ( shapePath ) {

	// Param shapePath: a shapepath as returned by the parse function of this class
	// Returns Shape object

	const BIGNUMBER = 999999999;

	const IntersectionLocationType = {
		ORIGIN: 0,
		DESTINATION: 1,
		BETWEEN: 2,
		LEFT: 3,
		RIGHT: 4,
		BEHIND: 5,
		BEYOND: 6
	};

	const classifyResult = {
		loc: IntersectionLocationType.ORIGIN,
		t: 0
	};

	function findEdgeIntersection( a0, a1, b0, b1 ) {

		var x1 = a0.x;
		var x2 = a1.x;
		var x3 = b0.x;
		var x4 = b1.x;
		var y1 = a0.y;
		var y2 = a1.y;
		var y3 = b0.y;
		var y4 = b1.y;
		var nom1 = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );
		var nom2 = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );
		var denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );
		var t1 = nom1 / denom;
		var t2 = nom2 / denom;

		if ( ( ( denom === 0 ) && ( nom1 !== 0 ) ) || ( t1 <= 0 ) || ( t1 >= 1 ) || ( t2 < 0 ) || ( t2 > 1 ) ) {

			//1. lines are parallel or edges don't intersect

			return null;

		} else if ( ( nom1 === 0 ) && ( denom === 0 ) ) {

			//2. lines are colinear

			//check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)
			for ( var i = 0; i < 2; i ++ ) {

				classifyPoint( i === 0 ? b0 : b1, a0, a1 );
				//find position of this endpoints relatively to edge1
				if ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {

					var point = ( i === 0 ? b0 : b1 );
					return { x: point.x, y: point.y, t: classifyResult.t };

				} else if ( classifyResult.loc == IntersectionLocationType.BETWEEN ) {

					var x = + ( ( x1 + classifyResult.t * ( x2 - x1 ) ).toPrecision( 10 ) );
					var y = + ( ( y1 + classifyResult.t * ( y2 - y1 ) ).toPrecision( 10 ) );
					return { x: x, y: y, t: classifyResult.t, };

				}

			}

			return null;

		} else {

			//3. edges intersect

			for ( var i = 0; i < 2; i ++ ) {

				classifyPoint( i === 0 ? b0 : b1, a0, a1 );

				if ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {

					var point = ( i === 0 ? b0 : b1 );
					return { x: point.x, y: point.y, t: classifyResult.t };

				}

			}

			var x = + ( ( x1 + t1 * ( x2 - x1 ) ).toPrecision( 10 ) );
			var y = + ( ( y1 + t1 * ( y2 - y1 ) ).toPrecision( 10 ) );
			return { x: x, y: y, t: t1 };

		}

	}

	function classifyPoint( p, edgeStart, edgeEnd ) {

		var ax = edgeEnd.x - edgeStart.x;
		var ay = edgeEnd.y - edgeStart.y;
		var bx = p.x - edgeStart.x;
		var by = p.y - edgeStart.y;
		var sa = ax * by - bx * ay;

		if ( ( p.x === edgeStart.x ) && ( p.y === edgeStart.y ) ) {

			classifyResult.loc = IntersectionLocationType.ORIGIN;
			classifyResult.t = 0;
			return;

		}

		if ( ( p.x === edgeEnd.x ) && ( p.y === edgeEnd.y ) ) {

			classifyResult.loc = IntersectionLocationType.DESTINATION;
			classifyResult.t = 1;
			return;

		}

		if ( sa < - Number.EPSILON ) {

			classifyResult.loc = IntersectionLocationType.LEFT;
			return;

		}

		if ( sa > Number.EPSILON ) {

			classifyResult.loc = IntersectionLocationType.RIGHT;
			return;


		}

		if ( ( ( ax * bx ) < 0 ) || ( ( ay * by ) < 0 ) ) {

			classifyResult.loc = IntersectionLocationType.BEHIND;
			return;

		}

		if ( ( Math.sqrt( ax * ax + ay * ay ) ) < ( Math.sqrt( bx * bx + by * by ) ) ) {

			classifyResult.loc = IntersectionLocationType.BEYOND;
			return;

		}

		var t;

		if ( ax !== 0 ) {

			t = bx / ax;

		} else {

			t = by / ay;

		}

		classifyResult.loc = IntersectionLocationType.BETWEEN;
		classifyResult.t = t;

	}

	function getIntersections( path1, path2 ) {

		const intersectionsRaw = [];
		const intersections = [];

		for ( let index = 1; index < path1.length; index ++ ) {

			const path1EdgeStart = path1[ index - 1 ];
			const path1EdgeEnd = path1[ index ];

			for ( let index2 = 1; index2 < path2.length; index2 ++ ) {

				const path2EdgeStart = path2[ index2 - 1 ];
				const path2EdgeEnd = path2[ index2 ];

				const intersection = findEdgeIntersection( path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd );

				if ( intersection !== null && intersectionsRaw.find( i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON ) === undefined ) {

					intersectionsRaw.push( intersection );
					intersections.push( new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]( intersection.x, intersection.y ) );

				}

			}

		}

		return intersections;

	}

	function getScanlineIntersections( scanline, boundingBox, paths ) {

		const center = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
		boundingBox.getCenter( center );

		const allIntersections = [];

		paths.forEach( path => {

			// check if the center of the bounding box is in the bounding box of the paths.
			// this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.
			// if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.
			if ( path.boundingBox.containsPoint( center ) ) {

				const intersections = getIntersections( scanline, path.points );

				intersections.forEach( p => {

					allIntersections.push( { identifier: path.identifier, isCW: path.isCW, point: p } );

				} );

			}

		} );

		allIntersections.sort( ( i1, i2 ) => {

			return i1.point.x - i2.point.x;

		} );

		return allIntersections;

	}

	function isHoleTo( simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule ) {

		if ( _fillRule === null || _fillRule === undefined || _fillRule === '' ) {

			_fillRule = 'nonzero';

		}

		const centerBoundingBox = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
		simplePath.boundingBox.getCenter( centerBoundingBox );

		const scanline = [ new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]( scanlineMinX, centerBoundingBox.y ), new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]( scanlineMaxX, centerBoundingBox.y ) ];

		const scanlineIntersections = getScanlineIntersections( scanline, simplePath.boundingBox, allPaths );

		scanlineIntersections.sort( ( i1, i2 ) => {

			return i1.point.x - i2.point.x;

		} );

		const baseIntersections = [];
		const otherIntersections = [];

		scanlineIntersections.forEach( i => {

			if ( i.identifier === simplePath.identifier ) {

				baseIntersections.push( i );

			} else {

				otherIntersections.push( i );

			}

		} );

		const firstXOfPath = baseIntersections[ 0 ].point.x;

		// build up the path hierarchy
		const stack = [];
		let i = 0;

		while ( i < otherIntersections.length && otherIntersections[ i ].point.x < firstXOfPath ) {

			if ( stack.length > 0 && stack[ stack.length - 1 ] === otherIntersections[ i ].identifier ) {

				stack.pop();

			} else {

				stack.push( otherIntersections[ i ].identifier );

			}

			i ++;

		}

		stack.push( simplePath.identifier );

		if ( _fillRule === 'evenodd' ) {

			const isHole = stack.length % 2 === 0 ? true : false;
			const isHoleFor = stack[ stack.length - 2 ];

			return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };

		} else if ( _fillRule === 'nonzero' ) {

			// check if path is a hole by counting the amount of paths with alternating rotations it has to cross.
			let isHole = true;
			let isHoleFor = null;
			let lastCWValue = null;

			for ( let i = 0; i < stack.length; i ++ ) {

				const identifier = stack[ i ];
				if ( isHole ) {

					lastCWValue = allPaths[ identifier ].isCW;
					isHole = false;
					isHoleFor = identifier;

				} else if ( lastCWValue !== allPaths[ identifier ].isCW ) {

					lastCWValue = allPaths[ identifier ].isCW;
					isHole = true;

				}

			}

			return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };

		} else {

			console.warn( 'fill-rule: "' + _fillRule + '" is currently not implemented.' );

		}

	}

	// check for self intersecting paths
	// TODO

	// check intersecting paths
	// TODO

	// prepare paths for hole detection
	let identifier = 0;

	let scanlineMinX = BIGNUMBER;
	let scanlineMaxX = - BIGNUMBER;

	let simplePaths = shapePath.subPaths.map( p => {

		const points = p.getPoints();
		let maxY = - BIGNUMBER;
		let minY = BIGNUMBER;
		let maxX = - BIGNUMBER;
		let minX = BIGNUMBER;

      	//points.forEach(p => p.y *= -1);

		for ( let i = 0; i < points.length; i ++ ) {

			const p = points[ i ];

			if ( p.y > maxY ) {

				maxY = p.y;

			}

			if ( p.y < minY ) {

				minY = p.y;

			}

			if ( p.x > maxX ) {

				maxX = p.x;

			}

			if ( p.x < minX ) {

				minX = p.x;

			}

		}

		//
		if ( scanlineMaxX <= maxX ) {

			scanlineMaxX = maxX + 1;

		}

		if ( scanlineMinX >= minX ) {

			scanlineMinX = minX - 1;

		}

		return { points: points, isCW: _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* ShapeUtils */ "u"].isClockWise( points ), identifier: identifier ++, boundingBox: new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Box2 */ "a"]( new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]( minX, minY ), new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]( maxX, maxY ) ) };

	} );

	simplePaths = simplePaths.filter( sp => sp.points.length > 0 );

	// check if path is solid or a hole
	const isAHole = simplePaths.map( p => isHoleTo( p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule ) );


	const shapesToReturn = [];
	simplePaths.forEach( p => {

		const amIAHole = isAHole[ p.identifier ];

		if ( ! amIAHole.isHole ) {

			const shape = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Shape */ "r"]( p.points );
			const holes = isAHole.filter( h => h.isHole && h.for === p.identifier );
			holes.forEach( h => {

				const path = simplePaths[ h.identifier ];
				shape.holes.push( new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Path */ "o"]( path.points ) );

			} );
			shapesToReturn.push( shape );

		}

	} );

	return shapesToReturn;

};

SVGLoader.getStrokeStyle = function ( width, color, lineJoin, lineCap, miterLimit ) {

	// Param width: Stroke width
	// Param color: As returned by THREE.Color.getStyle()
	// Param lineJoin: One of "round", "bevel", "miter" or "miter-limit"
	// Param lineCap: One of "round", "square" or "butt"
	// Param miterLimit: Maximum join length, in multiples of the "width" parameter (join is truncated if it exceeds that distance)
	// Returns style object

	width = width !== undefined ? width : 1;
	color = color !== undefined ? color : '#000';
	lineJoin = lineJoin !== undefined ? lineJoin : 'miter';
	lineCap = lineCap !== undefined ? lineCap : 'butt';
	miterLimit = miterLimit !== undefined ? miterLimit : 4;

	return {
		strokeColor: color,
		strokeWidth: width,
		strokeLineJoin: lineJoin,
		strokeLineCap: lineCap,
		strokeMiterLimit: miterLimit
	};

};

SVGLoader.pointsToStroke = function ( points, style, arcDivisions, minDistance ) {

	// Generates a stroke with some witdh around the given path.
	// The path can be open or closed (last point equals to first point)
	// Param points: Array of Vector2D (the path). Minimum 2 points.
	// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object
	// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)
	// Param minDistance: Points closer to this distance will be merged. (Optional)
	// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)

	var vertices = [];
	var normals = [];
	var uvs = [];

	if ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {

		return null;

	}

	var geometry = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* BufferGeometry */ "c"]();
	geometry.setAttribute( 'position', new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Float32BufferAttribute */ "g"]( vertices, 3 ) );
	geometry.setAttribute( 'normal', new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Float32BufferAttribute */ "g"]( normals, 3 ) );
	geometry.setAttribute( 'uv', new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Float32BufferAttribute */ "g"]( uvs, 2 ) );

	return geometry;

};

SVGLoader.pointsToStrokeWithBuffers = function () {

	var tempV2_1 = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
	var tempV2_2 = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
	var tempV2_3 = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
	var tempV2_4 = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
	var tempV2_5 = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
	var tempV2_6 = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
	var tempV2_7 = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
	var lastPointL = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
	var lastPointR = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
	var point0L = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
	var point0R = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
	var currentPointL = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
	var currentPointR = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
	var nextPointL = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
	var nextPointR = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
	var innerPoint = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();
	var outerPoint = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__[/* Vector2 */ "v"]();

	return function ( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {

		// This function can be called to update existing arrays or buffers.
		// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.
		// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)
		// Returns number of written vertices / normals / uvs pairs
		// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)
		// 'normals' and 'uvs' buffers are optional

		arcDivisions = arcDivisions !== undefined ? arcDivisions : 12;
		minDistance = minDistance !== undefined ? minDistance : 0.001;
		vertexOffset = vertexOffset !== undefined ? vertexOffset : 0;

		// First ensure there are no duplicated points
		points = removeDuplicatedPoints( points );

		var numPoints = points.length;

		if ( numPoints < 2 ) return 0;

		var isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );

		var currentPoint;
		var previousPoint = points[ 0 ];
		var nextPoint;

		var strokeWidth2 = style.strokeWidth / 2;

		var deltaU = 1 / ( numPoints - 1 );
		var u0 = 0;

		var innerSideModified;
		var joinIsOnLeftSide;
		var isMiter;
		var initialJoinIsOnLeftSide = false;

		var numVertices = 0;
		var currentCoordinate = vertexOffset * 3;
		var currentCoordinateUV = vertexOffset * 2;

		// Get initial left and right stroke points
		getNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );
		lastPointL.copy( points[ 0 ] ).sub( tempV2_1 );
		lastPointR.copy( points[ 0 ] ).add( tempV2_1 );
		point0L.copy( lastPointL );
		point0R.copy( lastPointR );

		for ( var iPoint = 1; iPoint < numPoints; iPoint ++ ) {

			currentPoint = points[ iPoint ];

			// Get next point
			if ( iPoint === numPoints - 1 ) {

				if ( isClosed ) {

					// Skip duplicated initial point
					nextPoint = points[ 1 ];

				} else nextPoint = undefined;

			} else {

				nextPoint = points[ iPoint + 1 ];

			}

			// Normal of previous segment in tempV2_1
			var normal1 = tempV2_1;
			getNormal( previousPoint, currentPoint, normal1 );

			tempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );
			currentPointL.copy( currentPoint ).sub( tempV2_3 );
			currentPointR.copy( currentPoint ).add( tempV2_3 );

			var u1 = u0 + deltaU;

			innerSideModified = false;

			if ( nextPoint !== undefined ) {

				// Normal of next segment in tempV2_2
				getNormal( currentPoint, nextPoint, tempV2_2 );

				tempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );
				nextPointL.copy( currentPoint ).sub( tempV2_3 );
				nextPointR.copy( currentPoint ).add( tempV2_3 );

				joinIsOnLeftSide = true;
				tempV2_3.subVectors( nextPoint, previousPoint );
				if ( normal1.dot( tempV2_3 ) < 0 ) {

					joinIsOnLeftSide = false;

				}

				if ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;

				tempV2_3.subVectors( nextPoint, currentPoint );
				tempV2_3.normalize();
				var dot = Math.abs( normal1.dot( tempV2_3 ) );

				// If path is straight, don't create join
				if ( dot !== 0 ) {

					// Compute inner and outer segment intersections
					var miterSide = strokeWidth2 / dot;
					tempV2_3.multiplyScalar( - miterSide );
					tempV2_4.subVectors( currentPoint, previousPoint );
					tempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );
					innerPoint.copy( tempV2_5 ).negate();
					var miterLength2 = tempV2_5.length();
					var segmentLengthPrev = tempV2_4.length();
					tempV2_4.divideScalar( segmentLengthPrev );
					tempV2_6.subVectors( nextPoint, currentPoint );
					var segmentLengthNext = tempV2_6.length();
					tempV2_6.divideScalar( segmentLengthNext );
					// Check that previous and next segments doesn't overlap with the innerPoint of intersection
					if ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {

						innerSideModified = true;

					}

					outerPoint.copy( tempV2_5 ).add( currentPoint );
					innerPoint.add( currentPoint );

					isMiter = false;

					if ( innerSideModified ) {

						if ( joinIsOnLeftSide ) {

							nextPointR.copy( innerPoint );
							currentPointR.copy( innerPoint );

						} else {

							nextPointL.copy( innerPoint );
							currentPointL.copy( innerPoint );

						}

					} else {

						// The segment triangles are generated here if there was overlapping

						makeSegmentTriangles();

					}

					switch ( style.strokeLineJoin ) {

						case 'bevel':

							makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );

							break;

						case 'round':

							// Segment triangles

							createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );

							// Join triangles

							if ( joinIsOnLeftSide ) {

								makeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );

							} else {

								makeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );

							}

							break;

						case 'miter':
						case 'miter-clip':
						default:

							var miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;

							if ( miterFraction < 1 ) {

								// The join miter length exceeds the miter limit

								if ( style.strokeLineJoin !== 'miter-clip' ) {

									makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );
									break;

								} else {

									// Segment triangles

									createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );

									// Miter-clip join triangles

									if ( joinIsOnLeftSide ) {

										tempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );
										tempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );

										addVertex( currentPointL, u1, 0 );
										addVertex( tempV2_6, u1, 0 );
										addVertex( currentPoint, u1, 0.5 );

										addVertex( currentPoint, u1, 0.5 );
										addVertex( tempV2_6, u1, 0 );
										addVertex( tempV2_7, u1, 0 );

										addVertex( currentPoint, u1, 0.5 );
										addVertex( tempV2_7, u1, 0 );
										addVertex( nextPointL, u1, 0 );

									} else {

										tempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );
										tempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );

										addVertex( currentPointR, u1, 1 );
										addVertex( tempV2_6, u1, 1 );
										addVertex( currentPoint, u1, 0.5 );

										addVertex( currentPoint, u1, 0.5 );
										addVertex( tempV2_6, u1, 1 );
										addVertex( tempV2_7, u1, 1 );

										addVertex( currentPoint, u1, 0.5 );
										addVertex( tempV2_7, u1, 1 );
										addVertex( nextPointR, u1, 1 );

									}

								}

							} else {

								// Miter join segment triangles

								if ( innerSideModified ) {

									// Optimized segment + join triangles

									if ( joinIsOnLeftSide ) {

										addVertex( lastPointR, u0, 1 );
										addVertex( lastPointL, u0, 0 );
										addVertex( outerPoint, u1, 0 );

										addVertex( lastPointR, u0, 1 );
										addVertex( outerPoint, u1, 0 );
										addVertex( innerPoint, u1, 1 );

									} else {

										addVertex( lastPointR, u0, 1 );
										addVertex( lastPointL, u0, 0 );
										addVertex( outerPoint, u1, 1 );

										addVertex( lastPointL, u0, 0 );
										addVertex( innerPoint, u1, 0 );
										addVertex( outerPoint, u1, 1 );

									}


									if ( joinIsOnLeftSide ) {

										nextPointL.copy( outerPoint );

									} else {

										nextPointR.copy( outerPoint );

									}


								} else {

									// Add extra miter join triangles

									if ( joinIsOnLeftSide ) {

										addVertex( currentPointL, u1, 0 );
										addVertex( outerPoint, u1, 0 );
										addVertex( currentPoint, u1, 0.5 );

										addVertex( currentPoint, u1, 0.5 );
										addVertex( outerPoint, u1, 0 );
										addVertex( nextPointL, u1, 0 );

									} else {

										addVertex( currentPointR, u1, 1 );
										addVertex( outerPoint, u1, 1 );
										addVertex( currentPoint, u1, 0.5 );

										addVertex( currentPoint, u1, 0.5 );
										addVertex( outerPoint, u1, 1 );
										addVertex( nextPointR, u1, 1 );

									}

								}

								isMiter = true;

							}

							break;

					}

				} else {

					// The segment triangles are generated here when two consecutive points are collinear

					makeSegmentTriangles();

				}

			} else {

				// The segment triangles are generated here if it is the ending segment

				makeSegmentTriangles();

			}

			if ( ! isClosed && iPoint === numPoints - 1 ) {

				// Start line endcap
				addCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );

			}

			// Increment loop variables

			u0 = u1;

			previousPoint = currentPoint;

			lastPointL.copy( nextPointL );
			lastPointR.copy( nextPointR );

		}

		if ( ! isClosed ) {

			// Ending line endcap
			addCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );

		} else if ( innerSideModified && vertices ) {

			// Modify path first segment vertices to adjust to the segments inner and outer intersections

			var lastOuter = outerPoint;
			var lastInner = innerPoint;

			if ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {

				lastOuter = innerPoint;
				lastInner = outerPoint;

			}

			if ( joinIsOnLeftSide ) {

				if ( isMiter || initialJoinIsOnLeftSide ) {

					lastInner.toArray( vertices, 0 * 3 );
					lastInner.toArray( vertices, 3 * 3 );

					if ( isMiter ) {

						lastOuter.toArray( vertices, 1 * 3 );

					}

				}

			} else {

				if ( isMiter || ! initialJoinIsOnLeftSide ) {

					lastInner.toArray( vertices, 1 * 3 );
					lastInner.toArray( vertices, 3 * 3 );

					if ( isMiter ) {

						lastOuter.toArray( vertices, 0 * 3 );

					}

				}

			}

		}

		return numVertices;

		// -- End of algorithm

		// -- Functions

		function getNormal( p1, p2, result ) {

			result.subVectors( p2, p1 );
			return result.set( - result.y, result.x ).normalize();

		}

		function addVertex( position, u, v ) {

			if ( vertices ) {

				vertices[ currentCoordinate ] = position.x;
				vertices[ currentCoordinate + 1 ] = position.y;
				vertices[ currentCoordinate + 2 ] = 0;

				if ( normals ) {

					normals[ currentCoordinate ] = 0;
					normals[ currentCoordinate + 1 ] = 0;
					normals[ currentCoordinate + 2 ] = 1;

				}

				currentCoordinate += 3;

				if ( uvs ) {

					uvs[ currentCoordinateUV ] = u;
					uvs[ currentCoordinateUV + 1 ] = v;

					currentCoordinateUV += 2;

				}

			}

			numVertices += 3;

		}

		function makeCircularSector( center, p1, p2, u, v ) {

			// param p1, p2: Points in the circle arc.
			// p1 and p2 are in clockwise direction.

			tempV2_1.copy( p1 ).sub( center ).normalize();
			tempV2_2.copy( p2 ).sub( center ).normalize();

			var angle = Math.PI;
			var dot = tempV2_1.dot( tempV2_2 );
			if ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );

			angle /= arcDivisions;

			tempV2_3.copy( p1 );

			for ( var i = 0, il = arcDivisions - 1; i < il; i ++ ) {

				tempV2_4.copy( tempV2_3 ).rotateAround( center, angle );

				addVertex( tempV2_3, u, v );
				addVertex( tempV2_4, u, v );
				addVertex( center, u, 0.5 );

				tempV2_3.copy( tempV2_4 );

			}

			addVertex( tempV2_4, u, v );
			addVertex( p2, u, v );
			addVertex( center, u, 0.5 );

		}

		function makeSegmentTriangles() {

			addVertex( lastPointR, u0, 1 );
			addVertex( lastPointL, u0, 0 );
			addVertex( currentPointL, u1, 0 );

			addVertex( lastPointR, u0, 1 );
			addVertex( currentPointL, u1, 1 );
			addVertex( currentPointR, u1, 0 );

		}

		function makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {

			if ( innerSideModified ) {

				// Optimized segment + bevel triangles

				if ( joinIsOnLeftSide ) {

					// Path segments triangles

					addVertex( lastPointR, u0, 1 );
					addVertex( lastPointL, u0, 0 );
					addVertex( currentPointL, u1, 0 );

					addVertex( lastPointR, u0, 1 );
					addVertex( currentPointL, u1, 0 );
					addVertex( innerPoint, u1, 1 );

					// Bevel join triangle

					addVertex( currentPointL, u, 0 );
					addVertex( nextPointL, u, 0 );
					addVertex( innerPoint, u, 0.5 );

				} else {

					// Path segments triangles

					addVertex( lastPointR, u0, 1 );
					addVertex( lastPointL, u0, 0 );
					addVertex( currentPointR, u1, 1 );

					addVertex( lastPointL, u0, 0 );
					addVertex( innerPoint, u1, 0 );
					addVertex( currentPointR, u1, 1 );

					// Bevel join triangle

					addVertex( currentPointR, u, 1 );
					addVertex( nextPointR, u, 0 );
					addVertex( innerPoint, u, 0.5 );

				}

			} else {

				// Bevel join triangle. The segment triangles are done in the main loop

				if ( joinIsOnLeftSide ) {

					addVertex( currentPointL, u, 0 );
					addVertex( nextPointL, u, 0 );
					addVertex( currentPoint, u, 0.5 );

				} else {

					addVertex( currentPointR, u, 1 );
					addVertex( nextPointR, u, 0 );
					addVertex( currentPoint, u, 0.5 );

				}

			}

		}

		function createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {

			if ( innerSideModified ) {

				if ( joinIsOnLeftSide ) {

					addVertex( lastPointR, u0, 1 );
					addVertex( lastPointL, u0, 0 );
					addVertex( currentPointL, u1, 0 );

					addVertex( lastPointR, u0, 1 );
					addVertex( currentPointL, u1, 0 );
					addVertex( innerPoint, u1, 1 );

					addVertex( currentPointL, u0, 0 );
					addVertex( currentPoint, u1, 0.5 );
					addVertex( innerPoint, u1, 1 );

					addVertex( currentPoint, u1, 0.5 );
					addVertex( nextPointL, u0, 0 );
					addVertex( innerPoint, u1, 1 );

				} else {

					addVertex( lastPointR, u0, 1 );
					addVertex( lastPointL, u0, 0 );
					addVertex( currentPointR, u1, 1 );

					addVertex( lastPointL, u0, 0 );
					addVertex( innerPoint, u1, 0 );
					addVertex( currentPointR, u1, 1 );

					addVertex( currentPointR, u0, 1 );
					addVertex( innerPoint, u1, 0 );
					addVertex( currentPoint, u1, 0.5 );

					addVertex( currentPoint, u1, 0.5 );
					addVertex( innerPoint, u1, 0 );
					addVertex( nextPointR, u0, 1 );

				}

			}

		}

		function addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {

			// param center: End point of the path
			// param p1, p2: Left and right cap points

			switch ( style.strokeLineCap ) {

				case 'round':

					if ( start ) {

						makeCircularSector( center, p2, p1, u, 0.5 );

					} else {

						makeCircularSector( center, p1, p2, u, 0.5 );

					}

					break;

				case 'square':

					if ( start ) {

						tempV2_1.subVectors( p1, center );
						tempV2_2.set( tempV2_1.y, - tempV2_1.x );

						tempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );
						tempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );

						// Modify already existing vertices
						if ( joinIsOnLeftSide ) {

							tempV2_3.toArray( vertices, 1 * 3 );
							tempV2_4.toArray( vertices, 0 * 3 );
							tempV2_4.toArray( vertices, 3 * 3 );

						} else {

							tempV2_3.toArray( vertices, 1 * 3 );
							tempV2_3.toArray( vertices, 3 * 3 );
							tempV2_4.toArray( vertices, 0 * 3 );

						}

					} else {

						tempV2_1.subVectors( p2, center );
						tempV2_2.set( tempV2_1.y, - tempV2_1.x );

						tempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );
						tempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );

						var vl = vertices.length;

						// Modify already existing vertices
						if ( joinIsOnLeftSide ) {

							tempV2_3.toArray( vertices, vl - 1 * 3 );
							tempV2_4.toArray( vertices, vl - 2 * 3 );
							tempV2_4.toArray( vertices, vl - 4 * 3 );

						} else {

							tempV2_3.toArray( vertices, vl - 2 * 3 );
							tempV2_4.toArray( vertices, vl - 1 * 3 );
							tempV2_4.toArray( vertices, vl - 4 * 3 );

						}

					}

					break;

				case 'butt':
				default:

					// Nothing to do here
					break;

			}

		}

		function removeDuplicatedPoints( points ) {

			// Creates a new array if necessary with duplicated points removed.
			// This does not remove duplicated initial and ending points of a closed path.

			var dupPoints = false;
			for ( var i = 1, n = points.length - 1; i < n; i ++ ) {

				if ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {

					dupPoints = true;
					break;

				}

			}

			if ( ! dupPoints ) return points;

			var newPoints = [];
			newPoints.push( points[ 0 ] );

			for ( var i = 1, n = points.length - 1; i < n; i ++ ) {

				if ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {

					newPoints.push( points[ i ] );

				}

			}

			newPoints.push( points[ points.length - 1 ] );

			return newPoints;

		}

	};

}();




/***/ }),

/***/ "e77a":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ComponentExpose_vue_vue_type_style_index_0_id_6c27d832_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("f116");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ComponentExpose_vue_vue_type_style_index_0_id_6c27d832_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_2_0_css_loader_dist_cjs_js_ref_7_oneOf_2_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_7_oneOf_2_2_quasar_app_lib_webpack_loader_auto_import_client_js_kebab_vue_loader_lib_index_js_vue_loader_options_ComponentExpose_vue_vue_type_style_index_0_id_6c27d832_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "e7a0":
/***/ (function(module, exports, __webpack_require__) {

var IS_NODE = __webpack_require__("f117");
var V8_VERSION = __webpack_require__("4fed");
var fails = __webpack_require__("72df");

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  // eslint-disable-next-line es/no-symbol -- required for testing
  return !Symbol.sham &&
    // Chrome 38 Symbol has incorrect toString conversion
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    (IS_NODE ? V8_VERSION === 38 : V8_VERSION > 37 && V8_VERSION < 41);
});


/***/ }),

/***/ "e81c":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/@babel/runtime/helpers/objectSpread2.js
var objectSpread2 = __webpack_require__("ca22");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2);

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/vue/dist/vue.runtime.esm.js
var vue_runtime_esm = __webpack_require__("9869");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/history.js
var src_history = __webpack_require__("7747");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/history.js

/* harmony default export */ var mixins_history = ({
  methods: {
    __addHistory() {
      this.__historyEntry = {
        condition: () => {
          return this.hideOnRouteChange === true;
        },
        handler: this.hide
      };
      src_history["a" /* default */].add(this.__historyEntry);
    },

    __removeHistory() {
      if (this.__historyEntry !== void 0) {
        src_history["a" /* default */].remove(this.__historyEntry);
        this.__historyEntry = void 0;
      }
    }

  },

  beforeDestroy() {
    this.showing === true && this.__removeHistory();
  }

});
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/model-toggle.js
var model_toggle = __webpack_require__("56c6");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/portal.js
var portal = __webpack_require__("6769");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("9ac9");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/scroll.js
var utils_scroll = __webpack_require__("8047");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/plugins/Platform.js
var Platform = __webpack_require__("5094");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/prevent-scroll.js



let registered = 0,
    scrollPositionX,
    scrollPositionY,
    maxScrollTop,
    vpPendingUpdate = false,
    bodyLeft,
    bodyTop,
    closeTimer;

function onWheel(e) {
  if (shouldPreventScroll(e)) {
    Object(utils_event["l" /* stopAndPrevent */])(e);
  }
}

function shouldPreventScroll(e) {
  if (e.target === document.body || e.target.classList.contains('q-layout__backdrop')) {
    return true;
  }

  const path = Object(utils_event["d" /* getEventPath */])(e),
        shift = e.shiftKey && !e.deltaX,
        scrollY = !shift && Math.abs(e.deltaX) <= Math.abs(e.deltaY),
        delta = shift || scrollY ? e.deltaY : e.deltaX;

  for (let index = 0; index < path.length; index++) {
    const el = path[index];

    if (Object(utils_scroll["f" /* hasScrollbar */])(el, scrollY)) {
      return scrollY ? delta < 0 && el.scrollTop === 0 ? true : delta > 0 && el.scrollTop + el.clientHeight === el.scrollHeight : delta < 0 && el.scrollLeft === 0 ? true : delta > 0 && el.scrollLeft + el.clientWidth === el.scrollWidth;
    }
  }

  return true;
}

function onAppleScroll(e) {
  if (e.target === document) {
    // required, otherwise iOS blocks further scrolling
    // until the mobile scrollbar dissappears
    document.scrollingElement.scrollTop = document.scrollingElement.scrollTop; // eslint-disable-line
  }
}

function onAppleResize(evt) {
  if (vpPendingUpdate === true) {
    return;
  }

  vpPendingUpdate = true;
  requestAnimationFrame(() => {
    vpPendingUpdate = false;
    const {
      height
    } = evt.target,
          {
      clientHeight,
      scrollTop
    } = document.scrollingElement;

    if (maxScrollTop === void 0 || height !== window.innerHeight) {
      maxScrollTop = clientHeight - height;
      document.scrollingElement.scrollTop = scrollTop;
    }

    if (scrollTop > maxScrollTop) {
      document.scrollingElement.scrollTop -= Math.ceil((scrollTop - maxScrollTop) / 8);
    }
  });
}

function apply(action) {
  const body = document.body,
        hasViewport = window.visualViewport !== void 0;

  if (action === 'add') {
    const overflowY = window.getComputedStyle(body).overflowY;
    scrollPositionX = Object(utils_scroll["b" /* getHorizontalScrollPosition */])(window);
    scrollPositionY = Object(utils_scroll["c" /* getScrollPosition */])(window);
    bodyLeft = body.style.left;
    bodyTop = body.style.top;
    body.style.left = `-${scrollPositionX}px`;
    body.style.top = `-${scrollPositionY}px`;

    if (overflowY !== 'hidden' && (overflowY === 'scroll' || body.scrollHeight > window.innerHeight)) {
      body.classList.add('q-body--force-scrollbar');
    }

    body.classList.add('q-body--prevent-scroll');
    document.qScrollPrevented = true;

    if (Platform["a" /* client */].is.ios === true) {
      if (hasViewport === true) {
        window.scrollTo(0, 0);
        window.visualViewport.addEventListener('resize', onAppleResize, utils_event["f" /* listenOpts */].passiveCapture);
        window.visualViewport.addEventListener('scroll', onAppleResize, utils_event["f" /* listenOpts */].passiveCapture);
        window.scrollTo(0, 0);
      } else {
        window.addEventListener('scroll', onAppleScroll, utils_event["f" /* listenOpts */].passiveCapture);
      }
    }
  }

  if (Platform["a" /* client */].is.desktop === true && Platform["a" /* client */].is.mac === true) {
    // ref. https://developers.google.com/web/updates/2017/01/scrolling-intervention
    window[`${action}EventListener`]('wheel', onWheel, utils_event["f" /* listenOpts */].notPassive);
  }

  if (action === 'remove') {
    if (Platform["a" /* client */].is.ios === true) {
      if (hasViewport === true) {
        window.visualViewport.removeEventListener('resize', onAppleResize, utils_event["f" /* listenOpts */].passiveCapture);
        window.visualViewport.removeEventListener('scroll', onAppleResize, utils_event["f" /* listenOpts */].passiveCapture);
      } else {
        window.removeEventListener('scroll', onAppleScroll, utils_event["f" /* listenOpts */].passiveCapture);
      }
    }

    body.classList.remove('q-body--prevent-scroll');
    body.classList.remove('q-body--force-scrollbar');
    document.qScrollPrevented = false;
    body.style.left = bodyLeft;
    body.style.top = bodyTop;
    window.scrollTo(scrollPositionX, scrollPositionY);
    maxScrollTop = void 0;
  }
}

function preventScroll(state) {
  let action = 'add';

  if (state === true) {
    registered++;

    if (closeTimer !== void 0) {
      clearTimeout(closeTimer);
      closeTimer = void 0;
      return;
    }

    if (registered > 1) {
      return;
    }
  } else {
    if (registered === 0) {
      return;
    }

    registered--;

    if (registered > 0) {
      return;
    }

    action = 'remove';

    if (Platform["a" /* client */].is.ios === true && Platform["a" /* client */].is.nativeMobile === true) {
      clearTimeout(closeTimer);
      closeTimer = setTimeout(() => {
        apply(action);
        closeTimer = void 0;
      }, 100);
      return;
    }
  }

  apply(action);
}
/* harmony default export */ var prevent_scroll = ({
  methods: {
    __preventScroll(state) {
      if (state !== this.preventedScroll && (this.preventedScroll !== void 0 || state === true)) {
        this.preventedScroll = state;
        preventScroll(state);
      }
    }

  }
});
// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/mixins/attrs.js
var attrs = __webpack_require__("ffad");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/dom.js
var dom = __webpack_require__("3230");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/escape-key.js
var escape_key = __webpack_require__("072e");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/slot.js
var slot = __webpack_require__("a4b3");

// EXTERNAL MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/utils/cache.js
var cache = __webpack_require__("6459");

// CONCATENATED MODULE: /Users/lucaban/ghq/github.com/CyCraft/pepicons/node_modules/quasar/src/components/dialog/QDialog.js












let maximizedModals = 0;
const positionClass = {
  standard: 'fixed-full flex-center',
  top: 'fixed-top justify-center',
  bottom: 'fixed-bottom justify-center',
  right: 'fixed-right items-center',
  left: 'fixed-left items-center'
};
const transitions = {
  standard: ['scale', 'scale'],
  top: ['slide-down', 'slide-up'],
  bottom: ['slide-up', 'slide-down'],
  right: ['slide-left', 'slide-right'],
  left: ['slide-right', 'slide-left']
};
/* harmony default export */ var QDialog = __webpack_exports__["a"] = (vue_runtime_esm["default"].extend({
  name: 'QDialog',
  mixins: [attrs["b" /* default */], mixins_history, model_toggle["a" /* default */], portal["b" /* default */], prevent_scroll],
  props: {
    persistent: Boolean,
    autoClose: Boolean,
    noEscDismiss: Boolean,
    noBackdropDismiss: Boolean,
    noRouteDismiss: Boolean,
    noRefocus: Boolean,
    noFocus: Boolean,
    seamless: Boolean,
    maximized: Boolean,
    fullWidth: Boolean,
    fullHeight: Boolean,
    square: Boolean,
    position: {
      type: String,
      default: 'standard',
      validator: val => val === 'standard' || ['top', 'bottom', 'left', 'right'].includes(val)
    },
    transitionShow: String,
    transitionHide: String
  },

  data() {
    return {
      transitionState: this.showing
    };
  },

  watch: {
    showing(val) {
      if (this.transitionShowComputed !== this.transitionHideComputed) {
        this.$nextTick(() => {
          this.transitionState = val;
        });
      }
    },

    maximized(state) {
      this.showing === true && this.__updateMaximized(state);
    },

    useBackdrop(v) {
      this.__preventScroll(v);

      this.__preventFocusout(v);
    }

  },
  computed: {
    classes() {
      return `q-dialog__inner--${this.maximized === true ? 'maximized' : 'minimized'} ` + `q-dialog__inner--${this.position} ${positionClass[this.position]}` + (this.fullWidth === true ? ' q-dialog__inner--fullwidth' : '') + (this.fullHeight === true ? ' q-dialog__inner--fullheight' : '') + (this.square === true ? ' q-dialog__inner--square' : '');
    },

    transitionShowComputed() {
      return 'q-transition--' + (this.transitionShow === void 0 ? transitions[this.position][0] : this.transitionShow);
    },

    transitionHideComputed() {
      return 'q-transition--' + (this.transitionHide === void 0 ? transitions[this.position][1] : this.transitionHide);
    },

    transition() {
      return this.transitionState === true ? this.transitionHideComputed : this.transitionShowComputed;
    },

    useBackdrop() {
      return this.showing === true && this.seamless !== true;
    },

    hideOnRouteChange() {
      return this.persistent !== true && this.noRouteDismiss !== true && this.seamless !== true;
    },

    onEvents() {
      const on = objectSpread2_default()(objectSpread2_default()({}, this.qListeners), {}, {
        // stop propagating these events from children
        input: utils_event["k" /* stop */],
        'popup-show': utils_event["k" /* stop */],
        'popup-hide': utils_event["k" /* stop */]
      });

      if (this.autoClose === true) {
        on.click = this.__onAutoClose;
      }

      return on;
    }

  },
  methods: {
    focus() {
      let node = this.__getInnerNode();

      if (node === void 0 || node.contains(document.activeElement) === true) {
        return;
      }

      node = node.querySelector('[autofocus], [data-autofocus]') || node;
      node.focus();
    },

    shake() {
      this.focus();
      this.$emit('shake');

      const node = this.__getInnerNode();

      if (node !== void 0) {
        node.classList.remove('q-animate--scale');
        node.classList.add('q-animate--scale');
        clearTimeout(this.shakeTimeout);
        this.shakeTimeout = setTimeout(() => {
          node.classList.remove('q-animate--scale');
        }, 170);
      }
    },

    __getInnerNode() {
      return this.__portal !== void 0 && this.__portal.$refs !== void 0 ? this.__portal.$refs.inner : void 0;
    },

    __show(evt) {
      this.__addHistory(); // IE can have null document.activeElement


      this.__refocusTarget = this.noRefocus === false && document.activeElement !== null ? document.activeElement : void 0;
      this.$el.dispatchEvent(Object(utils_event["c" /* create */])('popup-show', {
        bubbles: true
      }));

      this.__updateMaximized(this.maximized);

      escape_key["a" /* default */].register(this, () => {
        if (this.seamless !== true) {
          if (this.persistent === true || this.noEscDismiss === true) {
            this.maximized !== true && this.shake();
          } else {
            this.$emit('escape-key');
            this.hide();
          }
        }
      });

      this.__showPortal();

      if (this.noFocus !== true) {
        // IE can have null document.activeElement
        document.activeElement !== null && document.activeElement.blur();

        this.__nextTick(this.focus);
      }

      this.__setTimeout(() => {
        if (this.$q.platform.is.ios === true) {
          if (this.seamless !== true && document.activeElement) {
            const {
              top,
              bottom
            } = document.activeElement.getBoundingClientRect(),
                  {
              innerHeight
            } = window,
                  height = window.visualViewport !== void 0 ? window.visualViewport.height : innerHeight;

            if (top > 0 && bottom > height / 2) {
              document.scrollingElement.scrollTop = Math.min(document.scrollingElement.scrollHeight - height, bottom >= innerHeight ? Infinity : Math.ceil(document.scrollingElement.scrollTop + bottom - height / 2));
            }

            document.activeElement.scrollIntoView();
          } // required in order to avoid the "double-tap needed" issue


          this.__portal.$el.click();
        }

        this.$emit('show', evt);
      }, 300);
    },

    __hide(evt) {
      this.__removeHistory();

      this.__cleanup(true); // check null for IE


      if (this.__refocusTarget !== void 0 && this.__refocusTarget !== null) {
        this.__refocusTarget.focus();
      }

      this.$el.dispatchEvent(Object(utils_event["c" /* create */])('popup-hide', {
        bubbles: true
      }));

      this.__setTimeout(() => {
        this.__hidePortal();

        this.$emit('hide', evt);
      }, 300);
    },

    __cleanup(hiding) {
      clearTimeout(this.shakeTimeout);

      if (hiding === true || this.showing === true) {
        escape_key["a" /* default */].pop(this);

        this.__updateMaximized(false);

        if (this.seamless !== true) {
          this.__preventScroll(false);

          this.__preventFocusout(false);
        }
      }
    },

    __updateMaximized(active) {
      if (active === true) {
        if (this.isMaximized !== true) {
          maximizedModals < 1 && document.body.classList.add('q-body--dialog');
          maximizedModals++;
          this.isMaximized = true;
        }
      } else if (this.isMaximized === true) {
        if (maximizedModals < 2) {
          document.body.classList.remove('q-body--dialog');
        }

        maximizedModals--;
        this.isMaximized = false;
      }
    },

    __preventFocusout(state) {
      if (this.$q.platform.is.desktop === true) {
        const action = `${state === true ? 'add' : 'remove'}EventListener`;
        document.body[action]('focusin', this.__onFocusChange);
      }
    },

    __onAutoClose(e) {
      this.hide(e);
      this.qListeners.click !== void 0 && this.$emit('click', e);
    },

    __onBackdropClick(e) {
      if (this.persistent !== true && this.noBackdropDismiss !== true) {
        this.hide(e);
      } else {
        this.shake();
      }
    },

    __onFocusChange(e) {
      // the focus is not in a vue child component
      if (this.showing === true && this.__portal !== void 0 && Object(dom["a" /* childHasFocus */])(this.__portal.$el, e.target) !== true) {
        this.focus();
      }
    },

    __renderPortal(h) {
      return h('div', {
        staticClass: `q-dialog fullscreen no-pointer-events q-dialog--${this.useBackdrop === true ? 'modal' : 'seamless'}`,
        class: this.contentClass,
        style: this.contentStyle,
        attrs: this.qAttrs
      }, [h('transition', {
        props: {
          name: 'q-transition--fade'
        }
      }, this.useBackdrop === true ? [h('div', {
        staticClass: 'q-dialog__backdrop fixed-full',
        attrs: attrs["a" /* ariaHidden */],
        on: Object(cache["b" /* default */])(this, 'bkdrop', {
          click: this.__onBackdropClick
        })
      })] : null), h('transition', {
        props: {
          name: this.transition
        }
      }, [this.showing === true ? h('div', {
        ref: 'inner',
        staticClass: 'q-dialog__inner flex no-pointer-events',
        class: this.classes,
        attrs: {
          tabindex: -1
        },
        on: this.onEvents
      }, Object(slot["c" /* slot */])(this, 'default')) : null])]);
    }

  },

  mounted() {
    this.__processModelChange(this.value);
  },

  beforeDestroy() {
    this.__cleanup();
  }

}));

/***/ }),

/***/ "e9c4":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  isoName: 'en-us',
  nativeName: 'English (US)',
  label: {
    clear: 'Clear',
    ok: 'OK',
    cancel: 'Cancel',
    close: 'Close',
    set: 'Set',
    select: 'Select',
    reset: 'Reset',
    remove: 'Remove',
    update: 'Update',
    create: 'Create',
    search: 'Search',
    filter: 'Filter',
    refresh: 'Refresh'
  },
  date: {
    days: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    daysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    firstDayOfWeek: 0,
    // 0-6, 0 - Sunday, 1 Monday, ...
    format24h: false,
    pluralDay: 'days'
  },
  table: {
    noData: 'No data available',
    noResults: 'No matching records found',
    loading: 'Loading...',
    selectedRecords: function (rows) {
      return rows === 1 ? '1 record selected.' : (rows === 0 ? 'No' : rows) + ' records selected.';
    },
    recordsPerPage: 'Records per page:',
    allRows: 'All',
    pagination: function (start, end, total) {
      return start + '-' + end + ' of ' + total;
    },
    columns: 'Columns'
  },
  editor: {
    url: 'URL',
    bold: 'Bold',
    italic: 'Italic',
    strikethrough: 'Strikethrough',
    underline: 'Underline',
    unorderedList: 'Unordered List',
    orderedList: 'Ordered List',
    subscript: 'Subscript',
    superscript: 'Superscript',
    hyperlink: 'Hyperlink',
    toggleFullscreen: 'Toggle Fullscreen',
    quote: 'Quote',
    left: 'Left align',
    center: 'Center align',
    right: 'Right align',
    justify: 'Justify align',
    print: 'Print',
    outdent: 'Decrease indentation',
    indent: 'Increase indentation',
    removeFormat: 'Remove formatting',
    formatting: 'Formatting',
    fontSize: 'Font Size',
    align: 'Align',
    hr: 'Insert Horizontal Rule',
    undo: 'Undo',
    redo: 'Redo',
    heading1: 'Heading 1',
    heading2: 'Heading 2',
    heading3: 'Heading 3',
    heading4: 'Heading 4',
    heading5: 'Heading 5',
    heading6: 'Heading 6',
    paragraph: 'Paragraph',
    code: 'Code',
    size1: 'Very small',
    size2: 'A bit small',
    size3: 'Normal',
    size4: 'Medium-large',
    size5: 'Big',
    size6: 'Very big',
    size7: 'Maximum',
    defaultFont: 'Default Font',
    viewSource: 'View Source'
  },
  tree: {
    noNodes: 'No nodes available',
    noResults: 'No matching nodes found'
  }
});

/***/ }),

/***/ "ebac":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("72df");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "eca6":
/***/ (function(module, exports) {

/**
 * @typedef ComponentDoc
 * @type {object}
 * @prop {string} displayName
 * @prop {string} exportName
 * @prop {string} [description]
 * @prop {PropDescriptor[]} [props]
 * @prop {MethodDescriptor[]} [methods]
 * @prop {SlotDescriptor[]} [slots]
 * @prop {EventDescriptor[]} [events]
 * @prop {{ [key: string]: BlockTag[] }} [tags]
 * @prop {string[]} [docsBlocks]
 */

/***/ }),

/***/ "ed2b":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("7d53");
var create = __webpack_require__("82e8");
var definePropertyModule = __webpack_require__("abdf");

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "ee92":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  props: {
    transitionShow: {
      type: String,
      default: 'fade'
    },
    transitionHide: {
      type: String,
      default: 'fade'
    }
  },

  data() {
    return {
      transitionState: this.showing
    };
  },

  watch: {
    showing(val) {
      this.transitionShow !== this.transitionHide && this.$nextTick(() => {
        this.transitionState = val;
      });
    }

  },
  computed: {
    transition() {
      return 'q-transition--' + (this.transitionState === true ? this.transitionHide : this.transitionShow);
    }

  }
});

/***/ }),

/***/ "f028":
/***/ (function(module, exports) {

// IEEE754 conversions based on https://github.com/feross/ieee754
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;

var pack = function (number, mantissaLength, bytes) {
  var buffer = new Array(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number);
  // eslint-disable-next-line no-self-compare -- NaN check
  if (number != number || number === Infinity) {
    // eslint-disable-next-line no-self-compare -- NaN check
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor(log(number) / LN2);
    if (number * (c = pow(2, -exponent)) < 1) {
      exponent--;
      c *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }
    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }
  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;
  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
  buffer[--index] |= sign * 128;
  return buffer;
};

var unpack = function (buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;
  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;
  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity : Infinity;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

module.exports = {
  pack: pack,
  unpack: unpack
};


/***/ }),

/***/ "f04f":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "f116":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "f117":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("6a61");
var global = __webpack_require__("f498");

module.exports = classof(global.process) == 'process';


/***/ }),

/***/ "f1a7":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "f284":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return categories; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return pepiconCategoryDic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return pepiconSvgString; });
/* unused harmony export pop */
/* unused harmony export print */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return synonyms$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return synonyms; });
/** Do not edit! This file is auto-generated. */
const categories = ['transport', 'ui', 'device', 'sound', 'leisure', 'text', 'location', 'time', 'food-drinks', 'shape', 'item', 'nature', 'social'];
const pepiconCategoryDic = {
    'airplane': 'transport',
    'angle-down': 'ui',
    'angle-left': 'ui',
    'angle-right': 'ui',
    'angle-up': 'ui',
    'battery': 'device',
    'bell': 'sound',
    'bell-off': 'sound',
    'bicycle': 'transport',
    'bluetooth': 'ui',
    'book': 'leisure',
    'bookmark': 'text',
    'bookmark-filled': 'text',
    'building': 'location',
    'calculator': 'device',
    'calendar': 'time',
    'camera': 'device',
    'can': 'food-drinks',
    'car': 'transport',
    'cart': 'leisure',
    'checkmark': 'ui',
    'circle': 'shape',
    'circle-filled': 'shape',
    'clipboard': 'text',
    'clock': 'time',
    'cloud': 'ui',
    'cloud-down': 'ui',
    'cloud-down-filled': 'ui',
    'cloud-filled': 'ui',
    'cloud-up': 'ui',
    'cloud-up-filled': 'ui',
    'coctail': 'food-drinks',
    'color-picker': 'ui',
    'contract': 'ui',
    'controller': 'leisure',
    'credit-card': 'item',
    'cup': 'food-drinks',
    'division': 'shape',
    'dots-x': 'ui',
    'dots-y': 'ui',
    'dress': 'item',
    'duplicate': 'ui',
    'electricity': 'nature',
    'exclamation': 'text',
    'exclamation-filled': 'text',
    'expand': 'ui',
    'eye': 'ui',
    'eye-closed': 'ui',
    'eye-off': 'ui',
    'file': 'ui',
    'film-frame': 'leisure',
    'flag': 'location',
    'flower': 'nature',
    'flower-bud': 'nature',
    'folder': 'ui',
    'gear': 'ui',
    'gift': 'social',
    'grab': 'ui',
    'hamburger': 'food-drinks',
    'headphone': 'sound',
    'heart': 'social',
    'house': 'location',
    'info': 'text',
    'info-filled': 'text',
    'internet': 'location',
    'key': 'item',
    'knive-fork': 'food-drinks',
    'letter': 'social',
    'lock-closed': 'item',
    'lock-open': 'item',
    'loop': 'ui',
    'loop-minus': 'ui',
    'loop-plus': 'ui',
    'magnet': 'item',
    'map': 'transport',
    'microphone': 'sound',
    'minus': 'shape',
    'monitor': 'device',
    'monitor2': 'device',
    'moon': 'nature',
    'moon-filled': 'nature',
    'motorcycle': 'transport',
    'music-note-double': 'sound',
    'music-note-single': 'sound',
    'open': 'ui',
    'paint-pallet': 'leisure',
    'pen': 'text',
    'person': 'social',
    'person-filled': 'social',
    'phone': 'social',
    'photo-camera': 'device',
    'pill': 'item',
    'pinpoint': 'location',
    'pinpoint-filled': 'location',
    'pinpoint-off': 'location',
    'pinpoint-off-filled': 'location',
    'plus': 'shape',
    'power': 'ui',
    'printer': 'device',
    'refresh': 'ui',
    'reload': 'ui',
    'scissors': 'item',
    'send': 'social',
    'share-android': 'social',
    'share-ios': 'social',
    'smartphone': 'device',
    'smartphone-notch': 'device',
    'smartphone2': 'device',
    'soft-drink': 'food-drinks',
    'speaker-high': 'sound',
    'speaker-low': 'sound',
    'speaker-off': 'sound',
    'square': 'shape',
    'square-filled': 'shape',
    'star': 'nature',
    'star-filled': 'nature',
    'sun': 'nature',
    'sun-filled': 'nature',
    'syringe': 'item',
    't-shirt': 'item',
    'taxi': 'transport',
    'television': 'device',
    'text-bubble': 'social',
    'times': 'shape',
    'tool': 'ui',
    'train': 'transport',
    'trash': 'ui',
    'triangle-down': 'shape',
    'triangle-down-filled': 'shape',
    'triangle-left': 'shape',
    'triangle-left-filled': 'shape',
    'triangle-right': 'shape',
    'triangle-right-filled': 'shape',
    'triangle-up': 'shape',
    'triangle-up-filled': 'shape',
    'truck': 'transport',
    'umbrella': 'item',
    'wifi': 'ui',
};

/** Do not edit! This file is auto-generated. */
const synonyms$1 = {
    'airplane': ['aeroplane', 'fly', 'travel', 'vacation', 'trip', 'flight', 'airport'],
    'angle-down': ['arrow-down', 'chevron-down', 'bracket-down', 'to-bottom', 'go-down'],
    'angle-left': ['arrow-left', 'chevron-left', 'bracket-left', 'bracket-open', 'opening-bracket', 'less-than', 'back'],
    'angle-right': ['arrow-right', 'chevron-right', 'bracket-right', 'bracket-close', 'closing-bracket', 'greater-than', 'more-than', 'forward'],
    'angle-up': ['arrow-up', 'chevron-up', 'bracket-up', 'to-top', 'go-up'],
    'battery': ['charge'],
    'bell': ['notification', 'attention', 'alert'],
    'bell-off': ['no-notification', 'no-attention', 'quiet', 'silent', 'no-alert'],
    'bicycle': ['bike'],
    'bluetooth': [],
    'book': ['read', 'bookmark'],
    'bookmark': ['flag', 'clip'],
    'bookmark-filled': ['flag', 'clip'],
    'building': ['office', 'sky-scraper', 'business', 'work', 'workplace', 'headquarters', 'enterprise', 'company', 'firm', 'bureau', 'agency', 'corporation'],
    'calculator': ['calculate'],
    'calendar': ['date', 'when'],
    'camera': ['record', 'video'],
    'can': ['pepsi', 'soft-drink', 'fizzy', 'cola', 'cold-drink', 'refresher', 'juice'],
    'car': ['automobile', 'drive'],
    'cart': ['shopping', 'payout', 'commerce', 'transaction', 'buy', 'purchase'],
    'checkmark': ['check', 'toggle', 'tick', 'ok', 'confirmed'],
    'circle': ['bullet', 'ball'],
    'circle-filled': ['bullet', 'ball'],
    'clipboard': ['copy'],
    'clock': ['time', 'timer', 'countdown'],
    'cloud': ['upload', 'online', 'storage', 'save'],
    'cloud-down': ['download', 'storage', 'retrieve', 'fetch', 'local', 'load'],
    'cloud-down-filled': ['download', 'storage', 'retrieve', 'fetch', 'local', 'load'],
    'cloud-filled': ['upload', 'online', 'storage', 'save'],
    'cloud-up': ['upload', 'storage', 'save'],
    'cloud-up-filled': ['upload', 'storage', 'save'],
    'coctail': ['alcohol', 'tropical'],
    'color-picker': [],
    'contract': ['shrink', 'close', 'zoom-out', 'minimize'],
    'controller': ['video-game', 'console'],
    'credit-card': ['master-card', 'visa', 'cashless', 'payment', 'checkout'],
    'cup': ['coffee', 'hot-drink'],
    'division': ['divide'],
    'dots-x': ['dots-horizontal', 'more', 'details', 'menu'],
    'dots-y': ['dots-vertical', 'more', 'details', 'menu'],
    'dress': ['one-piece', 'clothing', 'gown', 'frock', 'garment'],
    'duplicate': ['copy'],
    'electricity': ['thunder', 'lightning'],
    'exclamation': ['bang', 'exclamation-mark', 'exclamation-point', 'shriek', 'pling', 'note-of-admiration', 'warning', 'danger', 'error'],
    'exclamation-filled': ['bang', 'exclamation-mark', 'exclamation-point', 'shriek', 'pling', 'note-of-admiration', 'warning', 'danger', 'error'],
    'expand': ['fullscreen', 'open', 'zoom-in', 'maximize'],
    'eye': ['password-visible', 'see', 'watch', 'awake'],
    'eye-closed': ['password-hidden', 'invisible', 'hide', 'secret', 'asleep'],
    'eye-off': ['password-hidden', 'invisible', 'hide', 'secret', 'not-allowed', 'no-access'],
    'file': ['document', 'record', 'note', 'data', 'archive'],
    'film-frame': ['picture', 'movie', 'roll', 'feature', 'tv', 'television', 'programme', 'motion-picture', 'animation', 'flick', 'cinema'],
    'flag': ['banner', 'country', 'important', 'pin'],
    'flower': ['tulip'],
    'flower-bud': ['daisy'],
    'folder': ['container', 'binder', 'files', 'archive', 'save', 'record', 'keep'],
    'gear': ['settings', 'cogwheel', 'configuration', 'mechanical', 'machinery'],
    'gift': ['present', 'surprise', 'give'],
    'grab': ['handle', 'move', 'drag'],
    'hamburger': ['fast-food'],
    'headphone': ['headset', 'earphone', 'music', 'listen', 'anc'],
    'heart': ['love', 'like'],
    'house': ['home', 'residence'],
    'info': ['information', 'help', 'hint', 'guide'],
    'info-filled': ['information', 'help', 'hint', 'guide'],
    'internet': ['web', 'cyber', 'remote'],
    'key': ['lock', 'unlock', 'encrypt', 'decrypt', 'safe', 'secret', 'solution', 'answer'],
    'knive-fork': ['eat', 'cutlery'],
    'letter': ['email', 'post', 'inbox'],
    'lock-closed': ['lock', 'encrypt'],
    'lock-open': ['unlock', 'decrypt'],
    'loop': ['zoom', 'magnify', 'detective'],
    'loop-minus': ['zoom-out', 'magnify-out', 'farther', 'further'],
    'loop-plus': ['zoom-in', 'magnify-in', 'closer'],
    'magnet': ['attraction', 'repel', 'repulsion'],
    'map': ['location', 'directions'],
    'microphone': ['record', 'voice', 'radio'],
    'minus': ['dash', 'hyphen', 'line'],
    'monitor': ['computer', 'desktop', 'screen'],
    'monitor2': ['computer', 'desktop', 'screen'],
    'moon': ['dark-mode', 'night', 'lights-out'],
    'moon-filled': ['dark-mode', 'lights-out'],
    'motorcycle': ['bike'],
    'music-note-double': ['score', 'solfege', 'song'],
    'music-note-single': ['score', 'solfege', 'song'],
    'open': ['link', 'new-tab', 'external', 'go'],
    'paint-pallet': ['painter', 'art'],
    'pen': ['edit', 'write', 'pencil', 'draw'],
    'person': ['human', 'man', 'someone', 'unknown', 'identity', 'profile', 'you'],
    'person-filled': ['human', 'man', 'someone', 'unknown', 'identity', 'profile', 'you'],
    'phone': ['call', 'talk', 'telephone'],
    'photo-camera': ['photography', 'shutter', 'picture'],
    'pill': ['medicine', 'capsule', 'pellet', 'doctor', 'sick', 'disease', 'cure', 'drugs'],
    'pinpoint': ['location-marker', 'pin', 'position', 'map', 'here', 'where'],
    'pinpoint-filled': ['location-marker', 'pin', 'position', 'map', 'here', 'where'],
    'pinpoint-off': ['location-marker-off', 'pin', 'position', 'map', 'here', 'where'],
    'pinpoint-off-filled': ['location-marker-off', 'pin', 'position', 'map', 'here', 'where'],
    'plus': ['cross', 'add', 'new'],
    'power': ['turn-off', 'shut-down'],
    'printer': ['pdf'],
    'refresh': ['reload', 'fetch', 'twist'],
    'reload': ['refresh', 'turn', 'start-over', 'back'],
    'scissors': ['cut', 'hair', 'clippers', 'shears', 'trimmer', 'barber', 'stylist', 'beauty-parlor', 'coiffeuse', 'coiffeur'],
    'send': ['email', 'paper-plane'],
    'share-android': ['forward', 'connect'],
    'share-ios': ['forward', 'connect'],
    'smartphone': ['iphone', 'mobile-phone', 'cell-phone', 'gsm'],
    'smartphone-notch': ['iphone', 'mobile-phone', 'cell-phone', 'gsm'],
    'smartphone2': ['iphone', 'mobile-phone', 'cell-phone', 'gsm'],
    'soft-drink': ['cold-drink', 'refresher', 'juice'],
    'speaker-high': ['high-volume', 'loud'],
    'speaker-low': ['low-volume', 'quiet'],
    'speaker-off': ['no-volume', 'silent'],
    'square': [],
    'square-filled': [],
    'star': ['favourite', 'favorite', 'rate', 'rating', 'score', 'flag'],
    'star-filled': ['favourite', 'favorite', 'rate', 'rating', 'score', 'flag'],
    'sun': ['light-mode', 'day', 'lights-on', 'brightness'],
    'sun-filled': ['light-mode', 'lights-on', 'brightness'],
    'syringe': ['hypodermic', 'injection', 'vaccine', 'vaccination', 'doctor', 'sick', 'disease', 'cure', 'drugs'],
    't-shirt': ['clothing'],
    'taxi': ['cab'],
    'television': ['tv', 'telly'],
    'text-bubble': ['message', 'chat', 'say', 'typing'],
    'times': ['cross', 'x', 'wrong', 'close', 'stop'],
    'tool': ['wrench', 'hardware', 'fix', 'repair', 'bolt'],
    'train': ['tube', 'metro'],
    'trash': ['delete', 'remove', 'dispense', 'trashcan', 'can', 'garbage'],
    'triangle-down': ['arrow-down'],
    'triangle-down-filled': ['arrow-down'],
    'triangle-left': ['arrow-left'],
    'triangle-left-filled': ['arrow-left'],
    'triangle-right': ['arrow-right'],
    'triangle-right-filled': ['arrow-right'],
    'triangle-up': ['arrow-up'],
    'triangle-up-filled': ['arrow-up'],
    'truck': ['heavy-goods-vehicle', 'juggernaut', 'van', 'pickup', 'lorry', 'move', 'wares', 'deliver', 'haul', 'distribution', 'delivery'],
    'umbrella': ['parasol', 'rain'],
    'wifi': ['internet', 'reception', 'connection', 'sonic', 'waves'],
};

/** This file is to be manually edited. */
const synonyms = {
    'airplane': ['', '', '', '', '', ''],
    'angle-down': ['', '', '', '', ''],
    'angle-left': ['', '', '', '', '', '', '', ''],
    'angle-right': ['', '', '', '', '', '', '', ''],
    'angle-up': ['', '', '', ''],
    'battery': ['', '', ''],
    'bell': ['', '', '', '', '', ''],
    'bell-off': ['', '', '', '', '', ''],
    'bicycle': ['', '', ''],
    'bluetooth': [''],
    'book': ['', '', '', ''],
    'bookmark': ['', '', ''],
    'bookmark-filled': ['', '', ''],
    'building': [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
    ],
    'calculator': ['', '', ''],
    'calendar': ['', '', '', ''],
    'camera': ['', '', '', '', '', ''],
    'can': [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
    ],
    'car': ['', '', '', ''],
    'cart': ['', '', '', '', '', '', ''],
    'checkmark': ['', '', '', 'ok', ''],
    'circle': ['', '', ''],
    'circle-filled': ['', '', ''],
    'clipboard': ['', ''],
    'clock': ['', '', '', '', ''],
    'cloud': [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
    ],
    'cloud-down': ['', '', '', '', '', '', ''],
    'cloud-down-filled': ['', '', '', ''],
    'cloud-filled': [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
    ],
    'cloud-up': ['', '', '', ''],
    'cloud-up-filled': ['', '', '', ''],
    'coctail': [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
    ],
    'color-picker': ['', ''],
    'contract': ['', '', ''],
    'controller': ['', '', ''],
    'credit-card': [
        '',
        '',
        'visa',
        '',
        '',
        '',
        '',
    ],
    'cup': ['', '', '', '', '', ''],
    'division': ['', ''],
    'dots-x': ['', '', '', ''],
    'dots-y': ['', '', '', ''],
    'dress': ['', '', ''],
    'duplicate': ['', ''],
    'electricity': ['', '', '', ''],
    'exclamation': ['', '', '', '', '', ''],
    'exclamation-filled': [
        '',
        '',
        '',
        '',
        '',
        '',
    ],
    'expand': ['', '', '', '', ''],
    'eye': ['', '', '', '', ''],
    'eye-closed': ['', '', '', '', '', ''],
    'eye-off': ['', '', '', '', ''],
    'file': ['', '', '', '', '', '', ''],
    'film-frame': ['', '', '', '', '', '', ''],
    'flag': ['', '', '', ''],
    'flower': ['', ''],
    'flower-bud': ['', ''],
    'folder': ['', '', '', '', ''],
    'gear': ['', '', '', '', ''],
    'gift': [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
    ],
    'grab': ['', '', ''],
    'hamburger': ['', '', ''],
    'headphone': ['', '', '', '', '', '', ''],
    'heart': ['', '', ''],
    'house': ['', '', '', ''],
    'info': ['', '', '', ''],
    'info-filled': ['', '', '', ''],
    'internet': ['', '', '', ''],
    'key': ['', '', '', '', '', '', '', '', '', ''],
    'knive-fork': ['', '', '', ''],
    'letter': ['', '', '', '', '', ''],
    'lock-closed': ['', '', '', '', ''],
    'lock-open': ['', '', '', '', ''],
    'loop': ['', '', '', '', ''],
    'loop-minus': ['', ''],
    'loop-plus': ['', ''],
    'map': ['', '', '', '', ''],
    'microphone': ['', '', '', ''],
    'minus': ['', '', '', '', ''],
    'monitor': ['', '', '', '', ''],
    'monitor2': ['', '', '', '', ''],
    'moon': ['', '', '', '', '', ''],
    'moon-filled': ['', '', '', '', ''],
    'motorcycle': ['', '', ''],
    'music-note-double': ['', '', '', '', '', ''],
    'music-note-single': ['', '', '', '', '', ''],
    'open': ['', ''],
    'paint-pallet': ['', '', ''],
    'pen': ['', '', '', '', ''],
    'person': ['', '', '', '', '', '', ''],
    'person-filled': ['', '', '', '', '', '', ''],
    'phone': ['', '', ''],
    'photo-camera': ['', '', ''],
    'pill': ['', '', '', '', '', '', '', ''],
    'pinpoint': ['', '', ' ', '', '', '', ''],
    'pinpoint-filled': ['', '', ' ', '', '', '', ''],
    'pinpoint-off': ['', '', '', ' ', '', '', '', ''],
    'pinpoint-off-filled': [
        '',
        '',
        '',
        ' ',
        '',
        '',
        '',
        '',
    ],
    'plus': ['', '', '', '', ''],
    'power': ['', '', '', ''],
    'printer': ['', ''],
    'refresh': ['', '', ''],
    'reload': ['', '', '', ''],
    'scissors': [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
    ],
    'send': ['', '', '', ''],
    'share-android': ['', ''],
    'share-ios': ['', ''],
    'smartphone': ['', '', '', '', ''],
    'smartphone2': ['', '', '', '', ''],
    'smartphone-notch': ['', '', '', '', ''],
    'soft-drink': ['', '', '', '', ''],
    'speaker-high': ['', '', '', '', '', ''],
    'speaker-low': ['', '', '', '', '', ''],
    'speaker-off': [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
    ],
    'square': [''],
    'square-filled': [''],
    'magnet': ['', ''],
    'star': ['', '', '', ''],
    'star-filled': ['', '', '', ''],
    'sun': ['', '', '', '', '', ''],
    'sun-filled': ['', '', '', '', '', ''],
    'syringe': ['', '', '', '', '', '', ''],
    't-shirt': ['T', '', ''],
    'taxi': ['', ''],
    'television': ['', ''],
    'text-bubble': ['', '', '', '', ''],
    'times': ['', '', '', '', '', '', '', ''],
    'tool': ['', '', '', '', ''],
    'train': ['', '', '', ''],
    'trash': ['', '', '', '', ''],
    'triangle-down': ['', ''],
    'triangle-down-filled': ['', ''],
    'triangle-left': ['', ''],
    'triangle-left-filled': ['', ''],
    'triangle-right': ['', ''],
    'triangle-right-filled': ['', ''],
    'triangle-up': ['', ''],
    'triangle-up-filled': ['', ''],
    'truck': ['', '', '', '', '', '', '', '', ''],
    'umbrella': ['', '', '', ''],
    'wifi': ['', '', '', ''],
};

const Airplane$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.7549 12.9963L12.6137 11.2918L14.0858 16.5607C14.2873 17.2817 15.1804 17.5338 15.7291 17.0246C17.3078 15.5597 18.1699 14.2058 18.2479 12.8948C18.3038 11.9539 17.8659 10.1553 16.9294 7.33446L17.1593 7.12366C19.4079 4.87645 20.0577 2.91564 18.5923 1.45023C17.1271 -0.0150314 15.1661 0.634362 12.9482 2.85086L12.7079 3.11245C9.88669 2.17579 8.08782 1.73782 7.14683 1.79379C5.83588 1.87176 4.48194 2.73388 3.01704 4.31253C2.50783 4.86128 2.75997 5.75441 3.48097 5.95585L8.75056 7.42815L7.0465 9.28692C5.32628 9.0514 4.24908 8.94907 3.72656 8.98019C2.78982 9.03596 1.86795 9.623 0.89294 10.6737C0.38371 11.2225 0.635886 12.1156 1.35692 12.317L6.01025 13.6169L6.42478 14.0314L7.72462 18.6847C7.92603 19.4058 8.81919 19.658 9.36796 19.1487C10.4187 18.1737 11.0057 17.2518 11.0615 16.3151C11.0926 15.7927 10.9903 14.7159 10.7549 12.9963ZM9.01615 11.8772C8.77322 12.0999 8.65566 12.4281 8.70187 12.7544C8.94065 14.4405 9.06247 15.5704 9.06757 16.0585L8.28047 13.2407C8.23421 13.0751 8.14603 12.9242 8.02445 12.8027L7.239 12.0172C7.11742 11.8956 6.96654 11.8075 6.80093 11.7612L3.98319 10.9741C4.47143 10.9792 5.60166 11.1011 7.28845 11.34C7.61484 11.3862 7.94304 11.2686 8.16579 11.0256L11.3255 7.57908C11.8296 7.02922 11.5759 6.14093 10.8574 5.9402L5.73365 4.50864C6.33268 4.04943 6.84845 3.81507 7.26558 3.79026C7.90809 3.75204 9.78145 4.2286 12.6835 5.21408C13.059 5.34156 13.4743 5.2352 13.7422 4.94295L14.3922 4.23396C15.8992 2.7292 16.7584 2.44469 17.1781 2.86445C17.5977 3.28405 17.3131 4.14277 15.7764 5.67951L15.0987 6.29966C14.8065 6.5676 14.7002 6.98285 14.8276 7.35825C15.8131 10.2603 16.2896 12.1336 16.2514 12.7761C16.2266 13.1932 15.9922 13.709 15.533 14.308L14.1016 9.18478C13.9009 8.46628 13.0125 8.21263 12.4627 8.71682L9.01615 11.8772Z" fill="currentColor"/>
</svg>
`;

const AngleDown$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M16.6402 8.26824L10.6402 13.2682C9.61589 14.1218 8.33552 12.5854 9.35982 11.7318L15.3598 6.7318C16.3841 5.87822 17.6645 7.41466 16.6402 8.26824Z" fill="currentColor"/>
<path d="M4.64018 6.7318L10.6402 11.7318C11.6645 12.5854 10.3841 14.1218 9.35982 13.2682L3.35982 8.26824C2.33552 7.41466 3.61589 5.87822 4.64018 6.7318Z" fill="currentColor"/>
</svg>
`;

const AngleLeft$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6.73178 10.6402C6.37821 10.2159 6.43554 9.58537 6.85981 9.2318C7.28409 8.87824 7.91466 8.93556 8.26822 9.35984L13.2682 15.3598C13.6218 15.7841 13.5645 16.4147 13.1402 16.7682C12.7159 17.1218 12.0853 17.0645 11.7318 16.6402L6.73178 10.6402Z" fill="currentColor"/>
<path d="M8.26822 10.6402C7.91466 11.0645 7.28409 11.1218 6.85981 10.7682C6.43554 10.4147 6.37821 9.78412 6.73178 9.35984L11.7318 3.35984C12.0853 2.93556 12.7159 2.87824 13.1402 3.2318C13.5645 3.58537 13.6218 4.21593 13.2682 4.64021L8.26822 10.6402Z" fill="currentColor"/>
</svg>
`;

const AngleRight$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M11.7318 9.35984C12.0853 8.93556 12.7159 8.87824 13.1402 9.2318C13.5645 9.58537 13.6218 10.2159 13.2682 10.6402L8.26822 16.6402C7.91466 17.0645 7.28409 17.1218 6.85982 16.7682C6.43554 16.4147 6.37822 15.7841 6.73178 15.3598L11.7318 9.35984Z" fill="currentColor"/>
<path d="M6.73178 4.64021C6.37822 4.21593 6.43554 3.58537 6.85982 3.2318C7.28409 2.87824 7.91466 2.93556 8.26822 3.35984L13.2682 9.35984C13.6218 9.78412 13.5645 10.4147 13.1402 10.7682C12.7159 11.1218 12.0853 11.0645 11.7318 10.6402L6.73178 4.64021Z" fill="currentColor"/>
</svg>
`;

const AngleUp$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M15.3598 13.2682L9.35982 8.26824C8.33552 7.41466 9.61589 5.87822 10.6402 6.7318L16.6402 11.7318C17.6645 12.5854 16.3841 14.1218 15.3598 13.2682Z" fill="currentColor"/>
<path d="M3.35982 11.7318L9.35982 6.7318C10.3841 5.87822 11.6645 7.41466 10.6402 8.26824L4.64019 13.2682C3.61589 14.1218 2.33552 12.5854 3.35982 11.7318Z" fill="currentColor"/>
</svg>
`;

const Battery$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="17" y="7.5" width="2" height="5" rx="0.5" fill="currentColor"/>
<path d="M4 7.5H7V12.5H4V7.5Z" fill="currentColor"/>
<path d="M7.5 7.5H10.5V12.5H7.5V7.5Z" fill="currentColor"/>
<path d="M11 7.5H14V12.5H11V7.5Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14 4.5H4C2.34315 4.5 1 5.84315 1 7.5V12.5C1 14.1569 2.34315 15.5 4 15.5H14C15.6569 15.5 17 14.1569 17 12.5V7.5C17 5.84315 15.6569 4.5 14 4.5ZM3 7.5C3 6.94772 3.44772 6.5 4 6.5H14C14.5523 6.5 15 6.94772 15 7.5V12.5C15 13.0523 14.5523 13.5 14 13.5H4C3.44772 13.5 3 13.0523 3 12.5V7.5Z" fill="currentColor"/>
</svg>
`;

const Bell$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M7.5 17C7.5 16.4477 7.94772 16 8.5 16C9.05228 16 9.5 16.4477 9.5 17C9.5 17.2761 9.72386 17.5 10 17.5C10.2761 17.5 10.5 17.2761 10.5 17C10.5 16.4477 10.9477 16 11.5 16C12.0523 16 12.5 16.4477 12.5 17C12.5 18.3807 11.3807 19.5 10 19.5C8.61929 19.5 7.5 18.3807 7.5 17Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M18 14.5C18 13.3482 17.4284 12.2866 16.5 11.6488V9C16.5 5.68629 13.8137 3 10.5 3H9.5C6.18629 3 3.5 5.68629 3.5 9V11.6488C2.57159 12.2867 2 13.3482 2 14.5C2 15.8807 3.11929 17 4.5 17H15.5C16.8807 17 18 15.8807 18 14.5ZM14.5 12.8819L15.0904 13.147L15.1434 13.1709C15.665 13.4075 16 13.9273 16 14.5C16 14.7761 15.7761 15 15.5 15H4.5C4.22386 15 4 14.7761 4 14.5C4 13.9273 4.335 13.4075 4.85658 13.1709L4.90959 13.147L5.5 12.8819V9C5.5 6.79086 7.29086 5 9.5 5H10.5C12.7091 5 14.5 6.79086 14.5 9V12.8819Z" fill="currentColor"/>
<path d="M9 1.5C9 0.947715 9.44772 0.5 10 0.5C10.5523 0.5 11 0.947716 11 1.5L11 4C11 4.55229 10.5523 5 10 5C9.44771 5 9 4.55228 9 4L9 1.5Z" fill="currentColor"/>
</svg>
`;

const BellOff$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M7.5 17C7.5 16.4477 7.94772 16 8.5 16C9.05229 16 9.5 16.4477 9.5 17C9.5 17.2761 9.72386 17.5 10 17.5C10.2761 17.5 10.5 17.2761 10.5 17C10.5 16.4477 10.9477 16 11.5 16C12.0523 16 12.5 16.4477 12.5 17C12.5 18.3807 11.3807 19.5 10 19.5C8.61929 19.5 7.5 18.3807 7.5 17Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M18 14.5C18 13.3482 17.4284 12.2866 16.5 11.6488V9C16.5 5.68629 13.8137 3 10.5 3H9.5C6.18629 3 3.5 5.68629 3.5 9V11.6488C2.57159 12.2867 2 13.3482 2 14.5C2 15.8807 3.11929 17 4.5 17H15.5C16.8807 17 18 15.8807 18 14.5ZM14.5 12.8819L15.0904 13.147L15.1434 13.1709C15.665 13.4075 16 13.9273 16 14.5C16 14.7761 15.7761 15 15.5 15H4.5C4.22386 15 4 14.7761 4 14.5C4 13.9273 4.335 13.4075 4.85658 13.1709L4.90959 13.147L5.5 12.8819V9C5.5 6.79086 7.29086 5 9.5 5H10.5C12.7091 5 14.5 6.79086 14.5 9V12.8819Z" fill="currentColor"/>
<path d="M9 1.5C9 0.947715 9.44772 0.5 10 0.5C10.5523 0.5 11 0.947716 11 1.5L11 4C11 4.55229 10.5523 5 10 5C9.44771 5 9 4.55228 9 4L9 1.5Z" fill="currentColor"/>
<path d="M0.81933 4.52526C0.415414 4.14861 0.393317 3.51583 0.769974 3.11191C1.14663 2.708 1.77941 2.6859 2.18333 3.06256L18.2232 18.0199C18.6271 18.3966 18.6492 19.0294 18.2725 19.4333C17.8959 19.8372 17.2631 19.8593 16.8592 19.4827L0.81933 4.52526Z" fill="currentColor"/>
</svg>
`;

const Bicycle$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13.0616 3.93632C12.5103 3.97032 12.0359 3.55102 12.0019 2.99978C11.9679 2.44854 12.3872 1.97411 12.9384 1.94011C16.8273 1.70025 19 2.46051 19 4.44073C19 6.01406 18.0221 6.71355 16.1454 6.9894C15.599 7.06971 15.0909 6.69187 15.0106 6.14545C14.9303 5.59904 15.3082 5.09098 15.8546 5.01066C16.8709 4.86127 17 4.76892 17 4.44073C17 4.14373 15.9059 3.76088 13.0616 3.93632Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15.5 20C17.9853 20 20 17.9853 20 15.5C20 13.0147 17.9853 11 15.5 11C13.0147 11 11 13.0147 11 15.5C11 17.9853 13.0147 20 15.5 20ZM15.5 13C16.8807 13 18 14.1193 18 15.5C18 16.8807 16.8807 18 15.5 18C14.1193 18 13 16.8807 13 15.5C13 14.1193 14.1193 13 15.5 13Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.5 20C6.98528 20 9 17.9853 9 15.5C9 13.0147 6.98528 11 4.5 11C2.01472 11 0 13.0147 0 15.5C0 17.9853 2.01472 20 4.5 20ZM4.5 13C5.88071 13 7 14.1193 7 15.5C7 16.8807 5.88071 18 4.5 18C3.11929 18 2 16.8807 2 15.5C2 14.1193 3.11929 13 4.5 13Z" fill="currentColor"/>
<path d="M5 6.5C4.44772 6.5 4 6.05228 4 5.5C4 4.94772 4.44772 4.5 5 4.5H9C9.55228 4.5 10 4.94772 10 5.5C10 6.05228 9.55228 6.5 9 6.5H5Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.49999 16.5004H9.99999C10.6363 16.5004 11.0986 15.9191 10.983 15.3153L14.8473 9.14984C15.2647 8.48384 14.786 7.61876 14 7.61876H8.45062L7.64761 5.18682C7.47444 4.66239 6.90893 4.37763 6.38449 4.55079C5.86006 4.72396 5.5753 5.28948 5.74846 5.81391L6.75471 8.86133L3.60865 15.047C3.27029 15.7123 3.75361 16.5004 4.49999 16.5004ZM7.63799 11.5364L6.1305 14.5004H8.61669L7.63799 11.5364ZM10.1744 12.8394L12.193 9.61876H9.11102L10.1744 12.8394Z" fill="currentColor"/>
<path d="M13.9808 2.74302L16.4808 15.3048C16.741 16.6125 14.7795 17.0029 14.5192 15.6952L12.0192 3.13339C11.759 1.8257 13.7205 1.43533 13.9808 2.74302Z" fill="currentColor"/>
</svg>
`;

const Bluetooth$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.5351 10.7951L17.1065 6.54508C17.6312 6.14486 17.6312 5.35514 17.1065 4.95492L11.5351 0.704921C10.8769 0.202853 9.92857 0.672195 9.92857 1.5L9.92857 10C9.92857 10.8278 10.8769 11.2971 11.5351 10.7951ZM11.9286 3.52056L14.8512 5.75L11.9286 7.97945L11.9286 3.52056Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.5351 19.2951L17.1065 15.0451C17.6312 14.6449 17.6312 13.8551 17.1065 13.4549L11.5351 9.20492C10.8769 8.70285 9.92857 9.1722 9.92857 10L9.92857 18.5C9.92857 19.3278 10.8769 19.7971 11.5351 19.2951ZM11.9286 12.0206L14.8512 14.25L11.9286 16.4794L11.9286 12.0206Z" fill="currentColor"/>
<path d="M11.5264 9.19846C11.9691 9.52866 12.0604 10.1552 11.7302 10.5979C11.4 11.0406 10.7734 11.1318 10.3307 10.8016L3.3664 5.60719C2.9237 5.27699 2.83249 4.65043 3.16269 4.20772C3.49289 3.76502 4.11945 3.67382 4.56216 4.00402L11.5264 9.19846Z" fill="currentColor"/>
<path d="M11.5264 10.8015C11.9691 10.4713 12.0604 9.84478 11.7302 9.40207C11.4 8.95937 10.7734 8.86817 10.3307 9.19837L3.3664 14.3928C2.9237 14.723 2.83249 15.3496 3.16269 15.7923C3.49289 16.235 4.11945 16.3262 4.56216 15.996L11.5264 10.8015Z" fill="currentColor"/>
</svg>
`;

const Book$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11 5.29733C11 4.80746 10.6451 4.38971 10.1617 4.31049L2.32344 3.02599C2.21652 3.00847 2.10835 2.99966 2 2.99966C0.89543 2.99966 0 3.89509 0 4.99966V14.7366C0 15.7218 0.717527 16.5603 1.69094 16.7125L9.84547 17.988C10.452 18.0829 11 17.6139 11 17V5.29733ZM2 14.7366V4.99966L9 6.14679V15.8314L2 14.7366Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M20 4.99966C20 3.89509 19.1046 2.99966 18 2.99966C17.8917 2.99966 17.7835 3.00847 17.6766 3.02599L9.83828 4.31049C9.35486 4.38971 9 4.80746 9 5.29733V17C9 17.6139 9.54801 18.0829 10.1545 17.988L18.3091 16.7125C19.2825 16.5603 20 15.7218 20 14.7366V4.99966ZM18 14.7366L11 15.8314V6.14679L18 4.99966V14.7366Z" fill="currentColor"/>
</svg>
`;

const Bookmark$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.24548 17.6665L10 13.4673L13.7545 17.6665C14.3665 18.3509 15.5 17.9181 15.5 17V3C15.5 2.44772 15.0523 2 14.5 2H5.5C4.94772 2 4.5 2.44772 4.5 3V17C4.5 17.9181 5.63355 18.3509 6.24548 17.6665ZM6.5 14.3812V4H13.5V14.3812L10.7455 11.3004C10.3479 10.8558 9.65206 10.8558 9.25452 11.3004L6.5 14.3812Z" fill="currentColor"/>
</svg>
`;

const BookmarkFilled = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10 13.4673L6.24548 17.6665C5.63355 18.3509 4.5 17.9181 4.5 17V3C4.5 2.44772 4.94772 2 5.5 2H14.5C15.0523 2 15.5 2.44772 15.5 3V17C15.5 17.9181 14.3665 18.3509 13.7545 17.6665L10 13.4673Z" fill="currentColor"/>
</svg>
`;

const Building$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M2 18.5C1.44772 18.5 1 18.0523 1 17.5C1 16.9477 1.44772 16.5 2 16.5H18C18.5523 16.5 19 16.9477 19 17.5C19 18.0523 18.5523 18.5 18 18.5H2Z" fill="currentColor"/>
<path d="M6.5 17C6.5 17.5523 6.05228 18 5.5 18C4.94772 18 4.5 17.5523 4.5 17V4.30769C4.5 2.51017 5.80881 1 7.5 1H12.5C14.1912 1 15.5 2.51017 15.5 4.30769V17C15.5 17.5523 15.0523 18 14.5 18C13.9477 18 13.5 17.5523 13.5 17V4.30769C13.5 3.55621 13.018 3 12.5 3H7.5C6.98205 3 6.5 3.55621 6.5 4.30769V17Z" fill="currentColor"/>
<path d="M8 4H9C9.27614 4 9.5 4.22386 9.5 4.5V5.5C9.5 5.77614 9.27614 6 9 6H8C7.72386 6 7.5 5.77614 7.5 5.5V4.5C7.5 4.22386 7.72386 4 8 4Z" fill="currentColor"/>
<path d="M11 4H12C12.2761 4 12.5 4.22386 12.5 4.5V5.5C12.5 5.77614 12.2761 6 12 6H11C10.7239 6 10.5 5.77614 10.5 5.5V4.5C10.5 4.22386 10.7239 4 11 4Z" fill="currentColor"/>
<path d="M11 7H12C12.2761 7 12.5 7.22386 12.5 7.5V8.5C12.5 8.77614 12.2761 9 12 9H11C10.7239 9 10.5 8.77614 10.5 8.5V7.5C10.5 7.22386 10.7239 7 11 7Z" fill="currentColor"/>
<path d="M11 10H12C12.2761 10 12.5 10.2239 12.5 10.5V11.5C12.5 11.7761 12.2761 12 12 12H11C10.7239 12 10.5 11.7761 10.5 11.5V10.5C10.5 10.2239 10.7239 10 11 10Z" fill="currentColor"/>
<path d="M11 13H12C12.2761 13 12.5 13.2239 12.5 13.5V14.5C12.5 14.7761 12.2761 15 12 15H11C10.7239 15 10.5 14.7761 10.5 14.5V13.5C10.5 13.2239 10.7239 13 11 13Z" fill="currentColor"/>
<path d="M8 7H9C9.27614 7 9.5 7.22386 9.5 7.5V8.5C9.5 8.77614 9.27614 9 9 9H8C7.72386 9 7.5 8.77614 7.5 8.5V7.5C7.5 7.22386 7.72386 7 8 7Z" fill="currentColor"/>
<path d="M8 13H9C9.27614 13 9.5 13.2239 9.5 13.5V14.5C9.5 14.7761 9.27614 15 9 15H8C7.72386 15 7.5 14.7761 7.5 14.5V13.5C7.5 13.2239 7.72386 13 8 13Z" fill="currentColor"/>
<path d="M8 10H9C9.27614 10 9.5 10.2239 9.5 10.5V11.5C9.5 11.7761 9.27614 12 9 12H8C7.72386 12 7.5 11.7761 7.5 11.5V10.5C7.5 10.2239 7.72386 10 8 10Z" fill="currentColor"/>
</svg>
`;

const Calculator$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 3L2 17C2 18.6569 3.34315 20 5 20H15C16.6569 20 18 18.6569 18 17V3C18 1.34315 16.6569 0 15 0H5C3.34315 0 2 1.34315 2 3ZM5 18C4.44772 18 4 17.5523 4 17L4 3C4 2.44772 4.44772 2 5 2H15C15.5523 2 16 2.44772 16 3V17C16 17.5523 15.5523 18 15 18H5Z" fill="currentColor"/>
<path d="M5 7.5V3.5C5 3.22386 5.22386 3 5.5 3L14.5 3C14.7761 3 15 3.22386 15 3.5V7.5C15 7.77614 14.7761 8 14.5 8H5.5C5.22386 8 5 7.77614 5 7.5Z" fill="currentColor"/>
<path d="M12 15.7V10.8C12 10.3582 12.3582 10 12.8 10H14.2C14.6418 10 15 10.3582 15 10.8V15.7C15 16.1418 14.6418 16.5 14.2 16.5H12.8C12.3582 16.5 12 16.1418 12 15.7Z" fill="currentColor"/>
<path d="M5 12V10.5C5 10.2239 5.22386 10 5.5 10H7C7.27614 10 7.5 10.2239 7.5 10.5V12C7.5 12.2761 7.27614 12.5 7 12.5H5.5C5.22386 12.5 5 12.2761 5 12Z" fill="currentColor"/>
<path d="M8.5 12V10.5C8.5 10.2239 8.72386 10 9 10H10.5C10.7761 10 11 10.2239 11 10.5V12C11 12.2761 10.7761 12.5 10.5 12.5H9C8.72386 12.5 8.5 12.2761 8.5 12Z" fill="currentColor"/>
<path d="M5 16V14.5C5 14.2239 5.22386 14 5.5 14H7C7.27614 14 7.5 14.2239 7.5 14.5V16C7.5 16.2761 7.27614 16.5 7 16.5H5.5C5.22386 16.5 5 16.2761 5 16Z" fill="currentColor"/>
<path d="M8.5 16V14.5C8.5 14.2239 8.72386 14 9 14H10.5C10.7761 14 11 14.2239 11 14.5V16C11 16.2761 10.7761 16.5 10.5 16.5H9C8.72386 16.5 8.5 16.2761 8.5 16Z" fill="currentColor"/>
</svg>
`;

const Calendar$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3 4H17C17.5523 4 18 4.44772 18 5V17C18 17.5523 17.5523 18 17 18H3C2.44772 18 2 17.5523 2 17V5C2 4.44772 2.44772 4 3 4ZM4 8V16H16V8H4Z" fill="currentColor"/>
<circle cx="6.5" cy="10.5" r="1.5" fill="currentColor"/>
<circle cx="5.5" cy="4.5" r="1.5" fill="currentColor"/>
<circle cx="14.5" cy="4.5" r="1.5" fill="currentColor"/>
</svg>
`;

const Camera$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.5 4H4.5C2.84315 4 1.5 5.34315 1.5 7V13C1.5 14.6569 2.84315 16 4.5 16H11.5C13.1569 16 14.5 14.6569 14.5 13V7C14.5 5.34315 13.1569 4 11.5 4ZM3.5 7C3.5 6.44772 3.94772 6 4.5 6H11.5C12.0523 6 12.5 6.44772 12.5 7V13C12.5 13.5523 12.0523 14 11.5 14H4.5C3.94772 14 3.5 13.5523 3.5 13V7Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M16.9339 5.17564L13.4659 7.55708C13.1971 7.74161 13.0352 8.04554 13.032 8.37151L13 11.5867C12.9967 11.9197 13.1594 12.2325 13.4339 12.421L16.9339 14.8244C17.5975 15.28 18.5 14.8049 18.5 14V6C18.5 5.19508 17.5975 4.72 16.9339 5.17564ZM16.5 12.1003L15.0052 11.0739L15.0267 8.91141L16.5 7.89974V12.1003Z" fill="currentColor"/>
</svg>
`;

const Can$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.5 2H7.5C5.83333 2.66667 4.83333 3.66667 4.5 5V15C4.5 16.6569 5.84315 18 7.5 18H12.5C14.1569 18 15.5 16.6569 15.5 15V5C15.1667 3.66667 14.1667 2.66667 12.5 2ZM6.5 15V5.29379C6.68962 4.79195 7.1237 4.36779 7.91138 4H12.0886C12.8763 4.36779 13.3104 4.79195 13.5 5.29379V15C13.5 15.5523 13.0523 16 12.5 16H7.5C6.94772 16 6.5 15.5523 6.5 15Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M7 9.5C7 11.7091 8.79086 13.5 11 13.5C13.2091 13.5 15 11.7091 15 9.5C15 7.29086 13.2091 5.5 11 5.5C8.79086 5.5 7 7.29086 7 9.5ZM9.80484 10.9055C9.55673 10.9664 9.15223 11.09 8.58357 11.2782C8.56278 11.25 8.54246 11.2214 8.52264 11.1925C9.78121 10.8145 10.7946 10.2379 11.5554 9.45908C12.2367 8.7617 12.6995 8.01039 12.9365 7.20862C13.0856 7.33479 13.2223 7.47526 13.3443 7.62791C13.4677 8.46285 13.3733 9.08532 13.0855 9.51186C12.7303 10.0384 12.1353 10.3668 11.5805 10.5122C11.5089 10.5309 11.3794 10.5603 11.1777 10.6038C11.1136 10.6176 10.9312 10.6565 10.7798 10.6887C10.683 10.7093 10.5989 10.7273 10.5665 10.7342L10.4542 10.7584C10.1799 10.8176 9.9714 10.8646 9.80484 10.9055Z" fill="currentColor"/>
</svg>
`;

const Car$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.65265 2.78967C4.74897 3.00861 4.04146 3.71098 3.81595 4.61304L2.68528 9.1357C1.70458 9.47358 1 10.4045 1 11.4999V14.4999C1 15.8807 2.11929 16.9999 3.5 16.9999H16.5C17.8807 16.9999 19 15.8807 19 14.4999V11.4999C19 10.4045 18.2954 9.47358 17.3147 9.1357L16.184 4.61293C15.9585 3.71099 15.2512 3.00867 14.3476 2.78962C12.9007 2.43894 11.4512 2.26331 10.0007 2.26331C8.55011 2.26331 7.10023 2.43896 5.65265 2.78967ZM3.5 10.9999C3.95887 10.9999 4.35885 10.6876 4.47014 10.2425L5.75623 5.09811C5.80133 4.9177 5.94284 4.77722 6.12357 4.73344C7.41806 4.41982 8.70992 4.26331 10.0007 4.26331C11.2914 4.26331 12.5828 4.41978 13.8765 4.73333C14.0572 4.77714 14.1986 4.91761 14.2437 5.09801L15.5299 10.2425C15.6411 10.6876 16.0411 10.9999 16.5 10.9999C16.7761 10.9999 17 11.2238 17 11.4999V14.4999C17 14.7761 16.7761 14.9999 16.5 14.9999H3.5C3.22386 14.9999 3 14.7761 3 14.4999V11.4999C3 11.2238 3.22386 10.9999 3.5 10.9999Z" fill="currentColor"/>
<path d="M16.5 13C16.5 13.8284 15.8284 14.5 15 14.5C14.1716 14.5 13.5 13.8284 13.5 13C13.5 12.1716 14.1716 11.5 15 11.5C15.8284 11.5 16.5 12.1716 16.5 13Z" fill="currentColor"/>
<path d="M6.5 13C6.5 13.8284 5.82843 14.5 5 14.5C4.17157 14.5 3.5 13.8284 3.5 13C3.5 12.1716 4.17157 11.5 5 11.5C5.82843 11.5 6.5 12.1716 6.5 13Z" fill="currentColor"/>
<path d="M4 15.5C4.82843 15.5 5.5 16.1716 5.5 17V18C5.5 18.8284 4.82843 19.5 4 19.5C3.17157 19.5 2.5 18.8284 2.5 18V17C2.5 16.1716 3.17157 15.5 4 15.5Z" fill="currentColor"/>
<path d="M16 15.5C16.8284 15.5 17.5 16.1716 17.5 17V18C17.5 18.8284 16.8284 19.5 16 19.5C15.1716 19.5 14.5 18.8284 14.5 18V17C14.5 16.1716 15.1716 15.5 16 15.5Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.1948 5H7.80491C6.862 5 6.04716 5.65858 5.8494 6.58052L5.42037 8.58052C5.3908 8.71839 5.37589 8.859 5.37589 9C5.37589 10.1046 6.27132 11 7.37589 11H12.6238C12.7648 11 12.9054 10.9851 13.0433 10.9555C14.1233 10.7238 14.811 9.66052 14.5793 8.58052L14.1503 6.58052C13.9525 5.65858 13.1377 5 12.1948 5ZM7.37589 9L7.80491 7H12.1948L12.6238 9H7.37589Z" fill="currentColor"/>
</svg>
`;

const Cart$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M16.5131 6L7.48727 6C7.29999 6 7.11329 6.02105 6.9307 6.06274C5.58464 6.37013 4.74263 7.71051 5.05002 9.05657L5.96345 13.0566C6.2231 14.1936 7.23443 15 8.40071 15L15.5996 15C16.7659 15 17.7772 14.1936 18.0369 13.0566L18.9503 9.05657C18.992 8.87398 19.0131 8.68729 19.0131 8.5C19.0131 7.11929 17.8938 6 16.5131 6ZM7.37596 8.01255C7.41248 8.00421 7.44982 8 7.48727 8L16.5131 8C16.7892 8 17.0131 8.22386 17.0131 8.5C17.0131 8.53746 17.0089 8.5748 17.0005 8.61131L16.0871 12.6113C16.0352 12.8387 15.8329 13 15.5996 13L8.40071 13C8.16745 13 7.96519 12.8387 7.91326 12.6113L6.99982 8.61131C6.93835 8.3421 7.10675 8.07403 7.37596 8.01255Z" fill="currentColor"/>
<path d="M3.49044 2L2 2C1.44772 2 1 1.55228 1 1C1 0.447715 1.44772 0 2 0L4.28977 0C4.75718 0 5.16223 0.323776 5.2652 0.779696L7.97543 12.7797C8.0971 13.3184 7.75902 13.8538 7.2203 13.9754C6.68159 14.0971 6.14624 13.759 6.02457 13.2203L3.49044 2Z" fill="currentColor"/>
<path d="M10 17.25C10 18.2165 9.2165 19 8.25 19C7.2835 19 6.5 18.2165 6.5 17.25C6.5 16.2835 7.2835 15.5 8.25 15.5C9.2165 15.5 10 16.2835 10 17.25Z" fill="currentColor"/>
<path d="M17 17.25C17 18.2165 16.2165 19 15.25 19C14.2835 19 13.5 18.2165 13.5 17.25C13.5 16.2835 14.2835 15.5 15.25 15.5C16.2165 15.5 17 16.2835 17 17.25Z" fill="currentColor"/>
</svg>
`;

const Checkmark$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M15.3742 5.98559L10.3742 14.9856C9.72664 16.1511 7.97833 15.1798 8.62585 14.0143L13.6258 5.01431C14.2734 3.84876 16.0217 4.82005 15.3742 5.98559Z" fill="currentColor"/>
<path d="M5.1247 9.71907L10.1247 13.7191C11.1659 14.552 9.91646 16.1137 8.87531 15.2808L3.87531 11.2808C2.83415 10.4479 4.08354 8.88615 5.1247 9.71907Z" fill="currentColor"/>
</svg>
`;

const Circle$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.5 10C4.5 13.0376 6.96243 15.5 10 15.5C13.0376 15.5 15.5 13.0376 15.5 10C15.5 6.96243 13.0376 4.5 10 4.5C6.96243 4.5 4.5 6.96243 4.5 10ZM13.5 10C13.5 11.933 11.933 13.5 10 13.5C8.067 13.5 6.5 11.933 6.5 10C6.5 8.067 8.067 6.5 10 6.5C11.933 6.5 13.5 8.067 13.5 10Z" fill="currentColor"/>
</svg>
`;

const CircleFilled = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="10" cy="10" r="6" fill="currentColor"/>
</svg>
`;

const Clipboard$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13 2.5H7C6.44772 2.5 6 2.94772 6 3.5V7C6 7.55228 6.44772 8 7 8H13C13.5523 8 14 7.55228 14 7V3.5C14 2.94772 13.5523 2.5 13 2.5ZM8 6V4.5H12V6H8Z" fill="currentColor"/>
<path d="M15.5 17.5H4.5C3.94772 17.5 3.5 17.0523 3.5 16.5V4.5C3.5 3.94772 3.94772 3.5 4.5 3.5H7.5V5.5H5.5V15.5H14.5V5.5H12.5V3.5H15.5C16.0523 3.5 16.5 3.94772 16.5 4.5V16.5C16.5 17.0523 16.0523 17.5 15.5 17.5Z" fill="currentColor"/>
</svg>
`;

const Clock$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10.4608 12.7593C10.0415 13.1187 9.41017 13.0701 9.05074 12.6508C8.69132 12.2315 8.73988 11.6002 9.15921 11.2408L12.6592 8.24076C13.0785 7.88134 13.7098 7.9299 14.0693 8.34923C14.4287 8.76855 14.3801 9.39985 13.9608 9.75927L10.4608 12.7593Z" fill="currentColor"/>
<path d="M8.81 6C8.81 5.44772 9.25772 5 9.81 5C10.3623 5 10.81 5.44772 10.81 6V12C10.81 12.5523 10.3623 13 9.81 13C9.25772 13 8.81 12.5523 8.81 12V6Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 10C2 14.4183 5.58172 18 10 18C14.4183 18 18 14.4183 18 10C18 5.58172 14.4183 2 10 2C5.58172 2 2 5.58172 2 10ZM16 10C16 13.3137 13.3137 16 10 16C6.68629 16 4 13.3137 4 10C4 6.68629 6.68629 4 10 4C13.3137 4 16 6.68629 16 10Z" fill="currentColor"/>
</svg>
`;

const Cloud$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11 3H10C8.13616 3 6.57006 4.27477 6.12602 6H6C3.79086 6 2 7.79086 2 10C2 12.2091 3.79086 14 6 14H14C16.2091 14 18 12.2091 18 10C18 8.09985 16.6751 6.50915 14.8987 6.10135C14.4909 4.32493 12.9002 3 11 3ZM7.67644 8L8.06289 6.49852C8.28793 5.62419 9.08228 5 10 5H11C11.9367 5 12.7431 5.65018 12.9494 6.54883L13.2297 7.77025L14.4512 8.05064C15.3498 8.25694 16 9.06327 16 10C16 11.1046 15.1046 12 14 12H6C4.89543 12 4 11.1046 4 10C4 8.89543 4.89543 8 6 8H7.67644Z" fill="currentColor"/>
</svg>
`;

const CloudDown$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11 3H10C8.13616 3 6.57006 4.27477 6.12602 6H6C3.79086 6 2 7.79086 2 10C2 12.2091 3.79086 14 6 14H14C16.2091 14 18 12.2091 18 10C18 8.09985 16.6751 6.50915 14.8987 6.10135C14.4909 4.32493 12.9002 3 11 3ZM7.67644 8L8.06289 6.49852C8.28793 5.62419 9.08228 5 10 5H11C11.9367 5 12.7431 5.65018 12.9494 6.54883L13.2297 7.77025L14.4512 8.05064C15.3498 8.25694 16 9.06327 16 10C16 11.1046 15.1046 12 14 12H6C4.89543 12 4 11.1046 4 10C4 8.89543 4.89543 8 6 8H7.67644Z" fill="currentColor"/>
<path d="M9.5 10C9.5 9.44771 9.94772 9 10.5 9C11.0523 9 11.5 9.44771 11.5 10L11.5 17.5C11.5 18.0523 11.0523 18.5 10.5 18.5C9.94772 18.5 9.5 18.0523 9.5 17.5V10Z" fill="currentColor"/>
<path d="M12.3753 14.7191C12.8066 14.3741 13.4359 14.444 13.7809 14.8753C14.1259 15.3065 14.056 15.9358 13.6247 16.2808L11.1247 18.2808C10.6934 18.6258 10.0641 18.5559 9.71912 18.1247C9.37412 17.6934 9.44404 17.0641 9.8753 16.7191L12.3753 14.7191Z" fill="currentColor"/>
<path d="M7.3753 16.2808C6.94404 15.9358 6.87412 15.3065 7.21912 14.8753C7.56413 14.444 8.19343 14.3741 8.62469 14.7191L11.1247 16.7191C11.556 17.0641 11.6259 17.6934 11.2809 18.1247C10.9359 18.5559 10.3066 18.6258 9.8753 18.2808L7.3753 16.2808Z" fill="currentColor"/>
</svg>
`;

const CloudDownFilled = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12 14V9.25C12 8.42157 11.3284 7.75 10.5 7.75C9.67157 7.75 9 8.42157 9 9.25V14H6C3.79086 14 2 12.2091 2 10C2 7.79086 3.79086 6 6 6H6.12602C6.57006 4.27477 8.13616 3 10 3H11C12.9002 3 14.4909 4.32493 14.8987 6.10135C16.6751 6.50915 18 8.09985 18 10C18 12.2091 16.2091 14 14 14H12Z" fill="currentColor"/>
<path d="M9.5 9.5C9.5 8.94771 9.94772 8.5 10.5 8.5C11.0523 8.5 11.5 8.94771 11.5 9.5L11.5 17C11.5 17.5523 11.0523 18 10.5 18C9.94772 18 9.5 17.5523 9.5 17V9.5Z" fill="currentColor"/>
<path d="M12.3753 14.7191C12.8066 14.3741 13.4359 14.444 13.7809 14.8753C14.1259 15.3065 14.056 15.9358 13.6247 16.2808L11.1247 18.2808C10.6934 18.6258 10.0641 18.5559 9.71912 18.1247C9.37412 17.6934 9.44404 17.0641 9.8753 16.7191L12.3753 14.7191Z" fill="currentColor"/>
<path d="M7.3753 16.2808C6.94404 15.9358 6.87412 15.3065 7.21912 14.8753C7.56413 14.444 8.19343 14.3741 8.62469 14.7191L11.1247 16.7191C11.556 17.0641 11.6259 17.6934 11.2809 18.1247C10.9359 18.5559 10.3066 18.6258 9.8753 18.2808L7.3753 16.2808Z" fill="currentColor"/>
</svg>
`;

const CloudFilled = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="2" y="6" width="16" height="8" rx="4" fill="currentColor"/>
<rect x="6" y="3" width="9" height="8" rx="4" fill="currentColor"/>
</svg>
`;

const CloudUp$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11 3H10C8.13616 3 6.57006 4.27477 6.12602 6H6C3.79086 6 2 7.79086 2 10C2 12.2091 3.79086 14 6 14H14C16.2091 14 18 12.2091 18 10C18 8.09985 16.6751 6.50915 14.8987 6.10135C14.4909 4.32493 12.9002 3 11 3ZM7.67644 8L8.06289 6.49852C8.28793 5.62419 9.08228 5 10 5H11C11.9367 5 12.7431 5.65018 12.9494 6.54883L13.2297 7.77025L14.4512 8.05064C15.3498 8.25694 16 9.06327 16 10C16 11.1046 15.1046 12 14 12H6C4.89543 12 4 11.1046 4 10C4 8.89543 4.89543 8 6 8H7.67644Z" fill="currentColor"/>
<path d="M11.5 16C11.5 16.5523 11.0523 17 10.5 17C9.94772 17 9.5 16.5523 9.5 16V8.5C9.5 7.94772 9.94772 7.5 10.5 7.5C11.0523 7.5 11.5 7.94772 11.5 8.5V16Z" fill="currentColor"/>
<path d="M8.6247 11.2809C8.19344 11.6259 7.56415 11.556 7.21914 11.1247C6.87413 10.6935 6.94405 10.0642 7.37531 9.71917L9.87531 7.71917C10.3066 7.37416 10.9359 7.44408 11.2809 7.87534C11.6259 8.3066 11.556 8.9359 11.1247 9.28091L8.6247 11.2809Z" fill="currentColor"/>
<path d="M13.6247 9.71917C14.056 10.0642 14.1259 10.6935 13.7809 11.1247C13.4359 11.556 12.8066 11.6259 12.3753 11.2809L9.87531 9.28091C9.44405 8.9359 9.37413 8.3066 9.71914 7.87534C10.0641 7.44408 10.6934 7.37416 11.1247 7.71917L13.6247 9.71917Z" fill="currentColor"/>
</svg>
`;

const CloudUpFilled = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.5 14V10.6777L12.252 11.2653C12.6872 11.6053 13.3157 11.5281 13.6557 11.0929C13.9957 10.6577 13.9186 10.0293 13.4834 9.68924L11.1791 7.88897C10.9911 7.71827 10.7494 7.6299 10.5057 7.63022C10.262 7.6299 10.0203 7.71827 9.83225 7.88897L7.52801 9.68924C7.0928 10.0293 7.01564 10.6577 7.35566 11.0929C7.69568 11.5281 8.32413 11.6053 8.75933 11.2653L9.5 10.6866V14H6C3.79086 14 2 12.2091 2 10C2 7.79086 3.79086 6 6 6H6.12602C6.57006 4.27477 8.13616 3 10 3H11C12.9002 3 14.4909 4.32493 14.8987 6.10135C16.6751 6.50915 18 8.09985 18 10C18 12.2091 16.2091 14 14 14H11.5Z" fill="currentColor"/>
</svg>
`;

const Coctail$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6 8C5.72386 8 5.5 7.77614 5.5 7.5C5.5 7.22386 5.72386 7 6 7H14C14.2761 7 14.5 7.22386 14.5 7.5C14.5 7.77614 14.2761 8 14 8H6Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.7672 5.68045L9.2672 12.6805C9.66284 13.1065 10.3372 13.1065 10.7328 12.6805L17.2328 5.68045C17.8269 5.0406 17.3732 4 16.5 4L3.5 4C2.62683 4 2.17306 5.0406 2.7672 5.68045ZM14.2068 6L10 10.5304L5.79321 6L14.2068 6Z" fill="currentColor"/>
<path d="M11 11.5V18.5H9V11.5H11Z" fill="currentColor"/>
<path d="M14.5 20H5.5C5.5 18.5251 7.55015 17.5 10 17.5C12.4499 17.5 14.5 18.5251 14.5 20Z" fill="currentColor"/>
<path d="M12.8181 1.7276C12.4163 1.62714 12.1719 1.21994 12.2724 0.818093C12.3729 0.416246 12.7801 0.171926 13.1819 0.272387L17.1819 1.27239C17.5837 1.37285 17.8281 1.78005 17.7276 2.1819C17.6271 2.58374 17.2199 2.82806 16.8181 2.7276L12.8181 1.7276Z" fill="currentColor"/>
<path d="M11.2115 8.73717C11.0805 9.13013 10.6558 9.3425 10.2628 9.21151C9.86987 9.08052 9.6575 8.65578 9.78849 8.26283L12.2885 0.762827C12.4195 0.369869 12.8442 0.157499 13.2372 0.288485C13.6301 0.419471 13.8425 0.844211 13.7115 1.23717L11.2115 8.73717Z" fill="currentColor"/>
</svg>
`;

const ColorPicker$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.53559 15.2365C5.97633 15.853 3.27901 17.6075 2.80761 17.1361C2.50214 16.8306 3.13132 15.5905 3.77986 14.331L8.44112 14.331C8.23989 14.5322 7.93805 14.8341 7.53559 15.2365Z" fill="currentColor"/>
<path d="M15.8033 5.55458C16.1938 5.16405 16.827 5.16405 17.2175 5.55458C17.608 5.9451 17.608 6.57827 17.2175 6.96879L8.24269 15.9436C8.14598 16.0403 8.03045 16.1162 7.90325 16.1665C7.50692 16.3231 7.10374 16.5206 6.15046 17.0117C5.67928 17.2544 5.47122 17.3604 5.21667 17.4858C3.46857 18.3471 2.81156 18.5542 2.1005 17.8432C1.39079 17.1334 1.59726 16.4757 2.45234 14.7382C2.57904 14.4807 2.68633 14.2702 2.93201 13.7932C3.42302 12.8399 3.62051 12.4367 3.7772 12.0404C3.82749 11.9132 3.90334 11.7977 4.00005 11.701L12.9749 2.72615C13.3654 2.33563 13.9986 2.33563 14.3891 2.72615C14.7796 3.11667 14.7796 3.74984 14.3891 4.14036L5.55694 12.9725C5.38269 13.3873 5.16355 13.8285 4.71 14.709C4.47005 15.1749 4.36624 15.3786 4.24681 15.6213C4.22194 15.6718 4.19797 15.721 4.17491 15.7688C4.22594 15.7441 4.27854 15.7184 4.33275 15.6917C4.57289 15.5734 4.77428 15.4708 5.23465 15.2337C6.11518 14.7801 6.55634 14.561 6.97115 14.3867L15.8033 5.55458Z" fill="currentColor"/>
<path d="M14.3891 4.14039C13.9986 4.53092 13.3654 4.53092 12.9749 4.14039C12.5843 3.74987 12.5843 3.1167 12.9749 2.72618C14.1464 1.55461 16.0459 1.55461 17.2175 2.72618C18.3891 3.89775 18.3891 5.79725 17.2175 6.96882C16.827 7.35934 16.1938 7.35934 15.8033 6.96882C15.4128 6.5783 15.4128 5.94513 15.8033 5.55461C16.1938 5.16408 16.1938 4.53092 15.8033 4.14039C15.4128 3.74987 14.7796 3.74987 14.3891 4.14039Z" fill="currentColor"/>
<path d="M9.4373 4.84541C9.04678 4.45489 9.04678 3.82172 9.4373 3.4312C9.82783 3.04067 10.461 3.04067 10.8515 3.4312L16.5084 9.08805C16.8989 9.47858 16.8989 10.1117 16.5084 10.5023C16.1178 10.8928 15.4847 10.8928 15.0942 10.5023L9.4373 4.84541Z" fill="currentColor"/>
</svg>
`;

const Contract$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M11.7071 9.70711C11.3166 10.0976 10.6834 10.0976 10.2929 9.70711C9.90237 9.31658 9.90237 8.68342 10.2929 8.29289L14.2929 4.29289C14.6834 3.90237 15.3166 3.90237 15.7071 4.29289C16.0976 4.68342 16.0976 5.31658 15.7071 5.70711L11.7071 9.70711Z" fill="currentColor"/>
<path d="M11 10C10.4477 10 10 9.55228 10 9C10 8.44772 10.4477 8 11 8H15C15.5523 8 16 8.44772 16 9C16 9.55228 15.5523 10 15 10H11Z" fill="currentColor"/>
<path d="M12 9C12 9.55228 11.5523 10 11 10C10.4477 10 10 9.55228 10 9V5C10 4.44772 10.4477 4 11 4C11.5523 4 12 4.44772 12 5V9Z" fill="currentColor"/>
<path d="M5.70711 15.7071C5.31658 16.0976 4.68342 16.0976 4.29289 15.7071C3.90237 15.3166 3.90237 14.6834 4.29289 14.2929L8.29289 10.2929C8.68342 9.90237 9.31658 9.90237 9.70711 10.2929C10.0976 10.6834 10.0976 11.3166 9.70711 11.7071L5.70711 15.7071Z" fill="currentColor"/>
<path d="M10 15C10 15.5523 9.55228 16 9 16C8.44772 16 8 15.5523 8 15V11C8 10.4477 8.44772 10 9 10C9.55228 10 10 10.4477 10 11V15Z" fill="currentColor"/>
<path d="M5 12C4.44772 12 4 11.5523 4 11C4 10.4477 4.44772 10 5 10H9C9.55228 10 10 10.4477 10 11C10 11.5523 9.55228 12 9 12H5Z" fill="currentColor"/>
</svg>
`;

const Controller$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12.25 10C11.5596 10 11 9.44036 11 8.75C11 8.05964 11.5596 7.5 12.25 7.5C12.9404 7.5 13.5 8.05964 13.5 8.75C13.5 9.44036 12.9404 10 12.25 10Z" fill="currentColor"/>
<path d="M14.25 12.5C13.5596 12.5 13 11.9404 13 11.25C13 10.5596 13.5596 10 14.25 10C14.9404 10 15.5 10.5596 15.5 11.25C15.5 11.9404 14.9404 12.5 14.25 12.5Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.5 4H5.5C2.73858 4 0.5 6.23858 0.5 9V11C0.5 13.7614 2.73858 16 5.5 16H14.5C17.2614 16 19.5 13.7614 19.5 11V9C19.5 6.23858 17.2614 4 14.5 4ZM2.5 9C2.5 7.34315 3.84315 6 5.5 6H14.5C16.1569 6 17.5 7.34315 17.5 9V11C17.5 12.6569 16.1569 14 14.5 14H5.5C3.84315 14 2.5 12.6569 2.5 11V9Z" fill="currentColor"/>
<path d="M4 11C3.44772 11 3 10.5523 3 10C3 9.44772 3.44772 9 4 9H8C8.55228 9 9 9.44772 9 10C9 10.5523 8.55228 11 8 11H4Z" fill="currentColor"/>
<path d="M7 12C7 12.5523 6.55228 13 6 13C5.44772 13 5 12.5523 5 12V8C5 7.44772 5.44772 7 6 7C6.55228 7 7 7.44772 7 8V12Z" fill="currentColor"/>
</svg>
`;

const CreditCard$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M16 4H4C2.34315 4 1 5.34315 1 7V14C1 15.6569 2.34315 17 4 17H16C17.6569 17 19 15.6569 19 14V7C19 5.34315 17.6569 4 16 4ZM3 7C3 6.44772 3.44772 6 4 6H16C16.5523 6 17 6.44772 17 7V14C17 14.5523 16.5523 15 16 15H4C3.44772 15 3 14.5523 3 14V7Z" fill="currentColor"/>
<path d="M2.5 7H17.5C17.7761 7 18 7.22386 18 7.5V8.5C18 8.77614 17.7761 9 17.5 9H2.5C2.22386 9 2 8.77614 2 8.5V7.5C2 7.22386 2.22386 7 2.5 7Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M6 10H5C4.44772 10 4 10.4477 4 11V12C4 12.5523 4.44772 13 5 13H6C6.55228 13 7 12.5523 7 12V11C7 10.4477 6.55228 10 6 10ZM5 12V11H6V12H5Z" fill="currentColor"/>
</svg>
`;

const Cup$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M15.5 4H3.5C2.94772 4 2.5 4.44772 2.5 5C2.5 9.91828 5.56129 14 9.5 14C13.4387 14 16.5 9.91828 16.5 5C16.5 4.44772 16.0523 4 15.5 4ZM9.5 12C7.04469 12 4.90411 9.43007 4.55098 6H14.449C14.0959 9.43007 11.9553 12 9.5 12Z" fill="currentColor"/>
<path d="M4 14.5H15C15.5523 14.5 16 14.9477 16 15.5C16 16.0523 15.5523 16.5 15 16.5H4C3.44772 16.5 3 16.0523 3 15.5C3 14.9477 3.44772 14.5 4 14.5Z" fill="currentColor"/>
<path d="M14.0244 10.8095L14.5756 8.88698C14.8334 8.96088 15.115 9 15.4073 9C16.5144 9 17.3 8.45687 17.3 8C17.3 7.54313 16.5144 7 15.4073 7V5C17.4953 5 19.3 6.24773 19.3 8C19.3 9.75227 17.4953 11 15.4073 11C14.9297 11 14.4625 10.9351 14.0244 10.8095Z" fill="currentColor"/>
</svg>
`;

const Division$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M5 11C4.44772 11 4 10.5523 4 10C4 9.44772 4.44772 9 5 9H15C15.5523 9 16 9.44772 16 10C16 10.5523 15.5523 11 15 11H5Z" fill="currentColor"/>
<circle cx="10" cy="5.5" r="1.5" fill="currentColor"/>
<circle cx="10" cy="14.5" r="1.5" fill="currentColor"/>
</svg>
`;

const DotsX$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="5" cy="10" r="2" fill="currentColor"/>
<circle cx="10" cy="10" r="2" fill="currentColor"/>
<circle cx="15" cy="10" r="2" fill="currentColor"/>
</svg>
`;

const DotsY$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="10" cy="15" r="2" fill="currentColor"/>
<circle cx="10" cy="10" r="2" fill="currentColor"/>
<circle cx="10" cy="5" r="2" fill="currentColor"/>
</svg>
`;

const Dress$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M9.99927 2.70211L9.64627 2.5941C9.28672 2.48409 8.90774 2.45252 8.53495 2.50153C7.09604 2.69069 6.08292 4.01049 6.27208 5.4494L6.46159 6.89101C6.65785 8.38388 7.93029 9.5 9.436 9.5H10.563C12.0687 9.5 13.3412 8.38388 13.5374 6.89101L13.7269 5.4494C13.7759 5.07661 13.7444 4.69765 13.6344 4.33811C13.2098 2.95027 11.7405 2.1694 10.3527 2.59398L9.99927 2.70211ZM8.79562 4.48447C8.88468 4.47276 8.97522 4.48031 9.06112 4.50659L9.99924 4.79362L10.9378 4.50648C11.2694 4.40504 11.6204 4.59161 11.7219 4.9232C11.7482 5.00911 11.7557 5.09965 11.744 5.18872L11.5545 6.63033C11.4891 7.12796 11.0649 7.5 10.563 7.5H9.436C8.9341 7.5 8.50995 7.12796 8.44453 6.63033L8.25502 5.18872C8.20983 4.84496 8.45187 4.52966 8.79562 4.48447Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.9944 8L7.76658 8C7.22684 8 6.69709 8.14562 6.23318 8.42149C4.53499 9.43138 3.28005 10.5679 2.46835 11.8311C2.20882 12.235 1.94566 12.6035 1.69984 12.9477C0.629095 14.4468 -0.112873 15.4856 1.20518 16.9893C2.82583 18.8381 6.25948 20 9.62895 20C12.9984 20 16.355 19.3152 18.5339 16.9893C20.1469 15.2674 19.4765 14.4997 18.4337 13.3053C18.0679 12.8863 17.6561 12.4148 17.2811 11.8311C16.4381 10.5193 15.1772 9.37695 13.4983 8.40423C13.0413 8.13944 12.5225 8 11.9944 8ZM15.5985 12.9123C15.791 13.2119 15.9976 13.4982 16.2256 13.7871C16.2732 13.8474 16.4181 14.0186 16.5949 14.2274C16.8774 14.5611 17.2411 14.9907 17.4184 15.2167C17.3498 15.31 17.2393 15.4458 17.0743 15.622C15.557 17.2417 13.041 18 9.62895 18C6.72121 18 3.87183 16.9973 2.70916 15.6709C2.51428 15.4486 2.49949 15.4439 2.49975 15.4404C2.49978 15.44 2.50002 15.4396 2.50019 15.4389C2.52953 15.3206 2.64581 15.0964 2.89442 14.7271C2.92791 14.6773 3.04237 14.5151 3.18785 14.309C3.45827 13.9257 3.83589 13.3906 3.99994 13.1434C4.05145 13.0658 4.10169 12.9889 4.15093 12.9123C4.78162 11.9308 5.8079 11.0013 7.25545 10.1405C7.41007 10.0485 7.58667 10 7.76658 10L11.9944 10C12.1704 10 12.3434 10.0465 12.4957 10.1347C13.9132 10.9561 14.9381 11.8845 15.5985 12.9123Z" fill="currentColor"/>
<path d="M5.80364 1.27854C5.64981 0.893957 5.83687 0.457479 6.22146 0.303644C6.60605 0.149809 7.04252 0.33687 7.19636 0.721458L8.19636 3.22146C8.35019 3.60605 8.16313 4.04252 7.77854 4.19636C7.39396 4.35019 6.95748 4.16313 6.80364 3.77854L5.80364 1.27854Z" fill="currentColor"/>
<path d="M12.8036 0.721458C12.9575 0.33687 13.394 0.149809 13.7785 0.303644C14.1631 0.457479 14.3502 0.893957 14.1964 1.27854L13.1964 3.77854C13.0425 4.16313 12.606 4.35019 12.2215 4.19636C11.8369 4.04252 11.6498 3.60605 11.8036 3.22146L12.8036 0.721458Z" fill="currentColor"/>
<path d="M9.5 12.5C9.5 12.2239 9.72386 12 10 12C10.2761 12 10.5 12.2239 10.5 12.5V16.5C10.5 16.7761 10.2761 17 10 17C9.72386 17 9.5 16.7761 9.5 16.5V12.5Z" fill="currentColor"/>
<path d="M7.05257 12.2768C7.17582 12.0297 7.47606 11.9293 7.72317 12.0526C7.97028 12.1758 8.07069 12.4761 7.94744 12.7232L6.44744 15.7306C6.32418 15.9777 6.02395 16.0781 5.77684 15.9549C5.52973 15.8316 5.42932 15.5314 5.55257 15.2843L7.05257 12.2768Z" fill="currentColor"/>
<path d="M12.9472 12.2764C12.8237 12.0294 12.5234 11.9293 12.2764 12.0528C12.0294 12.1763 11.9293 12.4766 12.0528 12.7236L13.5528 15.7236C13.6763 15.9706 13.9766 16.0707 14.2236 15.9472C14.4706 15.8237 14.5707 15.5234 14.4472 15.2764L12.9472 12.2764Z" fill="currentColor"/>
</svg>
`;

const Duplicate$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M15.5 6.5H7.5C6.94772 6.5 6.5 6.94772 6.5 7.5V15.5C6.5 16.0523 6.94772 16.5 7.5 16.5H15.5C16.0523 16.5 16.5 16.0523 16.5 15.5V7.5C16.5 6.94772 16.0523 6.5 15.5 6.5ZM8.5 14.5V8.5H14.5V14.5H8.5Z" fill="currentColor"/>
<path d="M6.5 13.5H4.5C3.94772 13.5 3.5 13.0523 3.5 12.5V4.5C3.5 3.94772 3.94772 3.5 4.5 3.5H12.5C13.0523 3.5 13.5 3.94772 13.5 4.5V6.5H11.5V5.5H5.5V11.5H6.5V13.5Z" fill="currentColor"/>
</svg>
`;

const Electricity$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M15 8H11.9451L13.9191 3.39392C14.2019 2.73405 13.7179 2 13 2H8C7.59997 2 7.23843 2.2384 7.08086 2.60608L4.08086 9.60608C3.79805 10.2659 4.28208 11 5 11H6.73423L4.07207 17.6273C3.67234 18.6223 4.90667 19.4633 5.68646 18.7272L10.7099 13.9849L15.6501 9.75985C16.3559 9.156 15.9289 8 15 8ZM9.50943 8.60608C9.22663 9.26595 9.71066 10 10.4286 10H12.2929L9.37334 12.4979L7.62514 14.1477L9.14152 10.3727C9.40546 9.71569 8.92168 9 8.21359 9H6.51654L8.6594 4H11.4835L9.50943 8.60608Z" fill="currentColor"/>
</svg>
`;

const Exclamation$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9 7C9 6.44772 9.44772 6 10 6C10.5523 6 11 6.44772 11 7V11C11 11.5523 10.5523 12 10 12C9.44772 12 9 11.5523 9 11V7Z" fill="currentColor"/>
<circle cx="10" cy="14" r="1" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 10C2 14.4183 5.58172 18 10 18C14.4183 18 18 14.4183 18 10C18 5.58172 14.4183 2 10 2C5.58172 2 2 5.58172 2 10ZM16 10C16 13.3137 13.3137 16 10 16C6.68629 16 4 13.3137 4 10C4 6.68629 6.68629 4 10 4C13.3137 4 16 6.68629 16 10Z" fill="currentColor"/>
</svg>
`;

const ExclamationFilled = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 18C5.58172 18 2 14.4183 2 10C2 5.58172 5.58172 2 10 2C14.4183 2 18 5.58172 18 10C18 14.4183 14.4183 18 10 18ZM10 6C9.44772 6 9 6.44772 9 7V11C9 11.5523 9.44772 12 10 12C10.5523 12 11 11.5523 11 11V7C11 6.44772 10.5523 6 10 6ZM10 15C10.5523 15 11 14.5523 11 14C11 13.4477 10.5523 13 10 13C9.44772 13 9 13.4477 9 14C9 14.5523 9.44772 15 10 15Z" fill="currentColor"/>
</svg>
`;

const Expand$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M5.70711 15.7071C5.31658 16.0976 4.68342 16.0976 4.29289 15.7071C3.90237 15.3166 3.90237 14.6834 4.29289 14.2929L8.29289 10.2929C8.68342 9.90237 9.31658 9.90237 9.70711 10.2929C10.0976 10.6834 10.0976 11.3166 9.70711 11.7071L5.70711 15.7071Z" fill="currentColor"/>
<path d="M5 16C4.44772 16 4 15.5523 4 15C4 14.4477 4.44772 14 5 14H9C9.55228 14 10 14.4477 10 15C10 15.5523 9.55228 16 9 16H5Z" fill="currentColor"/>
<path d="M6 15C6 15.5523 5.55228 16 5 16C4.44772 16 4 15.5523 4 15V11C4 10.4477 4.44772 10 5 10C5.55228 10 6 10.4477 6 11V15Z" fill="currentColor"/>
<path d="M11.7071 9.70711C11.3166 10.0976 10.6834 10.0976 10.2929 9.70711C9.90237 9.31658 9.90237 8.68342 10.2929 8.29289L14.2929 4.29289C14.6834 3.90237 15.3166 3.90237 15.7071 4.29289C16.0976 4.68342 16.0976 5.31658 15.7071 5.70711L11.7071 9.70711Z" fill="currentColor"/>
<path d="M16 9C16 9.55228 15.5523 10 15 10C14.4477 10 14 9.55228 14 9V5C14 4.44772 14.4477 4 15 4C15.5523 4 16 4.44772 16 5V9Z" fill="currentColor"/>
<path d="M11 6C10.4477 6 10 5.55228 10 5C10 4.44772 10.4477 4 11 4H15C15.5523 4 16 4.44772 16 5C16 5.55228 15.5523 6 15 6H11Z" fill="currentColor"/>
</svg>
`;

const Eye$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 16.5C14.8972 16.5 19 14.1922 19 11C19 7.80784 14.8972 5.5 10 5.5C5.10282 5.5 1 7.80784 1 11C1 14.1922 5.10282 16.5 10 16.5ZM10 7.5C13.9394 7.5 17 9.2216 17 11C17 12.7784 13.9394 14.5 10 14.5C6.06062 14.5 3 12.7784 3 11C3 9.2216 6.06062 7.5 10 7.5Z" fill="currentColor"/>
<path d="M9 3.5C9 2.94772 9.44772 2.5 10 2.5C10.5523 2.5 11 2.94772 11 3.5L11 6.5C11 7.05228 10.5523 7.5 10 7.5C9.44772 7.5 9 7.05228 9 6.5L9 3.5Z" fill="currentColor"/>
<path d="M13.0194 3.80383C13.1277 3.26227 13.6546 2.91106 14.1961 3.01937C14.7377 3.12768 15.0889 3.65451 14.9806 4.19606L14.4806 6.69606C14.3723 7.23762 13.8455 7.58884 13.3039 7.48053C12.7623 7.37222 12.4111 6.84539 12.5194 6.30383L13.0194 3.80383Z" fill="currentColor"/>
<path d="M6.98063 3.80383C6.87232 3.26227 6.34549 2.91106 5.80394 3.01937C5.26238 3.12768 4.91116 3.65451 5.01947 4.19606L5.51947 6.69606C5.62778 7.23762 6.15461 7.58884 6.69617 7.48053C7.23773 7.37222 7.58894 6.84539 7.48063 6.30383L6.98063 3.80383Z" fill="currentColor"/>
<path d="M2.85752 4.98553C2.57338 4.51195 1.95912 4.35839 1.48554 4.64254C1.01196 4.92668 0.858391 5.54094 1.14254 6.01452L2.64254 8.51452C2.92669 8.98811 3.54095 9.14167 4.01453 8.85752C4.48811 8.57337 4.64167 7.95911 4.35752 7.48553L2.85752 4.98553Z" fill="currentColor"/>
<path d="M17.1425 4.98553C17.4267 4.51195 18.0409 4.35839 18.5145 4.64254C18.9881 4.92668 19.1417 5.54094 18.8575 6.01452L17.3575 8.51452C17.0734 8.98811 16.4591 9.14167 15.9855 8.85752C15.512 8.57337 15.3584 7.95911 15.6425 7.48553L17.1425 4.98553Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 14C11.933 14 13.5 12.433 13.5 10.5C13.5 8.567 11.933 7 10 7C8.067 7 6.5 8.567 6.5 10.5C6.5 12.433 8.067 14 10 14ZM10 9C10.8284 9 11.5 9.67157 11.5 10.5C11.5 11.3284 10.8284 12 10 12C9.17157 12 8.5 11.3284 8.5 10.5C8.5 9.67157 9.17157 9 10 9Z" fill="currentColor"/>
</svg>
`;

const EyeClosed$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.68785 8.3059C1.36563 7.85735 1.46804 7.23252 1.91659 6.9103C2.36514 6.58809 2.98996 6.6905 3.31218 7.13905C3.61604 7.56204 4.08475 7.96552 4.69177 8.31591C5.98515 9.0625 7.77707 9.5 9.70427 9.5C11.6315 9.5 13.4234 9.0625 14.7168 8.31591C15.3238 7.96552 15.7925 7.56204 16.0964 7.13905C16.4186 6.6905 17.0434 6.58809 17.4919 6.9103C17.9405 7.23252 18.0429 7.85735 17.7207 8.3059C17.2402 8.97475 16.5568 9.56308 15.7166 10.048C14.1049 10.9784 11.9685 11.5 9.70427 11.5C7.44004 11.5 5.30364 10.9784 3.69192 10.048C2.85176 9.56308 2.16833 8.97475 1.68785 8.3059Z" fill="currentColor"/>
<path d="M11 11C11 10.4477 10.5523 10 10 10C9.44772 10 9 10.4477 9 11L9 13.5C9 14.0523 9.44772 14.5 10 14.5C10.5523 14.5 11 14.0523 11 13.5L11 11Z" fill="currentColor"/>
<path d="M5.52985 10.7575C5.6638 10.2217 6.20673 9.8959 6.74253 10.0298C7.27832 10.1638 7.60408 10.7067 7.47013 11.2425L6.97013 13.2425C6.83619 13.7783 6.29325 14.1041 5.75746 13.9701C5.22166 13.8362 4.8959 13.2933 5.02985 12.7575L5.52985 10.7575Z" fill="currentColor"/>
<path d="M13.9702 10.7575C13.8362 10.2217 13.2933 9.8959 12.7575 10.0298C12.2217 10.1638 11.8959 10.7067 12.0299 11.2425L12.5299 13.2425C12.6638 13.7783 13.2067 14.1041 13.7425 13.9701C14.2783 13.8362 14.6041 13.2933 14.4702 12.7575L13.9702 10.7575Z" fill="currentColor"/>
<path d="M16.5249 8.29289C16.1343 7.90237 15.5012 7.90237 15.1106 8.29289C14.7201 8.68342 14.7201 9.31658 15.1106 9.70711L17.1106 11.7071C17.5012 12.0976 18.1343 12.0976 18.5249 11.7071C18.9154 11.3166 18.9154 10.6834 18.5249 10.2929L16.5249 8.29289Z" fill="currentColor"/>
<path d="M3.07775 8.32742C3.44921 7.91872 4.08165 7.88853 4.49036 8.25999C4.89906 8.63145 4.92924 9.26389 4.55779 9.67259L2.74002 11.6726C2.36857 12.0813 1.73612 12.1115 1.32742 11.74C0.918719 11.3686 0.88853 10.7361 1.25999 10.3274L3.07775 8.32742Z" fill="currentColor"/>
</svg>
`;

const EyeOff$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 16.5C14.8972 16.5 19 14.1922 19 11C19 7.80784 14.8972 5.5 10 5.5C5.10282 5.5 1 7.80784 1 11C1 14.1922 5.10282 16.5 10 16.5ZM10 7.5C13.9394 7.5 17 9.2216 17 11C17 12.7784 13.9394 14.5 10 14.5C6.06062 14.5 3 12.7784 3 11C3 9.2216 6.06062 7.5 10 7.5Z" fill="currentColor"/>
<path d="M9 3.5C9 2.94772 9.44772 2.5 10 2.5C10.5523 2.5 11 2.94772 11 3.5L11 6.5C11 7.05228 10.5523 7.5 10 7.5C9.44772 7.5 9 7.05228 9 6.5L9 3.5Z" fill="currentColor"/>
<path d="M13.0194 3.80383C13.1277 3.26227 13.6546 2.91106 14.1961 3.01937C14.7377 3.12768 15.0889 3.65451 14.9806 4.19606L14.4806 6.69606C14.3723 7.23762 13.8455 7.58884 13.3039 7.48053C12.7623 7.37222 12.4111 6.84539 12.5194 6.30383L13.0194 3.80383Z" fill="currentColor"/>
<path d="M6.98063 3.80383C6.87232 3.26227 6.34549 2.91106 5.80394 3.01937C5.26238 3.12768 4.91116 3.65451 5.01947 4.19606L5.51947 6.69606C5.62778 7.23762 6.15461 7.58884 6.69617 7.48053C7.23773 7.37222 7.58894 6.84539 7.48063 6.30383L6.98063 3.80383Z" fill="currentColor"/>
<path d="M2.85752 4.98553C2.57338 4.51195 1.95912 4.35839 1.48554 4.64254C1.01196 4.92668 0.858391 5.54094 1.14254 6.01452L2.64254 8.51452C2.92669 8.98811 3.54095 9.14167 4.01453 8.85752C4.48811 8.57337 4.64167 7.95911 4.35752 7.48553L2.85752 4.98553Z" fill="currentColor"/>
<path d="M17.1425 4.98553C17.4267 4.51195 18.0409 4.35839 18.5145 4.64254C18.9881 4.92668 19.1417 5.54094 18.8575 6.01452L17.3575 8.51452C17.0734 8.98811 16.4591 9.14167 15.9855 8.85752C15.512 8.57337 15.3584 7.95911 15.6425 7.48553L17.1425 4.98553Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 14C11.933 14 13.5 12.433 13.5 10.5C13.5 8.567 11.933 7 10 7C8.067 7 6.5 8.567 6.5 10.5C6.5 12.433 8.067 14 10 14ZM10 9C10.8284 9 11.5 9.67157 11.5 10.5C11.5 11.3284 10.8284 12 10 12C9.17157 12 8.5 11.3284 8.5 10.5C8.5 9.67157 9.17157 9 10 9Z" fill="currentColor"/>
<path d="M17.9739 17.3101C18.3549 17.7098 18.3397 18.3428 17.9399 18.7239C17.5402 19.1049 16.9072 19.0897 16.5261 18.6899L1.27613 2.68994C0.895091 2.29016 0.910282 1.65717 1.31006 1.27613C1.70985 0.895091 2.34283 0.910282 2.72387 1.31006L17.9739 17.3101Z" fill="currentColor"/>
</svg>
`;

const File$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6.5 11.25C6.08579 11.25 5.75 10.9142 5.75 10.5C5.75 10.0858 6.08579 9.75 6.5 9.75H13.5C13.9142 9.75 14.25 10.0858 14.25 10.5C14.25 10.9142 13.9142 11.25 13.5 11.25H6.5Z" fill="currentColor"/>
<path d="M6.5 14.25C6.08579 14.25 5.75 13.9142 5.75 13.5C5.75 13.0858 6.08579 12.75 6.5 12.75H13.5C13.9142 12.75 14.25 13.0858 14.25 13.5C14.25 13.9142 13.9142 14.25 13.5 14.25H6.5Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.1854 0.5H4.5C3.39543 0.5 2.5 1.39543 2.5 2.5V17.5C2.5 18.6046 3.39543 19.5 4.5 19.5H15.5C16.6046 19.5 17.5 18.6046 17.5 17.5V7.20179C17.5 6.70104 17.3122 6.21851 16.9736 5.84956L12.659 1.14777C12.2802 0.734983 11.7457 0.5 11.1854 0.5ZM4.5 17.5V2.5H11.1854L15.5 7.20179V17.5H4.5Z" fill="currentColor"/>
<path d="M11.5 6.5H16.5C17.0523 6.5 17.5 6.94772 17.5 7.5C17.5 8.05228 17.0523 8.5 16.5 8.5H10.5C9.94772 8.5 9.5 8.05228 9.5 7.5V1.5C9.5 0.947715 9.94772 0.5 10.5 0.5C11.0523 0.5 11.5 0.947715 11.5 1.5V6.5Z" fill="currentColor"/>
</svg>
`;

const FilmFrame$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5C0.947715 2.5 0.5 2.94772 0.5 3.5V16.5C0.5 17.0523 0.947715 17.5 1.5 17.5H18.5C19.0523 17.5 19.5 17.0523 19.5 16.5V3.5C19.5 2.94772 19.0523 2.5 18.5 2.5H1.5ZM15.5 4.5H16.5C16.7761 4.5 17 4.72386 17 5V6C17 6.27614 16.7761 6.5 16.5 6.5H15.5C15.2239 6.5 15 6.27614 15 6V5C15 4.72386 15.2239 4.5 15.5 4.5ZM16.5 7.5H15.5C15.2239 7.5 15 7.72386 15 8V9C15 9.27614 15.2239 9.5 15.5 9.5H16.5C16.7761 9.5 17 9.27614 17 9V8C17 7.72386 16.7761 7.5 16.5 7.5ZM15.5 10.5H16.5C16.7761 10.5 17 10.7239 17 11V12C17 12.2761 16.7761 12.5 16.5 12.5H15.5C15.2239 12.5 15 12.2761 15 12V11C15 10.7239 15.2239 10.5 15.5 10.5ZM16.5 13.5H15.5C15.2239 13.5 15 13.7239 15 14V15C15 15.2761 15.2239 15.5 15.5 15.5H16.5C16.7761 15.5 17 15.2761 17 15V14C17 13.7239 16.7761 13.5 16.5 13.5ZM3.5 4.5H4.5C4.77614 4.5 5 4.72386 5 5V6C5 6.27614 4.77614 6.5 4.5 6.5H3.5C3.22386 6.5 3 6.27614 3 6V5C3 4.72386 3.22386 4.5 3.5 4.5ZM4.5 7.5H3.5C3.22386 7.5 3 7.72386 3 8V9C3 9.27614 3.22386 9.5 3.5 9.5H4.5C4.77614 9.5 5 9.27614 5 9V8C5 7.72386 4.77614 7.5 4.5 7.5ZM3.5 10.5H4.5C4.77614 10.5 5 10.7239 5 11V12C5 12.2761 4.77614 12.5 4.5 12.5H3.5C3.22386 12.5 3 12.2761 3 12V11C3 10.7239 3.22386 10.5 3.5 10.5ZM4.5 13.5H3.5C3.22386 13.5 3 13.7239 3 14V15C3 15.2761 3.22386 15.5 3.5 15.5H4.5C4.77614 15.5 5 15.2761 5 15V14C5 13.7239 4.77614 13.5 4.5 13.5ZM6.5 15.5V4.5H13.5V15.5H6.5Z" fill="currentColor"/>
</svg>
`;

const Flag$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.80448 2.63235L6.16667 2.89616C4.85526 3.43858 4 4.71786 4 6.13702V10.5225C4 10.7701 4.06299 11.0136 4.18304 11.2301C4.57382 11.9348 5.46192 12.1894 6.16667 11.7986L6.39359 11.6727C7.60021 11.0037 9.06646 11.0037 10.2731 11.6727L10.7269 11.9244C11.9335 12.5935 13.3998 12.5935 14.6064 11.9244L15.3405 11.5173C16.3646 10.9495 17 9.87065 17 8.69964V4.63805C17 4.47989 16.9766 4.3226 16.9306 4.17129C16.6728 3.32398 15.7769 2.84607 14.9296 3.10386L14.0366 3.37555C13.1508 3.64503 12.199 3.5989 11.3435 3.24503L9.86219 2.63235C8.88317 2.22741 7.78349 2.22741 6.80448 2.63235ZM11.6968 10.1753L11.243 9.92365C9.6212 9.02438 7.68677 8.93089 6 9.64316V6.13702C6 5.52716 6.36754 4.9774 6.93109 4.74431L7.56891 4.4805C8.05841 4.27803 8.60825 4.27803 9.09776 4.4805L10.579 5.09318C11.8624 5.62399 13.2901 5.69318 14.6187 5.28896L15 5.17296V8.69964C15 9.14374 14.759 9.55287 14.3707 9.76823L13.6365 10.1753C13.0332 10.5098 12.3001 10.5098 11.6968 10.1753Z" fill="currentColor"/>
<rect x="4" y="2" width="2" height="16" rx="1" fill="currentColor"/>
</svg>
`;

const Flower$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.5883 2.36575L12.5166 2.44429C12.4102 2.5604 12.3177 2.65963 12.2363 2.7445C12.1783 2.6674 12.131 2.60442 12.1069 2.57222C12.0962 2.55804 12.0901 2.54982 12.0895 2.54901C11.781 2.14919 11.521 1.85543 11.2421 1.61995C10.8599 1.29718 10.4625 1.10176 10 1.10176C9.75073 1.10176 9.51343 1.16296 9.29033 1.27123C8.80211 1.50815 8.44017 1.90299 7.95721 2.57792C7.93063 2.61506 7.88552 2.67912 7.83669 2.74871C7.74548 2.6579 7.64046 2.55003 7.51765 2.42149L7.44953 2.35008C6.89581 1.76866 6.74857 1.6202 6.50141 1.4188C6.26666 1.22751 6.05621 1.09922 5.79569 1.03537C5.22149 0.894639 4.64828 1.18504 4.43938 1.76057C4.1503 2.55696 4 3.41174 4 4.28812C4 8.2285 6.21172 11 10 11C13.7883 11 16 8.2285 16 4.28812C16 3.41174 15.8497 2.55696 15.5606 1.76057C15.3529 1.18826 14.7801 0.89035 14.2009 1.03736C13.938 1.10408 13.7302 1.23584 13.4994 1.43184C13.2609 1.63445 13.1249 1.77767 12.5883 2.36575ZM10 9.00002C7.42805 9.00002 6 7.21053 6 4.28812C6 4.10858 6.00853 3.93059 6.02539 3.75471L6.07157 3.80311C6.48039 4.23101 6.73147 4.4747 6.99228 4.67463C7.63975 5.17099 8.29621 5.36404 8.89641 4.67838C9.00414 4.55531 9.10967 4.4156 9.25158 4.21495C9.26057 4.20223 9.28945 4.16095 9.32704 4.10719C9.41015 3.98837 9.53586 3.80861 9.58368 3.74178C9.75942 3.4962 9.90624 3.31505 10.0126 3.20218C10.1467 3.32743 10.3081 3.51428 10.5059 3.77068C10.4612 3.71264 11.0562 4.50836 11.2051 4.67838C11.8078 5.36697 12.4722 5.16831 13.1048 4.66706C13.3559 4.46807 13.5972 4.22516 13.9795 3.80818C13.9931 3.96663 14 4.12675 14 4.28812C14 7.21053 12.572 9.00002 10 9.00002Z" fill="currentColor"/>
<path d="M9 11C9 10.4477 9.44772 10 10 10C10.5523 10 11 10.4477 11 11V17.5C11 18.0523 10.5523 18.5 10 18.5C9.44772 18.5 9 18.0523 9 17.5V11Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.7672 13.015C9.58159 14.8489 8.14539 17.1796 9.32942 18.5906C10.4954 19.9802 13.7081 19.2188 15.6239 17.6112C17.4921 16.0436 18.344 13.7765 17.18 12.3893C16.016 11.0021 13.6354 11.4474 11.7672 13.015ZM10.9199 17.3432C10.9062 17.3379 10.8943 17.3318 10.8841 17.325L10.9024 17.3544C10.9103 17.3611 10.915 17.3586 10.9199 17.3432ZM14.3383 16.0792C13.2305 17.0087 11.3237 17.5007 10.9199 17.3432C10.9221 17.3361 10.9244 17.3262 10.927 17.3132C10.9648 17.1241 11.0828 16.8557 11.2748 16.5442C11.6794 15.8876 12.3519 15.1352 13.0528 14.5471C14.1872 13.5951 15.3919 13.3698 15.6479 13.6749C15.9039 13.98 15.4728 15.1272 14.3383 16.0792Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.93234 13.015C10.1179 14.8489 11.5541 17.1796 10.3701 18.5906C9.20411 19.9802 5.99142 19.2188 4.07561 17.6112C2.20741 16.0436 1.35552 13.7765 2.51954 12.3893C3.68355 11.0021 6.06414 11.4474 7.93234 13.015ZM8.77963 17.3432C8.79329 17.3379 8.80524 17.3318 8.81537 17.325L8.79712 17.3544C8.78924 17.3611 8.78449 17.3586 8.77963 17.3432ZM5.36119 16.0792C6.46901 17.0087 8.37582 17.5007 8.77963 17.3432C8.77738 17.3361 8.77511 17.3262 8.7725 17.3132C8.73467 17.1241 8.61671 16.8557 8.42471 16.5442C8.02015 15.8876 7.34762 15.1352 6.64676 14.5471C5.5123 13.5951 4.30762 13.3698 4.05162 13.6749C3.79563 13.98 4.22673 15.1272 5.36119 16.0792Z" fill="currentColor"/>
</svg>
`;

const FlowerBud$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M16.4899 13.7135C17.9689 13.1201 19 11.6725 19 10C19 8.32751 17.9689 6.87985 16.4899 6.28652C16.4966 6.19151 16.5 6.09596 16.5 6C16.5 3.79086 14.7091 2 12.5 2C11.5711 2 10.6958 2.31953 10 2.87701C9.30417 2.31953 8.42887 2 7.5 2C5.29086 2 3.5 3.79086 3.5 6C3.5 6.09596 3.5034 6.19151 3.51015 6.28652C2.03108 6.87985 1 8.32751 1 10C1 11.6725 2.03108 13.1201 3.51015 13.7135C3.5034 13.8085 3.5 13.904 3.5 14C3.5 16.2091 5.29086 18 7.5 18C8.42887 18 9.30417 17.6805 10 17.123C10.6958 17.6805 11.5711 18 12.5 18C14.7091 18 16.5 16.2091 16.5 14C16.5 13.904 16.4966 13.8085 16.4899 13.7135ZM14.3824 6.67818C14.1626 7.28797 14.5722 7.94249 15.2167 8.01152C16.2258 8.1196 17 8.97583 17 10C17 11.0242 16.2258 11.8804 15.2167 11.9885C14.5722 12.0575 14.1626 12.712 14.3824 13.3218C14.4599 13.5369 14.5 13.765 14.5 14C14.5 15.1046 13.6046 16 12.5 16C11.8214 16 11.2019 15.6605 10.8327 15.1052C10.4371 14.5101 9.56294 14.5101 9.16727 15.1052C8.79807 15.6605 8.17862 16 7.5 16C6.39543 16 5.5 15.1046 5.5 14C5.5 13.765 5.54013 13.5369 5.61762 13.3218C5.83737 12.712 5.42783 12.0575 4.78334 11.9885C3.77418 11.8804 3 11.0242 3 10C3 8.97583 3.77418 8.1196 4.78334 8.01152C5.42783 7.94249 5.83737 7.28797 5.61762 6.67818C5.54013 6.46315 5.5 6.23504 5.5 6C5.5 4.89543 6.39543 4 7.5 4C8.17862 4 8.79807 4.3395 9.16727 4.89478C9.56294 5.48988 10.4371 5.48988 10.8327 4.89478C11.2019 4.3395 11.8214 4 12.5 4C13.6046 4 14.5 4.89543 14.5 6C14.5 6.23504 14.4599 6.46315 14.3824 6.67818Z" fill="currentColor"/>
<path d="M13.5 10C13.5 11.933 11.933 13.5 10 13.5C8.067 13.5 6.5 11.933 6.5 10C6.5 8.067 8.067 6.5 10 6.5C11.933 6.5 13.5 8.067 13.5 10Z" fill="currentColor"/>
</svg>
`;

const Folder$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M15.5 5H10.5089L9.94408 4.01158C9.40996 3.07686 8.41593 2.5 7.33935 2.5H4.5C2.84315 2.5 1.5 3.84315 1.5 5.5V15C1.5 16.6569 2.84315 18 4.5 18H15.5C17.1569 18 18.5 16.6569 18.5 15V8C18.5 6.34315 17.1569 5 15.5 5ZM4.5 16C3.94772 16 3.5 15.5523 3.5 15V5.5C3.5 4.94772 3.94772 4.5 4.5 4.5H7.33935C7.69821 4.5 8.02956 4.69229 8.2076 5.00386L9.06033 6.49614C9.23837 6.80771 9.56971 7 9.92857 7H15.5C16.0523 7 16.5 7.44772 16.5 8V15C16.5 15.5523 16.0523 16 15.5 16H4.5Z" fill="currentColor"/>
</svg>
`;

const Gear$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10.5576 2.25C10.8544 2.25 11.1234 2.42509 11.2435 2.69656L11.6859 3.69656C11.9052 4.1924 11.5422 4.75 11 4.75L9 4.75C8.47694 4.75 8.11452 4.22806 8.29727 3.73796L8.67016 2.73796C8.77957 2.44455 9.05975 2.25 9.37289 2.25H10.5576Z" fill="currentColor"/>
<path d="M9.44253 17.75C9.14568 17.75 8.87676 17.5749 8.75666 17.3034L8.31424 16.3034C8.09488 15.8076 8.45793 15.25 9.00012 15.25H11.0001C11.5232 15.25 11.8856 15.7719 11.7029 16.262L11.33 17.262C11.2206 17.5554 10.9404 17.75 10.6272 17.75H9.44253Z" fill="currentColor"/>
<path d="M17.7501 10.5575C17.7501 10.8544 17.575 11.1233 17.3035 11.2434L16.3035 11.6858C15.8077 11.9052 15.2501 11.5421 15.2501 10.9999V8.99994C15.2501 8.47688 15.772 8.11445 16.2621 8.29721L17.2621 8.6701C17.5555 8.77951 17.7501 9.05969 17.7501 9.37283V10.5575Z" fill="currentColor"/>
<path d="M2.25006 9.44247C2.25006 9.14562 2.42515 8.8767 2.69662 8.7566L3.69662 8.31418C4.19246 8.09482 4.75006 8.45786 4.75006 9.00006V11.0001C4.75006 11.5231 4.22812 11.8855 3.73802 11.7028L2.73802 11.3299C2.44461 11.2205 2.25006 10.9403 2.25006 10.6272V9.44247Z" fill="currentColor"/>
<path d="M15.8744 4.91417C16.0843 5.12408 16.1506 5.43804 16.0436 5.71492L15.6493 6.73486C15.4538 7.24059 14.8028 7.37816 14.4194 6.99477L13.0052 5.58056C12.6354 5.21069 12.7482 4.58535 13.2239 4.36803L14.1947 3.92459C14.4796 3.79449 14.8152 3.85504 15.0367 4.07646L15.8744 4.91417Z" fill="currentColor"/>
<path d="M4.12575 15.0858C3.91584 14.8759 3.84949 14.562 3.95653 14.2851L4.3508 13.2651C4.5463 12.7594 5.19729 12.6218 5.58068 13.0052L6.9949 14.4194C7.36476 14.7893 7.25196 15.4146 6.77618 15.632L5.8054 16.0754C5.52057 16.2055 5.18488 16.145 4.96346 15.9235L4.12575 15.0858Z" fill="currentColor"/>
<path d="M15.086 15.8743C14.876 16.0842 14.5621 16.1505 14.2852 16.0435L13.2653 15.6492C12.7595 15.4537 12.622 14.8027 13.0054 14.4193L14.4196 13.0051C14.7894 12.6352 15.4148 12.748 15.6321 13.2238L16.0755 14.1946C16.2056 14.4794 16.1451 14.8151 15.9237 15.0365L15.086 15.8743Z" fill="currentColor"/>
<path d="M4.91417 4.12575C5.12408 3.91584 5.43804 3.84949 5.71492 3.95653L6.73486 4.3508C7.24059 4.5463 7.37816 5.19729 6.99477 5.58068L5.58056 6.9949C5.21069 7.36476 4.58535 7.25196 4.36803 6.77618L3.92459 5.8054C3.79449 5.52057 3.85504 5.18488 4.07646 4.96346L4.91417 4.12575Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.58058 14.4194C6.74366 15.5825 8.32182 16.25 10 16.25C11.6782 16.25 13.2563 15.5825 14.4194 14.4194C15.5825 13.2563 16.25 11.6782 16.25 10C16.25 8.32182 15.5825 6.74366 14.4194 5.58058C13.2563 4.4175 11.6782 3.75 10 3.75C8.32182 3.75 6.74366 4.4175 5.58058 5.58058C4.4175 6.74366 3.75 8.32182 3.75 10C3.75 11.6782 4.4175 13.2563 5.58058 14.4194ZM11.2374 11.2374C10.9099 11.565 10.4724 11.75 10 11.75C9.52756 11.75 9.09009 11.565 8.76256 11.2374C8.43503 10.9099 8.25 10.4724 8.25 10C8.25 9.52756 8.43503 9.09009 8.76256 8.76256C9.09009 8.43503 9.52756 8.25 10 8.25C10.4724 8.25 10.9099 8.43503 11.2374 8.76256C11.565 9.09009 11.75 9.52756 11.75 10C11.75 10.4724 11.565 10.9099 11.2374 11.2374Z" fill="currentColor"/>
</svg>
`;

const Gift$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="9" y="7" width="2" height="11" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.3558 6.99849C11.3338 5.87341 10.5775 3.56252 9.27135 2.4271C7.99198 1.31497 6.1989 1.1107 5.22938 2.22601C4.25986 3.34132 4.71168 5.08851 5.99105 6.20065C7.4709 7.48706 9.33813 8.1692 10.3558 6.99849ZM8.8514 5.68071C8.90578 5.62028 8.96325 5.5902 8.99267 5.58096C8.96386 5.57852 8.91045 5.57208 8.8458 5.55793C8.85778 5.62324 8.85887 5.66785 8.84798 5.68427L8.8514 5.68071ZM7.30317 4.69123C7.69096 5.02833 8.19021 5.33453 8.60456 5.4859C8.69553 5.51913 8.77703 5.54289 8.8458 5.55793C8.78479 5.22531 8.44136 4.35563 7.95923 3.93652C7.41925 3.46713 6.85627 3.40299 6.7388 3.53813C6.62133 3.67326 6.76319 4.22184 7.30317 4.69123Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M9.88591 6.99849C8.90789 5.87341 9.66423 3.56252 10.9704 2.4271C12.2497 1.31497 14.0428 1.1107 15.0123 2.22601C15.9819 3.34132 15.53 5.08851 14.2507 6.20065C12.7708 7.48706 10.9036 8.1692 9.88591 6.99849ZM11.3903 5.68071C11.3359 5.62028 11.2785 5.5902 11.2491 5.58096C11.2779 5.57852 11.3313 5.57208 11.3959 5.55793C11.3839 5.62324 11.3829 5.66785 11.3937 5.68427L11.3903 5.68071ZM12.9386 4.69123C12.5508 5.02833 12.0515 5.33453 11.6372 5.4859C11.5462 5.51913 11.4647 5.54289 11.3959 5.55793C11.4569 5.22531 11.8004 4.35563 12.2825 3.93652C12.8225 3.46713 13.3855 3.40299 13.5029 3.53813C13.6204 3.67326 13.4785 4.22184 12.9386 4.69123Z" fill="currentColor"/>
<rect x="17" y="11" width="2" height="14" transform="rotate(90 17 11)" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M3 6H17C17.5523 6 18 6.44772 18 7V18C18 18.5523 17.5523 19 17 19H3C2.44771 19 2 18.5523 2 18V7C2 6.44772 2.44771 6 3 6ZM16 17V8H4V17H16Z" fill="currentColor"/>
</svg>
`;

const Grab$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M2.5 8C1.94772 8 1.5 7.55228 1.5 7C1.5 6.44772 1.94772 6 2.5 6H17.5C18.0523 6 18.5 6.44772 18.5 7C18.5 7.55228 18.0523 8 17.5 8H2.5Z" fill="currentColor"/>
<path d="M2.5 11.25C1.94772 11.25 1.5 10.8023 1.5 10.25C1.5 9.69772 1.94772 9.25 2.5 9.25H17.5C18.0523 9.25 18.5 9.69772 18.5 10.25C18.5 10.8023 18.0523 11.25 17.5 11.25H2.5Z" fill="currentColor"/>
<path d="M2.5 14.5C1.94772 14.5 1.5 14.0523 1.5 13.5C1.5 12.9477 1.94772 12.5 2.5 12.5H17.5C18.0523 12.5 18.5 12.9477 18.5 13.5C18.5 14.0523 18.0523 14.5 17.5 14.5H2.5Z" fill="currentColor"/>
</svg>
`;

const Hamburger$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M16.3926 13.8047C17.6807 13.977 18.496 14.6978 18.496 15.9707C18.496 17.4603 17.3825 18.2975 15.5789 18.6781C14.3977 18.9273 13.0457 18.9984 10.7025 19.0035C10.5147 19.0039 10.3642 19.004 10.0282 19.004H9.99603H9.96381C9.62786 19.004 9.47739 19.0039 9.28951 19.0035C6.94638 18.9984 5.59438 18.9273 4.4132 18.6781C2.60956 18.2975 1.49603 17.4603 1.49603 15.9707C1.49603 14.6978 2.31131 13.977 3.5994 13.8047C4.34932 13.7043 4.77922 13.7271 7.01146 13.9165C8.28024 14.0242 9.10265 14.0719 9.99603 14.0719C10.8894 14.0719 11.7118 14.0242 12.9806 13.9165C15.2128 13.7271 15.6427 13.7043 16.3926 13.8047ZM10.6982 17.0035C14.762 16.9948 16.496 16.6289 16.496 15.9707C16.496 15.92 16.4979 15.8886 16.4842 15.867C16.4585 15.8264 16.378 15.8205 16.1274 15.787C15.594 15.7157 15.1646 15.7384 13.1497 15.9094C11.829 16.0214 10.9591 16.0719 9.99603 16.0719C9.03294 16.0719 8.16309 16.0214 6.84237 15.9094C4.82745 15.7384 4.39803 15.7157 3.86462 15.787C3.61407 15.8205 3.53356 15.8264 3.50786 15.867C3.49418 15.8886 3.49603 15.92 3.49603 15.9707C3.49603 16.6289 5.23006 16.9948 9.29381 17.0035C9.47977 17.0039 9.62857 17.004 9.9638 17.004L9.99603 17.004L10.0283 17.004C10.3635 17.004 10.5123 17.0039 10.6982 17.0035Z" fill="currentColor"/>
<path d="M2.887 10.6424C2.53219 10.8562 2.07129 10.7418 1.85756 10.387C1.64382 10.0322 1.75819 9.57129 2.113 9.35756C2.78226 8.9544 3.50608 8.75 4.27059 8.75C4.79146 8.75 5.10019 8.84247 5.56693 9.0701L5.57882 9.0759C5.86725 9.21658 5.97953 9.25 6.25 9.25C6.51337 9.25 6.60676 9.22083 6.85951 9.08709L6.87097 9.08102C7.31358 8.84682 7.62078 8.75 8.14729 8.75C8.68251 8.75 8.99072 8.84947 9.43542 9.09084C9.68104 9.22415 9.7609 9.25 10 9.25C10.2388 9.25 10.3183 9.22426 10.5589 9.09345C11.0075 8.84961 11.3161 8.75 11.852 8.75C12.3817 8.75 12.6885 8.8467 13.139 9.08311L13.1443 9.08587C13.4023 9.22123 13.4939 9.25 13.75 9.25C14.0073 9.25 14.1022 9.22045 14.3653 9.08409C14.8249 8.84597 15.1316 8.75 15.6591 8.75C16.4138 8.75 17.1516 8.95039 17.8629 9.34364C18.2254 9.54405 18.3568 10.0004 18.1564 10.3629C17.9559 10.7254 17.4996 10.8568 17.1371 10.6564C16.6426 10.3829 16.1531 10.25 15.6591 10.25C15.4117 10.25 15.3206 10.2785 15.0615 10.4128L15.0554 10.4159C14.5978 10.653 14.2866 10.75 13.75 10.75C13.2122 10.75 12.9015 10.6524 12.4474 10.4141L12.4421 10.4114C12.1876 10.2778 12.0993 10.25 11.852 10.25C11.6055 10.25 11.5232 10.2766 11.2797 10.4089C10.8341 10.6512 10.5289 10.75 10 10.75C9.47095 10.75 9.16586 10.6512 8.72379 10.4113C8.47563 10.2766 8.39322 10.25 8.14729 10.25C7.90366 10.25 7.81782 10.2771 7.57252 10.4069L7.56106 10.4129C7.11071 10.6512 6.79449 10.75 6.25 10.75C5.71275 10.75 5.39638 10.6558 4.92128 10.4241L4.9094 10.4183C4.62925 10.2817 4.5235 10.25 4.27059 10.25C3.78102 10.25 3.32443 10.3789 2.887 10.6424Z" fill="currentColor"/>
<path d="M3 11.25H17C18.3333 11.25 18.3333 13.25 17 13.25H3C1.66667 13.25 1.66667 11.25 3 11.25Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M16.1732 8.20945C17.6372 7.87771 18.4999 6.98233 18.4999 5.51412C18.4999 2.40364 14.7363 0.401175 9.99988 0.401175C5.26346 0.401175 1.49988 2.40364 1.49988 5.51412C1.49988 6.98233 2.3626 7.87771 3.82652 8.20945C4.75693 8.4203 5.55609 8.43314 7.98584 8.36359C8.90621 8.33724 9.41604 8.32682 9.99988 8.32682C10.5837 8.32682 11.0935 8.33724 12.0139 8.36359C14.4437 8.43314 15.2428 8.4203 16.1732 8.20945ZM9.99988 2.40118C13.7779 2.40118 16.4999 3.84946 16.4999 5.51412C16.4999 5.96226 16.3489 6.11893 15.7312 6.25891C15.0385 6.41589 14.2899 6.42792 12.0711 6.36441C11.1327 6.33755 10.6081 6.32682 9.99988 6.32682C9.39164 6.32682 8.86703 6.33755 7.92861 6.36441C5.7099 6.42792 4.96125 6.41589 4.26854 6.25891C3.65083 6.11893 3.49988 5.96226 3.49988 5.51412C3.49988 3.84946 6.22188 2.40118 9.99988 2.40118Z" fill="currentColor"/>
<path d="M6.1 5C6.1 5.33137 5.83137 5.6 5.5 5.6C5.16863 5.6 4.9 5.33137 4.9 5C4.9 4.66863 5.16863 4.4 5.5 4.4C5.83137 4.4 6.1 4.66863 6.1 5Z" fill="currentColor"/>
<path d="M8.6 4C8.6 4.33137 8.33137 4.6 8 4.6C7.66863 4.6 7.4 4.33137 7.4 4C7.4 3.66863 7.66863 3.4 8 3.4C8.33137 3.4 8.6 3.66863 8.6 4Z" fill="currentColor"/>
<path d="M10.6 5.5C10.6 5.83137 10.3314 6.1 9.99999 6.1C9.66862 6.1 9.39999 5.83137 9.39999 5.5C9.39999 5.16863 9.66862 4.9 9.99999 4.9C10.3314 4.9 10.6 5.16863 10.6 5.5Z" fill="currentColor"/>
<path d="M12.6 4C12.6 4.33137 12.3314 4.6 12 4.6C11.6686 4.6 11.4 4.33137 11.4 4C11.4 3.66863 11.6686 3.4 12 3.4C12.3314 3.4 12.6 3.66863 12.6 4Z" fill="currentColor"/>
<path d="M15.1 5C15.1 5.33137 14.8314 5.6 14.5 5.6C14.1686 5.6 13.9 5.33137 13.9 5C13.9 4.66863 14.1686 4.4 14.5 4.4C14.8314 4.4 15.1 4.66863 15.1 5Z" fill="currentColor"/>
</svg>
`;

const Headphone$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M17.8801 15.0685C17.7061 15.5927 17.1402 15.8766 16.616 15.7027C16.0918 15.5287 15.8079 14.9628 15.9818 14.4386C16.3221 13.4132 16.5 12.3064 16.5 11.166C16.5 6.71008 13.7442 3.75354 10 3.75354C6.25581 3.75354 3.5 6.71008 3.5 11.166C3.5 12.3064 3.67791 13.4132 4.01817 14.4386C4.1921 14.9628 3.90817 15.5287 3.38399 15.7027C2.85981 15.8766 2.29387 15.5927 2.11994 15.0685C1.71209 13.8394 1.5 12.5199 1.5 11.166C1.5 5.63571 5.11859 1.75354 10 1.75354C14.8814 1.75354 18.5 5.63571 18.5 11.166C18.5 12.5199 18.2879 13.8394 17.8801 15.0685Z" fill="currentColor"/>
<path d="M5.97747 17.0341C4.32744 17.0028 3.01262 15.6445 3.03496 13.9943L3.03526 13.972C3.05752 12.3274 4.40876 11.0123 6.05335 11.0345C6.06146 11.0346 6.06146 11.0346 6.06958 11.0348C6.61963 11.0452 7.05795 11.498 7.0505 12.0481L6.99636 16.0478C6.98886 16.6022 6.53179 17.0446 5.97747 17.0341Z" fill="currentColor"/>
<path d="M14.0888 11.0002C15.7388 11.0315 17.0536 12.3898 17.0313 14.04L17.031 14.0623C17.0087 15.7069 15.6575 17.022 14.0129 16.9998C14.0048 16.9997 14.0048 16.9997 13.9967 16.9995C13.4466 16.9891 13.0083 16.5363 13.0158 15.9862L13.0699 11.9865C13.0774 11.4321 13.5345 10.9897 14.0888 11.0002Z" fill="currentColor"/>
</svg>
`;

const Heart$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 6.49228C11.4641 3.87207 16.5 4.78701 16.5 8.57245C16.5 11.1012 14.3333 13.4103 10 15.5C5.66667 13.4103 3.5 11.1012 3.5 8.57245C3.5 4.78701 8.5359 3.87207 10 6.49228Z" fill="currentColor"/>
</svg>
`;

const House$1 = `<svg width="22" height="20" viewBox="0 0 22 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 11C1.08049 11 0.648384 9.86349 1.33564 9.25259L10.3356 1.25259C10.7145 0.915803 11.2855 0.915803 11.6644 1.25259L20.6644 9.25259C21.3516 9.86349 20.9195 11 20 11H19V18C19 18.5523 18.5523 19 18 19H4C3.44772 19 3 18.5523 3 18V11H2ZM8 17V12C8 11.4477 8.44772 11 9 11H13C13.5523 11 14 11.4477 14 12V17H17V10C17 9.62477 17.2067 9.29781 17.5124 9.12674L11 3.33795L4.48762 9.12674C4.79334 9.29781 5 9.62477 5 10V17H8ZM10 17V13H12V17H10Z" fill="currentColor"/>
</svg>
`;

const Info$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9 10C9 9.44772 9.44772 9 10 9C10.5523 9 11 9.44772 11 10V14C11 14.5523 10.5523 15 10 15C9.44772 15 9 14.5523 9 14V10Z" fill="currentColor"/>
<circle cx="10" cy="7" r="1" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 10C2 14.4183 5.58172 18 10 18C14.4183 18 18 14.4183 18 10C18 5.58172 14.4183 2 10 2C5.58172 2 2 5.58172 2 10ZM16 10C16 13.3137 13.3137 16 10 16C6.68629 16 4 13.3137 4 10C4 6.68629 6.68629 4 10 4C13.3137 4 16 6.68629 16 10Z" fill="currentColor"/>
</svg>
`;

const InfoFilled = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 18C5.58172 18 2 14.4183 2 10C2 5.58172 5.58172 2 10 2C14.4183 2 18 5.58172 18 10C18 14.4183 14.4183 18 10 18ZM10 8.92857C9.44772 8.92857 9 9.37629 9 9.92857V13.9286C9 14.4809 9.44772 14.9286 10 14.9286C10.5523 14.9286 11 14.4809 11 13.9286V9.92857C11 9.37629 10.5523 8.92857 10 8.92857ZM10 7.5C10.5523 7.5 11 7.05228 11 6.5C11 5.94772 10.5523 5.5 10 5.5C9.44772 5.5 9 5.94772 9 6.5C9 7.05228 9.44772 7.5 10 7.5Z" fill="currentColor"/>
</svg>
`;

const Internet$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.25 10C1.25 14.8325 5.16751 18.75 10 18.75C14.8325 18.75 18.75 14.8325 18.75 10C18.75 5.16751 14.8325 1.25 10 1.25C5.16751 1.25 1.25 5.16751 1.25 10ZM17.25 10C17.25 14.0041 14.0041 17.25 10 17.25C5.99594 17.25 2.75 14.0041 2.75 10C2.75 5.99594 5.99594 2.75 10 2.75C14.0041 2.75 17.25 5.99594 17.25 10Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.25 10C6.25 14.5222 7.74111 18.25 10 18.25C12.2589 18.25 13.75 14.5222 13.75 10C13.75 5.47778 12.2589 1.75 10 1.75C7.74111 1.75 6.25 5.47778 6.25 10ZM12.25 10C12.25 13.7621 11.0548 16.75 10 16.75C8.94518 16.75 7.75 13.7621 7.75 10C7.75 6.23795 8.94518 3.25 10 3.25C11.0548 3.25 12.25 6.23795 12.25 10Z" fill="currentColor"/>
<path d="M3.60174 5.46733L4.60789 4.35483C4.70859 4.4459 4.817 4.53499 4.9328 4.62175C6.2041 5.57424 8.2323 6.16108 10.4482 6.16108C12.3391 6.16108 14.1005 5.73495 15.3792 5.00363C15.687 4.82759 15.9613 4.63663 16.1979 4.43451L17.1722 5.57496C16.8622 5.83981 16.511 6.08431 16.1239 6.3057C14.6076 7.17293 12.5898 7.66108 10.4482 7.66108C7.92613 7.66108 5.58282 6.98307 4.03339 5.82219C3.88117 5.70814 3.73712 5.58977 3.60174 5.46733Z" fill="currentColor"/>
<path d="M3.60174 14.5486L4.60789 15.6611C4.70859 15.57 4.817 15.4809 4.9328 15.3941C6.2041 14.4417 8.2323 13.8548 10.4482 13.8548C12.3391 13.8548 14.1005 14.2809 15.3792 15.0123C15.687 15.1883 15.9613 15.3793 16.1979 15.5814L17.1722 14.4409C16.8622 14.1761 16.511 13.9316 16.1239 13.7102C14.6076 12.843 12.5898 12.3548 10.4482 12.3548C7.92613 12.3548 5.58282 13.0328 4.03339 14.1937C3.88117 14.3078 3.73712 14.4261 3.60174 14.5486Z" fill="currentColor"/>
<path d="M1.75 10.75V9.25H18.25V10.75H1.75Z" fill="currentColor"/>
</svg>
`;

const Key$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.7184 12.3066C12.899 12.1201 13 11.8707 13 11.6111V9.00059C14.2398 8.07058 15 6.60167 15 5C15 2.23858 12.7614 0 10 0C7.23858 0 5 2.23858 5 5C5 6.60167 5.76016 8.07058 7 9.00059V17C7 18.6569 8.34315 20 10 20C11.6569 20 13 18.6569 13 17C13 16.701 12.8662 16.4178 12.6354 16.2278L12.4094 16.0419L12.4966 15.9919C12.8079 15.8138 13 15.4826 13 15.124V14.3488C13 14.0841 12.8951 13.8302 12.7082 13.6427L12.0571 12.9897L12.7184 12.3066ZM10.9686 8.7495C10.9894 8.83017 11 8.91395 11 9V11.2063L9.93681 12.3044C9.55743 12.6963 9.56201 13.3198 9.94709 13.706L10.8616 14.6233L10.1586 15.0255C9.55121 15.373 9.47947 16.221 10.0198 16.6656L10.9156 17.4027C10.7607 17.7544 10.409 18 10 18C9.44772 18 9 17.5523 9 17V9C9 8.91395 9.01064 8.83017 9.03138 8.7495C9.14475 8.30859 8.94599 7.84676 8.54786 7.62597C7.59988 7.10025 7 6.10326 7 5C7 3.34315 8.34315 2 10 2C11.6569 2 13 3.34315 13 5C13 6.10326 12.4001 7.10025 11.4521 7.62597C11.054 7.84676 10.8553 8.30859 10.9686 8.7495Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 5.5C10.8284 5.5 11.5 4.82843 11.5 4C11.5 3.17157 10.8284 2.5 10 2.5C9.17157 2.5 8.5 3.17157 8.5 4C8.5 4.82843 9.17157 5.5 10 5.5ZM10 3.5C10.2761 3.5 10.5 3.72386 10.5 4C10.5 4.27614 10.2761 4.5 10 4.5C9.72386 4.5 9.5 4.27614 9.5 4C9.5 3.72386 9.72386 3.5 10 3.5Z" fill="currentColor"/>
</svg>
`;

const KniveFork$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.2703 5.50648C11.2703 7.44763 12.333 8.81357 14.2703 9.50037V11C14.2703 11.5523 14.718 12 15.2703 12C15.8225 12 16.2703 11.5523 16.2703 11V8.77387C16.2706 8.75962 16.2706 8.74541 16.2703 8.73125V1.5C16.2703 0.759224 15.4929 0.275595 14.8284 0.602925C12.5118 1.74402 11.2703 3.40205 11.2703 5.50648ZM13.2703 5.50648C13.2703 4.6856 13.5885 3.97142 14.2703 3.34478V7.31599C13.5752 6.90454 13.2703 6.31705 13.2703 5.50648Z" fill="currentColor"/>
<path d="M13.2703 17.5V12.5C13.2703 11.3954 14.1657 10.5 15.2703 10.5C16.3748 10.5 17.2703 11.3954 17.2703 12.5V17.5C17.2703 18.6046 16.3748 19.5 15.2703 19.5C14.1657 19.5 13.2703 18.6046 13.2703 17.5Z" fill="currentColor"/>
<path d="M3.28304 2.4501C3.3106 1.8985 3.7801 1.47369 4.33169 1.50125C4.88329 1.5288 5.30811 1.9983 5.28055 2.5499C5.20048 4.15251 5.28317 5.23192 5.48057 5.7078C5.57632 5.93862 5.73403 6.02281 6.19257 5.99644C6.74395 5.96472 7.21664 6.38598 7.24836 6.93735C7.28007 7.48873 6.85881 7.96142 6.30744 7.99313C5.04935 8.06551 4.07832 7.54714 3.6332 6.47411C3.28974 5.64613 3.18904 4.33157 3.28304 2.4501Z" fill="currentColor"/>
<path d="M10.7166 2.4501C10.6891 1.8985 10.2196 1.47369 9.66799 1.50125C9.11639 1.5288 8.69157 1.9983 8.71913 2.5499C8.7992 4.15251 8.71651 5.23192 8.51911 5.7078C8.42336 5.93862 8.26565 6.02281 7.80711 5.99644C7.25573 5.96472 6.78304 6.38598 6.75132 6.93735C6.71961 7.48873 7.14087 7.96142 7.69224 7.99313C8.95033 8.06551 9.92136 7.54714 10.3665 6.47411C10.7099 5.64613 10.8106 4.33157 10.7166 2.4501Z" fill="currentColor"/>
<path d="M6 2.5C6 1.94772 6.44772 1.5 7 1.5C7.55228 1.5 8 1.94772 8 2.5V11.4998C8 12.0521 7.55228 12.4998 7 12.4998C6.44772 12.4998 6 12.0521 6 11.4998L6 2.5Z" fill="currentColor"/>
<path d="M5 17.5V12.5C5 11.3954 5.89543 10.5 7 10.5C8.10457 10.5 9 11.3954 9 12.5V17.5C9 18.6046 8.10457 19.5 7 19.5C5.89543 19.5 5 18.6046 5 17.5Z" fill="currentColor"/>
</svg>
`;

const Letter$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M17 3.5H3C2.44772 3.5 2 3.94772 2 4.5V15.5C2 16.0523 2.44772 16.5 3 16.5H17C17.5523 16.5 18 16.0523 18 15.5V4.5C18 3.94772 17.5523 3.5 17 3.5ZM4 14.5V5.5H16V14.5H4Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M17.6484 5.26131L10.6034 11.2613C10.2279 11.5811 9.67524 11.5794 9.30177 11.2572L2.34679 5.25718C1.64501 4.65176 2.07317 3.5 3 3.5H17C17.93 3.5 18.3564 4.65833 17.6484 5.26131ZM5.69006 5.5L9.95917 9.18292L14.2835 5.5H5.69006Z" fill="currentColor"/>
</svg>
`;

const LockClosed$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8 13C8 14.1046 8.89543 15 10 15C11.1046 15 12 14.1046 12 13C12 11.8954 11.1046 11 10 11C8.89543 11 8 11.8954 8 13ZM10.5 13C10.5 13.2761 10.2761 13.5 10 13.5C9.72386 13.5 9.5 13.2761 9.5 13C9.5 12.7239 9.72386 12.5 10 12.5C10.2761 12.5 10.5 12.7239 10.5 13Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M13 7H7C4.79086 7 3 8.79086 3 11V15C3 17.2091 4.79086 19 7 19H13C15.2091 19 17 17.2091 17 15V11C17 8.79086 15.2091 7 13 7ZM5 11C5 9.89543 5.89543 9 7 9H13C14.1046 9 15 9.89543 15 11V15C15 16.1046 14.1046 17 13 17H7C5.89543 17 5 16.1046 5 15V11Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14 4C14 1.79086 12.2091 0 10 0C7.79086 0 6 1.79086 6 4V9H14V4ZM12 4V7H8V4C8 2.89543 8.89543 2 10 2C11.1046 2 12 2.89543 12 4Z" fill="currentColor"/>
</svg>
`;

const LockOpen$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13 7H7C4.79086 7 3 8.79086 3 11V15C3 17.2091 4.79086 19 7 19H13C15.2091 19 17 17.2091 17 15V11C17 8.79086 15.2091 7 13 7ZM5 11C5 9.89543 5.89543 9 7 9H13C14.1046 9 15 9.89543 15 11V15C15 16.1046 14.1046 17 13 17H7C5.89543 17 5 16.1046 5 15V11Z" fill="currentColor"/>
<path d="M8 8C8 8.55229 7.55228 9 7 9C6.44772 9 6 8.55229 6 8V4C6 1.79086 7.79086 0 10 0C12.2091 0 14 1.79086 14 4V4.5C14 5.05228 13.5523 5.5 13 5.5C12.4477 5.5 12 5.05228 12 4.5V4C12 2.89543 11.1046 2 10 2C8.89543 2 8 2.89543 8 4V8Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M8 13C8 14.1046 8.89543 15 10 15C11.1046 15 12 14.1046 12 13C12 11.8954 11.1046 11 10 11C8.89543 11 8 11.8954 8 13ZM10.5 13C10.5 13.2761 10.2761 13.5 10 13.5C9.72386 13.5 9.5 13.2761 9.5 13C9.5 12.7239 9.72386 12.5 10 12.5C10.2761 12.5 10.5 12.7239 10.5 13Z" fill="currentColor"/>
</svg>
`;

const Loop$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.47493 4.4749C2.32704 6.62279 2.32704 10.1052 4.47493 12.2531C6.62281 14.401 10.1052 14.401 12.2531 12.2531C14.401 10.1052 14.401 6.62279 12.2531 4.4749C10.1052 2.32702 6.62281 2.32702 4.47493 4.4749ZM10.8389 10.8389C9.47205 12.2057 7.25598 12.2057 5.88914 10.8389C4.5223 9.47203 4.5223 7.25595 5.88914 5.88912C7.25598 4.52228 9.47205 4.52228 10.8389 5.88912C12.2057 7.25595 12.2057 9.47203 10.8389 10.8389Z" fill="currentColor"/>
<path d="M11.1924 13.3137C10.6066 12.7279 10.6066 11.7782 11.1924 11.1924C11.7782 10.6066 12.7279 10.6066 13.3137 11.1924L16.8492 14.7279C17.435 15.3137 17.435 16.2635 16.8492 16.8492C16.2635 17.435 15.3137 17.435 14.7279 16.8492L11.1924 13.3137Z" fill="currentColor"/>
</svg>
`;

const LoopMinus$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.82847 4.82846C2.48532 7.1716 2.48532 10.9706 4.82847 13.3137C7.17161 15.6569 10.9706 15.6569 13.3137 13.3137C15.6569 10.9706 15.6569 7.1716 13.3137 4.82846C10.9706 2.48531 7.17161 2.48531 4.82847 4.82846ZM11.8995 11.8995C10.3374 13.4616 7.80478 13.4616 6.24268 11.8995C4.68058 10.3374 4.68058 7.80477 6.24268 6.24267C7.80478 4.68057 10.3374 4.68057 11.8995 6.24267C13.4616 7.80477 13.4616 10.3374 11.8995 11.8995Z" fill="currentColor"/>
<path d="M11.8995 14.7279C11.3138 14.1421 11.3138 13.1924 11.8995 12.6066C12.4853 12.0208 13.4351 12.0208 14.0209 12.6066L17.5564 16.1421C18.1422 16.7279 18.1422 17.6776 17.5564 18.2634C16.9706 18.8492 16.0209 18.8492 15.4351 18.2634L11.8995 14.7279Z" fill="currentColor"/>
<path d="M6.70715 9.91418C6.15487 9.91418 5.70715 9.46647 5.70715 8.91418C5.70715 8.3619 6.15487 7.91418 6.70715 7.91418H11.1924C11.7447 7.91418 12.1924 8.3619 12.1924 8.91418C12.1924 9.46647 11.7447 9.91418 11.1924 9.91418H6.70715Z" fill="currentColor"/>
</svg>
`;

const LoopPlus$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.8284 4.82846C2.48526 7.1716 2.48526 10.9706 4.8284 13.3137C7.17155 15.6569 10.9705 15.6569 13.3137 13.3137C15.6568 10.9706 15.6568 7.1716 13.3137 4.82846C10.9705 2.48531 7.17155 2.48531 4.8284 4.82846ZM11.8995 11.8995C10.3374 13.4616 7.80471 13.4616 6.24262 11.8995C4.68052 10.3374 4.68052 7.80477 6.24262 6.24267C7.80472 4.68057 10.3374 4.68057 11.8995 6.24267C13.4616 7.80477 13.4616 10.3374 11.8995 11.8995Z" fill="currentColor"/>
<path d="M11.8995 14.7279C11.3138 14.1421 11.3138 13.1924 11.8995 12.6066C12.4853 12.0208 13.4351 12.0208 14.0209 12.6066L17.5564 16.1421C18.1422 16.7279 18.1422 17.6776 17.5564 18.2634C16.9706 18.8492 16.0209 18.8492 15.4351 18.2634L11.8995 14.7279Z" fill="currentColor"/>
<path d="M7.20715 10.1642C6.65487 10.1642 6.20715 9.71647 6.20715 9.16418C6.20715 8.6119 6.65487 8.16418 7.20715 8.16418H11.2072C11.7594 8.16418 12.2072 8.6119 12.2072 9.16418C12.2072 9.71647 11.7594 10.1642 11.2072 10.1642H7.20715Z" fill="currentColor"/>
<path d="M8.20715 7.16418C8.20715 6.6119 8.65487 6.16418 9.20715 6.16418C9.75944 6.16418 10.2072 6.6119 10.2072 7.16418V11.1642C10.2072 11.7165 9.75944 12.1642 9.20715 12.1642C8.65487 12.1642 8.20715 11.7165 8.20715 11.1642V7.16418Z" fill="currentColor"/>
</svg>
`;

const Magnet$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.29286 1.39339C7.68339 1.00286 8.31655 1.00286 8.70708 1.39339L12.2426 4.92892C12.6331 5.31944 12.6331 5.95261 12.2426 6.34313L7.29286 11.2929C6.90234 11.6834 6.90234 12.3166 7.29286 12.7071C7.68339 13.0976 8.31655 13.0976 8.70708 12.7071L13.6568 7.75735C14.0473 7.36682 14.6805 7.36682 15.071 7.75735L18.6066 11.2929C18.9971 11.6834 18.9971 12.3166 18.6066 12.7071L13.6568 17.6568C10.5326 20.781 5.46732 20.781 2.34312 17.6568C-0.781075 14.5326 -0.781077 9.46733 2.34312 6.34313L7.29286 1.39339ZM7.99997 3.51471L3.75733 7.75734C1.41419 10.1005 1.41419 13.8995 3.75734 16.2426C6.10048 18.5858 9.89947 18.5858 12.2426 16.2426L16.4853 12L14.3639 9.87867L10.1213 14.1213C8.94972 15.2929 7.05022 15.2929 5.87865 14.1213C4.70708 12.9497 4.70708 11.0502 5.87865 9.87867L10.1213 5.63603L7.99997 3.51471Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.29286 8.46446L5.17154 6.34314L6.58575 4.92892L8.70707 7.05024L7.29286 8.46446Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.6568 14.8284L11.5355 12.7071L12.9497 11.2929L15.071 13.4142L13.6568 14.8284Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.6286 6.42847C14.1158 6.22336 13.8664 5.64139 14.0715 5.1286L15.4217 1.75314L16.98 2.27258L17.7988 0.567164C18.0379 0.06929 18.6352 -0.140537 19.1331 0.0985035C19.631 0.337543 19.8408 0.93493 19.6018 1.4328L18.02 4.72741L16.5783 4.24685L15.9285 5.87139C15.7233 6.38417 15.1414 6.63359 14.6286 6.42847Z" fill="currentColor"/>
</svg>
`;

const Map$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 10C11.3807 10 12.5 8.88071 12.5 7.5C12.5 6.11929 11.3807 5 10 5C8.61929 5 7.5 6.11929 7.5 7.5C7.5 8.88071 8.61929 10 10 10ZM10 7C10.2761 7 10.5 7.22386 10.5 7.5C10.5 7.77614 10.2761 8 10 8C9.72386 8 9.5 7.77614 9.5 7.5C9.5 7.22386 9.72386 7 10 7Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5 7.28555C5 10.1987 7.80453 15 10 15C12.1955 15 15 10.1987 15 7.28555C15 4.38124 12.7774 2 10 2C7.22258 2 5 4.38124 5 7.28555ZM13 7.28555C13 9.2396 10.8035 13 10 13C9.19652 13 7 9.2396 7 7.28555C7 5.45617 8.35914 4 10 4C11.6409 4 13 5.45617 13 7.28555Z" fill="currentColor"/>
<path d="M13.7298 10C13.1775 10 12.7298 9.55228 12.7298 9C12.7298 8.44772 13.1775 8 13.7298 8C15.0774 8 16.2597 8.89861 16.6204 10.1971L18.0093 15.1971C18.4527 16.7935 17.5181 18.4471 15.9216 18.8906C15.6602 18.9632 15.3901 19 15.1187 19H4.88128C3.22442 19 1.88128 17.6569 1.88128 16C1.88128 15.7286 1.9181 15.4585 1.99073 15.1971L3.37961 10.1971C3.7403 8.89861 4.92254 8 6.27017 8C6.82245 8 7.27017 8.44772 7.27017 9C7.27017 9.55228 6.82245 10 6.27017 10C5.82096 10 5.42688 10.2995 5.30665 10.7324L3.91776 15.7324C3.89355 15.8195 3.88128 15.9095 3.88128 16C3.88128 16.5523 4.32899 17 4.88128 17H15.1187C15.2092 17 15.2992 16.9877 15.3864 16.9635C15.9185 16.8157 16.23 16.2645 16.0822 15.7324L14.6933 10.7324C14.5731 10.2995 14.179 10 13.7298 10Z" fill="currentColor"/>
</svg>
`;

const Microphone$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.5 4.5C7.5 3.11929 8.61929 2 10 2C11.3807 2 12.5 3.11929 12.5 4.5V8.5C12.5 9.88071 11.3807 11 10 11C8.61929 11 7.5 9.88071 7.5 8.5V4.5Z" fill="currentColor"/>
<path d="M10 18.5C7.16602 18.5 5.5 18.2917 5.5 17.5C5.5 16.7083 7.16602 16.5 10 16.5C12.834 16.5 14.5 16.7083 14.5 17.5C14.5 18.2917 12.834 18.5 10 18.5Z" fill="currentColor"/>
<path d="M9.03572 13.5H11.0357V18H9.03572V13.5Z" fill="currentColor"/>
<path d="M14 8C14 7.44772 14.4477 7 15 7C15.5523 7 16 7.44772 16 8V9.8C16 12.7142 13.2789 15 10 15C6.72114 15 4 12.7142 4 9.8V8C4 7.44772 4.44772 7 5 7C5.55228 7 6 7.44772 6 8V9.8C6 11.5249 7.75601 13 10 13C12.244 13 14 11.5249 14 9.8V8Z" fill="currentColor"/>
</svg>
`;

const Minus$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M5 11C4.44772 11 4 10.5523 4 10C4 9.44772 4.44772 9 5 9H15C15.5523 9 16 9.44772 16 10C16 10.5523 15.5523 11 15 11H5Z" fill="currentColor"/>
</svg>
`;

const Monitor$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M17.5 1H2.5C1.11929 1 0 2.11929 0 3.5V13.5C0 14.8807 1.11929 16 2.5 16H17.5C18.8807 16 20 14.8807 20 13.5V3.5C20 2.11929 18.8807 1 17.5 1ZM2 3.5C2 3.22386 2.22386 3 2.5 3H17.5C17.7761 3 18 3.22386 18 3.5V13.5C18 13.7761 17.7761 14 17.5 14H2.5C2.22386 14 2 13.7761 2 13.5V3.5Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.5 14.5H8.5C7.94772 14.5 7.5 14.9477 7.5 15.5V18C7.5 18.5523 7.94772 19 8.5 19H11.5C12.0523 19 12.5 18.5523 12.5 18V15.5C12.5 14.9477 12.0523 14.5 11.5 14.5ZM9 17.5V16H11V17.5H9Z" fill="currentColor"/>
<path d="M5.5 19.5C4.94772 19.5 4.5 19.0523 4.5 18.5C4.5 17.9477 4.94772 17.5 5.5 17.5H14.5C15.0523 17.5 15.5 17.9477 15.5 18.5C15.5 19.0523 15.0523 19.5 14.5 19.5H5.5Z" fill="currentColor"/>
<path d="M3.5 4H16.5C16.7761 4 17 4.22386 17 4.5V12.5C17 12.7761 16.7761 13 16.5 13H3.5C3.22386 13 3 12.7761 3 12.5V4.5C3 4.22386 3.22386 4 3.5 4Z" fill="currentColor"/>
</svg>
`;

const Monitor2$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M17.5 1H2.5C1.11929 1 0 2.11929 0 3.5V13.5C0 14.8807 1.11929 16 2.5 16H17.5C18.8807 16 20 14.8807 20 13.5V3.5C20 2.11929 18.8807 1 17.5 1ZM2 3.5C2 3.22386 2.22386 3 2.5 3H17.5C17.7761 3 18 3.22386 18 3.5V13.5C18 13.7761 17.7761 14 17.5 14H2.5C2.22386 14 2 13.7761 2 13.5V3.5Z" fill="currentColor"/>
<path d="M10 13.75C9.58579 13.75 9.25 13.4142 9.25 13C9.25 12.5858 9.58579 12.25 10 12.25C10.4142 12.25 10.75 12.5858 10.75 13C10.75 13.4142 10.4142 13.75 10 13.75Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.5 14.5H8.5C7.94772 14.5 7.5 14.9477 7.5 15.5V18C7.5 18.5523 7.94772 19 8.5 19H11.5C12.0523 19 12.5 18.5523 12.5 18V15.5C12.5 14.9477 12.0523 14.5 11.5 14.5ZM9 17.5V16H11V17.5H9Z" fill="currentColor"/>
<path d="M5.5 19.5C4.94772 19.5 4.5 19.0523 4.5 18.5C4.5 17.9477 4.94772 17.5 5.5 17.5H14.5C15.0523 17.5 15.5 17.9477 15.5 18.5C15.5 19.0523 15.0523 19.5 14.5 19.5H5.5Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M19 12H1V11H19V12Z" fill="currentColor"/>
</svg>
`;

const Moon$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.76447 6.1275C9.07052 4.68767 10.0433 3.51293 11.3637 2.93174C12.2938 2.52236 12.0913 1.14759 11.0826 1.02391C6.47122 0.458427 2.16189 3.52205 1.18835 8.10223C0.15323 12.9721 3.2549 17.7583 8.11727 18.7918C12.9796 19.8254 17.7599 16.7145 18.795 11.8446C18.9477 11.1264 19.0122 10.4004 18.9896 9.67855C18.9577 8.66019 17.6015 8.33612 17.1127 9.23007C16.1656 10.9622 14.1849 11.891 12.2283 11.4751C9.79778 10.9585 8.24645 8.56461 8.76447 6.1275ZM8.53309 16.8355C4.752 16.0318 2.339 12.3083 3.14464 8.51805C3.68521 5.97489 5.54698 4.0327 7.871 3.28807C7.36391 4.00107 6.99737 4.82159 6.80818 5.71168C6.06068 9.22838 8.30068 12.685 11.8125 13.4314C13.445 13.7784 15.0883 13.478 16.449 12.6805C15.176 15.7335 11.8789 17.5467 8.53309 16.8355Z" fill="currentColor"/>
</svg>
`;

const MoonFilled = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M11.3637 2.93174C10.0433 3.51293 9.07052 4.68767 8.76447 6.1275C8.24645 8.56461 9.79778 10.9585 12.2283 11.4751C14.1849 11.891 16.1656 10.9622 17.1127 9.23007C17.6015 8.33612 18.9577 8.66019 18.9896 9.67855C19.0122 10.4004 18.9477 11.1264 18.795 11.8446C17.7599 16.7145 12.9796 19.8254 8.11727 18.7918C3.2549 17.7583 0.15323 12.9721 1.18835 8.10223C2.16189 3.52205 6.47122 0.458427 11.0826 1.02391C12.0913 1.14759 12.2938 2.52236 11.3637 2.93174Z" fill="currentColor"/>
</svg>
`;

const Motorcycle$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12.75 12.5C12.75 13.0523 12.3023 13.5 11.75 13.5C11.1977 13.5 10.75 13.0523 10.75 12.5C10.75 11.9477 11.1977 11.5 11.75 11.5C12.3023 11.5 12.75 11.9477 12.75 12.5Z" fill="currentColor"/>
<path d="M9.25 12.5C9.25 13.0523 8.80228 13.5 8.25 13.5C7.69772 13.5 7.25 13.0523 7.25 12.5C7.25 11.9477 7.69772 11.5 8.25 11.5C8.80228 11.5 9.25 11.9477 9.25 12.5Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 8C11.933 8 13.5 6.433 13.5 4.5C13.5 2.567 11.933 1 10 1C8.067 1 6.5 2.567 6.5 4.5C6.5 6.433 8.067 8 10 8ZM10 3C10.8284 3 11.5 3.67157 11.5 4.5C11.5 5.32843 10.8284 6 10 6C9.17157 6 8.5 5.32843 8.5 4.5C8.5 3.67157 9.17157 3 10 3Z" fill="currentColor"/>
<path d="M10 14C11.1046 14 12 14.8954 12 16V17.5C12 18.6046 11.1046 19.5 10 19.5C8.89543 19.5 8 18.6046 8 17.5V16C8 14.8954 8.89543 14 10 14Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15 11C15 8.23858 12.7614 6 10 6C7.23858 6 5 8.23858 5 11V13.5C5 14.8807 6.11929 16 7.5 16H12.5C13.8807 16 15 14.8807 15 13.5V11ZM7 11C7 9.34315 8.34315 8 10 8C11.6569 8 13 9.34315 13 11V13.5C13 13.7761 12.7761 14 12.5 14H7.5C7.22386 14 7 13.7761 7 13.5V11Z" fill="currentColor"/>
<path d="M15.5 4.5C14.9477 4.5 14.5 4.05228 14.5 3.5C14.5 2.94772 14.9477 2.5 15.5 2.5H17.5C18.0523 2.5 18.5 2.94772 18.5 3.5C18.5 4.05228 18.0523 4.5 17.5 4.5H15.5Z" fill="currentColor"/>
<path d="M2.5 4.5C1.94772 4.5 1.5 4.05228 1.5 3.5C1.5 2.94772 1.94772 2.5 2.5 2.5H4.5C5.05228 2.5 5.5 2.94772 5.5 3.5C5.5 4.05228 5.05228 4.5 4.5 4.5H2.5Z" fill="currentColor"/>
<path d="M3.40952 4.04579L3.88582 2.59058L8.40952 3.45438L7.93321 4.90959L3.40952 4.04579Z" fill="currentColor"/>
<path d="M11.5905 3.45433L12.0668 4.90955L16.5905 4.04574L16.1142 2.59053L11.5905 3.45433Z" fill="currentColor"/>
</svg>
`;

const MusicNoteDouble$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.75 3.80989C6.75 3.29386 7.14265 2.86257 7.65642 2.81428L16.6564 1.96832C17.2431 1.91318 17.75 2.37468 17.75 2.96393V5.14519C17.75 5.65923 17.3603 6.08955 16.8487 6.1403L7.84873 7.03323C7.26031 7.09161 6.75 6.62943 6.75 6.03812V3.80989Z" fill="currentColor"/>
<ellipse cx="14.75" cy="15" rx="3" ry="2.5" fill="currentColor"/>
<ellipse cx="5.75" cy="16" rx="3" ry="2.5" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15.75 5H17.75V15H15.75V5Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.75 6H8.75V16H6.75V6Z" fill="currentColor"/>
</svg>
`;

const MusicNoteSingle$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9.78103 1.69759C14.1038 4.63512 16.25 6.76176 16.25 8.30413C16.25 9.79646 15.4291 11.0034 13.8541 11.8872C13.418 12.132 12.9324 11.6555 13.1688 11.2148C13.5756 10.4565 13.4416 9.60793 12.7079 8.59803C11.934 7.53285 10.8174 6.75731 9.34301 6.26969C9.13826 6.20198 9 6.01063 9 5.79498V2.11114C9 1.70978 9.44906 1.47201 9.78103 1.69759Z" fill="currentColor"/>
<path d="M7.75 17.75C5.97914 17.75 4.5 16.607 4.5 15.125C4.5 13.643 5.97914 12.5 7.75 12.5C9.52086 12.5 11 13.643 11 15.125C11 16.607 9.52086 17.75 7.75 17.75Z" fill="currentColor"/>
<path d="M10 4C10.5523 4 11 4.44772 11 5V15C11 15.5523 10.5523 16 10 16C9.44772 16 9 15.5523 9 15V5C9 4.44772 9.44772 4 10 4Z" fill="currentColor"/>
</svg>
`;

const Open$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10.7071 10.7071C10.3166 11.0976 9.68342 11.0976 9.29289 10.7071C8.90237 10.3166 8.90237 9.68342 9.29289 9.29289L15.2929 3.29289C15.6834 2.90237 16.3166 2.90237 16.7071 3.29289C17.0976 3.68342 17.0976 4.31658 16.7071 4.70711L10.7071 10.7071Z" fill="currentColor"/>
<path d="M15 15V11.5C15 10.9477 15.4477 10.5 16 10.5C16.5523 10.5 17 10.9477 17 11.5V16C17 16.5523 16.5523 17 16 17H4C3.44772 17 3 16.5523 3 16V4C3 3.44772 3.44772 3 4 3H8.5C9.05228 3 9.5 3.44772 9.5 4C9.5 4.55228 9.05228 5 8.5 5H5V15H15Z" fill="currentColor"/>
<path d="M17 8C17 8.55228 16.5523 9 16 9C15.4477 9 15 8.55228 15 8V4C15 3.44772 15.4477 3 16 3C16.5523 3 17 3.44772 17 4V8Z" fill="currentColor"/>
<path d="M12 5C11.4477 5 11 4.55228 11 4C11 3.44772 11.4477 3 12 3H16C16.5523 3 17 3.44772 17 4C17 4.55228 16.5523 5 16 5H12Z" fill="currentColor"/>
</svg>
`;

const PaintPallet$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M16.2196 13.9555C17.2636 10.0595 14.7915 6.03562 10.731 4.94761C6.14492 3.71877 -0.364424 6.91181 1.08416 11.0092C1.56325 12.3643 2.48817 12.6814 4.23088 12.7061L4.33978 12.7075C5.26123 12.7191 5.52041 12.7792 5.59794 12.9054C5.72536 13.1128 5.72679 13.4439 5.58387 14.3543C5.51634 14.7845 5.49418 14.9355 5.46808 15.1703C5.30897 16.6011 5.55075 17.7169 6.48838 18.7268C9.41611 21.8802 15.0412 18.3535 16.2196 13.9555ZM2.96979 10.3425C2.24104 8.28126 6.9056 5.99314 10.2134 6.87946C13.2298 7.68772 15.0393 10.6331 14.2878 13.4379C13.4497 16.5656 9.50636 19.0379 7.95406 17.366C7.47464 16.8496 7.35504 16.2977 7.45583 15.3913C7.47737 15.1975 7.49709 15.0631 7.55967 14.6645C7.77887 13.2683 7.77611 12.6302 7.30206 11.8585C6.70834 10.8921 6.00236 10.7282 4.36491 10.7076L4.25922 10.7063C3.29465 10.6926 3.06582 10.6141 2.96979 10.3425Z" fill="currentColor"/>
<path d="M6 10C5.30964 10 4.75 9.44036 4.75 8.75C4.75 8.05964 5.30964 7.5 6 7.5C6.69036 7.5 7.25 8.05964 7.25 8.75C7.25 9.44036 6.69036 10 6 10Z" fill="currentColor"/>
<path d="M9.75 10C9.05964 10 8.5 9.44036 8.5 8.75C8.5 8.05964 9.05964 7.5 9.75 7.5C10.4404 7.5 11 8.05964 11 8.75C11 9.44036 10.4404 10 9.75 10Z" fill="currentColor"/>
<path d="M12.25 13C11.5596 13 11 12.4404 11 11.75C11 11.0596 11.5596 10.5 12.25 10.5C12.9404 10.5 13.5 11.0596 13.5 11.75C13.5 12.4404 12.9404 13 12.25 13Z" fill="currentColor"/>
<path d="M10.75 16.5C10.0596 16.5 9.5 15.9404 9.5 15.25C9.5 14.5596 10.0596 14 10.75 14C11.4404 14 12 14.5596 12 15.25C12 15.9404 11.4404 16.5 10.75 16.5Z" fill="currentColor"/>
<path d="M14.3707 3.60451C14.8605 3.34411 15.466 3.52923 15.7253 4.01686C15.7308 4.02727 15.7362 4.03777 15.7413 4.04836L19.8336 12.4482C19.9869 12.7628 19.8635 13.1422 19.5545 13.3065C19.2452 13.471 18.8612 13.3618 18.6847 13.0592L13.9771 4.98893C13.6993 4.5127 13.8602 3.90144 14.3364 3.62364C14.3477 3.61704 14.3592 3.61066 14.3707 3.60451Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.5375 3.48434C13.0238 4.39897 13.8434 4.65522 14.6347 4.23444C15.4262 3.81362 15.6726 2.99053 15.1863 2.07592C14.6289 1.0276 13.438 0.0775719 12.6482 0.497483C11.8585 0.917395 11.9801 2.43602 12.5375 3.48434ZM13.4204 3.01486C13.2581 2.70947 13.1315 2.26269 13.1007 1.8773C13.0806 1.62643 13.1063 1.45889 13.1151 1.40204C13.1171 1.38903 13.1182 1.38181 13.1176 1.38073C13.1183 1.38172 13.1245 1.38462 13.1356 1.38985C13.1866 1.41372 13.3408 1.48594 13.5391 1.64416C13.8414 1.88525 14.141 2.24 14.3034 2.54539C14.5316 2.97464 14.4668 3.19118 14.1653 3.3515C13.8641 3.51165 13.6488 3.44435 13.4204 3.01486Z" fill="currentColor"/>
</svg>
`;

const Pen$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.1976 1.21963L3.11967 11.2976C2.9692 11.448 2.87065 11.6426 2.83836 11.8529L2.13291 16.4474C2.03041 17.115 2.60551 17.6901 3.27309 17.5876L7.86762 16.8822C8.07795 16.8499 8.2725 16.7513 8.42297 16.6009L18.5009 6.52294C18.8914 6.13241 18.8914 5.49925 18.5009 5.10872L14.6118 1.21963C14.2213 0.82911 13.5881 0.829111 13.1976 1.21963ZM4.31657 15.404L4.76548 12.4802L13.9047 3.34095L16.3796 5.81583L7.24036 14.9551L4.31657 15.404Z" fill="currentColor"/>
<path d="M11.442 5.24658L12.5027 4.18592L15.7436 7.42683L14.6829 8.48749L11.442 5.24658Z" fill="currentColor"/>
</svg>
`;

const Person$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6 6C6 8.20914 7.79086 10 10 10C12.2091 10 14 8.20914 14 6C14 3.79086 12.2091 2 10 2C7.79086 2 6 3.79086 6 6ZM12 6C12 7.10457 11.1046 8 10 8C8.89543 8 8 7.10457 8 6C8 4.89543 8.89543 4 10 4C11.1046 4 12 4.89543 12 6Z" fill="currentColor"/>
<path d="M17 18C17 18.5523 16.5523 19 16 19C15.4477 19 15 18.5523 15 18V15.5C15 13.0059 12.7945 11 10.0162 11C7.23004 11 5 13.0132 5 15.4992L5.00204 17.9992C5.0025 18.5515 4.55515 18.9995 4.00286 19C3.45058 19.0005 3.0025 18.5531 3.00205 18.0008L3 15.5C3 11.8604 6.16851 9 10.0162 9C13.859 9 17 11.8567 17 15.5V18Z" fill="currentColor"/>
</svg>
`;

const PersonFilled = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10 9C11.6569 9 13 7.65685 13 6C13 4.34315 11.6569 3 10 3C8.34315 3 7 4.34315 7 6C7 7.65685 8.34315 9 10 9Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M16 15.5C16 12.309 13.314 10 10 10C6.686 10 4 12.309 4 15.5L4.002 17C4.002 17.2652 4.10736 17.5196 4.29489 17.7071C4.48243 17.8946 4.73678 18 5.002 18H15C15.2652 18 15.5196 17.8946 15.7071 17.7071C15.8946 17.5196 16 17.2652 16 17V15.5Z" fill="currentColor"/>
</svg>
`;

const Phone$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.5208 10.1924L11.9389 10.7743C10.9366 9.8925 9.99424 8.94935 9.11167 7.94467L9.69238 7.36396C10.864 6.19239 10.864 4.2929 9.69238 3.12132L8.27817 1.70711C7.1066 0.535537 5.2071 0.535537 4.03553 1.70711L1.22986 4.51278C0.952956 4.78968 0.86316 5.20273 1.00011 5.5696C3.37437 11.9301 7.81797 16.4042 14.3082 18.882C14.6766 19.0227 15.0932 18.9337 15.372 18.6549L18.1777 15.8492C19.3492 14.6777 19.3492 12.7782 18.1777 11.6066L16.7635 10.1924C15.5919 9.02082 13.6924 9.02082 12.5208 10.1924ZM16.7635 13.0208C17.154 13.4113 17.154 14.0445 16.7635 14.435L14.4223 16.7761C8.99791 14.5464 5.24853 10.7759 3.10515 5.46592L5.44974 3.12132C5.84027 2.7308 6.47343 2.7308 6.86396 3.12132L8.27817 4.53554C8.66869 4.92606 8.66869 5.55923 8.27817 5.94975L7.04424 7.18368C6.67929 7.54863 6.65203 8.13136 6.98131 8.52879C8.30405 10.1253 9.76178 11.5841 11.3538 12.9048C11.7513 13.2344 12.3343 13.2073 12.6994 12.8422L13.935 11.6066C14.3255 11.2161 14.9587 11.2161 15.3492 11.6066L16.7635 13.0208Z" fill="currentColor"/>
</svg>
`;

const PhotoCamera$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.69572 5.07845L5.39825 6H4.5C2.84315 6 1.5 7.34315 1.5 9V15C1.5 16.6569 2.84315 18 4.5 18H15.5C17.1569 18 18.5 16.6569 18.5 15V9C18.5 7.34315 17.1569 6 15.5 6H14.6013L14.3038 5.07845C13.9039 3.83958 12.7507 3 11.4489 3H8.55067C7.24886 3 6.09561 3.83958 5.69572 5.07845ZM4.5 8H6.85428L7.59902 5.69282C7.73232 5.27986 8.11673 5 8.55067 5H11.4489C11.8828 5 12.2672 5.27986 12.4005 5.69282L13.1453 8H15.5C16.0523 8 16.5 8.44772 16.5 9V15C16.5 15.5523 16.0523 16 15.5 16H4.5C3.94772 16 3.5 15.5523 3.5 15V9C3.5 8.44772 3.94772 8 4.5 8Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.5 11.5C6.5 13.433 8.067 15 10 15C11.933 15 13.5 13.433 13.5 11.5C13.5 9.567 11.933 8 10 8C8.067 8 6.5 9.567 6.5 11.5ZM11.5 11.5C11.5 12.3284 10.8284 13 10 13C9.17157 13 8.5 12.3284 8.5 11.5C8.5 10.6716 9.17157 10 10 10C10.8284 10 11.5 10.6716 11.5 11.5Z" fill="currentColor"/>
</svg>
`;

const Pill$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.5459 4.18199L16.9099 10.5459C18.6673 12.3033 18.6673 15.1525 16.9099 16.9099C15.1525 18.6673 12.3033 18.6673 10.5459 16.9099L4.18199 10.5459C2.42463 8.78859 2.42463 5.93935 4.18199 4.18199C5.93935 2.42463 8.78859 2.42463 10.5459 4.18199ZM13 9.50001C12.3333 8.83334 11.5 8.66667 10.5 9.00001C9.50001 9.33334 8.83334 10.3333 8.50001 12L11.9203 15.4437C11.9223 15.4457 11.9243 15.4477 11.9263 15.4498C12.8993 16.4227 14.4768 16.4227 15.4498 15.4498C15.4522 15.4473 15.4547 15.4448 15.4572 15.4423C16.4253 14.466 16.4186 12.8898 15.4423 11.9217L13 9.50001Z" fill="currentColor"/>
</svg>
`;

const Pinpoint$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 11.5C11.933 11.5 13.5 9.933 13.5 8C13.5 6.067 11.933 4.5 10 4.5C8.067 4.5 6.5 6.067 6.5 8C6.5 9.933 8.067 11.5 10 11.5ZM10 6.5C10.8284 6.5 11.5 7.17157 11.5 8C11.5 8.82843 10.8284 9.5 10 9.5C9.17157 9.5 8.5 8.82843 8.5 8C8.5 7.17157 9.17157 6.5 10 6.5Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.5 8.12313C2.5 12.3656 6.88183 19.5 10 19.5C13.1182 19.5 17.5 12.3656 17.5 8.12313C17.5 3.91715 14.1464 0.5 10 0.5C5.85362 0.5 2.5 3.91715 2.5 8.12313ZM15.5 8.12313C15.5 11.4027 11.7551 17.5 10 17.5C8.24487 17.5 4.5 11.4027 4.5 8.12313C4.5 5.0134 6.96668 2.5 10 2.5C13.0333 2.5 15.5 5.0134 15.5 8.12313Z" fill="currentColor"/>
</svg>
`;

const PinpointFilled = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.5 8.12313C2.5 12.3656 6.88183 19.5 10 19.5C13.1182 19.5 17.5 12.3656 17.5 8.12313C17.5 3.91715 14.1464 0.5 10 0.5C5.85362 0.5 2.5 3.91715 2.5 8.12313ZM10 5.5C11.3807 5.5 12.5 6.61929 12.5 8C12.5 9.38071 11.3807 10.5 10 10.5C8.61929 10.5 7.5 9.38071 7.5 8C7.5 6.61929 8.61929 5.5 10 5.5Z" fill="currentColor"/>
</svg>
`;

const PinpointOff$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.29289 2.70711C0.902369 2.31658 0.902369 1.68342 1.29289 1.29289C1.68342 0.902369 2.31658 0.902369 2.70711 1.29289L18.7071 17.2929C19.0976 17.6834 19.0976 18.3166 18.7071 18.7071C18.3166 19.0976 17.6834 19.0976 17.2929 18.7071L1.29289 2.70711Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 11.5C11.933 11.5 13.5 9.933 13.5 8C13.5 6.067 11.933 4.5 10 4.5C8.067 4.5 6.5 6.067 6.5 8C6.5 9.933 8.067 11.5 10 11.5ZM10 6.5C10.8284 6.5 11.5 7.17157 11.5 8C11.5 8.82843 10.8284 9.5 10 9.5C9.17157 9.5 8.5 8.82843 8.5 8C8.5 7.17157 9.17157 6.5 10 6.5Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.5 8.12313C2.5 12.3656 6.88183 19.5 10 19.5C13.1182 19.5 17.5 12.3656 17.5 8.12313C17.5 3.91715 14.1464 0.5 10 0.5C5.85362 0.5 2.5 3.91715 2.5 8.12313ZM15.5 8.12313C15.5 11.4027 11.7551 17.5 10 17.5C8.24487 17.5 4.5 11.4027 4.5 8.12313C4.5 5.0134 6.96668 2.5 10 2.5C13.0333 2.5 15.5 5.0134 15.5 8.12313Z" fill="currentColor"/>
</svg>
`;

const PinpointOffFilled = `<svg width="21" height="21" viewBox="0 0 21 21" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.5 8.12313C2.5 12.3656 6.88183 19.5 10 19.5C13.1182 19.5 17.5 12.3656 17.5 8.12313C17.5 3.91715 14.1464 0.5 10 0.5C5.85362 0.5 2.5 3.91715 2.5 8.12313ZM10 5.5C11.3807 5.5 12.5 6.61929 12.5 8C12.5 9.38071 11.3807 10.5 10 10.5C8.61929 10.5 7.5 9.38071 7.5 8C7.5 6.61929 8.61929 5.5 10 5.5Z" fill="currentColor"/>
<path d="M1.53272 2.44678C1.1479 2.05064 1.15707 1.41755 1.55321 1.03272C1.94936 0.647896 2.58246 0.65707 2.96728 1.05321L19.9673 18.5532C20.3521 18.9494 20.3429 19.5825 19.9468 19.9673C19.5506 20.3521 18.9175 20.3429 18.5327 19.9468L1.53272 2.44678Z" fill="currentColor"/>
</svg>
`;

const Plus$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M5 11C4.44772 11 4 10.5523 4 10C4 9.44772 4.44772 9 5 9H15C15.5523 9 16 9.44772 16 10C16 10.5523 15.5523 11 15 11H5Z" fill="currentColor"/>
<path d="M9 5C9 4.44772 9.44772 4 10 4C10.5523 4 11 4.44772 11 5V15C11 15.5523 10.5523 16 10 16C9.44772 16 9 15.5523 9 15V5Z" fill="currentColor"/>
</svg>
`;

const Power$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4.33819 5.17875C4.72595 4.78548 5.3591 4.78103 5.75236 5.16879C6.14563 5.55656 6.15008 6.18971 5.76232 6.58297C4.64106 7.72013 4 9.25726 4 10.9008C4 14.2724 6.68947 17 10 17C13.3105 17 16 14.2724 16 10.9008C16 9.25726 15.3589 7.72013 14.2377 6.58297C13.8499 6.18971 13.8544 5.55656 14.2476 5.16879C14.6409 4.78103 15.274 4.78548 15.6618 5.17875C17.1491 6.68714 18 8.72737 18 10.9008C18 15.3708 14.4215 19 10 19C5.57855 19 2 15.3708 2 10.9008C2 8.72737 2.85088 6.68714 4.33819 5.17875Z" fill="currentColor"/>
<rect x="9" y="1" width="2" height="10.5" rx="1" fill="currentColor"/>
</svg>
`;

const Printer$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5 7V3C5 2.44772 5.3731 2 5.83333 2H14.1667C14.6269 2 15 2.44772 15 3V7" fill="white"/>
<path d="M6 3V7C6 7.55228 5.55228 8 5 8C4.44772 8 4 7.55228 4 7V3C4 1.93165 4.77637 1 5.83333 1H14.1667C15.2236 1 16 1.93165 16 3V7C16 7.55228 15.5523 8 15 8C14.4477 8 14 7.55228 14 7V3H6Z" fill="currentColor"/>
<path d="M4 6H16C17.6569 6 19 7.34315 19 9V14C19 15.6569 17.6569 17 16 17H4C2.34315 17 1 15.6569 1 14L1 9C1 7.34315 2.34315 6 4 6Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5 12V16.8C5 17.4627 5.3731 18 5.83333 18H14.1667C14.6269 18 15 17.4627 15 16.8V12" fill="white"/>
<path d="M6 16.8V12C6 11.4477 5.55228 11 5 11C4.44772 11 4 11.4477 4 12V16.8C4 17.9536 4.72664 19 5.83333 19H14.1667C15.2734 19 16 17.9536 16 16.8V12C16 11.4477 15.5523 11 15 11C14.4477 11 14 11.4477 14 12V16.8C14 16.8775 13.9883 16.9466 13.971 17H6.02904C6.0117 16.9466 6 16.8775 6 16.8Z" fill="currentColor"/>
<path d="M7 16C6.72386 16 6.5 15.7761 6.5 15.5C6.5 15.2239 6.72386 15 7 15H13C13.2761 15 13.5 15.2239 13.5 15.5C13.5 15.7761 13.2761 16 13 16H7Z" fill="currentColor"/>
<path d="M7 14C6.72386 14 6.5 13.7761 6.5 13.5C6.5 13.2239 6.72386 13 7 13H13C13.2761 13 13.5 13.2239 13.5 13.5C13.5 13.7761 13.2761 14 13 14H7Z" fill="currentColor"/>
</svg>
`;

const Refresh$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M5.05022 14.9497C4.65969 14.5592 4.65969 13.9261 5.05022 13.5355C5.44074 13.145 6.07391 13.145 6.46443 13.5355C7.39671 14.4678 8.65494 15 9.99996 15C12.7614 15 15 12.7614 15 10C15 9.44772 15.4477 9 16 9C16.5522 9 17 9.44772 17 10C17 13.866 13.866 17 9.99996 17C8.11906 17 6.35385 16.2534 5.05022 14.9497Z" fill="currentColor"/>
<path d="M13.5585 12.832C13.0989 13.1384 12.478 13.0141 12.1717 12.5546C11.8654 12.0951 11.9896 11.4742 12.4491 11.1679L15.4495 9.16787C15.9091 8.86154 16.5299 8.98575 16.8363 9.4453C17.1426 9.90484 17.0184 10.5257 16.5588 10.832L13.5585 12.832Z" fill="currentColor"/>
<path d="M18.832 12.4452C19.1383 12.9048 19.0141 13.5256 18.5546 13.832C18.0951 14.1383 17.4742 14.0142 17.1679 13.5546L15.1679 10.5546C14.8615 10.0951 14.9857 9.47424 15.4452 9.16789C15.9047 8.86153 16.5256 8.98571 16.832 9.44524L18.832 12.4452Z" fill="currentColor"/>
<path d="M14.8571 4.85116C15.2477 5.24168 15.2477 5.87485 14.8571 6.26537C14.4666 6.65589 13.8334 6.65589 13.4429 6.26537C12.5106 5.33309 11.2524 4.8009 9.90738 4.8009C7.14596 4.8009 4.90738 7.03948 4.90738 9.8009C4.90738 10.3532 4.45967 10.8009 3.90738 10.8009C3.3551 10.8009 2.90738 10.3532 2.90738 9.8009C2.90738 5.93491 6.04139 2.8009 9.90738 2.8009C11.7883 2.8009 13.5535 3.54752 14.8571 4.85116Z" fill="currentColor"/>
<path d="M6.34889 6.96887C6.80844 6.66255 7.4293 6.78676 7.73563 7.2463C8.04195 7.70585 7.91775 8.32671 7.4582 8.63304L4.45782 10.633C3.99828 10.9394 3.37741 10.8152 3.07109 10.3556C2.76476 9.89606 2.88897 9.2752 3.34852 8.96887L6.34889 6.96887Z" fill="currentColor"/>
<path d="M1.07539 7.35567C0.769038 6.89614 0.893212 6.27527 1.35274 5.96892C1.81227 5.66256 2.43314 5.78674 2.73949 6.24627L4.73949 9.24627C5.04584 9.7058 4.92167 10.3267 4.46214 10.633C4.00261 10.9394 3.38174 10.8152 3.07539 10.3557L1.07539 7.35567Z" fill="currentColor"/>
</svg>
`;

const Reload$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13.9372 4.21148C14.3936 4.52244 14.5115 5.14453 14.2005 5.60095C13.8896 6.05738 13.2675 6.1753 12.8111 5.86434C11.9885 5.30394 11.0183 5 10 5C7.23858 5 5 7.23858 5 10C5 12.7614 7.23858 15 10 15C12.7614 15 15 12.7614 15 10C15 9.44772 15.4477 9 16 9C16.5523 9 17 9.44772 17 10C17 13.866 13.866 17 10 17C6.13401 17 3 13.866 3 10C3 6.13401 6.13401 3 10 3C11.4232 3 12.7852 3.42666 13.9372 4.21148Z" fill="currentColor"/>
<path d="M13.5385 12.5062C13.0733 12.8038 12.4549 12.6679 12.1573 12.2026C11.8597 11.7373 11.9956 11.1189 12.4608 10.8214L15.9427 8.59426C16.4079 8.29667 17.0263 8.43258 17.3239 8.89784C17.6215 9.36309 17.4856 9.98149 17.0204 10.2791L13.5385 12.5062Z" fill="currentColor"/>
<path d="M18.9034 12.4104C19.1284 12.9147 18.9019 13.506 18.3975 13.731C17.8931 13.956 17.3019 13.7295 17.0769 13.2252L15.5687 9.84436C15.3437 9.33999 15.5702 8.74871 16.0745 8.52371C16.5789 8.29871 17.1702 8.52519 17.3952 9.02957L18.9034 12.4104Z" fill="currentColor"/>
</svg>
`;

const Scissors$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 5.5C2 7.433 3.567 9 5.5 9C7.433 9 9 7.433 9 5.5C9 3.567 7.433 2 5.5 2C3.567 2 2 3.567 2 5.5ZM7 5.5C7 6.32843 6.32843 7 5.5 7C4.67157 7 4 6.32843 4 5.5C4 4.67157 4.67157 4 5.5 4C6.32843 4 7 4.67157 7 5.5Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 14C2 15.933 3.567 17.5 5.5 17.5C7.433 17.5 9 15.933 9 14C9 12.067 7.433 10.5 5.5 10.5C3.567 10.5 2 12.067 2 14ZM7 14C7 14.8284 6.32843 15.5 5.5 15.5C4.67157 15.5 4 14.8284 4 14C4 13.1716 4.67157 12.5 5.5 12.5C6.32843 12.5 7 13.1716 7 14Z" fill="currentColor"/>
<path d="M16.7071 15.2929C17.0976 15.6834 17.0976 16.3166 16.7071 16.7071C16.3166 17.0976 15.6834 17.0976 15.2929 16.7071L6.79289 8.20711C6.40237 7.81658 6.40237 7.18342 6.79289 6.79289C7.18342 6.40237 7.81658 6.40237 8.20711 6.79289L16.7071 15.2929Z" fill="currentColor"/>
<path d="M6.79289 11.2929C6.40237 11.6834 6.40237 12.3166 6.79289 12.7071C7.18342 13.0976 7.81658 13.0976 8.20711 12.7071L16.7071 4.20711C17.0976 3.81658 17.0976 3.18342 16.7071 2.79289C16.3166 2.40237 15.6834 2.40237 15.2929 2.79289L6.79289 11.2929Z" fill="currentColor"/>
</svg>
`;

const Send$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.68542 6.65868C0.758716 6.96758 0.779177 8.28543 1.71502 8.56541L9.20844 10.8072L11.6551 18.5165C11.948 19.4394 13.2507 19.4488 13.5569 18.5302L18.8602 2.62029C19.1208 1.83853 18.3771 1.09479 17.5953 1.35538L1.68542 6.65868ZM5.31842 7.55586L16.3304 3.8852L12.6316 14.9817L10.9548 9.69826C10.8547 9.38295 10.6052 9.13754 10.2883 9.04272L5.31842 7.55586Z" fill="currentColor"/>
<path d="M17.7674 1.43951L18.8105 2.51742L9.98262 11.0605L8.93948 9.98265L17.7674 1.43951Z" fill="currentColor"/>
</svg>
`;

const ShareAndroid$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5 13C6.65685 13 8 11.6569 8 10C8 8.34315 6.65685 7 5 7C3.34315 7 2 8.34315 2 10C2 11.6569 3.34315 13 5 13ZM5 9C5.55228 9 6 9.44772 6 10C6 10.5523 5.55228 11 5 11C4.44772 11 4 10.5523 4 10C4 9.44772 4.44772 9 5 9Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14 8C15.6569 8 17 6.65685 17 5C17 3.34315 15.6569 2 14 2C12.3431 2 11 3.34315 11 5C11 6.65685 12.3431 8 14 8ZM14 4C14.5523 4 15 4.44772 15 5C15 5.55228 14.5523 6 14 6C13.4477 6 13 5.55228 13 5C13 4.44772 13.4477 4 14 4Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14 18C15.6569 18 17 16.6569 17 15C17 13.3431 15.6569 12 14 12C12.3431 12 11 13.3431 11 15C11 16.6569 12.3431 18 14 18ZM14 14C14.5523 14 15 14.4477 15 15C15 15.5523 14.5523 16 14 16C13.4477 16 13 15.5523 13 15C13 14.4477 13.4477 14 14 14Z" fill="currentColor"/>
<path d="M6.23584 9.77722L5.47275 8.48583L12.2641 4.47274L13.0272 5.76413L6.23584 9.77722Z" fill="currentColor"/>
<path d="M12.2572 15.529L13.029 14.2428L6.74275 10.471L5.97101 11.7572L12.2572 15.529Z" fill="currentColor"/>
</svg>
`;

const ShareIos$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9 3C9 2.44772 9.44772 2 10 2C10.5523 2 11 2.44772 11 3L11 13.5C11 14.0523 10.5523 14.5 10 14.5C9.44772 14.5 9 14.0523 9 13.5L9 3Z" fill="currentColor"/>
<path d="M10.6402 2.76826C11.0645 2.41469 11.1218 1.78413 10.7682 1.35985C10.4147 0.935575 9.7841 0.878251 9.35982 1.23181L6.35982 3.73181C5.93554 4.08538 5.87822 4.71594 6.23178 5.14022C6.58535 5.5645 7.21591 5.62182 7.64019 5.26826L10.6402 2.76826Z" fill="currentColor"/>
<path d="M9.35981 2.76826C8.93553 2.41469 8.87821 1.78413 9.23177 1.35985C9.58534 0.935575 10.2159 0.878251 10.6402 1.23181L13.6402 3.73181C14.0645 4.08538 14.1218 4.71594 13.7682 5.14022C13.4147 5.5645 12.7841 5.62182 12.3598 5.26826L9.35981 2.76826Z" fill="currentColor"/>
<path d="M13 9C12.4477 9 12 8.55228 12 8C12 7.44772 12.4477 7 13 7H14C15.6233 7 17 8.16491 17 9.69231V17.3077C17 18.8351 15.6233 20 14 20L6 20C4.37672 20 3 18.8351 3 17.3077L3 9.69231C3 8.16491 4.37672 7 6 7H7C7.55228 7 8 7.44772 8 8C8 8.55228 7.55228 9 7 9H6C5.41414 9 5 9.35043 5 9.69231L5 17.3077C5 17.6496 5.41414 18 6 18L14 18C14.5859 18 15 17.6496 15 17.3077L15 9.69231C15 9.35043 14.5859 9 14 9L13 9Z" fill="currentColor"/>
</svg>
`;

const Smartphone$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.25 3C6.25 2.86193 6.36193 2.75 6.5 2.75H13.5C13.6381 2.75 13.75 2.86193 13.75 3V15C13.75 15.1381 13.6381 15.25 13.5 15.25H6.5C6.36193 15.25 6.25 15.1381 6.25 15V3Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.5 0H5.5C4.39543 0 3.5 0.942558 3.5 2.10526V17.8947C3.5 19.0574 4.39543 20 5.5 20H14.5C15.6046 20 16.5 19.0574 16.5 17.8947V2.10526C16.5 0.942558 15.6046 0 14.5 0ZM5.5 18V2H14.5V18H5.5Z" fill="currentColor"/>
<path d="M10.5 16.5C10.5 16.7761 10.2761 17 10 17C9.72386 17 9.5 16.7761 9.5 16.5C9.5 16.2239 9.72386 16 10 16C10.2761 16 10.5 16.2239 10.5 16.5Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M9 16.5C9 15.9477 9.44772 15.5 10 15.5C10.5523 15.5 11 15.9477 11 16.5C11 17.0523 10.5523 17.5 10 17.5C9.44772 17.5 9 17.0523 9 16.5Z" fill="currentColor"/>
</svg>
`;

const SmartphoneNotch$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6 0H15C16.1046 0 17 0.942558 17 2.10526V17.8947C17 19.0574 16.1046 20 15 20H6C4.89543 20 4 19.0574 4 17.8947V2.10526C4 0.942558 4.89543 0 6 0ZM7 2C6.44772 2 6 2.44772 6 3V17C6 17.5523 6.44772 18 7 18H14C14.5523 18 15 17.5523 15 17V3C15 2.44772 14.5523 2 14 2H13V3.5C13 3.77614 12.7761 4 12.5 4H8.5C8.22386 4 8 3.77614 8 3.5V2H7Z" fill="currentColor"/>
</svg>
`;

const Smartphone2$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.5 0H5.5C4.39543 0 3.5 0.89543 3.5 2V18C3.5 19.1046 4.39543 20 5.5 20H14.5C15.6046 20 16.5 19.1046 16.5 18V2C16.5 0.89543 15.6046 0 14.5 0ZM5.5 18V2H14.5V18H5.5Z" fill="currentColor"/>
<path d="M10 17.25C9.30964 17.25 8.75 16.6904 8.75 16C8.75 15.3096 9.30964 14.75 10 14.75C10.6904 14.75 11.25 15.3096 11.25 16C11.25 16.6904 10.6904 17.25 10 17.25Z" fill="currentColor"/>
</svg>
`;

const SoftDrink$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.411 4H6.58933C6.48813 4 6.38701 4.00615 6.28655 4.0184C4.916 4.18563 3.94052 5.43224 4.10774 6.80278L5.32785 16.8028C5.48089 18.0571 6.54584 19 7.80945 19H12.1937C13.4576 19 14.5227 18.0567 14.6754 16.8021L15.8927 6.80209C15.9049 6.70186 15.911 6.60097 15.911 6.5C15.911 5.11929 14.7917 4 13.411 4ZM6.52878 6.00368C6.54887 6.00123 6.56909 6 6.58933 6H13.411C13.6871 6 13.911 6.22386 13.911 6.5C13.911 6.52019 13.9097 6.54037 13.9073 6.56042L12.69 16.5604C12.6595 16.8113 12.4465 17 12.1937 17H7.80945C7.55673 17 7.34374 16.8114 7.31313 16.5606L6.09302 6.56056C6.05957 6.28645 6.25467 6.03713 6.52878 6.00368Z" fill="currentColor"/>
<path d="M9.21684 14.7206C9.09502 15.1165 8.67533 15.3386 8.27944 15.2168C7.88354 15.095 7.66135 14.6753 7.78317 14.2794L11.7832 1.27944C11.905 0.88354 12.3247 0.661352 12.7206 0.783167C13.1165 0.904981 13.3386 1.32467 13.2168 1.72057L9.21684 14.7206Z" fill="currentColor"/>
<path d="M5.5 10.25C5.08579 10.25 4.75 9.91421 4.75 9.5C4.75 9.08579 5.08579 8.75 5.5 8.75H14.5C14.9142 8.75 15.25 9.08579 15.25 9.5C15.25 9.91421 14.9142 10.25 14.5 10.25H5.5Z" fill="currentColor"/>
<path d="M12.3181 2.22761C11.9163 2.12715 11.6719 1.71995 11.7724 1.3181C11.8729 0.916254 12.2801 0.671934 12.6819 0.772395L16.6819 1.7724C17.0838 1.87286 17.3281 2.28006 17.2276 2.6819C17.1272 3.08375 16.72 3.32807 16.3181 3.22761L12.3181 2.22761Z" fill="currentColor"/>
</svg>
`;

const SpeakerHigh$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.3341 1.75396L5.6534 5.93183H2C1.44772 5.93183 1 6.37954 1 6.93183V12.9318C1 13.4841 1.44772 13.9318 2 13.9318H5.53532L10.3314 18.2437C10.9751 18.8223 12 18.3655 12 17.5V2.5C12 1.63618 10.9785 1.17875 10.3341 1.75396ZM6.6659 7.70891L10 4.73298V15.2563L6.87443 12.4463C6.70368 12.1394 6.37609 11.9318 6 11.9318H3V7.93183H5.75114C6.05292 8.01082 6.39317 7.95234 6.6659 7.70891Z" fill="currentColor"/>
<path d="M15.4888 13.0688C15.1747 13.3388 14.7012 13.303 14.4312 12.9889C14.1612 12.6747 14.197 12.2012 14.5112 11.9312C14.545 11.9021 14.5784 11.8705 14.6111 11.8366C14.7486 11.6941 14.872 11.5127 14.9728 11.3008C15.1512 10.9258 15.25 10.4758 15.25 10C15.25 9.24552 15.0002 8.56671 14.6111 8.16341C14.5784 8.12949 14.545 8.09794 14.5112 8.06882C14.197 7.79884 14.1612 7.32532 14.4312 7.01118C14.7012 6.69703 15.1747 6.66123 15.4888 6.93121C15.5585 6.99105 15.6258 7.05473 15.6907 7.12202C16.3619 7.8178 16.75 8.87235 16.75 10C16.75 10.6958 16.6028 11.3662 16.3272 11.9454C16.1586 12.2997 15.9438 12.6156 15.6907 12.878C15.6258 12.9453 15.5585 13.009 15.4888 13.0688Z" fill="currentColor"/>
<path d="M16.4113 16.1272C16.065 16.3543 15.6 16.2577 15.3729 15.9114C15.1457 15.565 15.2423 15.1001 15.5887 14.8729C15.7519 14.7658 15.9098 14.6509 16.0616 14.5287C16.2134 14.4065 16.359 14.2771 16.4979 14.1411C16.6367 14.005 16.7687 13.8625 16.8933 13.7139C17.0178 13.5654 17.1348 13.4111 17.2438 13.2516C17.3527 13.0921 17.4536 12.9276 17.5461 12.7585C17.6384 12.5896 17.7222 12.4164 17.7971 12.2393C17.8719 12.0626 17.9378 11.8823 17.9945 11.6989C18.051 11.5161 18.0984 11.3304 18.1363 11.1423C18.1741 10.9551 18.2026 10.7656 18.2216 10.5744C18.2405 10.3844 18.25 10.1929 18.25 10C18.25 9.80718 18.2405 9.6156 18.2216 9.42568C18.2026 9.23441 18.1741 9.04493 18.1363 8.85772C18.0984 8.66962 18.051 8.48393 17.9945 8.30115C17.9378 8.11775 17.8719 7.93743 17.7971 7.76072C17.7222 7.58369 17.6384 7.41043 17.5461 7.24153C17.4536 7.07247 17.3527 6.90792 17.2438 6.74848C17.1348 6.58891 17.0178 6.43461 16.8933 6.28613C16.7687 6.13758 16.6367 5.99502 16.4979 5.859C16.359 5.72293 16.2134 5.59354 16.0616 5.47135C15.9098 5.34914 15.7519 5.23426 15.5887 5.12716C15.2423 4.89999 15.1457 4.43505 15.3729 4.08869C15.6 3.74233 16.065 3.64571 16.4113 3.87289C16.6153 4.00666 16.8125 4.15018 17.0022 4.30288C17.1919 4.45561 17.374 4.61737 17.5477 4.78755C17.7214 4.95777 17.8866 5.13625 18.0426 5.32231C18.1987 5.50844 18.3455 5.70199 18.4823 5.90223C18.6192 6.10255 18.746 6.30939 18.8622 6.52202C18.9785 6.73469 19.0841 6.95295 19.1785 7.17608C19.2728 7.39899 19.356 7.62654 19.4275 7.85804C19.4989 8.08883 19.5587 8.32333 19.6067 8.56084C19.6544 8.79714 19.6903 9.03622 19.7143 9.27743C19.738 9.51659 19.75 9.75765 19.75 10C19.75 10.2424 19.738 10.4835 19.7143 10.7226C19.6903 10.9638 19.6544 11.2029 19.6067 11.4392C19.5587 11.6767 19.4989 11.9112 19.4275 12.142C19.356 12.3735 19.2728 12.6011 19.1785 12.824C19.0841 13.0471 18.9785 13.2654 18.8622 13.478C18.746 13.6907 18.6192 13.8975 18.4823 14.0978C18.3455 14.2981 18.1987 14.4916 18.0426 14.6777C17.8866 14.8638 17.7214 15.0423 17.5477 15.2125C17.374 15.3827 17.1919 15.5444 17.0022 15.6972C16.8125 15.8499 16.6153 15.9934 16.4113 16.1272Z" fill="currentColor"/>
</svg>
`;

const SpeakerLow$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.3341 1.75396L5.6534 5.93183H2C1.44772 5.93183 1 6.37954 1 6.93183V12.9318C1 13.4841 1.44772 13.9318 2 13.9318H5.53532L10.3314 18.2437C10.9751 18.8223 12 18.3655 12 17.5V2.5C12 1.63618 10.9785 1.17875 10.3341 1.75396ZM6.6659 7.70891L10 4.73298V15.2563L6.87443 12.4463C6.70368 12.1394 6.37609 11.9318 6 11.9318H3V7.93183H5.75114C6.05292 8.01082 6.39317 7.95234 6.6659 7.70891Z" fill="currentColor"/>
<path d="M15.4889 13.0688C15.1747 13.3388 14.7012 13.303 14.4312 12.9889C14.1612 12.6747 14.197 12.2012 14.5112 11.9312C14.5451 11.9021 14.5784 11.8705 14.6111 11.8366C14.7486 11.6941 14.872 11.5127 14.9728 11.3008C15.1512 10.9258 15.25 10.4758 15.25 10C15.25 9.24552 15.0002 8.56671 14.6111 8.16341C14.5784 8.12949 14.5451 8.09794 14.5112 8.06882C14.197 7.79884 14.1612 7.32532 14.4312 7.01118C14.7012 6.69703 15.1747 6.66123 15.4889 6.93121C15.5585 6.99105 15.6258 7.05473 15.6907 7.12202C16.3619 7.8178 16.75 8.87235 16.75 10C16.75 10.6958 16.6028 11.3662 16.3272 11.9454C16.1586 12.2997 15.9439 12.6156 15.6907 12.878C15.6258 12.9453 15.5585 13.009 15.4889 13.0688Z" fill="currentColor"/>
</svg>
`;

const SpeakerOff$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.3341 1.75396L5.6534 5.93183H2C1.44772 5.93183 1 6.37954 1 6.93183V12.9318C1 13.4841 1.44772 13.9318 2 13.9318H5.53532L10.3314 18.2437C10.9751 18.8223 12 18.3655 12 17.5V2.5C12 1.63618 10.9785 1.17875 10.3341 1.75396ZM6.6659 7.70891L10 4.73298V15.2563L6.87443 12.4463C6.70368 12.1394 6.37609 11.9318 6 11.9318H3V7.93183H5.75114C6.05292 8.01082 6.39317 7.95234 6.6659 7.70891Z" fill="currentColor"/>
<path d="M15.4889 13.0688C15.1747 13.3388 14.7012 13.303 14.4312 12.9889C14.1612 12.6747 14.197 12.2012 14.5112 11.9312C14.5451 11.9021 14.5784 11.8705 14.6111 11.8366C14.7486 11.6941 14.872 11.5127 14.9728 11.3008C15.1512 10.9258 15.25 10.4758 15.25 10C15.25 9.24552 15.0002 8.56671 14.6111 8.16341C14.5784 8.12949 14.5451 8.09794 14.5112 8.06882C14.197 7.79884 14.1612 7.32532 14.4312 7.01118C14.7012 6.69703 15.1747 6.66123 15.4889 6.93121C15.5585 6.99105 15.6258 7.05473 15.6907 7.12202C16.3619 7.8178 16.75 8.87235 16.75 10C16.75 10.6958 16.6028 11.3662 16.3272 11.9454C16.1586 12.2997 15.9439 12.6156 15.6907 12.878C15.6258 12.9453 15.5585 13.009 15.4889 13.0688Z" fill="currentColor"/>
<path d="M16.4113 16.1272C16.065 16.3543 15.6 16.2577 15.3729 15.9114C15.1457 15.565 15.2423 15.1001 15.5887 14.8729C15.7519 14.7658 15.9098 14.6509 16.0616 14.5287C16.2134 14.4065 16.359 14.2771 16.4979 14.1411C16.6367 14.005 16.7687 13.8625 16.8933 13.7139C17.0178 13.5654 17.1348 13.4111 17.2438 13.2516C17.3527 13.0921 17.4536 12.9276 17.5461 12.7585C17.6384 12.5896 17.7222 12.4164 17.7971 12.2393C17.8719 12.0626 17.9378 11.8823 17.9945 11.6989C18.051 11.5161 18.0984 11.3304 18.1363 11.1423C18.1741 10.9551 18.2026 10.7656 18.2216 10.5744C18.2405 10.3844 18.25 10.1929 18.25 10C18.25 9.80718 18.2405 9.6156 18.2216 9.42568C18.2026 9.23441 18.1741 9.04493 18.1363 8.85772C18.0984 8.66962 18.051 8.48393 17.9945 8.30115C17.9378 8.11775 17.8719 7.93743 17.7971 7.76072C17.7222 7.58369 17.6384 7.41043 17.5461 7.24153C17.4536 7.07247 17.3527 6.90792 17.2438 6.74848C17.1348 6.58891 17.0178 6.43461 16.8933 6.28613C16.7687 6.13758 16.6367 5.99502 16.4979 5.859C16.359 5.72293 16.2134 5.59354 16.0616 5.47135C15.9098 5.34914 15.7519 5.23426 15.5887 5.12716C15.2423 4.89999 15.1457 4.43505 15.3729 4.08869C15.6 3.74233 16.065 3.64571 16.4113 3.87289C16.6153 4.00666 16.8125 4.15018 17.0022 4.30288C17.1919 4.45561 17.374 4.61737 17.5477 4.78755C17.7214 4.95777 17.8866 5.13625 18.0426 5.32231C18.1987 5.50844 18.3455 5.70199 18.4823 5.90223C18.6192 6.10255 18.746 6.30939 18.8622 6.52202C18.9785 6.73469 19.0841 6.95295 19.1785 7.17608C19.2728 7.39899 19.356 7.62654 19.4275 7.85804C19.4989 8.08883 19.5587 8.32333 19.6067 8.56084C19.6544 8.79714 19.6903 9.03622 19.7143 9.27743C19.738 9.51659 19.75 9.75765 19.75 10C19.75 10.2424 19.738 10.4835 19.7143 10.7226C19.6903 10.9638 19.6544 11.2029 19.6067 11.4392C19.5587 11.6767 19.4989 11.9112 19.4275 12.142C19.356 12.3735 19.2728 12.6011 19.1785 12.824C19.0841 13.0471 18.9785 13.2654 18.8622 13.478C18.746 13.6907 18.6192 13.8975 18.4823 14.0978C18.3455 14.2981 18.1987 14.4916 18.0426 14.6777C17.8866 14.8638 17.7214 15.0423 17.5477 15.2125C17.374 15.3827 17.1919 15.5444 17.0022 15.6972C16.8125 15.8499 16.6153 15.9934 16.4113 16.1272Z" fill="currentColor"/>
<path d="M1.36429 3.77196C0.937965 3.42087 0.876976 2.79065 1.22807 2.36432C1.57916 1.938 2.20938 1.87701 2.6357 2.2281L19.6357 16.2281C20.062 16.5792 20.123 17.2094 19.7719 17.6357C19.4208 18.0621 18.7906 18.1231 18.3643 17.772L1.36429 3.77196Z" fill="currentColor"/>
</svg>
`;

const Square$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M14 5H6C5.44772 5 5 5.44772 5 6V14C5 14.5523 5.44772 15 6 15H14C14.5523 15 15 14.5523 15 14V6C15 5.44772 14.5523 5 14 5ZM7 13V7H13V13H7Z" fill="currentColor"/>
</svg>
`;

const SquareFilled = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6 4.5H14C14.8284 4.5 15.5 5.17157 15.5 6V14C15.5 14.8284 14.8284 15.5 14 15.5H6C5.17157 15.5 4.5 14.8284 4.5 14V6C4.5 5.17157 5.17157 4.5 6 4.5Z" fill="currentColor"/>
</svg>
`;

const Star$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.70492 17.8855L10 15.9706L14.2951 17.8855C14.9986 18.1991 15.7777 17.6331 15.6967 16.8671L15.2028 12.1905L18.3513 8.69737C18.8669 8.12523 18.5694 7.20937 17.8159 7.04961L13.2155 6.07423L10.8663 2.00044C10.4815 1.33319 9.5185 1.33319 9.13372 2.00044L6.78449 6.07423L2.18413 7.04961C1.43063 7.20937 1.13305 8.12523 1.64874 8.69737L4.79719 12.1905L4.30325 16.8671C4.22234 17.6331 5.00142 18.1991 5.70492 17.8855ZM9.5928 13.9623L6.47433 15.3527L6.83295 11.9572C6.86276 11.675 6.77127 11.3934 6.58129 11.1826L4.29534 8.64644L7.63546 7.93826C7.91305 7.8794 8.15257 7.70538 8.29432 7.45957L10 4.50177L11.7057 7.45957C11.8474 7.70538 12.0869 7.8794 12.3645 7.93826L15.7047 8.64644L13.4187 11.1826C13.2287 11.3934 13.1372 11.675 13.167 11.9572L13.5257 15.3527L10.4072 13.9623C10.148 13.8468 9.85197 13.8468 9.5928 13.9623Z" fill="currentColor"/>
</svg>
`;

const StarFilled = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10 15.9706L5.70492 17.8855C5.00142 18.1991 4.22234 17.6331 4.30325 16.8671L4.79719 12.1905L1.64874 8.69737C1.13305 8.12523 1.43063 7.20937 2.18413 7.04961L6.78449 6.07423L9.13372 2.00044C9.5185 1.33319 10.4815 1.33319 10.8663 2.00044L13.2155 6.07423L17.8159 7.04961C18.5694 7.20937 18.8669 8.12523 18.3513 8.69737L15.2028 12.1905L15.6967 16.8671C15.7777 17.6331 14.9986 18.1991 14.2951 17.8855L10 15.9706Z" fill="currentColor"/>
</svg>
`;

const Sun$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 14C12.2091 14 14 12.2091 14 10C14 7.79086 12.2091 6 10 6C7.79086 6 6 7.79086 6 10C6 12.2091 7.79086 14 10 14ZM10 8C11.1046 8 12 8.89543 12 10C12 11.1046 11.1046 12 10 12C8.89543 12 8 11.1046 8 10C8 8.89543 8.89543 8 10 8Z" fill="currentColor"/>
<path d="M0.5 10C0.5 9.44772 0.947715 9 1.5 9H3.5C4.05228 9 4.5 9.44772 4.5 10C4.5 10.5523 4.05228 11 3.5 11H1.5C0.947715 11 0.5 10.5523 0.5 10Z" fill="currentColor"/>
<path d="M15.5 10C15.5 9.44772 15.9477 9 16.5 9H18.5C19.0523 9 19.5 9.44772 19.5 10C19.5 10.5523 19.0523 11 18.5 11H16.5C15.9477 11 15.5 10.5523 15.5 10Z" fill="currentColor"/>
<path d="M14 14C14.3905 13.6095 15.0237 13.6095 15.4142 14L16.8284 15.4142C17.219 15.8047 17.219 16.4379 16.8284 16.8284C16.4379 17.2189 15.8048 17.2189 15.4142 16.8284L14 15.4142C13.6095 15.0237 13.6095 14.3905 14 14Z" fill="currentColor"/>
<path d="M2.99999 2.99999C3.39051 2.60946 4.02367 2.60946 4.4142 2.99999L5.82841 4.4142C6.21894 4.80472 6.21894 5.43789 5.82841 5.82841C5.43789 6.21894 4.80472 6.21894 4.4142 5.82841L2.99999 4.4142C2.60946 4.02367 2.60946 3.39051 2.99999 2.99999Z" fill="currentColor"/>
<path d="M10 15.5C10.5523 15.5 11 15.9477 11 16.5V18.5C11 19.0523 10.5523 19.5 10 19.5C9.44772 19.5 9 19.0523 9 18.5V16.5C9 15.9477 9.44772 15.5 10 15.5Z" fill="currentColor"/>
<path d="M10 0.5C10.5523 0.5 11 0.947715 11 1.5V3.5C11 4.05228 10.5523 4.5 10 4.5C9.44772 4.5 9 4.05228 9 3.5V1.5C9 0.947715 9.44772 0.5 10 0.5Z" fill="currentColor"/>
<path d="M16.8284 2.99999C17.2189 3.39051 17.2189 4.02367 16.8284 4.4142L15.4142 5.82841C15.0237 6.21894 14.3905 6.21894 14 5.82841C13.6095 5.43789 13.6095 4.80472 14 4.4142L15.4142 2.99999C15.8047 2.60946 16.4379 2.60946 16.8284 2.99999Z" fill="currentColor"/>
<path d="M5.82841 15.4142L4.4142 16.8284C4.02368 17.219 3.39051 17.219 2.99999 16.8284C2.60946 16.4379 2.60946 15.8048 2.99999 15.4142L4.4142 14C4.80472 13.6095 5.43789 13.6095 5.82841 14C6.21894 14.3905 6.21894 15.0237 5.82841 15.4142Z" fill="currentColor"/>
</svg>
`;

const SunFilled = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13.5 10C13.5 11.933 11.933 13.5 10 13.5C8.067 13.5 6.5 11.933 6.5 10C6.5 8.067 8.067 6.5 10 6.5C11.933 6.5 13.5 8.067 13.5 10Z" fill="currentColor"/>
<path d="M0.5 10C0.5 9.44772 0.947715 9 1.5 9H3.5C4.05228 9 4.5 9.44772 4.5 10C4.5 10.5523 4.05228 11 3.5 11H1.5C0.947715 11 0.5 10.5523 0.5 10Z" fill="currentColor"/>
<path d="M15.5 10C15.5 9.44772 15.9477 9 16.5 9H18.5C19.0523 9 19.5 9.44772 19.5 10C19.5 10.5523 19.0523 11 18.5 11H16.5C15.9477 11 15.5 10.5523 15.5 10Z" fill="currentColor"/>
<path d="M15.4142 14L16.8284 15.4142C17.2189 15.8047 17.2189 16.4379 16.8284 16.8284C16.4379 17.2189 15.8047 17.2189 15.4142 16.8284L14 15.4142C13.6095 15.0237 13.6095 14.3905 14 14C14.3905 13.6095 15.0237 13.6095 15.4142 14Z" fill="currentColor"/>
<path d="M2.99999 2.99999C3.39051 2.60946 4.02367 2.60946 4.4142 2.99999L5.82841 4.4142C6.21894 4.80472 6.21894 5.43789 5.82841 5.82841C5.43789 6.21894 4.80472 6.21894 4.4142 5.82841L2.99999 4.4142C2.60946 4.02367 2.60946 3.39051 2.99999 2.99999Z" fill="currentColor"/>
<path d="M10 15.5C10.5523 15.5 11 15.9477 11 16.5V18.5C11 19.0523 10.5523 19.5 10 19.5C9.44772 19.5 9 19.0523 9 18.5V16.5C9 15.9477 9.44772 15.5 10 15.5Z" fill="currentColor"/>
<path d="M10 0.5C10.5523 0.5 11 0.947715 11 1.5V3.5C11 4.05228 10.5523 4.5 10 4.5C9.44772 4.5 9 4.05228 9 3.5V1.5C9 0.947715 9.44772 0.5 10 0.5Z" fill="currentColor"/>
<path d="M16.8284 2.99999C17.2189 3.39051 17.2189 4.02367 16.8284 4.4142L15.4142 5.82841C15.0237 6.21894 14.3905 6.21894 14 5.82841C13.6095 5.43789 13.6095 4.80472 14 4.4142L15.4142 2.99999C15.8047 2.60946 16.4379 2.60946 16.8284 2.99999Z" fill="currentColor"/>
<path d="M5.82841 14C6.21894 14.3905 6.21894 15.0237 5.82841 15.4142L4.4142 16.8284C4.02367 17.2189 3.39051 17.2189 2.99999 16.8284C2.60946 16.4379 2.60946 15.8047 2.99999 15.4142L4.4142 14C4.80472 13.6095 5.43789 13.6095 5.82841 14Z" fill="currentColor"/>
</svg>
`;

const Syringe$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.35354 10.7175C3.37723 11.6938 3.37723 13.2767 4.35354 14.253L5.76776 15.6673C6.74407 16.6436 8.32698 16.6436 9.30329 15.6673L16.2744 8.69611C16.7572 8.21339 17.0215 7.55425 17.006 6.87175L16.9742 5.46465C16.9436 4.11666 15.8497 3.03572 14.5014 3.02138L13.1266 3.00676C12.4543 2.99961 11.8076 3.2635 11.3322 3.73885L4.35354 10.7175ZM14.8602 7.2819L7.88908 14.253C7.69381 14.4483 7.37723 14.4483 7.18197 14.253L5.76776 12.8388C5.57249 12.6436 5.57249 12.327 5.76776 12.1317L12.7464 5.15307C12.8415 5.058 12.9708 5.00522 13.1053 5.00665L14.4801 5.02127C14.7498 5.02414 14.9686 5.24033 14.9747 5.50992L15.0065 6.91703C15.0096 7.05353 14.9568 7.18536 14.8602 7.2819Z" fill="currentColor"/>
<path d="M11.0208 11.6066C11.2161 11.8019 11.2161 12.1185 11.0208 12.3137C10.8256 12.509 10.509 12.509 10.3137 12.3137L8.8995 10.8995C8.70424 10.7042 8.70424 10.3877 8.8995 10.1924C9.09476 9.99713 9.41134 9.99713 9.60661 10.1924L11.0208 11.6066Z" fill="currentColor"/>
<path d="M5.71751 16.9099C6.10804 17.3004 6.10804 17.9336 5.71751 18.3241C5.32699 18.7146 4.69382 18.7146 4.3033 18.3241L1.47487 15.4957C1.08435 15.1052 1.08435 14.472 1.47487 14.0815C1.8654 13.6909 2.49856 13.6909 2.88909 14.0815L5.71751 16.9099Z" fill="currentColor"/>
<path d="M9.38505 16.6709C9.77558 17.0614 9.77558 17.6945 9.38505 18.0851C8.99453 18.4756 8.36137 18.4756 7.97084 18.0851L2.00709 12.1213C1.61656 11.7308 1.61656 11.0976 2.00709 10.7071C2.39761 10.3166 3.03078 10.3166 3.4213 10.7071L9.38505 16.6709Z" fill="currentColor"/>
<path d="M13.1421 9.48528C13.3374 9.68055 13.3374 9.99713 13.1421 10.1924C12.9469 10.3877 12.6303 10.3877 12.435 10.1924L11.0208 8.77818C10.8255 8.58292 10.8255 8.26633 11.0208 8.07107C11.2161 7.87581 11.5327 7.87581 11.7279 8.07107L13.1421 9.48528Z" fill="currentColor"/>
<path d="M5 16.4142L3.58578 15L5 13.5858L6.41421 15L5 16.4142Z" fill="currentColor"/>
<path d="M17.9703 0.970326C18.2632 0.677433 18.7381 0.677433 19.031 0.970326C19.3239 1.26322 19.3239 1.73809 19.031 2.03099L16.031 5.03099C15.7381 5.32388 15.2632 5.32388 14.9703 5.03099C14.6774 4.73809 14.6774 4.26322 14.9703 3.97033L17.9703 0.970326Z" fill="currentColor"/>
</svg>
`;

const TShirt$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.4481 10.3965L2.99999 10.1199V17C2.99999 18.6569 4.34314 20 5.99999 20H14C15.6568 20 17 18.6569 17 17V10.118L17.5528 10.3944C18.1347 10.6854 18.835 10.352 18.9762 9.71693L19.9762 5.21693C20.0503 4.88317 19.9489 4.53465 19.7071 4.29289L17.2929 1.87868C16.7303 1.31607 15.9672 1 15.1716 1H13C12.5133 1 12.0973 1.35042 12.0145 1.83004C11.7469 3.3817 11.1284 4 9.99902 4C8.86986 4 8.25211 3.38205 7.98555 1.83066C7.90309 1.35075 7.48694 1 6.99999 1H4.82884C4.03282 1 3.26943 1.31637 2.70676 1.87945L0.294793 4.29315C0.0533553 4.53476 -0.0480615 4.88289 0.0258427 5.21637L1.02368 9.71889C1.16458 10.3547 1.86593 10.6883 2.4481 10.3965ZM4.12148 3.29315C4.30904 3.10546 4.5635 3 4.82884 3H6.20588C6.77637 4.92818 8.07723 6 9.99902 6C11.9208 6 13.2221 4.92825 13.7936 3H15.1716C15.4368 3 15.6911 3.10536 15.8787 3.29289L17.9047 5.31894L17.3016 8.03279L16.4472 7.60557C15.7823 7.27312 15 7.75662 15 8.5V17C15 17.5523 14.5523 18 14 18H5.99999C5.44771 18 4.99999 17.5523 4.99999 17V8.5C4.99999 7.75618 4.21684 7.27271 3.55188 7.60602L2.69873 8.03367L2.09711 5.31898L4.12148 3.29315Z" fill="currentColor"/>
<path d="M11.5 10.5C10.9477 10.5 10.5 10.0523 10.5 9.5C10.5 8.94772 10.9477 8.5 11.5 8.5H13.5C14.0523 8.5 14.5 8.94772 14.5 9.5C14.5 10.0523 14.0523 10.5 13.5 10.5H11.5Z" fill="currentColor"/>
</svg>
`;

const Taxi$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.17116 3C5.024 3 4.02404 3.78074 3.74581 4.89366L2.68528 9.13576C1.70458 9.47364 1 10.4045 1 11.5V14.5C1 15.8807 2.11929 17 3.5 17H16.5C17.8807 17 19 15.8807 19 14.5V11.5C19 10.4045 18.2954 9.47364 17.3147 9.13576L16.2542 4.89366C15.976 3.78074 14.976 3 13.8288 3H6.17116ZM3.5 11C3.95887 11 4.35885 10.6877 4.47014 10.2425L5.68609 5.37873C5.74174 5.15615 5.94173 5 6.17116 5H10.0007H13.8288C14.0583 5 14.2583 5.15615 14.3139 5.37873L15.5299 10.2425C15.6411 10.6877 16.0411 11 16.5 11C16.7761 11 17 11.2239 17 11.5V14.5C17 14.7761 16.7761 15 16.5 15H3.5C3.22386 15 3 14.7761 3 14.5V11.5C3 11.2239 3.22386 11 3.5 11Z" fill="currentColor"/>
<path d="M16.5 13C16.5 13.8284 15.8284 14.5 15 14.5C14.1716 14.5 13.5 13.8284 13.5 13C13.5 12.1716 14.1716 11.5 15 11.5C15.8284 11.5 16.5 12.1716 16.5 13Z" fill="currentColor"/>
<path d="M6.5 13C6.5 13.8284 5.82843 14.5 5 14.5C4.17157 14.5 3.5 13.8284 3.5 13C3.5 12.1716 4.17157 11.5 5 11.5C5.82843 11.5 6.5 12.1716 6.5 13Z" fill="currentColor"/>
<path d="M4 15.5C4.82843 15.5 5.5 16.1716 5.5 17V18C5.5 18.8284 4.82843 19.5 4 19.5C3.17157 19.5 2.5 18.8284 2.5 18V17C2.5 16.1716 3.17157 15.5 4 15.5Z" fill="currentColor"/>
<path d="M16 15.5C16.8284 15.5 17.5 16.1716 17.5 17V18C17.5 18.8284 16.8284 19.5 16 19.5C15.1716 19.5 14.5 18.8284 14.5 18V17C14.5 16.1716 15.1716 15.5 16 15.5Z" fill="currentColor"/>
<path d="M10 1C11.1046 1 12 1.89543 12 3C12 4.10457 11.1046 5 10 5C8.89543 5 8 4.10457 8 3C8 1.89543 8.89543 1 10 1Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.1503 7.08052C13.9525 6.15858 13.1377 5.5 12.1948 5.5H7.80491C6.862 5.5 6.04716 6.15858 5.8494 7.08052L5.42037 9.08052C5.3908 9.21839 5.37589 9.359 5.37589 9.5C5.37589 10.6046 6.27132 11.5 7.37589 11.5H12.6238C12.7648 11.5 12.9054 11.4851 13.0433 11.4555C14.1233 11.2238 14.811 10.1605 14.5793 9.08052L14.1503 7.08052ZM12.6238 9.5H7.37589L7.80491 7.5H12.1948L12.6238 9.5Z" fill="currentColor"/>
</svg>
`;

const Television$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 8L2 15C2 16.6569 3.34315 18 5 18H15C16.6569 18 18 16.6569 18 15V8C18 6.34315 16.6569 5 15 5H5C3.34315 5 2 6.34315 2 8ZM5 16C4.44772 16 4 15.5523 4 15V8C4 7.44771 4.44772 7 5 7H15C15.5523 7 16 7.44771 16 8V15C16 15.5523 15.5523 16 15 16H5Z" fill="currentColor"/>
<path d="M11.2809 5.62469C10.9359 6.05596 10.3066 6.12588 9.87531 5.78087C9.44405 5.43586 9.37413 4.80657 9.71914 4.3753L11.7191 1.8753C12.0641 1.44404 12.6934 1.37412 13.1247 1.71913C13.556 2.06414 13.6259 2.69343 13.2809 3.12469L11.2809 5.62469Z" fill="currentColor"/>
<path d="M8.71912 5.62469C9.06413 6.05596 9.69343 6.12588 10.1247 5.78087C10.556 5.43586 10.6259 4.80657 10.2809 4.3753L8.28086 1.8753C7.93585 1.44404 7.30656 1.37412 6.8753 1.71913C6.44404 2.06414 6.37412 2.69343 6.71912 3.12469L8.71912 5.62469Z" fill="currentColor"/>
</svg>
`;

const TextBubble$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="7" cy="9" r="1" fill="currentColor"/>
<circle cx="10" cy="9" r="1" fill="currentColor"/>
<circle cx="13" cy="9" r="1" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M1 6V12.1024C1 13.7138 2.27046 15.0285 3.86436 15.0994C4.22426 16.3232 4.75773 17 5.70388 17C6.46059 17 7.38816 16.3911 8.83458 15.1024H16C17.6569 15.1024 19 13.7593 19 12.1024V6C19 4.34315 17.6569 3 16 3H4C2.34315 3 1 4.34315 1 6ZM8.06421 13.1024L7.77816 13.3625C6.91423 14.1477 6.23474 14.6664 5.90912 14.8838C5.81363 14.6587 5.71621 14.3271 5.62633 13.8976L5.45993 13.1024H4C3.44772 13.1024 3 12.6547 3 12.1024V6C3 5.44772 3.44772 5 4 5H16C16.5523 5 17 5.44772 17 6V12.1024C17 12.6547 16.5523 13.1024 16 13.1024H8.06421Z" fill="currentColor"/>
</svg>
`;

const Times$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M7.17158 14.2426C6.78106 14.6332 6.14789 14.6332 5.75737 14.2426C5.36684 13.8521 5.36684 13.2189 5.75737 12.8284L12.8284 5.75735C13.219 5.36682 13.8521 5.36682 14.2427 5.75735C14.6332 6.14787 14.6332 6.78104 14.2427 7.17156L7.17158 14.2426Z" fill="currentColor"/>
<path d="M5.75737 7.17152C5.36684 6.781 5.36684 6.14783 5.75737 5.75731C6.14789 5.36679 6.78106 5.36679 7.17158 5.75731L14.2427 12.8284C14.6332 13.2189 14.6332 13.8521 14.2427 14.2426C13.8521 14.6331 13.219 14.6331 12.8284 14.2426L5.75737 7.17152Z" fill="currentColor"/>
</svg>
`;

const Tool$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M17.5617 13.5712L12.2594 7.2522C12.1884 7.16762 12.1136 7.08658 12.0352 7.00933C12.2547 5.6013 11.8405 4.10669 10.8614 2.93989C9.55326 1.38087 7.50228 0.72522 5.67031 1.2589C4.97701 1.46088 4.71979 2.30861 5.18396 2.86178L6.92543 4.93718L6.34416 5.42492L4.60269 3.34953C4.13852 2.79635 3.259 2.90246 2.93971 3.55015C2.09601 5.26161 2.38555 7.39529 3.69372 8.95431C4.65968 10.1055 6.03568 10.7711 7.44204 10.8155C7.51041 10.9169 7.58419 11.0149 7.66312 11.1089L12.9654 17.4279C14.0304 18.6972 15.9227 18.8627 17.1919 17.7977C18.4611 16.7327 18.6267 14.8404 17.5617 13.5712ZM5.22581 7.66873C4.90858 7.29067 4.68922 6.86235 4.56962 6.42156L4.81207 6.7105C5.52207 7.55665 6.78358 7.66702 7.62973 6.95701L8.211 6.46927C9.05715 5.75927 9.16752 4.49776 8.45752 3.65161L8.21507 3.36267C8.62839 3.557 9.01211 3.84739 9.32935 4.22546C10.034 5.06518 10.261 6.15832 9.96754 7.09453C9.83235 7.52578 10.0032 7.9941 10.3843 8.23698C10.5132 8.31907 10.6288 8.42044 10.7273 8.53778L16.0296 14.8568C16.3846 15.2799 16.3294 15.9106 15.9063 16.2656C15.4832 16.6206 14.8525 16.5654 14.4975 16.1424L9.19521 9.82335C9.09345 9.70209 9.01169 9.56568 8.95274 9.41921C8.7843 9.00068 8.35647 8.74677 7.90839 8.79941C6.94383 8.91271 5.92226 8.49873 5.22581 7.66873Z" fill="currentColor"/>
</svg>
`;

const Train$1 = `<svg width="20" height="21" viewBox="0 0 20 21" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M17.5 5C17.5 2.79086 15.7092 1 13.5 1L6.5 1C4.29086 1 2.5 2.79086 2.5 5V11.9894C2.5 13.7416 3.64042 15.2898 5.31383 15.8095C6.87197 16.2933 8.43504 16.5359 10 16.5359C11.565 16.5359 13.128 16.2933 14.6862 15.8095C16.3596 15.2898 17.5 13.7416 17.5 11.9894L17.5 5ZM4.5 11.9894V5C4.5 3.89543 5.39543 3 6.5 3L13.5 3C14.6046 3 15.5 3.89543 15.5 5L15.5 11.9894C15.5 12.8655 14.9298 13.6396 14.0931 13.8994C12.7248 14.3243 11.3615 14.5359 10 14.5359C8.63854 14.5359 7.2752 14.3243 5.90691 13.8994C5.07021 13.6396 4.5 12.8655 4.5 11.9894Z" fill="currentColor"/>
<path d="M8 12C8 12.8284 7.32843 13.5 6.5 13.5C5.67157 13.5 5 12.8284 5 12C5 11.1716 5.67157 10.5 6.5 10.5C7.32843 10.5 8 11.1716 8 12Z" fill="currentColor"/>
<path d="M15 12C15 12.8284 14.3284 13.5 13.5 13.5C12.6716 13.5 12 12.8284 12 12C12 11.1716 12.6716 10.5 13.5 10.5C14.3284 10.5 15 11.1716 15 12Z" fill="currentColor"/>
<path d="M4.58137 15.147C4.79717 14.6386 5.38423 14.4014 5.89261 14.6172C6.40099 14.833 6.63818 15.4201 6.42238 15.9285L4.94741 19.4033C4.73161 19.9117 4.14455 20.1489 3.63617 19.9331C3.12779 19.7173 2.8906 19.1302 3.1064 18.6218L4.58137 15.147Z" fill="currentColor"/>
<path d="M15.4678 14.6528C15.276 14.1349 14.7007 13.8705 14.1828 14.0623C13.6648 14.254 13.4004 14.8294 13.5922 15.3473L15.0622 19.3173C15.254 19.8352 15.8293 20.0996 16.3472 19.9078C16.8652 19.716 17.1295 19.1407 16.9378 18.6228L15.4678 14.6528Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15 6C15 4.61929 13.8807 3.5 12.5 3.5L7.5 3.5C6.11929 3.5 5 4.61929 5 6V7.53465C5 8.75174 5.87647 9.79198 7.07592 9.99842C8.04987 10.1661 9.02477 10.25 10 10.25C10.9752 10.25 11.9502 10.1661 12.9242 9.99841C14.1236 9.79192 15 8.7517 15 7.53464L15 6ZM7 7.53465V6C7 5.72386 7.22386 5.5 7.5 5.5L12.5 5.5C12.7762 5.5 13 5.72386 13 6L13 7.53464C13 7.77805 12.8247 7.9861 12.5848 8.0274C11.7225 8.17586 10.8611 8.25 10 8.25C9.13892 8.25 8.27752 8.17586 7.4152 8.02741C7.17529 7.98611 7 7.77807 7 7.53465Z" fill="currentColor"/>
<path d="M4.75 18.25V16.75H15.2514V18.25H4.75Z" fill="currentColor"/>
</svg>
`;

const Trash$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M11.9371 4.5H11.9363H8.06326C8.02121 4.33649 8.00037 4.16864 8.00037 4.00049C8.00037 2.89728 8.89746 1.99976 10.0002 1.99976C11.1028 1.99976 11.9999 2.89728 11.9999 4.00049C11.9999 4.16937 11.9789 4.33716 11.9373 4.49927L11.9371 4.5Z" fill="currentColor"/>
<path d="M4.5 5.5C3.94772 5.5 3.5 5.05228 3.5 4.5C3.5 3.94772 3.94772 3.5 4.5 3.5H15.5C16.0523 3.5 16.5 3.94772 16.5 4.5C16.5 5.05228 16.0523 5.5 15.5 5.5H4.5Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.5 18.5C15.0523 18.5 15.5 18.0523 15.5 17.5V7C15.5 6.44772 15.0523 6 14.5 6H5.5C4.94772 6 4.5 6.44772 4.5 7V17.5C4.5 18.0523 4.94772 18.5 5.5 18.5H14.5ZM12.5 8.5C12.5 8.22386 12.7239 8 13 8C13.2761 8 13.5 8.22386 13.5 8.5V15.5C13.5 15.7761 13.2761 16 13 16C12.7239 16 12.5 15.7761 12.5 15.5V8.5ZM10 8C9.72386 8 9.5 8.22386 9.5 8.5V15.5C9.5 15.7761 9.72386 16 10 16C10.2761 16 10.5 15.7761 10.5 15.5V8.5C10.5 8.22386 10.2761 8 10 8ZM6.5 8.5C6.5 8.22386 6.72386 8 7 8C7.27614 8 7.5 8.22386 7.5 8.5V15.5C7.5 15.7761 7.27614 16 7 16C6.72386 16 6.5 15.7761 6.5 15.5V8.5Z" fill="currentColor"/>
</svg>
`;

const TriangleDown$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.15202 7.53L9.15202 15.53C9.54369 16.1567 10.4563 16.1567 10.848 15.53L15.848 7.53C16.2643 6.86395 15.7855 6 15 6L5.00002 6C4.21458 6 3.73574 6.86395 4.15202 7.53ZM13.1958 8L10 13.1132L6.80427 8H13.1958Z" fill="currentColor"/>
</svg>
`;

const TriangleDownFilled = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8.72798 15.795L3.72798 7.795C3.10356 6.79593 3.82183 5.5 4.99998 5.5L15 5.5C16.1781 5.5 16.8964 6.79593 16.272 7.795L11.272 15.795C10.6845 16.735 9.31549 16.735 8.72798 15.795Z" fill="currentColor"/>
</svg>
`;

const TriangleLeft$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.47 4.15199L4.47 9.15199C3.84333 9.54366 3.84333 10.4563 4.47 10.848L12.47 15.848C13.136 16.2643 14 15.7854 14 15V4.99999C14 4.21455 13.136 3.73571 12.47 4.15199ZM12 6.80424V13.1957L6.8868 9.99999L12 6.80424Z" fill="currentColor"/>
</svg>
`;

const TriangleLeftFilled = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4.205 8.72805L12.205 3.72805C13.2041 3.10363 14.5 3.82189 14.5 5.00004V15C14.5 16.1782 13.2041 16.8965 12.205 16.272L4.205 11.272C3.265 10.6845 3.265 9.31555 4.205 8.72805Z" fill="currentColor"/>
</svg>
`;

const TriangleRight$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.53 15.848L15.53 10.848C16.1567 10.4563 16.1567 9.54368 15.53 9.15201L7.53 4.15201C6.86395 3.73573 6 4.21458 6 5.00001L6 15C6 15.7854 6.86395 16.2643 7.53 15.848ZM8 13.1958L8 6.80426L13.1132 10L8 13.1958Z" fill="currentColor"/>
</svg>
`;

const TriangleRightFilled = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M15.795 11.272L7.795 16.272C6.79593 16.8964 5.5 16.1782 5.5 15L5.5 5.00002C5.5 3.82186 6.79593 3.1036 7.795 3.72802L15.795 8.72802C16.735 9.31552 16.735 10.6845 15.795 11.272Z" fill="currentColor"/>
</svg>
`;

const TriangleUp$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M15.848 13.47L10.848 5.47C10.4563 4.84333 9.54368 4.84333 9.15201 5.47L4.15201 13.47C3.73573 14.136 4.21458 15 5.00001 15H15C15.7854 15 16.2643 14.136 15.848 13.47ZM6.80426 13L10 7.8868L13.1958 13H6.80426Z" fill="currentColor"/>
</svg>
`;

const TriangleUpFilled = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M11.272 5.205L16.272 13.205C16.8964 14.2041 16.1782 15.5 15 15.5H5.00002C3.82186 15.5 3.1036 14.2041 3.72802 13.205L8.72802 5.205C9.31552 4.265 10.6845 4.265 11.272 5.205Z" fill="currentColor"/>
</svg>
`;

const Truck$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M7.5 18.75C6.25736 18.75 5.25 17.7426 5.25 16.5C5.25 15.2574 6.25736 14.25 7.5 14.25C8.74264 14.25 9.75 15.2574 9.75 16.5C9.75 17.7426 8.74264 18.75 7.5 18.75Z" fill="currentColor"/>
<path d="M16.5 18.75C15.2574 18.75 14.25 17.7426 14.25 16.5C14.25 15.2574 15.2574 14.25 16.5 14.25C17.7426 14.25 18.75 15.2574 18.75 16.5C18.75 17.7426 17.7426 18.75 16.5 18.75Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M18 4.5H8C6.89543 4.5 6 5.39543 6 6.5V14C6 15.1046 6.89543 16 8 16H18C19.1046 16 20 15.1046 20 14V6.5C20 5.39543 19.1046 4.5 18 4.5ZM8 14V6.5H18V14H8Z" fill="currentColor"/>
<path d="M10.25 8.75C9.97386 8.75 9.75 8.52614 9.75 8.25C9.75 7.97386 9.97386 7.75 10.25 7.75H15.75C16.0261 7.75 16.25 7.97386 16.25 8.25C16.25 8.52614 16.0261 8.75 15.75 8.75H10.25Z" fill="currentColor"/>
<path d="M10.25 10.75C9.97386 10.75 9.75 10.5261 9.75 10.25C9.75 9.97386 9.97386 9.75 10.25 9.75H15.75C16.0261 9.75 16.25 9.97386 16.25 10.25C16.25 10.5261 16.0261 10.75 15.75 10.75H10.25Z" fill="currentColor"/>
<path d="M10.25 12.75C9.97386 12.75 9.75 12.5261 9.75 12.25C9.75 11.9739 9.97386 11.75 10.25 11.75H15.75C16.0261 11.75 16.25 11.9739 16.25 12.25C16.25 12.5261 16.0261 12.75 15.75 12.75H10.25Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M6 7.5H2.73605C1.8463 7.5 1.06354 8.08778 0.815401 8.94223L0 11.75V14C0 15.1046 0.89543 16 2 16H6C7.10457 16 8 15.1046 8 14V9.5C8 8.39543 7.10457 7.5 6 7.5ZM2 14V12.0345L2.73605 9.5H6V14H2Z" fill="currentColor"/>
<path d="M3.29046 10.1H5C5.27614 10.1 5.5 10.3238 5.5 10.6V12.6C5.5 12.8761 5.27614 13.1 5 13.1H3C2.72386 13.1 2.5 12.8761 2.5 12.6V11.75L2.51522 11.6276L2.80568 10.4775C2.86175 10.2555 3.06147 10.1 3.29046 10.1Z" fill="currentColor"/>
</svg>
`;

const Umbrella$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M11.3863 17.3581C11.515 17.3581 11.6111 17.1982 11.6111 16.3198C11.6111 15.7676 12.0588 15.3198 12.6111 15.3198C13.1634 15.3198 13.6111 15.7676 13.6111 16.3198C13.6111 18.1592 12.8907 19.3581 11.3863 19.3581C10.0411 19.3581 9.17227 18.507 9.00701 17.1182L9 17V10.5C9 9.94772 9.44772 9.5 10 9.5C10.5523 9.5 11 9.94772 11 10.5V16.9379C11.0488 17.3087 11.1119 17.3581 11.3863 17.3581Z" fill="currentColor"/>
<path d="M9 1.5C9 0.947715 9.44772 0.5 10 0.5C10.5523 0.5 11 0.947715 11 1.5V3C11 3.55228 10.5523 4 10 4C9.44772 4 9 3.55228 9 3L9 1.5Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.66803 11.2348C5.70837 11.1785 5.74282 11.1304 5.75566 11.1127C5.91724 10.8896 6.04642 10.7345 6.12513 10.6432C6.1774 10.6826 6.24691 10.737 6.34702 10.8162C7.06596 11.3853 7.47315 11.6014 8.16417 11.4864C8.56768 11.4193 8.88935 11.2531 9.3036 10.964C9.36217 10.9231 9.41133 10.888 9.50965 10.817C9.851 10.571 9.98417 10.5004 10.0162 10.4999C10.017 10.4999 10.1455 10.5685 10.4822 10.8134L10.5664 10.8745C11.0756 11.2426 11.3943 11.4194 11.8497 11.4886C12.543 11.5941 12.9334 11.3718 13.6611 10.7686C13.755 10.6908 13.8227 10.6353 13.875 10.5938C13.8792 10.5992 13.8837 10.6048 13.8882 10.6105C13.9659 10.7084 14.0873 10.8613 14.2344 11.0701C14.2391 11.0768 14.2556 11.1004 14.2783 11.1329C14.342 11.224 14.4546 11.3853 14.4962 11.4435C14.6062 11.5979 14.6973 11.7186 14.7894 11.8282C15.1433 12.2496 15.4778 12.4979 15.9962 12.4999C17.2043 12.5045 18 11.6884 18 10.5C18 6.00945 14.5737 2.5 10.1135 2.5C5.61932 2.5 2 6.04373 2 10.5C2 11.691 2.80684 12.4653 3.97058 12.4996C4.49773 12.5151 4.84171 12.2702 5.20109 11.8524C5.29327 11.7452 5.38393 11.6278 5.49488 11.4756C5.52617 11.4327 5.60443 11.3235 5.66803 11.2348ZM4.0123 10.1117C4.21305 6.95433 6.84728 4.5 10.1135 4.5C13.3213 4.5 15.7905 6.89462 15.9873 10.0869L15.8695 9.91849C15.2637 9.05819 14.8777 8.65893 14.2005 8.52031C13.7705 8.43229 13.384 8.53828 13.0099 8.76164C12.8134 8.879 12.7042 8.96398 12.3847 9.22882C12.2299 9.35714 12.1385 9.42855 12.0688 9.47431C12.0017 9.43641 11.8947 9.36694 11.7382 9.25373L11.6585 9.19592C10.9452 8.67711 10.5954 8.49025 9.98384 8.50013C9.38495 8.50981 9.02693 8.69953 8.34016 9.19458C8.2447 9.26343 8.20591 9.29119 8.15893 9.32398C8.04542 9.40321 7.96278 9.45402 7.90806 9.48298C7.83841 9.4411 7.74687 9.37356 7.58824 9.248C7.26436 8.99166 7.16224 8.91568 6.96646 8.80468C6.59508 8.59412 6.21204 8.49791 5.79041 8.58829C5.12256 8.73144 4.72218 9.13005 4.13588 9.93956C4.11944 9.96226 4.07861 10.0192 4.03366 10.0819L4.0123 10.1117Z" fill="currentColor"/>
</svg>
`;

const Wifi$1 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13.6961 11.2821C14.0926 11.6665 14.1024 12.2996 13.7179 12.6961C13.3335 13.0926 12.7004 13.1024 12.3039 12.7179C12.273 12.688 12.2391 12.6581 12.2022 12.6285C12.0406 12.4986 11.8292 12.3788 11.5791 12.2796C11.1265 12.1001 10.5793 12 10 12C9.08604 12 8.26716 12.2511 7.79777 12.6285C7.76089 12.6581 7.72699 12.688 7.69613 12.7179C7.29964 13.1024 6.66655 13.0926 6.28209 12.6961C5.89762 12.2996 5.90738 11.6665 6.30387 11.2821C6.37977 11.2085 6.46015 11.1377 6.54472 11.0697C7.39422 10.3868 8.65538 10 10 10C10.8267 10 11.6239 10.1459 12.3163 10.4204C12.7456 10.5907 13.131 10.809 13.4553 11.0697C13.5399 11.1377 13.6202 11.2085 13.6961 11.2821Z" fill="currentColor"/>
<path d="M16.2128 8.68869C16.6002 9.08238 16.595 9.71553 16.2013 10.1029C15.8076 10.4902 15.1745 10.485 14.7872 10.0913C14.6908 9.99338 14.5866 9.89798 14.4751 9.80557C14.362 9.71196 14.2416 9.62159 14.1142 9.53491C13.9855 9.44731 13.8498 9.36361 13.7078 9.28424C13.5647 9.20419 13.4152 9.12866 13.2601 9.05801C13.104 8.9869 12.9424 8.92084 12.7758 8.86013C12.6085 8.79914 12.4364 8.74364 12.2601 8.6939C12.0833 8.64404 11.9026 8.60002 11.7185 8.56207C11.5345 8.52413 11.3472 8.49229 11.1573 8.46673C10.968 8.44124 10.7762 8.42202 10.5824 8.40919C10.3899 8.39644 10.1956 8.39001 10 8.39001C9.80443 8.39001 9.61014 8.39644 9.4176 8.40919C9.22385 8.42202 9.03203 8.44124 8.84266 8.46673C8.65277 8.49229 8.46552 8.52413 8.28146 8.56207C8.09736 8.60002 7.91666 8.64404 7.73993 8.6939C7.56364 8.74364 7.39152 8.79914 7.22416 8.86013C7.0576 8.92084 6.89597 8.9869 6.73987 9.05801C6.58477 9.12866 6.43534 9.20419 6.29217 9.28424C6.15018 9.36361 6.01455 9.44731 5.88581 9.53491C5.75842 9.62159 5.63797 9.71196 5.52494 9.80557C5.41338 9.89798 5.30922 9.99338 5.21284 10.0913C4.82551 10.485 4.19237 10.4902 3.79868 10.1029C3.40498 9.71553 3.39983 9.08238 3.78716 8.68869C3.93166 8.54182 4.0859 8.40053 4.24924 8.26525C4.41113 8.13118 4.58183 8.0031 4.76069 7.8814C4.93819 7.76061 5.12361 7.6462 5.31623 7.53851C5.50766 7.4315 5.70608 7.3312 5.91079 7.23795C6.11446 7.14517 6.32421 7.05944 6.53934 6.98104C6.75355 6.90297 6.97295 6.83222 7.19683 6.76905C7.41971 6.70617 7.64688 6.65083 7.87767 6.60326C8.10719 6.55594 8.34013 6.51634 8.57585 6.48461C8.80999 6.45309 9.04673 6.42936 9.28546 6.41356C9.522 6.39789 9.76036 6.39001 10 6.39001C10.2396 6.39001 10.478 6.39789 10.7145 6.41356C10.9533 6.42936 11.19 6.45309 11.4241 6.48461C11.6599 6.51634 11.8928 6.55594 12.1223 6.60326C12.3531 6.65083 12.5803 6.70617 12.8032 6.76905C13.0271 6.83222 13.2464 6.90297 13.4607 6.98104C13.6758 7.05944 13.8855 7.14517 14.0892 7.23795C14.2939 7.3312 14.4923 7.4315 14.6838 7.53851C14.8764 7.6462 15.0618 7.76061 15.2393 7.8814C15.4182 8.0031 15.5889 8.13118 15.7508 8.26525C15.9141 8.40053 16.0683 8.54182 16.2128 8.68869Z" fill="currentColor"/>
<path d="M18.2454 6.22201C18.6136 6.63366 18.5783 7.26584 18.1667 7.63403C17.755 8.00221 17.1228 7.96697 16.7546 7.55532C16.6133 7.3973 16.4611 7.24398 16.2987 7.09599C16.1352 6.94702 15.9614 6.80363 15.7782 6.66645C15.5939 6.5285 15.4001 6.397 15.1977 6.27253C14.9944 6.14748 14.7825 6.02968 14.5629 5.91965C14.3426 5.80922 14.1147 5.70676 13.8801 5.61271C13.6448 5.51841 13.4031 5.43268 13.1558 5.35591C12.9082 5.27907 12.6552 5.21129 12.3976 5.15288C12.1404 5.09455 11.8788 5.04562 11.6136 5.00636C11.3494 4.96723 11.0818 4.93773 10.8116 4.91805C10.5433 4.89851 10.2725 4.88866 10 4.88866C9.72751 4.88866 9.45676 4.89851 9.18838 4.91805C8.91819 4.93773 8.65062 4.96723 8.38638 5.00636C8.12121 5.04562 7.85962 5.09455 7.60238 5.15288C7.34479 5.21129 7.0918 5.27907 6.84422 5.35591C6.59687 5.43268 6.35518 5.51841 6.11995 5.61271C5.88536 5.70676 5.65746 5.80922 5.43708 5.91965C5.2175 6.02968 5.00564 6.14748 4.80229 6.27253C4.59988 6.397 4.40615 6.5285 4.22185 6.66645C4.03857 6.80363 3.86484 6.94702 3.70132 7.09599C3.53888 7.24398 3.38671 7.3973 3.24538 7.55532C2.87719 7.96697 2.24501 8.00221 1.83335 7.63403C1.4217 7.26584 1.38646 6.63366 1.75464 6.22201C1.94178 6.01278 2.14198 5.81106 2.35441 5.61753C2.56577 5.42498 2.78906 5.24069 3.02339 5.06529C3.2567 4.89067 3.50075 4.725 3.75463 4.56888C4.00757 4.41334 4.27004 4.26739 4.54111 4.13157C4.81132 3.99617 5.08986 3.87094 5.37575 3.75633C5.66085 3.64203 5.95304 3.53839 6.25138 3.4458C6.54872 3.35351 6.85193 3.27227 7.1601 3.20239C7.46682 3.13284 7.77822 3.0746 8.09344 3.02793C8.40671 2.98154 8.72353 2.94661 9.04309 2.92334C9.35982 2.90027 9.67904 2.88866 10 2.88866C10.321 2.88866 10.6402 2.90027 10.9569 2.92334C11.2765 2.94661 11.5933 2.98154 11.9066 3.02793C12.2218 3.0746 12.5332 3.13284 12.8399 3.20239C13.1481 3.27227 13.4513 3.35351 13.7486 3.4458C14.047 3.53839 14.3392 3.64203 14.6243 3.75633C14.9102 3.87094 15.1887 3.99617 15.4589 4.13157C15.73 4.26739 15.9925 4.41334 16.2454 4.56888C16.4993 4.725 16.7433 4.89067 16.9766 5.06529C17.211 5.24069 17.4342 5.42498 17.6456 5.61753C17.858 5.81106 18.0582 6.01278 18.2454 6.22201Z" fill="currentColor"/>
<path d="M12 15.25C12 16.3546 11.1046 17.25 10 17.25C8.89543 17.25 8 16.3546 8 15.25C8 14.1454 8.89543 13.25 10 13.25C11.1046 13.25 12 14.1454 12 15.25Z" fill="currentColor"/>
</svg>
`;

/** Do not edit! This file is auto-generated. */
const pop = {
    'airplane': Airplane$1,
    'angle-down': AngleDown$1,
    'angle-left': AngleLeft$1,
    'angle-right': AngleRight$1,
    'angle-up': AngleUp$1,
    'battery': Battery$1,
    'bell': Bell$1,
    'bell-off': BellOff$1,
    'bicycle': Bicycle$1,
    'bluetooth': Bluetooth$1,
    'book': Book$1,
    'bookmark': Bookmark$1,
    'bookmark-filled': BookmarkFilled,
    'building': Building$1,
    'calculator': Calculator$1,
    'calendar': Calendar$1,
    'camera': Camera$1,
    'can': Can$1,
    'car': Car$1,
    'cart': Cart$1,
    'checkmark': Checkmark$1,
    'circle': Circle$1,
    'circle-filled': CircleFilled,
    'clipboard': Clipboard$1,
    'clock': Clock$1,
    'cloud': Cloud$1,
    'cloud-down': CloudDown$1,
    'cloud-down-filled': CloudDownFilled,
    'cloud-filled': CloudFilled,
    'cloud-up': CloudUp$1,
    'cloud-up-filled': CloudUpFilled,
    'coctail': Coctail$1,
    'color-picker': ColorPicker$1,
    'contract': Contract$1,
    'controller': Controller$1,
    'credit-card': CreditCard$1,
    'cup': Cup$1,
    'division': Division$1,
    'dots-x': DotsX$1,
    'dots-y': DotsY$1,
    'dress': Dress$1,
    'duplicate': Duplicate$1,
    'electricity': Electricity$1,
    'exclamation': Exclamation$1,
    'exclamation-filled': ExclamationFilled,
    'expand': Expand$1,
    'eye': Eye$1,
    'eye-closed': EyeClosed$1,
    'eye-off': EyeOff$1,
    'file': File$1,
    'film-frame': FilmFrame$1,
    'flag': Flag$1,
    'flower': Flower$1,
    'flower-bud': FlowerBud$1,
    'folder': Folder$1,
    'gear': Gear$1,
    'gift': Gift$1,
    'grab': Grab$1,
    'hamburger': Hamburger$1,
    'headphone': Headphone$1,
    'heart': Heart$1,
    'house': House$1,
    'info': Info$1,
    'info-filled': InfoFilled,
    'internet': Internet$1,
    'key': Key$1,
    'knive-fork': KniveFork$1,
    'letter': Letter$1,
    'lock-closed': LockClosed$1,
    'lock-open': LockOpen$1,
    'loop': Loop$1,
    'loop-minus': LoopMinus$1,
    'loop-plus': LoopPlus$1,
    'magnet': Magnet$1,
    'map': Map$1,
    'microphone': Microphone$1,
    'minus': Minus$1,
    'monitor': Monitor$1,
    'monitor2': Monitor2$1,
    'moon': Moon$1,
    'moon-filled': MoonFilled,
    'motorcycle': Motorcycle$1,
    'music-note-double': MusicNoteDouble$1,
    'music-note-single': MusicNoteSingle$1,
    'open': Open$1,
    'paint-pallet': PaintPallet$1,
    'pen': Pen$1,
    'person': Person$1,
    'person-filled': PersonFilled,
    'phone': Phone$1,
    'photo-camera': PhotoCamera$1,
    'pill': Pill$1,
    'pinpoint': Pinpoint$1,
    'pinpoint-filled': PinpointFilled,
    'pinpoint-off': PinpointOff$1,
    'pinpoint-off-filled': PinpointOffFilled,
    'plus': Plus$1,
    'power': Power$1,
    'printer': Printer$1,
    'refresh': Refresh$1,
    'reload': Reload$1,
    'scissors': Scissors$1,
    'send': Send$1,
    'share-android': ShareAndroid$1,
    'share-ios': ShareIos$1,
    'smartphone': Smartphone$1,
    'smartphone-notch': SmartphoneNotch$1,
    'smartphone2': Smartphone2$1,
    'soft-drink': SoftDrink$1,
    'speaker-high': SpeakerHigh$1,
    'speaker-low': SpeakerLow$1,
    'speaker-off': SpeakerOff$1,
    'square': Square$1,
    'square-filled': SquareFilled,
    'star': Star$1,
    'star-filled': StarFilled,
    'sun': Sun$1,
    'sun-filled': SunFilled,
    'syringe': Syringe$1,
    't-shirt': TShirt$1,
    'taxi': Taxi$1,
    'television': Television$1,
    'text-bubble': TextBubble$1,
    'times': Times$1,
    'tool': Tool$1,
    'train': Train$1,
    'trash': Trash$1,
    'triangle-down': TriangleDown$1,
    'triangle-down-filled': TriangleDownFilled,
    'triangle-left': TriangleLeft$1,
    'triangle-left-filled': TriangleLeftFilled,
    'triangle-right': TriangleRight$1,
    'triangle-right-filled': TriangleRightFilled,
    'triangle-up': TriangleUp$1,
    'triangle-up-filled': TriangleUpFilled,
    'truck': Truck$1,
    'umbrella': Umbrella$1,
    'wifi': Wifi$1,
};

const Airplane = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M11.2237 13.805C11.4794 15.6396 11.5923 16.7828 11.5624 17.2854C11.5159 18.0655 10.9931 18.8865 10.0279 19.7822C9.75347 20.0369 9.30689 19.9108 9.20619 19.5502L7.87106 14.7706L7.27107 14.1706L2.49144 12.8355C2.13092 12.7348 2.00483 12.2882 2.25945 12.0138C3.15519 11.0485 3.97614 10.5258 4.75628 10.4793C5.25901 10.4494 6.40254 10.5624 8.23783 10.8181L10.6694 8.16575L4.61552 6.47431C4.25502 6.37359 4.12895 5.92703 4.38355 5.65265C5.76919 4.15943 7.02218 3.36158 8.17652 3.29293C9.06242 3.24023 10.9254 3.70483 13.8567 4.68935L14.3016 4.20455C16.3494 2.15809 18.0349 1.59992 19.2388 2.80381C20.4427 4.00777 19.8842 5.69305 17.8214 7.75516L17.3524 8.1852C18.3369 11.1164 18.8014 12.9793 18.7488 13.8652C18.6801 15.0195 17.8823 16.2725 16.389 17.6581C16.1147 17.9127 15.6681 17.7867 15.5674 17.4262L13.8761 11.3729L11.2237 13.805Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.5624 16.2854C10.5923 15.7828 10.4794 14.6396 10.2237 12.805L12.8761 10.3729L14.5674 16.4262C14.6681 16.7867 15.1147 16.9127 15.389 16.6581C16.8823 15.2725 17.6801 14.0195 17.7488 12.8652C17.8014 11.9793 17.3369 10.1164 16.3524 7.1852L16.8214 6.75516C18.8842 4.69305 19.4427 3.00777 18.2388 1.80381C17.0349 0.59992 15.3494 1.15809 13.3016 3.20455L12.8567 3.68935C9.92541 2.70483 8.06242 2.24023 7.17652 2.29293C6.02218 2.36158 4.76919 3.15943 3.38355 4.65265C3.12895 4.92703 3.25502 5.37359 3.61552 5.47431L9.66945 7.16575L7.23783 9.81814C5.40254 9.56238 4.25901 9.44939 3.75628 9.47932C2.97614 9.52577 2.15519 10.0485 1.25945 11.0138C1.00483 11.2882 1.13092 11.7348 1.49144 11.8355L6.27107 13.1706L6.87106 13.7706L8.20619 18.5502C8.30689 18.9108 8.75347 19.0369 9.02786 18.7822C9.99314 17.8865 10.5159 17.0655 10.5624 16.2854ZM9.19693 12.6843C9.46746 14.5947 9.58981 15.7947 9.56413 16.226C9.54433 16.5585 9.33872 16.9682 8.93509 17.4427L7.79891 13.3753C7.77578 13.2925 7.73169 13.217 7.6709 13.1562L6.88545 12.3708C6.82466 12.31 6.74922 12.2659 6.66642 12.2428L2.599 11.1066C3.07353 10.703 3.4832 10.4974 3.81571 10.4776C4.24707 10.4519 5.44749 10.5743 7.35857 10.8449C7.52176 10.868 7.68586 10.8092 7.79724 10.6877L10.9569 7.24122C11.2089 6.96629 11.0821 6.52215 10.7229 6.42178L4.70117 4.73934C5.68001 3.80916 6.53157 3.33305 7.23589 3.29116C7.96978 3.24751 9.87294 3.73165 12.8443 4.74065C13.032 4.80439 13.2397 4.75121 13.3736 4.60508L14.0236 3.8961C15.7159 2.20551 16.8505 1.82978 17.5317 2.51091C18.2127 3.19197 17.8368 4.32621 16.1299 6.03309L15.4366 6.66821C15.2905 6.80217 15.2373 7.0098 15.3011 7.1975C16.31 10.1688 16.7942 12.0719 16.7505 12.8058C16.7086 13.5101 16.2325 14.3617 15.3023 15.3405L13.6201 9.31934C13.5197 8.96009 13.0755 8.83327 12.8006 9.08536L9.35407 12.2457C9.23261 12.3571 9.17383 12.5212 9.19693 12.6843Z" fill="black"/>
</svg>
`;

const AngleDown = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12 11.5475L6.96028 7.34769C5.42383 6.06732 3.50328 8.37199 5.03972 9.65236L10.9878 14.6091C11.2603 14.8652 11.6176 15.0286 12 15.0275C12.3824 15.0286 12.7397 14.8652 13.0122 14.6091L18.9603 9.65236C20.4967 8.37199 18.5762 6.06732 17.0397 7.34769L12 11.5475Z" fill="currentColor"/>
</g>
<path d="M15.6799 7.11597L9.67991 12.116L10.3201 12.8842L16.3201 7.88419L15.6799 7.11597Z" fill="black"/>
<path d="M16.3201 7.88412L10.3201 12.8841C9.80794 13.3109 9.16776 12.5427 9.67991 12.1159L15.6799 7.1159C16.1921 6.68911 16.8322 7.45733 16.3201 7.88412Z" fill="black"/>
<path d="M3.67991 7.88419L9.67991 12.8842L10.3201 12.116L4.32009 7.11597L3.67991 7.88419Z" fill="black"/>
<path d="M4.32009 7.1159L10.3201 12.1159C10.8322 12.5427 10.1921 13.3109 9.67991 12.8841L3.67991 7.88412C3.16776 7.45733 3.80794 6.68911 4.32009 7.1159Z" fill="black"/>
</svg>
`;

const AngleLeft = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.4526 11L15.6523 5.96027C16.9327 4.42382 14.628 2.50327 13.3477 4.03971L8.39096 9.98776C8.13483 10.2603 7.97147 10.6176 7.97252 11C7.97147 11.3824 8.13483 11.7397 8.39096 12.0122L13.3477 17.9603C14.628 19.4967 16.9327 17.5762 15.6523 16.0397L11.4526 11Z" fill="currentColor"/>
</g>
<path d="M12.3841 15.6799L7.38411 9.67993L6.61589 10.3201L11.6159 16.3201L12.3841 15.6799Z" fill="black"/>
<path d="M11.6159 16.32L6.61589 10.32C6.1891 9.8079 6.95732 9.16772 7.38411 9.67986L12.3841 15.6799C12.8109 16.192 12.0427 16.8322 11.6159 16.32Z" fill="black"/>
<path d="M11.6159 3.67993L6.61589 9.67993L7.38411 10.3201L12.3841 4.32012L11.6159 3.67993Z" fill="black"/>
<path d="M12.3841 4.32005L7.38411 10.32C6.95732 10.8322 6.1891 10.192 6.61589 9.67986L11.6159 3.67986C12.0427 3.16772 12.8109 3.8079 12.3841 4.32005Z" fill="black"/>
</svg>
`;

const AngleRight = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M15.8115 11.7288C15.7623 11.8174 15.7036 11.9018 15.6355 11.9805L10.6523 17.9603C10.122 18.5967 9.17614 18.6827 8.53972 18.1524C7.90331 17.622 7.81732 16.6762 8.34767 16.0398L12.5474 11L8.34767 5.96031C7.81732 5.3239 7.90331 4.37805 8.53972 3.84771C9.17614 3.31736 10.122 3.40335 10.6523 4.03976L15.6523 10.0398C16.0606 10.5296 16.1036 11.2028 15.8116 11.7288L15.8115 11.7288Z" fill="currentColor"/>
</g>
<path d="M7.11589 4.3201C6.9391 4.10797 6.96777 3.79268 7.17991 3.6159C7.39204 3.43912 7.70733 3.46778 7.88411 3.67992L12.8841 9.67992C13.0609 9.89206 13.0322 10.2073 12.8201 10.3841C12.608 10.5609 12.2927 10.5322 12.1159 10.3201L7.11589 4.3201Z" fill="black"/>
<path d="M7.88411 16.3201C7.70733 16.5322 7.39204 16.5609 7.17991 16.3841C6.96777 16.2073 6.9391 15.8921 7.11589 15.6799L12.1159 9.67992C12.2927 9.46778 12.608 9.43912 12.8201 9.6159C13.0322 9.79268 13.0609 10.108 12.8841 10.3201L7.88411 16.3201Z" fill="black"/>
</svg>
`;

const AngleUp = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.9878 7.39098L5.03973 12.3477C3.50328 13.6281 5.42384 15.9327 6.96028 14.6524L12 10.4526L17.0397 14.6524C18.5762 15.9327 20.4967 13.6281 18.9603 12.3477L13.0122 7.39098C12.7397 7.13485 12.3824 6.9715 12 6.97254C11.6176 6.9715 11.2603 7.13485 10.9878 7.39098Z" fill="currentColor"/>
</g>
<path d="M16.3201 12.116L10.3201 7.11597L9.67992 7.88419L15.6799 12.8842L16.3201 12.116Z" fill="black"/>
<path d="M15.6799 12.8841L9.67991 7.88412C9.16776 7.45733 9.80795 6.68911 10.3201 7.1159L16.3201 12.1159C16.8322 12.5427 16.1921 13.3109 15.6799 12.8841Z" fill="black"/>
<path d="M4.32009 12.8842L10.3201 7.88419L9.67991 7.11597L3.67991 12.116L4.32009 12.8842Z" fill="black"/>
<path d="M3.67991 12.1159L9.67991 7.1159C10.1921 6.68911 10.8322 7.45733 10.3201 7.88412L4.32009 12.8841C3.80795 13.3109 3.16776 12.5427 3.67991 12.1159Z" fill="black"/>
</svg>
`;

const Battery = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<rect x="3" y="7" width="13" height="8" rx="1" fill="currentColor"/>
<rect x="16.5" y="8.5" width="2" height="5" rx="0.5" fill="currentColor"/>
</g>
<rect x="16" y="7.5" width="2" height="5" rx="0.5" fill="black"/>
<path d="M4 7.5H6.5V12.5H4V7.5Z" fill="black"/>
<path d="M7.25 7.5H9.75V12.5H7.25V7.5Z" fill="black"/>
<rect x="10.5" y="7.5" width="2.5" height="5" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14 5.5H3C2.17157 5.5 1.5 6.17157 1.5 7V13C1.5 13.8284 2.17157 14.5 3 14.5H14C14.8284 14.5 15.5 13.8284 15.5 13V7C15.5 6.17157 14.8284 5.5 14 5.5ZM2.5 7C2.5 6.72386 2.72386 6.5 3 6.5H14C14.2761 6.5 14.5 6.72386 14.5 7V13C14.5 13.2761 14.2761 13.5 14 13.5H3C2.72386 13.5 2.5 13.2761 2.5 13V7Z" fill="black"/>
</svg>
`;

const Bell = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path opacity="0.8" fill-rule="evenodd" clip-rule="evenodd" d="M12.5 5.02242C15.3033 5.27504 17.5 7.63098 17.5 10.5V13.4254C18.4211 13.9472 19 14.9279 19 16C19 17.1046 18.1046 18 17 18H13.5C13.5 19.1046 12.6046 20 11.5 20C10.3954 20 9.5 19.1046 9.5 18H6C4.89543 18 4 17.1046 4 16C4 14.9279 4.5789 13.9472 5.5 13.4254V10.5C5.5 7.63098 7.69675 5.27504 10.5 5.02242L10.5 3C10.5 2.44771 10.9477 2 11.5 2C12.0523 2 12.5 2.44772 12.5 3L12.5 5.02242Z" fill="currentColor"/>
<path d="M8 17C8 16.7239 8.22386 16.5 8.5 16.5C8.77614 16.5 9 16.7239 9 17C9 17.5523 9.44772 18 10 18C10.5523 18 11 17.5523 11 17C11 16.7239 11.2239 16.5 11.5 16.5C11.7761 16.5 12 16.7239 12 17C12 18.1046 11.1046 19 10 19C8.89543 19 8 18.1046 8 17Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M17.5 14.5C17.5 13.4279 16.9211 12.4472 16 11.9254V9C16 5.96243 13.5376 3.5 10.5 3.5H9.5C6.46243 3.5 4 5.96243 4 9V11.9254C3.0789 12.4472 2.5 13.4279 2.5 14.5C2.5 15.6046 3.39543 16.5 4.5 16.5H15.5C16.6046 16.5 17.5 15.6046 17.5 14.5ZM15 12.5583L15.2952 12.6908L15.35 12.7155C16.0502 13.0332 16.5 13.7311 16.5 14.5C16.5 15.0523 16.0523 15.5 15.5 15.5H4.5C3.94772 15.5 3.5 15.0523 3.5 14.5C3.5 13.7311 3.94976 13.0332 4.65004 12.7155L4.7048 12.6908L5 12.5583V9C5 6.51472 7.01472 4.5 9.5 4.5H10.5C12.9853 4.5 15 6.51472 15 9V12.5583Z" fill="black"/>
<path d="M9.5 1.5C9.5 1.22386 9.72386 1 10 1C10.2761 1 10.5 1.22386 10.5 1.5L10.5 4C10.5 4.27614 10.2761 4.5 10 4.5C9.72386 4.5 9.5 4.27614 9.5 4L9.5 1.5Z" fill="black"/>
</svg>
`;

const BellOff = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path opacity="0.8" fill-rule="evenodd" clip-rule="evenodd" d="M12.5 5.02242C15.3033 5.27504 17.5 7.63098 17.5 10.5V13.4254C18.4211 13.9472 19 14.9279 19 16C19 17.1046 18.1046 18 17 18H13.5C13.5 19.1046 12.6046 20 11.5 20C10.3954 20 9.5 19.1046 9.5 18H6C4.89543 18 4 17.1046 4 16C4 14.9279 4.5789 13.9472 5.5 13.4254V10.5C5.5 7.63098 7.69675 5.27504 10.5 5.02242L10.5 3C10.5 2.44771 10.9477 2 11.5 2C12.0523 2 12.5 2.44772 12.5 3L12.5 5.02242Z" fill="currentColor"/>
<path d="M8 17C8 16.7239 8.22386 16.5 8.5 16.5C8.77614 16.5 9 16.7239 9 17C9 17.5523 9.44772 18 10 18C10.5523 18 11 17.5523 11 17C11 16.7239 11.2239 16.5 11.5 16.5C11.7761 16.5 12 16.7239 12 17C12 18.1046 11.1046 19 10 19C8.89543 19 8 18.1046 8 17Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M17.5 14.5C17.5 13.4279 16.9211 12.4472 16 11.9254V9C16 5.96243 13.5376 3.5 10.5 3.5H9.5C6.46243 3.5 4 5.96243 4 9V11.9254C3.0789 12.4472 2.5 13.4279 2.5 14.5C2.5 15.6046 3.39543 16.5 4.5 16.5H15.5C16.6046 16.5 17.5 15.6046 17.5 14.5ZM15 12.5583L15.2952 12.6908L15.35 12.7155C16.0502 13.0332 16.5 13.7311 16.5 14.5C16.5 15.0523 16.0523 15.5 15.5 15.5H4.5C3.94772 15.5 3.5 15.0523 3.5 14.5C3.5 13.7311 3.94976 13.0332 4.65004 12.7155L4.7048 12.6908L5 12.5583V9C5 6.51472 7.01472 4.5 9.5 4.5H10.5C12.9853 4.5 15 6.51472 15 9V12.5583Z" fill="black"/>
<path d="M9.5 1.5C9.5 1.22386 9.72386 1 10 1C10.2761 1 10.5 1.22386 10.5 1.5L10.5 4C10.5 4.27614 10.2761 4.5 10 4.5C9.72386 4.5 9.5 4.27614 9.5 4L9.5 1.5Z" fill="black"/>
<path d="M2.64772 2.88933C2.45246 2.69407 2.45246 2.37748 2.64772 2.18222C2.84298 1.98696 3.15956 1.98696 3.35482 2.18222L19.3548 18.1822C19.5501 18.3775 19.5501 18.6941 19.3548 18.8893C19.1596 19.0846 18.843 19.0846 18.6477 18.8893L2.64772 2.88933Z" fill="black"/>
</svg>
`;

const Bicycle = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5 20C7.03981 20 8.723 18.4732 8.96905 16.5H10.7105C11.0479 16.5 11.2884 16.1727 11.1877 15.8507L11.1519 15.7363L14.3662 10.323L14.8118 12.1794C13.1829 12.6855 12 14.2046 12 16C12 18.2091 13.7909 20 16 20C18.2091 20 20 18.2091 20 16C20 13.8966 18.3765 12.1724 16.3142 12.0122L14.4395 4.20066C15.5947 4.15838 16.4782 4.21094 17.078 4.35228C17.6121 4.47813 17.75 4.59459 17.75 4.67811C17.75 5.18897 17.51 5.34761 16.5749 5.25375C16.1628 5.21238 15.7951 5.51295 15.7537 5.9251C15.7124 6.33724 16.013 6.70488 16.4251 6.74625C18.1567 6.92006 19.25 6.19744 19.25 4.67811C19.25 2.97369 17.2603 2.49573 13.5094 2.74763C13.4582 2.74825 13.407 2.7537 13.3567 2.76375C13.3302 2.76887 13.3042 2.77537 13.2788 2.78317C12.9408 2.88486 12.6683 3.19872 12.7654 3.65171C12.768 3.66423 12.7709 3.67662 12.774 3.68888L13.9571 8.61839H8.92533L8.34087 6.75H9.5C9.91421 6.75 10.25 6.41421 10.25 6C10.25 5.58579 9.91421 5.25 9.5 5.25H5.5C5.08579 5.25 4.75 5.58579 4.75 6C4.75 6.41421 5.08579 6.75 5.5 6.75H7.29308L8.12324 9.40383L6.69192 12.3744C6.17806 12.1342 5.6047 12 5 12C2.79086 12 1 13.7909 1 16C1 18.2091 2.79086 20 5 20Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15.5 18.5C17.7091 18.5 19.5 16.7091 19.5 14.5C19.5 12.2909 17.7091 10.5 15.5 10.5C13.2909 10.5 11.5 12.2909 11.5 14.5C11.5 16.7091 13.2909 18.5 15.5 18.5ZM15.5 11.5C17.1569 11.5 18.5 12.8431 18.5 14.5C18.5 16.1569 17.1569 17.5 15.5 17.5C13.8431 17.5 12.5 16.1569 12.5 14.5C12.5 12.8431 13.8431 11.5 15.5 11.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.5 18.5C6.70914 18.5 8.5 16.7091 8.5 14.5C8.5 12.2909 6.70914 10.5 4.5 10.5C2.29086 10.5 0.5 12.2909 0.5 14.5C0.5 16.7091 2.29086 18.5 4.5 18.5ZM4.5 11.5C6.15685 11.5 7.5 12.8431 7.5 14.5C7.5 16.1569 6.15685 17.5 4.5 17.5C2.84315 17.5 1.5 16.1569 1.5 14.5C1.5 12.8431 2.84315 11.5 4.5 11.5Z" fill="black"/>
<path d="M5 5C4.72386 5 4.5 4.77614 4.5 4.5C4.5 4.22386 4.72386 4 5 4H9C9.27614 4 9.5 4.22386 9.5 4.5C9.5 4.77614 9.27614 5 9 5H5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.4748 14.3433L10.4404 14.2392L14.4237 7.88405C14.6324 7.55105 14.393 7.11852 14 7.11852L8.08918 7.11852L7.17283 4.34335C7.08625 4.08113 6.80349 3.93875 6.54127 4.02534C6.27905 4.11192 6.13667 4.39468 6.22326 4.65689L7.29481 7.9021L4.05433 14.2735C3.88515 14.6061 4.12681 15.0001 4.5 15.0001H10C10.3407 15.0001 10.5816 14.6669 10.4748 14.3433ZM5.31525 14.0001H9.30835L7.73645 9.23962L5.31525 14.0001ZM8.41937 8.11852L10.0332 13.006L13.0965 8.11852H8.41937Z" fill="black"/>
<path d="M13.5441 2.99899C13.2689 3.02279 13.0266 2.81906 13.0028 2.54394C12.979 2.26883 13.1828 2.02651 13.4579 2.00271C17.1126 1.68654 19.001 2.0642 19.001 3.50085C19.001 4.76632 18.0928 5.44744 16.5178 5.50056C16.2418 5.50987 16.0106 5.29369 16.0013 5.0177C15.9919 4.74172 16.2081 4.51044 16.4841 4.50113C17.5758 4.46431 18.001 4.14544 18.001 3.50085C18.001 3.02744 16.556 2.73843 13.5441 2.99899Z" fill="black"/>
<path d="M13.9932 2.41771L15.9932 14.4177C16.1028 15.0753 15.1164 15.2397 15.0068 14.5821L13.0068 2.58211C12.8972 1.92451 13.8836 1.76011 13.9932 2.41771Z" fill="black"/>
</svg>
`;

const Bluetooth = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12 11.7967L5.44351 16.6048C5.10949 16.8497 4.64014 16.7775 4.39519 16.4435C4.15023 16.1094 4.22244 15.6401 4.55647 15.3951L11.2317 10.5L4.55647 5.6048C4.22244 5.35985 4.15023 4.8905 4.39519 4.55647C4.64014 4.22245 5.10949 4.15024 5.44351 4.39519L12 9.20328L12 1.49995C12 1.08792 12.4704 0.852734 12.8 1.09995L18.8 5.59995C19.0667 5.79995 19.0667 6.19995 18.8 6.39995L13.3333 10.4999L18.8 14.5999C19.0667 14.7999 19.0667 15.1999 18.8 15.3999L12.8 19.8999C12.4704 20.1472 12 19.912 12 19.4999L12 11.7967Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.2318 10.3975L16.8033 6.14748C17.0656 5.94737 17.0656 5.55251 16.8033 5.3524L11.2318 1.1024C10.9027 0.851366 10.4286 1.08604 10.4286 1.49994L10.4286 9.99994C10.4286 10.4138 10.9027 10.6485 11.2318 10.3975ZM11.4286 8.98966L11.4286 2.51022L15.6756 5.74994L11.4286 8.98966Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.2318 18.8975L16.8033 14.6475C17.0656 14.4474 17.0656 14.0525 16.8033 13.8524L11.2318 9.6024C10.9027 9.35137 10.4286 9.58604 10.4286 9.99994L10.4286 18.4999C10.4286 18.9138 10.9027 19.1485 11.2318 18.8975ZM11.4286 11.0102L15.6756 14.2499L11.4286 17.4897L11.4286 11.0102Z" fill="black"/>
<path d="M11.2275 9.5991C11.4489 9.7642 11.4945 10.0775 11.3294 10.2988C11.1643 10.5202 10.851 10.5658 10.6296 10.4007L3.66534 5.20624C3.44399 5.04114 3.39839 4.72786 3.56349 4.50651C3.72859 4.28516 4.04187 4.23956 4.26322 4.40466L11.2275 9.5991Z" fill="black"/>
<path d="M11.2275 10.4008C11.4489 10.2357 11.4945 9.9224 11.3294 9.70104C11.1643 9.47969 10.851 9.43409 10.6296 9.59919L3.66534 14.7936C3.44399 14.9587 3.39839 15.272 3.56349 15.4934C3.72859 15.7147 4.04187 15.7603 4.26322 15.5952L11.2275 10.4008Z" fill="black"/>
</svg>
`;

const Book = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M11 5.78986L18.3136 4.52084C18.3935 4.50697 18.4745 4.5 18.5556 4.5C19.357 4.5 20 5.164 20 5.97522V15.761C20 16.4819 19.489 17.1009 18.7868 17.2172L11.0817 18.4933C11.0203 18.5035 10.9599 18.502 10.9028 18.4907L3.25492 17.2241C2.53094 17.1042 2 16.4781 2 15.7443V6.01091C2 5.18248 2.67157 4.51091 3.5 4.51091C3.58596 4.51091 3.67175 4.5183 3.75644 4.53299L11 5.78986Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.0809 4.30391L2.24258 3.01941C2.16239 3.00627 2.08126 2.99966 2 2.99966C1.17157 2.99966 0.5 3.67124 0.5 4.49966V14.2366C0.5 14.9755 1.03815 15.6043 1.7682 15.7185L9.92273 16.994C10.226 17.0414 10.5 16.8069 10.5 16.5V4.79733C10.5 4.5524 10.3226 4.34352 10.0809 4.30391ZM2.08086 4.00625L9.5 5.22206V15.9157L1.92273 14.7305C1.67938 14.6925 1.5 14.4829 1.5 14.2366V4.49966C1.5 4.22352 1.72386 3.99966 2 3.99966C2.02709 3.99966 2.05413 4.00187 2.08086 4.00625Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M18 2.99966C17.9187 2.99966 17.8376 3.00627 17.7574 3.01941L9.91914 4.30391C9.67743 4.34352 9.5 4.5524 9.5 4.79733V16.5C9.5 16.8069 9.774 17.0414 10.0773 16.994L18.2318 15.7185C18.9619 15.6043 19.5 14.9755 19.5 14.2366V4.49966C19.5 3.67124 18.8284 2.99966 18 2.99966ZM18.0773 14.7305L10.5 15.9157V5.22206L17.9191 4.00625C17.9459 4.00187 17.9729 3.99966 18 3.99966C18.2761 3.99966 18.5 4.22352 18.5 4.49966V14.2366C18.5 14.4829 18.3206 14.6925 18.0773 14.7305Z" fill="black"/>
</svg>
`;

const Bookmark = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M12 14.6764L7.35472 19.3524C7.04021 19.669 6.5 19.4462 6.5 19V5C6.5 4.72386 6.72386 4.5 7 4.5H17C17.2761 4.5 17.5 4.72386 17.5 5V19C17.5 19.4462 16.9598 19.669 16.6453 19.3524L12 14.6764Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.35472 17.3524L10 12.6764L14.6453 17.3524C14.9598 17.669 15.5 17.4462 15.5 17V3C15.5 2.72386 15.2761 2.5 15 2.5H5C4.72386 2.5 4.5 2.72386 4.5 3V17C4.5 17.4462 5.04021 17.669 5.35472 17.3524ZM5.5 15.7872V3.5H14.5V15.7872L10.3547 11.6146C10.1592 11.4178 9.84081 11.4178 9.64528 11.6146L5.5 15.7872Z" fill="black"/>
</svg>
`;

const Building = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M17 18.25H19C19.4142 18.25 19.75 18.5858 19.75 19C19.75 19.4142 19.4142 19.75 19 19.75H5C4.58579 19.75 4.25 19.4142 4.25 19C4.25 18.5858 4.58579 18.25 5 18.25H7V6.30769C7 4.77168 8.10212 3.5 9.5 3.5H14.5C15.8979 3.5 17 4.77168 17 6.30769V18.25Z" fill="currentColor"/>
</g>
<path d="M2.5 18.5C2.22386 18.5 2 18.2761 2 18C2 17.7239 2.22386 17.5 2.5 17.5H18.5C18.7761 17.5 19 17.7239 19 18C19 18.2761 18.7761 18.5 18.5 18.5H2.5Z" fill="black"/>
<path d="M6.5 17.5C6.5 17.7761 6.27614 18 6 18C5.72386 18 5.5 17.7761 5.5 17.5V4.80769C5.5 3.27168 6.60212 2 8 2H13C14.3979 2 15.5 3.27168 15.5 4.80769V17.5C15.5 17.7761 15.2761 18 15 18C14.7239 18 14.5 17.7761 14.5 17.5V4.80769C14.5 3.7947 13.8113 3 13 3H8C7.18874 3 6.5 3.7947 6.5 4.80769V17.5Z" fill="black"/>
<path d="M8.5 4.5H9.5C9.77614 4.5 10 4.72386 10 5V6C10 6.27614 9.77614 6.5 9.5 6.5H8.5C8.22386 6.5 8 6.27614 8 6V5C8 4.72386 8.22386 4.5 8.5 4.5Z" fill="black"/>
<path d="M11.5 4.5H12.5C12.7761 4.5 13 4.72386 13 5V6C13 6.27614 12.7761 6.5 12.5 6.5H11.5C11.2239 6.5 11 6.27614 11 6V5C11 4.72386 11.2239 4.5 11.5 4.5Z" fill="black"/>
<path d="M11.5 7.5H12.5C12.7761 7.5 13 7.72386 13 8V9C13 9.27614 12.7761 9.5 12.5 9.5H11.5C11.2239 9.5 11 9.27614 11 9V8C11 7.72386 11.2239 7.5 11.5 7.5Z" fill="black"/>
<path d="M11.5 10.5H12.5C12.7761 10.5 13 10.7239 13 11V12C13 12.2761 12.7761 12.5 12.5 12.5H11.5C11.2239 12.5 11 12.2761 11 12V11C11 10.7239 11.2239 10.5 11.5 10.5Z" fill="black"/>
<path d="M11.5 13.5H12.5C12.7761 13.5 13 13.7239 13 14V15C13 15.2761 12.7761 15.5 12.5 15.5H11.5C11.2239 15.5 11 15.2761 11 15V14C11 13.7239 11.2239 13.5 11.5 13.5Z" fill="black"/>
<path d="M8.5 7.5H9.5C9.77614 7.5 10 7.72386 10 8V9C10 9.27614 9.77614 9.5 9.5 9.5H8.5C8.22386 9.5 8 9.27614 8 9V8C8 7.72386 8.22386 7.5 8.5 7.5Z" fill="black"/>
<path d="M8.5 13.5H9.5C9.77614 13.5 10 13.7239 10 14V15C10 15.2761 9.77614 15.5 9.5 15.5H8.5C8.22386 15.5 8 15.2761 8 15V14C8 13.7239 8.22386 13.5 8.5 13.5Z" fill="black"/>
<path d="M8.5 10.5H9.5C9.77614 10.5 10 10.7239 10 11V12C10 12.2761 9.77614 12.5 9.5 12.5H8.5C8.22386 12.5 8 12.2761 8 12V11C8 10.7239 8.22386 10.5 8.5 10.5Z" fill="black"/>
</svg>
`;

const Calculator = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path opacity="0.8" fill-rule="evenodd" clip-rule="evenodd" d="M4 18.1053L4 3.89474C4 2.8483 4.86558 2 5.93333 2H16.5667C17.6344 2 18.5 2.8483 18.5 3.89474V18.1053C18.5 19.1517 17.6344 20 16.5667 20H5.93333C4.86558 20 4 19.1517 4 18.1053Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.5 3V17C2.5 18.3807 3.61929 19.5 5 19.5H15C16.3807 19.5 17.5 18.3807 17.5 17V3C17.5 1.61929 16.3807 0.5 15 0.5H5C3.61929 0.5 2.5 1.61929 2.5 3ZM5 18.5C4.17157 18.5 3.5 17.8284 3.5 17V3C3.5 2.17157 4.17157 1.5 5 1.5H15C15.8284 1.5 16.5 2.17157 16.5 3V17C16.5 17.8284 15.8284 18.5 15 18.5H5Z" fill="black"/>
<path d="M5 7.5V3.5C5 3.22386 5.22386 3 5.5 3H14.5C14.7761 3 15 3.22386 15 3.5V7.5C15 7.77614 14.7761 8 14.5 8H5.5C5.22386 8 5 7.77614 5 7.5Z" fill="black"/>
<path d="M12 15.7V10.8C12 10.3582 12.3582 10 12.8 10H14.2C14.6418 10 15 10.3582 15 10.8V15.7C15 16.1418 14.6418 16.5 14.2 16.5H12.8C12.3582 16.5 12 16.1418 12 15.7Z" fill="black"/>
<path d="M5 12V10.5C5 10.2239 5.22386 10 5.5 10H7C7.27614 10 7.5 10.2239 7.5 10.5V12C7.5 12.2761 7.27614 12.5 7 12.5H5.5C5.22386 12.5 5 12.2761 5 12Z" fill="black"/>
<path d="M8.5 12V10.5C8.5 10.2239 8.72386 10 9 10H10.5C10.7761 10 11 10.2239 11 10.5V12C11 12.2761 10.7761 12.5 10.5 12.5H9C8.72386 12.5 8.5 12.2761 8.5 12Z" fill="black"/>
<path d="M5 16V14.5C5 14.2239 5.22386 14 5.5 14H7C7.27614 14 7.5 14.2239 7.5 14.5V16C7.5 16.2761 7.27614 16.5 7 16.5H5.5C5.22386 16.5 5 16.2761 5 16Z" fill="black"/>
<path d="M8.5 16V14.5C8.5 14.2239 8.72386 14 9 14H10.5C10.7761 14 11 14.2239 11 14.5V16C11 16.2761 10.7761 16.5 10.5 16.5H9C8.72386 16.5 8.5 16.2761 8.5 16Z" fill="black"/>
</svg>
`;

const Calendar = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect opacity="0.8" x="5" y="6" width="14" height="12" rx="1" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M16.5 4.5H3.5C3.22386 4.5 3 4.72386 3 5V16C3 16.2761 3.22386 16.5 3.5 16.5H16.5C16.7761 16.5 17 16.2761 17 16V5C17 4.72386 16.7761 4.5 16.5 4.5ZM4 15.5V5.5H16V15.5H4Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M16.5 4.5H3.5C3.22386 4.5 3 4.72386 3 5V8C3 8.27614 3.22386 8.5 3.5 8.5H16.5C16.7761 8.5 17 8.27614 17 8V5C17 4.72386 16.7761 4.5 16.5 4.5ZM4 7.5V5.5H16V7.5H4Z" fill="black"/>
<path d="M5.5 5.5H6.5C6.77614 5.5 7 5.27614 7 5V4C7 3.72386 6.77614 3.5 6.5 3.5H5.5C5.22386 3.5 5 3.72386 5 4V5C5 5.27614 5.22386 5.5 5.5 5.5Z" fill="black"/>
<path d="M13.5 5.5H14.5C14.7761 5.5 15 5.27614 15 5V4C15 3.72386 14.7761 3.5 14.5 3.5H13.5C13.2239 3.5 13 3.72386 13 4V5C13 5.27614 13.2239 5.5 13.5 5.5Z" fill="black"/>
<path d="M6 11.5C5.44772 11.5 5 11.0523 5 10.5C5 9.94772 5.44772 9.5 6 9.5C6.55228 9.5 7 9.94772 7 10.5C7 11.0523 6.55228 11.5 6 11.5Z" fill="black"/>
</svg>
`;

const Camera = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13 6.5H7C5.61929 6.5 4.5 7.61929 4.5 9V14C4.5 15.3807 5.61929 16.5 7 16.5H13C14.3807 16.5 15.5 15.3807 15.5 14V13.9759L17.8477 15.541C18.1799 15.7625 18.625 15.5243 18.625 15.125V8.125C18.625 7.72565 18.1799 7.48746 17.8477 7.70897L15.5 9.27408V9C15.5 7.61929 14.3807 6.5 13 6.5Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11 4.5H5C3.61929 4.5 2.5 5.61929 2.5 7V12C2.5 13.3807 3.61929 14.5 5 14.5H11C12.3807 14.5 13.5 13.3807 13.5 12V7C13.5 5.61929 12.3807 4.5 11 4.5ZM3.5 7C3.5 6.17157 4.17157 5.5 5 5.5H11C11.8284 5.5 12.5 6.17157 12.5 7V12C12.5 12.8284 11.8284 13.5 11 13.5H5C4.17157 13.5 3.5 12.8284 3.5 12V7Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15.7275 5.58078L12.7507 7.5157C12.6104 7.60692 12.525 7.76231 12.5232 7.92968L12.4958 10.542C12.494 10.7131 12.5799 10.8732 12.7233 10.9665L15.7275 12.9192C16.0601 13.1354 16.5 12.8967 16.5 12.5V6C16.5 5.60328 16.0601 5.36457 15.7275 5.58078ZM15.5 11.5787L13.4987 10.2778L13.5204 8.20811L15.5 6.92134V11.5787Z" fill="black"/>
</svg>
`;

const Can = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M9 3H14C15.6667 3.66667 16.6667 4.66667 17 6V16C17 17.6569 15.6569 19 14 19H9C7.34315 19 6 17.6569 6 16V6C6.33333 4.66667 7.33333 3.66667 9 3Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.5 2H7.5C5.83333 2.66667 4.83333 3.66667 4.5 5V15C4.5 16.6569 5.84315 18 7.5 18H12.5C14.1569 18 15.5 16.6569 15.5 15V5C15.1667 3.66667 14.1667 2.66667 12.5 2ZM5.5 15V5.13263C5.76428 4.2329 6.46901 3.52753 7.69872 3H12.3013C13.531 3.52753 14.2357 4.2329 14.5 5.13263V15C14.5 16.1046 13.6046 17 12.5 17H7.5C6.39543 17 5.5 16.1046 5.5 15Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M7 9.5C7 11.7091 8.79086 13.5 11 13.5C13.2091 13.5 15 11.7091 15 9.5C15 7.29086 13.2091 5.5 11 5.5C8.79086 5.5 7 7.29086 7 9.5ZM14 9.5C14 11.1569 12.6569 12.5 11 12.5C9.34315 12.5 8 11.1569 8 9.5C8 7.84315 9.34315 6.5 11 6.5C12.6569 6.5 14 7.84315 14 9.5Z" fill="black"/>
<path d="M12.074 6.50549L13.0605 6.66932C12.8934 7.67545 12.3874 8.60748 11.5554 9.45909C10.7241 10.3101 9.59116 10.9196 8.16632 11.2925L7.91317 10.325C9.17196 9.99565 10.1444 9.47247 10.8401 8.76028C11.5353 8.0487 11.9422 7.29921 12.074 6.50549Z" fill="black"/>
<path d="M13.342 7.61187C13.3008 7.3388 13.4889 7.08411 13.762 7.04301C14.035 7.0019 14.2897 7.18994 14.3308 7.46301C14.492 8.53379 14.3614 9.40881 13.9145 10.0712C13.3957 10.84 12.6016 11.2783 11.834 11.4795C11.7433 11.5033 11.6048 11.5346 11.3885 11.5813C11.2817 11.6043 10.8578 11.6945 10.7761 11.712C10.7206 11.7239 10.7206 11.7239 10.6653 11.7358C10.3994 11.7933 10.1986 11.8385 10.0432 11.8767C9.81481 11.9327 9.3984 12.0609 8.80309 12.259C8.54108 12.3462 8.25798 12.2045 8.17078 11.9425C8.08357 11.6805 8.22528 11.3974 8.48729 11.3102C9.10681 11.104 9.54295 10.9698 9.80484 10.9055C9.9714 10.8646 10.1799 10.8176 10.4542 10.7584C10.5103 10.7463 10.5103 10.7463 10.5665 10.7342C10.6495 10.7164 11.0726 10.6264 11.1777 10.6038C11.3794 10.5603 11.5089 10.5309 11.5805 10.5122C12.1353 10.3668 12.7303 10.0384 13.0855 9.51186C13.3752 9.08259 13.4689 8.45488 13.342 7.61187Z" fill="black"/>
</svg>
`;

const Car = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.27323 4.00237C6.54965 4.17438 5.98127 4.73371 5.79768 5.45445L4.60127 10.1512C3.68774 10.336 3 11.1434 3 12.1115V15C3 15.8061 3.4769 16.5008 4.16395 16.8174C4.05913 17.0222 4 17.2542 4 17.5V18.5C4 19.3284 4.67157 20 5.5 20C6.32843 20 7 19.3284 7 18.5V17.5C7 17.3247 6.96992 17.1564 6.91465 17H16.0854C16.0301 17.1564 16 17.3247 16 17.5V18.5C16 19.3284 16.6716 20 17.5 20C18.3284 20 19 19.3284 19 18.5V17.5C19 17.2542 18.9409 17.0222 18.836 16.8174C19.5231 16.5008 20 15.8061 20 15V12.1115C20 11.1434 19.3123 10.336 18.3987 10.1512L17.2023 5.45433C17.0187 4.73367 16.4504 4.17437 15.7269 4.00229C14.3193 3.66752 12.9103 3.5 11.5007 3.5C10.0911 3.5 8.68164 3.66755 7.27323 4.00237Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.29768 3.95445L3.10127 8.65122C2.18774 8.83604 1.5 9.64344 1.5 10.6115V13.5C1.5 14.6046 2.39543 15.5 3.5 15.5L16.5 15.5C17.6046 15.5 18.5 14.6046 18.5 13.5V10.6115C18.5 9.64344 17.8123 8.83604 16.8987 8.65122L15.7023 3.95433C15.5187 3.23367 14.9504 2.67437 14.2269 2.50229C12.8193 2.16752 11.4103 2 10.0007 2C8.59105 2 7.18164 2.16755 5.77323 2.50237C5.04965 2.67438 4.48127 3.23371 4.29768 3.95445ZM3.5 9.61147C3.72861 9.61147 3.9281 9.45643 3.98453 9.2349L5.26673 4.2013C5.35853 3.84093 5.64272 3.56126 6.00452 3.47525C7.33767 3.15832 8.66949 3 10.0007 3C11.3318 3 12.6632 3.15829 13.9955 3.47515C14.3573 3.56119 14.6414 3.84085 14.7332 4.20118L16.0155 9.2349C16.0719 9.45643 16.2714 9.61147 16.5 9.61147C17.0523 9.61147 17.5 10.0592 17.5 10.6115V13.5C17.5 14.0523 17.0523 14.5 16.5 14.5H3.5C2.94772 14.5 2.5 14.0523 2.5 13.5V10.6115C2.5 10.0592 2.94772 9.61147 3.5 9.61147Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 16C5.5 15.1716 4.82843 14.5 4 14.5C3.17157 14.5 2.5 15.1716 2.5 16V17C2.5 17.8284 3.17157 18.5 4 18.5C4.82843 18.5 5.5 17.8284 5.5 17V16ZM3.5 16C3.5 15.7239 3.72386 15.5 4 15.5C4.27614 15.5 4.5 15.7239 4.5 16V17C4.5 17.2761 4.27614 17.5 4 17.5C3.72386 17.5 3.5 17.2761 3.5 17V16Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M17.5 16C17.5 15.1716 16.8284 14.5 16 14.5C15.1716 14.5 14.5 15.1716 14.5 16V17C14.5 17.8284 15.1716 18.5 16 18.5C16.8284 18.5 17.5 17.8284 17.5 17V16ZM15.5 16C15.5 15.7239 15.7239 15.5 16 15.5C16.2761 15.5 16.5 15.7239 16.5 16V17C16.5 17.2761 16.2761 17.5 16 17.5C15.7239 17.5 15.5 17.2761 15.5 17V16Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15 13.5C15.8284 13.5 16.5 12.8284 16.5 12C16.5 11.1716 15.8284 10.5 15 10.5C14.1716 10.5 13.5 11.1716 13.5 12C13.5 12.8284 14.1716 13.5 15 13.5ZM15 11.5C15.2761 11.5 15.5 11.7239 15.5 12C15.5 12.2761 15.2761 12.5 15 12.5C14.7239 12.5 14.5 12.2761 14.5 12C14.5 11.7239 14.7239 11.5 15 11.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5 13.5C5.82843 13.5 6.5 12.8284 6.5 12C6.5 11.1716 5.82843 10.5 5 10.5C4.17157 10.5 3.5 11.1716 3.5 12C3.5 12.8284 4.17157 13.5 5 13.5ZM5 11.5C5.27614 11.5 5.5 11.7239 5.5 12C5.5 12.2761 5.27614 12.5 5 12.5C4.72386 12.5 4.5 12.2761 4.5 12C4.5 11.7239 4.72386 11.5 5 11.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.6476 4.5H7.35208C6.66122 4.5 6.05972 4.97186 5.89522 5.64284L5.4049 7.64284C5.37625 7.75973 5.36176 7.87965 5.36176 8C5.36176 8.82843 6.03334 9.5 6.86176 9.5H13.1379C13.2582 9.5 13.3782 9.48552 13.495 9.45686C14.2996 9.2596 14.792 8.44744 14.5947 7.64284L14.1044 5.64284C13.9399 4.97186 13.3384 4.5 12.6476 4.5ZM6.86646 5.88095C6.92129 5.65729 7.12179 5.5 7.35208 5.5H12.6476C12.8779 5.5 13.0784 5.65729 13.1332 5.88095L13.6235 7.88095C13.6893 8.14915 13.5251 8.41987 13.2569 8.48562C13.218 8.49517 13.178 8.5 13.1379 8.5H6.86176C6.58562 8.5 6.36176 8.27614 6.36176 8C6.36176 7.95988 6.36659 7.91991 6.37614 7.88095L6.86646 5.88095Z" fill="black"/>
</svg>
`;

const Cart = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.21893 2.75H4.2C3.78579 2.75 3.45 2.41421 3.45 2C3.45 1.58579 3.78579 1.25 4.2 1.25H5.80284C6.14621 1.25 6.44573 1.48319 6.52994 1.81608L8.03184 7.7535C8.19308 7.66344 8.36948 7.59443 8.5583 7.55091C8.70507 7.51708 8.85517 7.5 9.00574 7.5H16.9946C18.1032 7.5 19 8.40519 19 9.51948C19 9.67043 18.9832 9.82091 18.9499 9.96809L18.1669 13.4291C17.9591 14.3474 17.1482 15 16.2115 15H9.78879C8.85212 15 8.04122 14.3474 7.83348 13.4291L7.05044 9.96809C7.0395 9.91977 7.03039 9.87144 7.02305 9.8232C7.00217 9.77935 6.98527 9.73281 6.9729 9.68392L5.21893 2.75ZM9.25 18.5C10.2165 18.5 11 17.7165 11 16.75C11 15.7835 10.2165 15 9.25 15C8.2835 15 7.5 15.7835 7.5 16.75C7.5 17.7165 8.2835 18.5 9.25 18.5ZM16.25 18.5C17.2165 18.5 18 17.7165 18 16.75C18 15.7835 17.2165 15 16.25 15C15.2835 15 14.5 15.7835 14.5 16.75C14.5 17.7165 15.2835 18.5 16.25 18.5Z" fill="currentColor"/>
</g>
<path d="M3.71231 2.5L2.5 2.5C2.22386 2.5 2 2.27614 2 2C2 1.72386 2.22386 1.5 2.5 1.5L4.10284 1.5C4.33234 1.5 4.53237 1.65624 4.58795 1.8789L6.48511 9.4789C6.55199 9.74682 6.38902 10.0182 6.1211 10.0851C5.85318 10.152 5.58177 9.98902 5.51489 9.7211L3.71231 2.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15.4946 7.5H7.50575C7.35517 7.5 7.20507 7.51708 7.0583 7.55091C5.97851 7.79979 5.30478 8.88231 5.55044 9.96809L6.33348 13.4291C6.54122 14.3474 7.35212 15 8.28879 15H14.7115C15.6482 15 16.4591 14.3474 16.6669 13.4291L17.4499 9.96809C17.4832 9.82091 17.5 9.67043 17.5 9.51948C17.5 8.40519 16.6032 7.5 15.4946 7.5ZM7.2829 8.52536C7.35602 8.5085 7.43077 8.5 7.50575 8.5H15.4946C16.0488 8.5 16.5 8.9554 16.5 9.51948C16.5 9.5962 16.4915 9.67266 16.4745 9.74743L15.6915 13.2085C15.5865 13.6724 15.1795 14 14.7115 14H8.28879C7.82086 14 7.41379 13.6724 7.30883 13.2085L6.52579 9.74743C6.40125 9.19696 6.74158 8.65013 7.2829 8.52536Z" fill="black"/>
<path d="M17 16.75C17 17.7165 16.2165 18.5 15.25 18.5C14.2835 18.5 13.5 17.7165 13.5 16.75C13.5 15.7835 14.2835 15 15.25 15C16.2165 15 17 15.7835 17 16.75Z" fill="black"/>
<path d="M10 16.75C10 17.7165 9.2165 18.5 8.25 18.5C7.2835 18.5 6.5 17.7165 6.5 16.75C6.5 15.7835 7.2835 15 8.25 15C9.2165 15 10 15.7835 10 16.75Z" fill="black"/>
</svg>
`;

const Checkmark = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.8699 17.1228L17.8112 8.22845C18.7825 6.48013 16.1601 5.0232 15.1888 6.77152L11.0509 14.2197L7.43705 11.3287C5.87531 10.0793 4.00122 12.4219 5.56296 13.6713L10.4686 17.5958C10.524 17.6454 10.5829 17.6914 10.6446 17.7332C11.0317 18.0105 11.4337 18.0749 11.7947 17.9963C12.1586 17.9321 12.5062 17.7201 12.7591 17.3167C12.8004 17.2546 12.8375 17.1897 12.8699 17.1228Z" fill="currentColor"/>
</g>
<path d="M14.9371 5.74286L9.93707 14.7429C9.61331 15.3256 8.73916 14.84 9.06292 14.2572L14.0629 5.25721C14.3867 4.67444 15.2608 5.16009 14.9371 5.74286Z" fill="black"/>
<path d="M4.81235 10.1097L9.81235 14.1097C10.3329 14.5261 9.70823 15.307 9.18765 14.8905L4.18765 10.8905C3.66707 10.4741 4.29177 9.6932 4.81235 10.1097Z" fill="black"/>
</svg>
`;

const Circle = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle opacity="0.8" cx="12" cy="11" r="6" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M4 10C4 13.3137 6.68629 16 10 16C13.3137 16 16 13.3137 16 10C16 6.68629 13.3137 4 10 4C6.68629 4 4 6.68629 4 10ZM15 10C15 12.7614 12.7614 15 10 15C7.23858 15 5 12.7614 5 10C5 7.23858 7.23858 5 10 5C12.7614 5 15 7.23858 15 10Z" fill="black"/>
</svg>
`;

const Clipboard = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M14.75 5.23333H17C17.2761 5.23333 17.5 5.45719 17.5 5.73333V17C17.5 17.2761 17.2761 17.5 17 17.5H6C5.72386 17.5 5.5 17.2761 5.5 17V5.73333C5.5 5.45719 5.72386 5.23333 6 5.23333H8.25V4C8.25 3.72386 8.47386 3.5 8.75 3.5H14.25C14.5261 3.5 14.75 3.72386 14.75 4V5.23333Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M13 2.25H6C5.72386 2.25 5.5 2.47386 5.5 2.75V5.75C5.5 6.02614 5.72386 6.25 6 6.25H13C13.2761 6.25 13.5 6.02614 13.5 5.75V2.75C13.5 2.47386 13.2761 2.25 13 2.25ZM6.5 5.25V3.25H12.5V5.25H6.5Z" fill="black"/>
<path d="M14.5 4.5H12.9926V3.5H15C15.2761 3.5 15.5 3.72386 15.5 4V16C15.5 16.2761 15.2761 16.5 15 16.5H4C3.72386 16.5 3.5 16.2761 3.5 16V4C3.5 3.72386 3.72386 3.5 4 3.5H6.01025V4.5H4.5V15.5H14.5V4.5Z" fill="black"/>
</svg>
`;

const Clock = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle opacity="0.8" cx="12" cy="11" r="7" fill="currentColor"/>
<path d="M10.1354 12.3796C9.92573 12.5593 9.61008 12.5351 9.43037 12.3254C9.25066 12.1157 9.27494 11.8001 9.4846 11.6204L12.9846 8.62038C13.1943 8.44067 13.5099 8.46495 13.6896 8.67461C13.8693 8.88428 13.8451 9.19993 13.6354 9.37964L10.1354 12.3796Z" fill="black"/>
<path d="M9.31 6C9.31 5.72386 9.53386 5.5 9.81 5.5C10.0861 5.5 10.31 5.72386 10.31 6V12C10.31 12.2761 10.0861 12.5 9.81 12.5C9.53386 12.5 9.31 12.2761 9.31 12V6Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M3 10C3 13.866 6.13401 17 10 17C13.866 17 17 13.866 17 10C17 6.13401 13.866 3 10 3C6.13401 3 3 6.13401 3 10ZM16 10C16 13.3137 13.3137 16 10 16C6.68629 16 4 13.3137 4 10C4 6.68629 6.68629 4 10 4C13.3137 4 16 6.68629 16 10Z" fill="black"/>
</svg>
`;

const Cloud = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13 4H12C10.1362 4 8.57006 5.27477 8.12602 7H8C5.79086 7 4 8.79086 4 11C4 13.2091 5.79086 15 8 15H16C18.2091 15 20 13.2091 20 11C20 9.09985 18.6751 7.50915 16.8987 7.10135C16.4909 5.32493 14.9002 4 13 4Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 3H9C7.13616 3 5.57006 4.27477 5.12602 6H5C2.79086 6 1 7.79086 1 10C1 12.2091 2.79086 14 5 14H13C15.2091 14 17 12.2091 17 10C17 8.09985 15.6751 6.50915 13.8987 6.10135C13.4909 4.32493 11.9002 3 10 3ZM5.90123 7L6.09445 6.24926C6.43255 4.93565 7.62326 4 9 4H10C11.4053 4 12.614 4.97458 12.924 6.32509L13.0642 6.9358L13.6749 7.07599C15.0254 7.38602 16 8.59467 16 10C16 11.6569 14.6569 13 13 13H5C3.34315 13 2 11.6569 2 10C2 8.34315 3.34315 7 5 7H5.90123Z" fill="black"/>
</svg>
`;

const CloudDown = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13 4H12C10.1362 4 8.57006 5.27477 8.12602 7H8C5.79086 7 4 8.79086 4 11C4 13.2091 5.79086 15 8 15H16C18.2091 15 20 13.2091 20 11C20 9.09985 18.6751 7.50915 16.8987 7.10135C16.4909 5.32493 14.9002 4 13 4Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 3H9C7.13616 3 5.57006 4.27477 5.12602 6H5C2.79086 6 1 7.79086 1 10C1 12.2091 2.79086 14 5 14H13C15.2091 14 17 12.2091 17 10C17 8.09985 15.6751 6.50915 13.8987 6.10135C13.4909 4.32493 11.9002 3 10 3ZM5.90123 7L6.09445 6.24926C6.43255 4.93565 7.62326 4 9 4H10C11.4053 4 12.614 4.97458 12.924 6.32509L13.0642 6.9358L13.6749 7.07599C15.0254 7.38602 16 8.59467 16 10C16 11.6569 14.6569 13 13 13H5C3.34315 13 2 11.6569 2 10C2 8.34315 3.34315 7 5 7H5.90123Z" fill="black"/>
<path d="M9 10C9 9.72386 9.22386 9.5 9.5 9.5C9.77614 9.5 10 9.72386 10 10L10 17.5C10 17.7761 9.77614 18 9.5 18C9.22386 18 9 17.7761 9 17.5V10Z" fill="black"/>
<path d="M11.6876 15.1095C11.9033 14.937 12.2179 14.972 12.3904 15.1876C12.5629 15.4033 12.528 15.7179 12.3123 15.8904L9.81234 17.8904C9.59671 18.0629 9.28207 18.028 9.10956 17.8123C8.93706 17.5967 8.97202 17.2821 9.18765 17.1095L11.6876 15.1095Z" fill="black"/>
<path d="M6.68765 15.8904C6.47202 15.7179 6.43706 15.4033 6.60956 15.1876C6.78207 14.972 7.09671 14.937 7.31234 15.1095L9.81234 17.1095C10.028 17.2821 10.0629 17.5967 9.89043 17.8123C9.71793 18.028 9.40328 18.0629 9.18765 17.8904L6.68765 15.8904Z" fill="black"/>
</svg>
`;

const CloudUp = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13 4H12C10.1362 4 8.57006 5.27477 8.12602 7H8C5.79086 7 4 8.79086 4 11C4 13.2091 5.79086 15 8 15H16C18.2091 15 20 13.2091 20 11C20 9.09985 18.6751 7.50915 16.8987 7.10135C16.4909 5.32493 14.9002 4 13 4Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 3H9C7.13616 3 5.57006 4.27477 5.12602 6H5C2.79086 6 1 7.79086 1 10C1 12.2091 2.79086 14 5 14H13C15.2091 14 17 12.2091 17 10C17 8.09985 15.6751 6.50915 13.8987 6.10135C13.4909 4.32493 11.9002 3 10 3ZM5.90123 7L6.09445 6.24926C6.43255 4.93565 7.62326 4 9 4H10C11.4053 4 12.614 4.97458 12.924 6.32509L13.0642 6.9358L13.6749 7.07599C15.0254 7.38602 16 8.59467 16 10C16 11.6569 14.6569 13 13 13H5C3.34315 13 2 11.6569 2 10C2 8.34315 3.34315 7 5 7H5.90123Z" fill="black"/>
<path d="M10 16.5C10 16.7761 9.77614 17 9.5 17C9.22386 17 9 16.7761 9 16.5V9C9 8.72386 9.22386 8.5 9.5 8.5C9.77614 8.5 10 8.72386 10 9V16.5Z" fill="black"/>
<path d="M7.31234 11.3905C7.0967 11.563 6.78206 11.528 6.60955 11.3124C6.43705 11.0967 6.47201 10.7821 6.68764 10.6096L9.18764 8.60958C9.40327 8.43708 9.71792 8.47204 9.89042 8.68767C10.0629 8.9033 10.028 9.21795 9.81234 9.39045L7.31234 11.3905Z" fill="black"/>
<path d="M12.3123 10.6096C12.528 10.7821 12.5629 11.0967 12.3904 11.3124C12.2179 11.528 11.9033 11.563 11.6876 11.3905L9.18764 9.39045C8.97201 9.21795 8.93705 8.9033 9.10955 8.68767C9.28206 8.47204 9.5967 8.43708 9.81234 8.60958L12.3123 10.6096Z" fill="black"/>
</svg>
`;

const Coctail = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.75 18.0241V12.9271L18.8664 6.34023C19.1635 6.0203 18.9366 5.5 18.5 5.5H5.5C5.06342 5.5 4.83653 6.0203 5.1336 6.34023L11.25 12.9271V18.0241C9.1328 18.1626 7.5 18.8897 7.5 20H16.5C16.5 18.8897 14.8672 18.1626 12.75 18.0241Z" fill="currentColor"/>
</g>
<path d="M6 8C5.72386 8 5.5 7.77614 5.5 7.5C5.5 7.22386 5.72386 7 6 7H14C14.2761 7 14.5 7.22386 14.5 7.5C14.5 7.77614 14.2761 8 14 8H6Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.13361 5.34023L9.63361 12.3402C9.83142 12.5533 10.1686 12.5533 10.3664 12.3402L16.8664 5.34023C17.1635 5.0203 16.9366 4.5 16.5 4.5L3.5 4.5C3.06342 4.5 2.83653 5.0203 3.13361 5.34023ZM4.64661 5.5L15.3534 5.5L10 11.2652L4.64661 5.5Z" fill="black"/>
<path d="M9.5 11.875H10.5L10.625 12V18L10.5 18.125H9.5L9.375 18V12L9.5 11.875Z" fill="black"/>
<path d="M14.5 20H5.5C5.5 18.5251 7.55015 17.5 10 17.5C12.4499 17.5 14.5 18.5251 14.5 20Z" fill="black"/>
<path d="M12.8787 1.56669C12.6108 1.49971 12.448 1.22825 12.5149 0.960348C12.5819 0.69245 12.8534 0.52957 13.1213 0.596544L17.1213 1.59654C17.3892 1.66352 17.552 1.93499 17.4851 2.20288C17.4181 2.47078 17.1466 2.63366 16.8787 2.56669L12.8787 1.56669Z" fill="black"/>
<path d="M10.2031 9.74651C10.1086 10.006 9.82165 10.1398 9.56217 10.0453C9.3027 9.9508 9.16893 9.66387 9.26341 9.40439L12.356 0.910556C12.4505 0.651077 12.7374 0.517316 12.9969 0.611791C13.2563 0.706266 13.3901 0.993202 13.2956 1.25268L10.2031 9.74651Z" fill="black"/>
</svg>
`;

const ColorPicker = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path opacity="0.8" d="M17.9277 3.76777C18.904 4.74409 18.7457 6.48529 17.5741 7.65686L8.59932 16.6317C8.5026 16.7284 8.39037 16.8076 8.26958 16.8642C7.89323 17.0409 7.50719 17.2555 6.59243 17.7851C6.13999 18.047 5.9403 18.1616 5.69637 18.2979C4.02272 19.2327 3.40316 19.4773 2.81068 18.8848C2.21916 18.2933 2.46329 17.6732 3.39243 16.0084C3.52991 15.762 3.6457 15.5603 3.91039 15.103C4.43992 14.1883 4.65456 13.8022 4.83121 13.4259C4.88791 13.3051 4.96706 13.1929 5.06378 13.0961L14.0386 4.12133C15.2102 2.94976 16.9514 2.79146 17.9277 3.76777Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M16.3241 6.71747C17.3004 5.74116 17.3004 4.15825 16.3241 3.18194C15.3478 2.20563 13.7649 2.20563 12.7886 3.18194L3.81377 12.1568L3.70235 12.3265C3.53711 12.7444 3.33628 13.1544 2.83667 14.1244C1.58212 16.56 1.38156 17.0592 1.91422 17.5918C2.44688 18.1245 2.94605 17.9239 5.38168 16.6694C6.35163 16.1698 6.76163 15.969 7.17958 15.8037L7.34931 15.6923L16.3241 6.71747ZM15.617 3.88905C16.2028 4.47483 16.2028 5.42458 15.617 6.01037L6.71449 14.9129C6.28794 15.087 5.85619 15.3001 4.92377 15.7804C3.97452 16.2693 3.57257 16.4667 3.15837 16.6331C2.98658 16.7021 2.84068 16.7521 2.7234 16.7827C2.75396 16.6654 2.80393 16.5195 2.87295 16.3477C3.03938 15.9335 3.23673 15.5315 3.72567 14.5823C4.20595 13.6499 4.41909 13.2181 4.59317 12.7916L13.4957 3.88905C14.0815 3.30326 15.0312 3.30326 15.617 3.88905Z" fill="black"/>
<path d="M9.85102 3.82413C9.65576 3.62887 9.65576 3.31229 9.85102 3.11703C10.0463 2.92177 10.3629 2.92177 10.5581 3.11703L16.215 8.77388C16.4102 8.96914 16.4102 9.28573 16.215 9.48099C16.0197 9.67625 15.7031 9.67625 15.5079 9.48099L9.85102 3.82413Z" fill="black"/>
</svg>
`;

const Contract = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M13 5.5H17C17.2761 5.5 17.5 5.72386 17.5 6V10C17.5 10.2761 17.2761 10.5 17 10.5H13C12.7239 10.5 12.5 10.2761 12.5 10V6C12.5 5.72386 12.7239 5.5 13 5.5Z" fill="currentColor"/>
<path d="M7 11H11C11.5523 11 12 11.4477 12 12V16C12 16.5523 11.5523 17 11 17H7C6.44772 17 6 16.5523 6 16V12C6 11.4477 6.44772 11 7 11Z" fill="currentColor"/>
</g>
<path d="M5.35355 15.3536C5.15829 15.5488 4.84171 15.5488 4.64645 15.3536C4.45118 15.1583 4.45118 14.8417 4.64645 14.6464L8.64645 10.6464C8.84171 10.4512 9.15829 10.4512 9.35355 10.6464C9.54882 10.8417 9.54882 11.1583 9.35355 11.3536L5.35355 15.3536Z" fill="black"/>
<path d="M9.5 15C9.5 15.2761 9.27614 15.5 9 15.5C8.72386 15.5 8.5 15.2761 8.5 15V11C8.5 10.7239 8.72386 10.5 9 10.5C9.27614 10.5 9.5 10.7239 9.5 11V15Z" fill="black"/>
<path d="M5 11.5C4.72386 11.5 4.5 11.2761 4.5 11C4.5 10.7239 4.72386 10.5 5 10.5H9C9.27614 10.5 9.5 10.7239 9.5 11C9.5 11.2761 9.27614 11.5 9 11.5H5Z" fill="black"/>
<path d="M11.3536 9.35355C11.1583 9.54882 10.8417 9.54882 10.6464 9.35355C10.4512 9.15829 10.4512 8.84171 10.6464 8.64645L14.6464 4.64645C14.8417 4.45118 15.1583 4.45118 15.3536 4.64645C15.5488 4.84171 15.5488 5.15829 15.3536 5.35355L11.3536 9.35355Z" fill="black"/>
<path d="M11 9.5C10.7239 9.5 10.5 9.27614 10.5 9C10.5 8.72386 10.7239 8.5 11 8.5H15C15.2761 8.5 15.5 8.72386 15.5 9C15.5 9.27614 15.2761 9.5 15 9.5H11Z" fill="black"/>
<path d="M11.5 9C11.5 9.27614 11.2761 9.5 11 9.5C10.7239 9.5 10.5 9.27614 10.5 9V5C10.5 4.72386 10.7239 4.5 11 4.5C11.2761 4.5 11.5 4.72386 11.5 5V9Z" fill="black"/>
</svg>
`;

const Controller = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M6.5 6.5H15.5C17.9853 6.5 20 8.51472 20 11V13C20 15.4853 17.9853 17.5 15.5 17.5H6.5C4.01472 17.5 2 15.4853 2 13V11C2 8.51472 4.01472 6.5 6.5 6.5Z" fill="currentColor"/>
</g>
<path d="M12.25 10C11.5596 10 11 9.44036 11 8.75C11 8.05964 11.5596 7.5 12.25 7.5C12.9404 7.5 13.5 8.05964 13.5 8.75C13.5 9.44036 12.9404 10 12.25 10Z" fill="black"/>
<path d="M14.25 12.5C13.5596 12.5 13 11.9404 13 11.25C13 10.5596 13.5596 10 14.25 10C14.9404 10 15.5 10.5596 15.5 11.25C15.5 11.9404 14.9404 12.5 14.25 12.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.5 4.5H5.5C3.01472 4.5 1 6.51472 1 9V11C1 13.4853 3.01472 15.5 5.5 15.5H14.5C16.9853 15.5 19 13.4853 19 11V9C19 6.51472 16.9853 4.5 14.5 4.5ZM2 9C2 7.067 3.567 5.5 5.5 5.5H14.5C16.433 5.5 18 7.067 18 9V11C18 12.933 16.433 14.5 14.5 14.5H5.5C3.567 14.5 2 12.933 2 11V9Z" fill="black"/>
<path d="M4 11C3.44772 11 3 10.5523 3 10C3 9.44772 3.44772 9 4 9H8C8.55228 9 9 9.44772 9 10C9 10.5523 8.55228 11 8 11H4Z" fill="black"/>
<path d="M7 12C7 12.5523 6.55228 13 6 13C5.44772 13 5 12.5523 5 12V8C5 7.44772 5.44772 7 6 7C6.55228 7 7 7.44772 7 8V12Z" fill="black"/>
</svg>
`;

const CreditCard = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M5.5 6.5H17.5C18.8807 6.5 20 7.61929 20 9V16C20 17.3807 18.8807 18.5 17.5 18.5H5.5C4.11929 18.5 3 17.3807 3 16V9C3 7.61929 4.11929 6.5 5.5 6.5Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M16 4.5H4C2.61929 4.5 1.5 5.61929 1.5 7V14C1.5 15.3807 2.61929 16.5 4 16.5H16C17.3807 16.5 18.5 15.3807 18.5 14V7C18.5 5.61929 17.3807 4.5 16 4.5ZM2.5 7C2.5 6.17157 3.17157 5.5 4 5.5H16C16.8284 5.5 17.5 6.17157 17.5 7V14C17.5 14.8284 16.8284 15.5 16 15.5H4C3.17157 15.5 2.5 14.8284 2.5 14V7Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.5 7H17.5C17.7761 7 18 7.22386 18 7.5V8.5C18 8.77614 17.7761 9 17.5 9H2.5C2.22386 9 2 8.77614 2 8.5V7.5C2 7.22386 2.22386 7 2.5 7Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M6 10H5C4.44772 10 4 10.4477 4 11V12C4 12.5523 4.44772 13 5 13H6C6.55228 13 7 12.5523 7 12V11C7 10.4477 6.55228 10 6 10ZM5 12V11H6V12H5Z" fill="black"/>
</svg>
`;

const Cup = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M5.5 16H16.5C17.0523 16 17.5 16.4477 17.5 17C17.5 17.5523 17.0523 18 16.5 18H5.5C4.94772 18 4.5 17.5523 4.5 17C4.5 16.4477 4.94772 16 5.5 16Z" fill="currentColor"/>
<path d="M17.4778 7.20915C18.6708 7.59201 19.5 8.46066 19.5 9.5C19.5 10.9284 17.9501 12 16.1073 12C16.0589 12 16.0107 11.9993 15.9627 11.9978C14.7459 13.8773 12.9524 15 11 15C7.37379 15 4.5 11.1683 4.5 6.5C4.5 6.22386 4.72386 6 5 6H17C17.2761 6 17.5 6.22386 17.5 6.5C17.5 6.7377 17.4926 6.97422 17.4778 7.20915Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15 4.5H3C2.72386 4.5 2.5 4.72386 2.5 5C2.5 9.66828 5.37379 13.5 9 13.5C12.6262 13.5 15.5 9.66828 15.5 5C15.5 4.72386 15.2761 4.5 15 4.5ZM14.4879 5.5C14.2977 9.43156 11.8802 12.5 9 12.5C6.11981 12.5 3.70234 9.43156 3.51206 5.5H14.4879Z" fill="black"/>
<path d="M13.8622 10.3289L14.1378 9.36761C14.4407 9.45444 14.7687 9.5 15.1073 9.5C16.4597 9.5 17.5 8.78072 17.5 8C17.5 7.21928 16.4597 6.5 15.1073 6.5V5.5C16.9501 5.5 18.5 6.57158 18.5 8C18.5 9.42842 16.9501 10.5 15.1073 10.5C14.676 10.5 14.2552 10.4416 13.8622 10.3289Z" fill="black"/>
<path d="M3.5 14.75H14.5C14.9142 14.75 15.25 15.0858 15.25 15.5C15.25 15.9142 14.9142 16.25 14.5 16.25H3.5C3.08579 16.25 2.75 15.9142 2.75 15.5C2.75 15.0858 3.08579 14.75 3.5 14.75Z" fill="black"/>
</svg>
`;

const Division = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M6.5 12.5C5.67157 12.5 5 11.8284 5 11C5 10.1716 5.67157 9.5 6.5 9.5H16.5C17.3284 9.5 18 10.1716 18 11C18 11.8284 17.3284 12.5 16.5 12.5H6.5Z" fill="currentColor"/>
<circle cx="11" cy="7" r="2" fill="currentColor"/>
<circle cx="11" cy="15" r="2" fill="currentColor"/>
</g>
<path d="M5 10.5C4.72386 10.5 4.5 10.2761 4.5 10C4.5 9.72386 4.72386 9.5 5 9.5H15C15.2761 9.5 15.5 9.72386 15.5 10C15.5 10.2761 15.2761 10.5 15 10.5H5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.5 6C8.5 6.82843 9.17157 7.5 10 7.5C10.8284 7.5 11.5 6.82843 11.5 6C11.5 5.17157 10.8284 4.5 10 4.5C9.17157 4.5 8.5 5.17157 8.5 6ZM10.5 6C10.5 6.27614 10.2761 6.5 10 6.5C9.72386 6.5 9.5 6.27614 9.5 6C9.5 5.72386 9.72386 5.5 10 5.5C10.2761 5.5 10.5 5.72386 10.5 6Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.5 14C8.5 14.8284 9.17157 15.5 10 15.5C10.8284 15.5 11.5 14.8284 11.5 14C11.5 13.1716 10.8284 12.5 10 12.5C9.17157 12.5 8.5 13.1716 8.5 14ZM10.5 14C10.5 14.2761 10.2761 14.5 10 14.5C9.72386 14.5 9.5 14.2761 9.5 14C9.5 13.7239 9.72386 13.5 10 13.5C10.2761 13.5 10.5 13.7239 10.5 14Z" fill="black"/>
</svg>
`;

const DotsX = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M6.5 13C5.67157 13 5 12.3284 5 11.5C5 10.6716 5.67157 10 6.5 10H17.5C18.3284 10 19 10.6716 19 11.5C19 12.3284 18.3284 13 17.5 13H6.5Z" fill="currentColor"/>
</g>
<path d="M14 10.25C14 9.55964 14.5596 9 15.25 9C15.5814 9 15.8993 9.13173 16.1335 9.36618C16.3678 9.60063 16.4993 9.91857 16.499 10.25C16.4993 10.5814 16.3678 10.8994 16.1335 11.1338C15.8993 11.3683 15.5814 11.5 15.25 11.5C14.9185 11.5 14.6005 11.3683 14.3661 11.1339C14.1317 10.8995 14 10.5815 14 10.25H14Z" fill="black"/>
<path d="M9 10.25C9 9.55964 9.55964 9 10.25 9C10.9404 9 11.5 9.55964 11.5 10.25C11.5 10.9404 10.9404 11.5 10.25 11.5C9.55964 11.5 9 10.9404 9 10.25H9Z" fill="black"/>
<path d="M4 10.25C3.99973 9.9184 4.13135 9.6003 4.36582 9.36582C4.6003 9.13135 4.9184 8.99973 5.25 9C5.94036 9 6.5 9.55964 6.5 10.25C6.5 10.9404 5.94036 11.5 5.25 11.5C4.9184 11.5003 4.6003 11.3687 4.36582 11.1342C4.13135 10.8997 3.99973 10.5816 4 10.25H4Z" fill="black"/>
</svg>
`;

const DotsY = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M11 6.5C11 5.67157 11.6716 5 12.5 5C13.3284 5 14 5.67157 14 6.5L14 17.5C14 18.3284 13.3284 19 12.5 19C11.6716 19 11 18.3284 11 17.5L11 6.5Z" fill="currentColor"/>
</g>
<path d="M9 15.25C9 14.5596 9.55964 14 10.25 14C10.5814 14 10.8993 14.1317 11.1335 14.3662C11.3678 14.6006 11.4993 14.9186 11.499 15.25C11.4993 15.5814 11.3678 15.8994 11.1335 16.1338C10.8993 16.3683 10.5814 16.5 10.25 16.5C9.91848 16.5 9.60054 16.3683 9.36612 16.1339C9.1317 15.8995 9 15.5815 9 15.25H9Z" fill="black"/>
<path d="M9 10.25C9 9.55964 9.55964 9 10.25 9C10.9404 9 11.5 9.55964 11.5 10.25C11.5 10.9404 10.9404 11.5 10.25 11.5C9.55964 11.5 9 10.9404 9 10.25H9Z" fill="black"/>
<path d="M9 5.25C8.99973 4.9184 9.13135 4.6003 9.36582 4.36582C9.6003 4.13135 9.9184 3.99973 10.25 4C10.9404 4 11.5 4.55964 11.5 5.25C11.5 5.94036 10.9404 6.5 10.25 6.5C9.9184 6.50027 9.6003 6.36866 9.36582 6.13418C9.13135 5.8997 8.99973 5.5816 9 5.25H9Z" fill="black"/>
</svg>
`;

const Dress = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.5369 0.8076C14.1545 0.648426 13.7155 0.829394 13.5563 1.2118L12.35 4.10993C11.9475 4.00207 11.5101 4.00605 11.0846 4.1455L10.9999 4.17325L10.9156 4.14561C10.6054 4.04395 10.2767 4.01186 9.95275 4.05162C9.84916 4.06433 9.74811 4.08398 9.65001 4.11004L8.44231 1.21155C8.28299 0.8292 7.84389 0.648392 7.46154 0.807705C7.07919 0.967018 6.89838 1.40612 7.05769 1.78847L8.30769 4.78847C8.33521 4.8545 8.37106 4.91452 8.41353 4.96782C8.10234 5.40433 7.94722 5.95405 8.01767 6.52807L8.13236 7.46266C8.20459 8.05129 8.45059 8.58048 8.81514 9.00134C8.31895 9.01612 7.83367 9.15382 7.40309 9.40272C5.80865 10.3244 4.62921 11.3608 3.86476 12.5119C3.61888 12.8821 3.36958 13.2199 3.13669 13.5354C2.1223 14.9096 1.41938 15.8618 2.66806 17.2402C4.20342 18.935 7.45634 20 10.6485 20C13.8406 20 17.0206 19.3723 19.0847 17.2402C20.6128 15.6618 19.9778 14.9581 18.9898 13.8632C18.6432 13.4791 18.2532 13.0469 17.8979 12.5119C17.104 11.3164 15.9187 10.2745 14.3422 9.3863C13.9812 9.1829 13.583 9.05704 13.1729 9.01537C13.5441 8.59226 13.7948 8.05785 13.8679 7.46266L13.9826 6.52807C14.0223 6.20413 13.9902 5.8754 13.8886 5.56526C13.8168 5.34608 13.7141 5.14564 13.587 4.96718C13.6293 4.91397 13.665 4.85409 13.6924 4.78822L14.9411 1.78822C15.1003 1.40581 14.9193 0.966774 14.5369 0.8076Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.0846 3.14548L9.99993 3.17323L9.9156 3.14559C9.60545 3.04394 9.27671 3.01185 8.95275 3.0516C7.73454 3.2011 6.86817 4.30984 7.01767 5.52805L7.13236 6.46265C7.31014 7.91138 8.54051 9 10.0001 9C11.4597 9 12.6901 7.91138 12.8679 6.46265L12.9826 5.52805C13.0223 5.20411 12.9902 4.87539 12.8886 4.56524C12.5063 3.39889 11.251 2.76324 10.0846 3.14548ZM9.07455 4.04416C9.25274 4.02229 9.43355 4.03994 9.60414 4.09585L9.99991 4.22557L10.396 4.09575C11.0376 3.88551 11.7281 4.23513 11.9383 4.87667C11.9942 5.04726 12.0119 5.22807 11.99 5.40625L11.8753 6.34084C11.7591 7.28816 10.9545 8 10.0001 8C9.04569 8 8.24116 7.28816 8.12491 6.34084L8.01022 5.40625C7.928 4.73621 8.40451 4.12638 9.07455 4.04416Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.8696 8L7.90444 8.00001C7.3773 8.00001 6.85947 8.13891 6.40309 8.40272C4.80865 9.32437 3.62921 10.3608 2.86476 11.5119C2.61888 11.8821 2.36958 12.2199 2.13669 12.5354C1.1223 13.9096 0.419383 14.8618 1.66806 16.2402C3.20342 17.935 6.45634 19 9.64848 19C12.8406 19 16.0206 18.3723 18.0847 16.2402C19.6128 14.6618 18.9778 13.958 17.9898 12.8632C17.6432 12.4791 17.2532 12.0469 16.8979 11.5119C16.104 10.3164 14.9187 9.27454 13.3422 8.3863C12.8927 8.13305 12.3855 8 11.8696 8ZM6.90354 9.26848C7.20779 9.09261 7.55301 9.00001 7.90444 9.00001L11.8696 9C12.2136 9 12.5517 9.0887 12.8514 9.25753C14.2975 10.0723 15.3641 11.0099 16.0648 12.0651C16.2313 12.3157 16.4108 12.5565 16.6103 12.8011C16.6332 12.8291 16.716 12.9236 16.8296 13.0533C17.1712 13.4432 17.7914 14.1513 17.8985 14.326C18.0925 14.6424 18.0488 14.8396 17.3663 15.5446C15.7285 17.2363 13.1097 18 9.64848 18C6.65197 18 3.70161 16.9954 2.40917 15.5688C2.02828 15.1483 1.9535 14.9033 2.02458 14.626C2.08114 14.4053 2.23125 14.1252 2.51751 13.7138C2.55413 13.6612 2.67316 13.4979 2.8206 13.2957C3.07602 12.9453 3.41668 12.4781 3.56171 12.2666C3.60821 12.1989 3.65349 12.1318 3.69779 12.0651C4.36984 11.0531 5.43432 10.1178 6.90354 9.26848Z" fill="black"/>
<path d="M6.53576 1.18571C6.4332 0.929314 6.55791 0.638329 6.8143 0.535773C7.0707 0.433216 7.36168 0.557924 7.46424 0.814316L8.46424 3.31432C8.56679 3.57071 8.44209 3.86169 8.18569 3.96425C7.9293 4.06681 7.63832 3.9421 7.53576 3.68571L6.53576 1.18571Z" fill="black"/>
<path d="M12.5358 0.814316C12.6383 0.557924 12.9293 0.433216 13.1857 0.535773C13.4421 0.638329 13.5668 0.929314 13.4642 1.18571L12.4642 3.68571C12.3617 3.9421 12.0707 4.06681 11.8143 3.96425C11.5579 3.86169 11.4332 3.57071 11.5358 3.31432L12.5358 0.814316Z" fill="black"/>
<path d="M9.5 11.5C9.5 11.2239 9.72386 11 10 11C10.2761 11 10.5 11.2239 10.5 11.5V15.5C10.5 15.7761 10.2761 16 10 16C9.72386 16 9.5 15.7761 9.5 15.5V11.5Z" fill="black"/>
<path d="M7.08397 11.2227C7.23715 10.9929 7.54759 10.9308 7.77735 11.084C8.00711 11.2372 8.0692 11.5476 7.91603 11.7774L5.91602 14.7774C5.76285 15.0071 5.45241 15.0692 5.22265 14.916C4.99289 14.7629 4.9308 14.4524 5.08397 14.2227L7.08397 11.2227Z" fill="black"/>
<path d="M12.916 11.2227C12.7628 10.9929 12.4524 10.9308 12.2227 11.084C11.9929 11.2372 11.9308 11.5476 12.084 11.7774L14.084 14.7774C14.2372 15.0071 14.5476 15.0692 14.7774 14.916C15.0071 14.7629 15.0692 14.4524 14.916 14.2227L12.916 11.2227Z" fill="black"/>
</svg>
`;

const Duplicate = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M15 9H17C17.5523 9 18 9.44772 18 10V17C18 17.5523 17.5523 18 17 18H10C9.44772 18 9 17.5523 9 17V15H7C6.44772 15 6 14.5523 6 14V7C6 6.44772 6.44772 6 7 6H14C14.5523 6 15 6.44772 15 7V9Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15 7.5H8C7.72386 7.5 7.5 7.72386 7.5 8V15C7.5 15.2761 7.72386 15.5 8 15.5H15C15.2761 15.5 15.5 15.2761 15.5 15V8C15.5 7.72386 15.2761 7.5 15 7.5ZM8.5 14.5V8.5H14.5V14.5H8.5Z" fill="black"/>
<path d="M5.5 11.5H8.5V12.5H5C4.72386 12.5 4.5 12.2761 4.5 12V5C4.5 4.72386 4.72386 4.5 5 4.5H12C12.2761 4.5 12.5 4.72386 12.5 5V8.5H11.5V5.5H5.5V11.5Z" fill="black"/>
</svg>
`;

const Electricity = `<svg width="20" height="21" viewBox="0 0 20 21" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M12.1868 10H16C16.4644 10 16.6779 10.578 16.325 10.8799L11.3667 15.1213L6.34323 19.8636C5.95334 20.2317 5.33617 19.8112 5.53603 19.3136L8.47391 12H6C5.64104 12 5.39903 11.633 5.54043 11.303L8.54043 4.30304C8.61922 4.1192 8.79999 4 9 4H14C14.359 4 14.601 4.36703 14.4596 4.69696L12.1868 10Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15 8.5H11.1868L13.4596 3.19696C13.601 2.86703 13.359 2.5 13 2.5H8C7.79999 2.5 7.61922 2.6192 7.54043 2.80304L4.54043 9.80304C4.39903 10.133 4.64104 10.5 5 10.5H7.47391L4.53603 17.8136C4.33617 18.3112 4.95334 18.7317 5.34323 18.3636L10.3667 13.6213L15.325 9.37993C15.6779 9.078 15.4644 8.5 15 8.5ZM10.4286 9.5H13.6465L9.69839 12.8778L6.31274 16.0734L8.67756 10.1864C8.80953 9.85784 8.56764 9.5 8.21359 9.5H5.75827L8.3297 3.5H12.2417L9.969 8.80304C9.8276 9.13297 10.0696 9.5 10.4286 9.5Z" fill="black"/>
</svg>
`;

const Exclamation = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle opacity="0.8" cx="12" cy="11" r="7" fill="currentColor"/>
<path d="M9.5 6.5C9.5 6.22386 9.72386 6 10 6C10.2761 6 10.5 6.22386 10.5 6.5V11.5C10.5 11.7761 10.2761 12 10 12C9.72386 12 9.5 11.7761 9.5 11.5V6.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M3 10C3 13.866 6.13401 17 10 17C13.866 17 17 13.866 17 10C17 6.13401 13.866 3 10 3C6.13401 3 3 6.13401 3 10ZM16 10C16 13.3137 13.3137 16 10 16C6.68629 16 4 13.3137 4 10C4 6.68629 6.68629 4 10 4C13.3137 4 16 6.68629 16 10Z" fill="black"/>
<circle cx="10" cy="13.75" r="0.75" fill="black"/>
</svg>
`;

const Expand = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M13 5H17C17.5523 5 18 5.44772 18 6V10C18 10.5523 17.5523 11 17 11H13C12.4477 11 12 10.5523 12 10V6C12 5.44772 12.4477 5 13 5Z" fill="currentColor"/>
<path d="M7 11H11C11.5523 11 12 11.4477 12 12V16C12 16.5523 11.5523 17 11 17H7C6.44772 17 6 16.5523 6 16V12C6 11.4477 6.44772 11 7 11Z" fill="currentColor"/>
</g>
<path d="M11.3536 9.35355C11.1583 9.54882 10.8417 9.54882 10.6464 9.35355C10.4512 9.15829 10.4512 8.84171 10.6464 8.64645L14.6464 4.64645C14.8417 4.45118 15.1583 4.45118 15.3536 4.64645C15.5488 4.84171 15.5488 5.15829 15.3536 5.35355L11.3536 9.35355Z" fill="black"/>
<path d="M5.35355 15.3536C5.15829 15.5488 4.84171 15.5488 4.64645 15.3536C4.45118 15.1583 4.45118 14.8417 4.64645 14.6464L8.64645 10.6464C8.84171 10.4512 9.15829 10.4512 9.35355 10.6464C9.54882 10.8417 9.54882 11.1583 9.35355 11.3536L5.35355 15.3536Z" fill="black"/>
<path d="M5 15.5C4.72386 15.5 4.5 15.2761 4.5 15C4.5 14.7239 4.72386 14.5 5 14.5H9C9.27614 14.5 9.5 14.7239 9.5 15C9.5 15.2761 9.27614 15.5 9 15.5H5Z" fill="black"/>
<path d="M5.5 15C5.5 15.2761 5.27614 15.5 5 15.5C4.72386 15.5 4.5 15.2761 4.5 15V11C4.5 10.7239 4.72386 10.5 5 10.5C5.27614 10.5 5.5 10.7239 5.5 11V15Z" fill="black"/>
<path d="M15.5 9C15.5 9.27614 15.2761 9.5 15 9.5C14.7239 9.5 14.5 9.27614 14.5 9V5C14.5 4.72386 14.7239 4.5 15 4.5C15.2761 4.5 15.5 4.72386 15.5 5V9Z" fill="black"/>
<path d="M11 5.5C10.7239 5.5 10.5 5.27614 10.5 5C10.5 4.72386 10.7239 4.5 11 4.5H15C15.2761 4.5 15.5 4.72386 15.5 5C15.5 5.27614 15.2761 5.5 15 5.5H11Z" fill="black"/>
</svg>
`;

const Eye = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 4.5C10 3.94772 10.4477 3.5 11 3.5C11.5523 3.5 12 3.94772 12 4.5V6.53241C12.5606 6.56898 13.107 6.63604 13.634 6.73128L14.0194 4.80388C14.1278 4.26232 14.6546 3.91111 15.1961 4.01942C15.7377 4.12773 16.0889 4.65456 15.9806 5.19612L15.5722 7.23826C16.0866 7.41912 16.569 7.63048 17.0123 7.86926L18.1425 5.9855C18.4267 5.51192 19.0409 5.35836 19.5145 5.64251C19.9881 5.92666 20.1417 6.54092 19.8575 7.0145L18.6414 9.04137C19.5003 9.87952 20 10.8859 20 12C20 15.1922 15.8972 17.5 11 17.5C6.10285 17.5 2.00003 15.1922 2.00003 12C2.00003 10.8859 2.49979 9.87952 3.35866 9.04137L2.14254 7.0145C1.85839 6.54092 2.01195 5.92666 2.48553 5.64251C2.95911 5.35836 3.57337 5.51192 3.85752 5.9855L4.98777 7.86926C5.43107 7.63048 5.91349 7.41912 6.42788 7.23826L6.01945 5.19612C5.91114 4.65456 6.26235 4.12773 6.80391 4.01942C7.34547 3.91111 7.8723 4.26232 7.98061 4.80388L8.36609 6.73128C8.89305 6.63604 9.43949 6.56898 10 6.53241V4.5ZM7.99948 8.85479C5.61088 9.44952 4.00003 10.7098 4.00003 12C4.00003 13.7784 7.06065 15.5 11 15.5C14.9394 15.5 18 13.7784 18 12C18 10.7098 16.3892 9.44952 14.0006 8.85479C14.6226 9.55985 15 10.4859 15 11.5C15 13.7091 13.2092 15.5 11 15.5C8.79089 15.5 7.00003 13.7091 7.00003 11.5C7.00003 10.4859 7.37745 9.55985 7.99948 8.85479Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 16C14.6577 16 18.5 13.8387 18.5 11C18.5 8.16128 14.6577 6 10 6C5.34227 6 1.5 8.16128 1.5 11C1.5 13.8387 5.34227 16 10 16ZM10 7C14.1788 7 17.5 8.86816 17.5 11C17.5 13.1318 14.1788 15 10 15C5.82117 15 2.5 13.1318 2.5 11C2.5 8.86816 5.82117 7 10 7Z" fill="black"/>
<path d="M9.5 3.5C9.5 3.22386 9.72386 3 10 3C10.2761 3 10.5 3.22386 10.5 3.5L10.5 6.5C10.5 6.77614 10.2761 7 10 7C9.72386 7 9.5 6.77614 9.5 6.5L9.5 3.5Z" fill="black"/>
<path d="M13.5097 3.90192C13.5639 3.63114 13.8273 3.45553 14.0981 3.50968C14.3689 3.56384 14.5445 3.82725 14.4903 4.09803L13.9903 6.59803C13.9362 6.86881 13.6728 7.04442 13.402 6.99026C13.1312 6.93611 12.9556 6.6727 13.0097 6.40192L13.5097 3.90192Z" fill="black"/>
<path d="M6.49032 3.90192C6.43616 3.63114 6.17275 3.45553 5.90197 3.50968C5.63119 3.56384 5.45558 3.82725 5.50974 4.09803L6.00974 6.59803C6.06389 6.86881 6.3273 7.04442 6.59808 6.99026C6.86886 6.93611 7.04447 6.6727 6.99032 6.40192L6.49032 3.90192Z" fill="black"/>
<path d="M2.42873 5.24271C2.28666 5.00592 1.97953 4.92913 1.74274 5.07121C1.50595 5.21328 1.42916 5.52041 1.57124 5.7572L3.07124 8.2572C3.21331 8.49399 3.52044 8.57077 3.75723 8.4287C3.99402 8.28663 4.07081 7.9795 3.92873 7.74271L2.42873 5.24271Z" fill="black"/>
<path d="M17.5713 5.24271C17.7133 5.00592 18.0205 4.92913 18.2573 5.07121C18.4941 5.21328 18.5708 5.52041 18.4288 5.7572L16.9288 8.2572C16.7867 8.49399 16.4796 8.57077 16.2428 8.4287C16.006 8.28663 15.9292 7.9795 16.0713 7.74271L17.5713 5.24271Z" fill="black"/>
<path d="M13 10.5C13 12.1569 11.6569 13.5 10 13.5C8.34315 13.5 7 12.1569 7 10.5C7 8.84315 8.34315 7.5 10 7.5C11.6569 7.5 13 8.84315 13 10.5Z" fill="black"/>
</svg>
`;

const EyeClosed = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.91662 8.91032C2.46807 9.23254 2.36566 9.85737 2.68788 10.3059C2.88621 10.582 3.11912 10.8444 3.38335 11.0914L2.25999 12.3274C1.88853 12.7361 1.91872 13.3685 2.32742 13.74C2.73612 14.1115 3.36857 14.0813 3.74002 13.6726L5.04237 12.2397C5.49676 12.4749 5.9873 12.6798 6.50619 12.8521L6.02986 14.7574C5.89592 15.2932 6.22168 15.8362 6.75747 15.9701C7.29327 16.1041 7.8362 15.7783 7.97015 15.2425L8.45007 13.3228C8.95377 13.4037 9.47216 13.4577 10 13.4831V15.5C10 16.0523 10.4477 16.5 11 16.5C11.5523 16.5 12 16.0523 12 15.5V13.4424C12.5215 13.3956 13.0314 13.3207 13.5246 13.2193L13.5301 13.2425L14.0301 15.2425C14.1641 15.7783 14.707 16.1041 15.2428 15.9701C15.7786 15.8362 16.1043 15.2932 15.9704 14.7574L15.4704 12.7574C15.4619 12.7234 15.4517 12.6902 15.44 12.6579C15.8733 12.4883 16.283 12.2945 16.664 12.0782L18.2929 13.7071C18.6834 14.0976 19.3166 14.0976 19.7071 13.7071C20.0976 13.3166 20.0976 12.6834 19.7071 12.2929L18.2666 10.8523C18.4334 10.6769 18.5851 10.4946 18.7207 10.3059C19.0429 9.85737 18.9405 9.23254 18.492 8.91032C18.0434 8.5881 17.4186 8.69052 17.0964 9.13906C16.7925 9.56205 16.3238 9.96553 15.7168 10.3159C14.4234 11.0625 12.6315 11.5 10.7043 11.5C8.7771 11.5 6.98518 11.0625 5.6918 10.3159C5.08478 9.96553 4.61607 9.56205 4.31221 9.13906C3.99 8.69052 3.36517 8.5881 2.91662 8.91032Z" fill="currentColor"/>
</g>
<path d="M2.09395 8.01418C1.93285 7.78991 1.98405 7.4775 2.20833 7.31639C2.4326 7.15528 2.74501 7.20648 2.90612 7.43076C3.25413 7.91522 3.77652 8.36491 4.44183 8.74895C5.8148 9.54147 7.69284 10 9.70429 10C11.7157 10 13.5938 9.54147 14.9668 8.74895C15.6321 8.36491 16.1544 7.91522 16.5025 7.43076C16.6636 7.20648 16.976 7.15528 17.2003 7.31639C17.4245 7.4775 17.4757 7.78991 17.3146 8.01418C16.8783 8.62157 16.2486 9.16369 15.4667 9.61501C13.9345 10.4994 11.8843 11 9.70429 11C7.52432 11 5.47404 10.4994 3.9419 9.61501C3.16003 9.16369 2.53028 8.62157 2.09395 8.01418Z" fill="black"/>
<path d="M10.5 11C10.5 10.7239 10.2761 10.5 10 10.5C9.72386 10.5 9.5 10.7239 9.5 11L9.5 13.5C9.5 13.7761 9.72386 14 10 14C10.2761 14 10.5 13.7761 10.5 13.5L10.5 11Z" fill="black"/>
<path d="M6.00968 10.4019C6.06384 10.1311 6.32725 9.95553 6.59803 10.0097C6.86881 10.0638 7.04442 10.3273 6.99026 10.598L6.49026 13.098C6.43611 13.3688 6.1727 13.5444 5.90192 13.4903C5.63114 13.4361 5.45553 13.1727 5.50968 12.9019L6.00968 10.4019Z" fill="black"/>
<path d="M13.9904 10.4019C13.9362 10.1311 13.6728 9.95553 13.402 10.0097C13.1312 10.0638 12.9556 10.3273 13.0098 10.598L13.5098 13.098C13.564 13.3688 13.8274 13.5444 14.0981 13.4903C14.3689 13.4361 14.5445 13.1727 14.4904 12.9019L13.9904 10.4019Z" fill="black"/>
<path d="M16.3536 8.64645C16.1583 8.45118 15.8417 8.45118 15.6464 8.64645C15.4512 8.84171 15.4512 9.15829 15.6464 9.35355L17.6464 11.3536C17.8417 11.5488 18.1583 11.5488 18.3536 11.3536C18.5488 11.1583 18.5488 10.8417 18.3536 10.6464L16.3536 8.64645Z" fill="black"/>
<path d="M3.44776 8.66371C3.63349 8.45936 3.94971 8.44426 4.15406 8.62999C4.35841 8.81572 4.3735 9.13195 4.18777 9.3363L2.37001 11.3363C2.18428 11.5406 1.86806 11.5557 1.66371 11.37C1.45936 11.1843 1.44426 10.8681 1.62999 10.6637L3.44776 8.66371Z" fill="black"/>
</svg>
`;

const EyeOff = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 4.5C10 3.94772 10.4477 3.5 11 3.5C11.5523 3.5 12 3.94772 12 4.5V6.53241C12.5606 6.56898 13.107 6.63604 13.634 6.73128L14.0194 4.80388C14.1278 4.26232 14.6546 3.91111 15.1961 4.01942C15.7377 4.12773 16.0889 4.65456 15.9806 5.19612L15.5722 7.23826C16.0866 7.41912 16.569 7.63048 17.0123 7.86926L18.1425 5.9855C18.4267 5.51192 19.0409 5.35836 19.5145 5.64251C19.9881 5.92666 20.1417 6.54092 19.8575 7.0145L18.6414 9.04137C19.5003 9.87952 20 10.8859 20 12C20 15.1922 15.8972 17.5 11 17.5C6.10285 17.5 2.00003 15.1922 2.00003 12C2.00003 10.8859 2.49979 9.87952 3.35866 9.04137L2.14254 7.0145C1.85839 6.54092 2.01195 5.92666 2.48553 5.64251C2.95911 5.35836 3.57337 5.51192 3.85752 5.9855L4.98777 7.86926C5.43107 7.63048 5.91349 7.41912 6.42788 7.23826L6.01945 5.19612C5.91114 4.65456 6.26235 4.12773 6.80391 4.01942C7.34547 3.91111 7.8723 4.26232 7.98061 4.80388L8.36609 6.73128C8.89305 6.63604 9.43949 6.56898 10 6.53241V4.5ZM7.99948 8.85479C5.61088 9.44952 4.00003 10.7098 4.00003 12C4.00003 13.7784 7.06065 15.5 11 15.5C14.9394 15.5 18 13.7784 18 12C18 10.7098 16.3892 9.44952 14.0006 8.85479C14.6226 9.55985 15 10.4859 15 11.5C15 13.7091 13.2092 15.5 11 15.5C8.79089 15.5 7.00003 13.7091 7.00003 11.5C7.00003 10.4859 7.37745 9.55985 7.99948 8.85479Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 16C14.6577 16 18.5 13.8387 18.5 11C18.5 8.16128 14.6577 6 10 6C5.34227 6 1.5 8.16128 1.5 11C1.5 13.8387 5.34227 16 10 16ZM10 7C14.1788 7 17.5 8.86816 17.5 11C17.5 13.1318 14.1788 15 10 15C5.82117 15 2.5 13.1318 2.5 11C2.5 8.86816 5.82117 7 10 7Z" fill="black"/>
<path d="M9.5 3.5C9.5 3.22386 9.72386 3 10 3C10.2761 3 10.5 3.22386 10.5 3.5L10.5 6.5C10.5 6.77614 10.2761 7 10 7C9.72386 7 9.5 6.77614 9.5 6.5L9.5 3.5Z" fill="black"/>
<path d="M13.5097 3.90192C13.5638 3.63114 13.8273 3.45553 14.098 3.50968C14.3688 3.56384 14.5444 3.82725 14.4903 4.09803L13.9903 6.59803C13.9361 6.86881 13.6727 7.04442 13.4019 6.99026C13.1311 6.93611 12.9555 6.6727 13.0097 6.40192L13.5097 3.90192Z" fill="black"/>
<path d="M6.49032 3.90192C6.43616 3.63114 6.17275 3.45553 5.90197 3.50968C5.63119 3.56384 5.45558 3.82725 5.50974 4.09803L6.00974 6.59803C6.06389 6.86881 6.3273 7.04442 6.59808 6.99026C6.86886 6.93611 7.04447 6.6727 6.99032 6.40192L6.49032 3.90192Z" fill="black"/>
<path d="M2.42873 5.24271C2.28666 5.00592 1.97953 4.92913 1.74274 5.07121C1.50595 5.21328 1.42916 5.52041 1.57124 5.7572L3.07124 8.2572C3.21331 8.49399 3.52044 8.57077 3.75723 8.4287C3.99402 8.28663 4.07081 7.9795 3.92873 7.74271L2.42873 5.24271Z" fill="black"/>
<path d="M17.5713 5.24271C17.7133 5.00592 18.0205 4.92913 18.2573 5.07121C18.4941 5.21328 18.5708 5.52041 18.4288 5.7572L16.9288 8.2572C16.7867 8.49399 16.4796 8.57077 16.2428 8.4287C16.006 8.28663 15.9292 7.9795 16.0713 7.74271L17.5713 5.24271Z" fill="black"/>
<path d="M13 10.5C13 12.1569 11.6569 13.5 10 13.5C8.34315 13.5 7 12.1569 7 10.5C7 8.84315 8.34315 7.5 10 7.5C11.6569 7.5 13 8.84315 13 10.5Z" fill="black"/>
<path d="M17.6117 17.6548C17.8023 17.8545 17.795 18.171 17.5952 18.3617C17.3955 18.5523 17.079 18.545 16.8883 18.3452L1.13832 1.84524C0.947653 1.64549 0.955014 1.32899 1.15476 1.13832C1.35451 0.947653 1.67101 0.955014 1.86168 1.15476L17.6117 17.6548Z" fill="black"/>
</svg>
`;

const File = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M6.5 2L13.1854 2C13.6056 2 14.0065 2.17624 14.2906 2.48582L18.6052 7.18761C18.8591 7.46433 19 7.82623 19 8.20179V18.5C19 19.3284 18.3284 20 17.5 20H6.5C5.67157 20 5 19.3284 5 18.5V3.5C5 2.67157 5.67157 2 6.5 2Z" fill="currentColor"/>
</g>
<path d="M6.5 11C6.22386 11 6 10.7761 6 10.5C6 10.2239 6.22386 10 6.5 10H13.5C13.7761 10 14 10.2239 14 10.5C14 10.7761 13.7761 11 13.5 11H6.5Z" fill="black"/>
<path d="M6.5 14C6.22386 14 6 13.7761 6 13.5C6 13.2239 6.22386 13 6.5 13H13.5C13.7761 13 14 13.2239 14 13.5C14 13.7761 13.7761 14 13.5 14H6.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.1854 1H4.5C3.67157 1 3 1.67157 3 2.5V17.5C3 18.3284 3.67157 19 4.5 19H15.5C16.3284 19 17 18.3284 17 17.5V7.20179C17 6.82623 16.8591 6.46433 16.6052 6.18761L12.2906 1.48582C12.0065 1.17624 11.6056 1 11.1854 1ZM4 2.5C4 2.22386 4.22386 2 4.5 2H11.1854C11.3255 2 11.4591 2.05875 11.5538 2.16194L15.8684 6.86373C15.953 6.95597 16 7.0766 16 7.20179V17.5C16 17.7761 15.7761 18 15.5 18H4.5C4.22386 18 4 17.7761 4 17.5V2.5Z" fill="black"/>
<path d="M11 7H16.5C16.7761 7 17 7.22386 17 7.5C17 7.77614 16.7761 8 16.5 8H10.5C10.2239 8 10 7.77614 10 7.5V1.5C10 1.22386 10.2239 1 10.5 1C10.7761 1 11 1.22386 11 1.5V7Z" fill="black"/>
</svg>
`;

const FilmFrame = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path opacity="0.8" d="M2 6.5C2 5.94772 2.44772 5.5 3 5.5H19C19.5523 5.5 20 5.94772 20 6.5V18.5C20 19.0523 19.5523 19.5 19 19.5H3C2.44772 19.5 2 19.0523 2 18.5V6.5Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 3C1.44772 3 1 3.44772 1 4V16C1 16.5523 1.44772 17 2 17H18C18.5523 17 19 16.5523 19 16V4C19 3.44772 18.5523 3 18 3H2ZM15.5 4.5H16.5C16.7761 4.5 17 4.72386 17 5V6C17 6.27614 16.7761 6.5 16.5 6.5H15.5C15.2239 6.5 15 6.27614 15 6V5C15 4.72386 15.2239 4.5 15.5 4.5ZM16.5 7.5H15.5C15.2239 7.5 15 7.72386 15 8V9C15 9.27614 15.2239 9.5 15.5 9.5H16.5C16.7761 9.5 17 9.27614 17 9V8C17 7.72386 16.7761 7.5 16.5 7.5ZM15.5 10.5H16.5C16.7761 10.5 17 10.7239 17 11V12C17 12.2761 16.7761 12.5 16.5 12.5H15.5C15.2239 12.5 15 12.2761 15 12V11C15 10.7239 15.2239 10.5 15.5 10.5ZM16.5 13.5H15.5C15.2239 13.5 15 13.7239 15 14V15C15 15.2761 15.2239 15.5 15.5 15.5H16.5C16.7761 15.5 17 15.2761 17 15V14C17 13.7239 16.7761 13.5 16.5 13.5ZM3.5 4.5H4.5C4.77614 4.5 5 4.72386 5 5V6C5 6.27614 4.77614 6.5 4.5 6.5H3.5C3.22386 6.5 3 6.27614 3 6V5C3 4.72386 3.22386 4.5 3.5 4.5ZM4.5 7.5H3.5C3.22386 7.5 3 7.72386 3 8V9C3 9.27614 3.22386 9.5 3.5 9.5H4.5C4.77614 9.5 5 9.27614 5 9V8C5 7.72386 4.77614 7.5 4.5 7.5ZM3.5 10.5H4.5C4.77614 10.5 5 10.7239 5 11V12C5 12.2761 4.77614 12.5 4.5 12.5H3.5C3.22386 12.5 3 12.2761 3 12V11C3 10.7239 3.22386 10.5 3.5 10.5ZM4.5 13.5H3.5C3.22386 13.5 3 13.7239 3 14V15C3 15.2761 3.22386 15.5 3.5 15.5H4.5C4.77614 15.5 5 15.2761 5 15V14C5 13.7239 4.77614 13.5 4.5 13.5ZM6.5 16V4H13.5V16H6.5Z" fill="black"/>
</svg>
`;

const Flag = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M7.99957 4.97042L8.95446 4.57383C9.89482 4.22847 10.9329 4.24798 11.8622 4.63236L13.3435 5.24505C14.199 5.59892 15.1508 5.64505 16.0366 5.37556L16.9296 5.10387C17.7769 4.84609 18.6728 5.32399 18.9306 6.1713C18.9766 6.32261 19 6.4799 19 6.63806V10.6997C19 11.8707 18.3646 12.9495 17.3405 13.5173L16.6064 13.9244C15.3998 14.5935 13.9335 14.5935 12.7269 13.9244L12.2731 13.6728C11.0665 13.0037 9.60021 13.0037 8.39359 13.6728L8.16667 13.7986C8.1121 13.8288 8.05644 13.8552 8 13.8778V19C8 19.5523 7.55228 20 7 20C6.44772 20 6 19.5523 6 19V5C6 4.44772 6.44772 4 7 4C7.81074 4 7.99957 4.97042 7.99957 4.97042Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.80448 2.63238L6.16667 2.89619C4.85526 3.43861 4 4.7179 4 6.13705V10.5225C4 10.7701 4.06299 11.0136 4.18304 11.2301C4.57382 11.9349 5.46192 12.1894 6.16667 11.7986L6.39359 11.6728C7.60021 11.0037 9.06646 11.0037 10.2731 11.6728L10.7269 11.9244C11.9335 12.5935 13.3998 12.5935 14.6064 11.9244L15.3405 11.5174C16.3646 10.9495 17 9.87068 17 8.69967V4.63808C17 4.47992 16.9766 4.32263 16.9306 4.17132C16.6728 3.32401 15.7769 2.8461 14.9296 3.10389L14.0366 3.37558C13.1508 3.64506 12.199 3.59893 11.3435 3.24506L9.86219 2.63238C8.88317 2.22744 7.78349 2.22744 6.80448 2.63238ZM5 6.13705C5 5.12254 5.6114 4.20802 6.54888 3.82026L7.18669 3.55645C7.92095 3.25275 8.74571 3.25275 9.47998 3.55645L10.9613 4.16914C12.0307 4.61148 13.2205 4.66914 14.3277 4.33228L15.2207 4.06059C15.5396 3.96356 15.8768 4.14345 15.9739 4.46238C15.9912 4.51934 16 4.57854 16 4.63808V8.69967C16 9.50723 15.5618 10.2512 14.8556 10.6428L14.1215 11.0499C13.2165 11.5517 12.1168 11.5517 11.2119 11.0499L10.758 10.7982C9.24974 9.96189 7.41693 9.96189 5.90865 10.7982L5.68173 10.9241C5.45999 11.047 5.18055 10.9669 5.05759 10.7452C5.01982 10.6771 5 10.6004 5 10.5225V6.13705Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5 2C5.55228 2 6 2.44772 6 3V17C6 17.5523 5.55228 18 5 18C4.44772 18 4 17.5523 4 17V3C4 2.44772 4.44772 2 5 2Z" fill="black"/>
</svg>
`;

const Flower = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.9577 3.70271L14.8853 3.78196C14.5511 4.14683 14.3446 4.35528 14.1748 4.49015C13.9784 4.23554 13.6887 3.84808 13.6936 3.8544C13.4051 3.48043 13.165 3.20924 12.9195 3.00194C12.619 2.74817 12.3212 2.60174 12 2.60174C11.8313 2.60174 11.6672 2.64406 11.5086 2.72103C11.122 2.90864 10.798 3.26211 10.3638 3.86885C10.3094 3.94496 10.1721 4.14131 10.0899 4.25879L10.0269 4.34878C9.98779 4.40411 9.95266 4.45293 9.92077 4.4962L9.90489 4.48417C9.72623 4.3472 9.51116 4.13846 9.15613 3.76687L9.08747 3.69487C8.55371 3.13443 8.40866 2.98816 8.18558 2.80638C8.00393 2.65837 7.84702 2.56272 7.67667 2.52097C7.34592 2.43991 7.0295 2.60022 6.90938 2.93114C6.64016 3.67283 6.5 4.46989 6.5 5.28809C6.5 8.66894 8.19597 11.074 11.1655 11.4489C11.0609 11.6069 11 11.7963 11 12V15.7721C10.6014 15.2998 10.1289 14.8326 9.61094 14.398C7.92618 12.9843 5.83957 12.594 4.90256 13.7107C3.96555 14.8274 4.71224 16.8145 6.397 18.2282C8.00906 19.5809 10.6602 20.2761 11.7674 19.4728C11.8328 19.4884 11.9007 19.4975 11.9704 19.4996C13.0994 20.2603 15.7087 19.5655 17.3025 18.2282C18.9873 16.8145 19.734 14.8274 18.797 13.7107C17.8599 12.594 15.7733 12.9843 14.0886 14.398C13.6953 14.7279 13.3284 15.0766 13 15.4321V12C13 11.7963 12.9391 11.6069 12.8346 11.4489C15.804 11.074 17.5 8.66894 17.5 5.28809C17.5 4.46989 17.3599 3.67283 17.0906 2.93114C16.9711 2.60183 16.6556 2.43776 16.3239 2.52196C16.1538 2.56515 16.0002 2.66253 15.8231 2.8129C15.6085 2.99518 15.4743 3.13653 14.9577 3.70271Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.9577 2.70271L12.8853 2.78196C12.5511 3.14683 12.3446 3.35528 12.1748 3.49015C11.9784 3.23554 11.6887 2.84808 11.6936 2.8544C11.4051 2.48043 11.165 2.20924 10.9195 2.00194C10.619 1.74817 10.3212 1.60174 10 1.60174C9.83135 1.60174 9.66724 1.64406 9.50862 1.72103C9.12201 1.90864 8.798 2.26211 8.36383 2.86885C8.30938 2.94494 8.17213 3.14122 8.08998 3.2587C8.05753 3.3051 8.03368 3.33921 8.02692 3.34878C7.98778 3.40411 7.95265 3.45293 7.92076 3.4962L7.90489 3.48417C7.72623 3.3472 7.51115 3.13846 7.15613 2.76687L7.08746 2.69487C6.55371 2.13443 6.40865 1.98816 6.18557 1.80638C6.00392 1.65837 5.84702 1.56272 5.67667 1.52097C5.34592 1.43991 5.02949 1.60022 4.90937 1.93114C4.64015 2.67283 4.5 3.46989 4.5 4.28809C4.5 7.97398 6.51581 10.5 10 10.5C13.4842 10.5 15.5 7.97398 15.5 4.28809C15.5 3.46989 15.3598 2.67283 15.0906 1.93114C14.9711 1.60183 14.6556 1.43776 14.3239 1.52196C14.1538 1.56515 14.0002 1.66253 13.8231 1.8129C13.6085 1.99518 13.4742 2.13653 12.9577 2.70271ZM5.5 4.28809C5.5 3.74768 5.57105 3.21929 5.70851 2.71616C5.84152 2.83956 6.01414 3.01788 6.36332 3.38453L6.43309 3.45768C6.82398 3.86681 7.06306 4.09885 7.29648 4.27779C7.7511 4.62631 8.16971 4.74941 8.52019 4.34902C8.61368 4.24222 8.71072 4.11375 8.84336 3.92621C8.85158 3.91458 8.87876 3.87571 8.91467 3.82437C8.9976 3.70578 9.12709 3.52063 9.17706 3.45079C9.51365 2.98042 9.76183 2.70968 9.94521 2.62069C9.97484 2.60631 9.99258 2.60174 10 2.60174C10.0387 2.60174 10.1373 2.65022 10.2743 2.76597C10.4531 2.91693 10.6532 3.14297 10.9018 3.46524C10.8697 3.42366 11.4473 4.19598 11.5813 4.34902C11.9329 4.75066 12.3526 4.62516 12.7943 4.27514C13.0202 4.09616 13.2515 3.86269 13.6227 3.45736L13.6965 3.37669C14.0099 3.03318 14.1737 2.85605 14.2965 2.73475C14.4307 3.2323 14.5 3.75433 14.5 4.28809C14.5 7.46499 12.876 9.49999 10 9.49999C7.12397 9.49999 5.5 7.46499 5.5 4.28809Z" fill="black"/>
<path d="M9.5 11C9.5 10.7239 9.72386 10.5 10 10.5C10.2761 10.5 10.5 10.7239 10.5 11V17.5C10.5 17.7761 10.2761 18 10 18C9.72386 18 9.5 17.7761 9.5 17.5V11Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.0886 13.398C10.114 15.0548 8.80192 17.1841 9.71244 18.2692C10.6408 19.3756 13.571 18.6811 15.3025 17.2282C16.9873 15.8145 17.734 13.8274 16.797 12.7107C15.8599 11.594 13.7733 11.9843 12.0886 13.398ZM14.6597 16.4622C13.2968 17.6058 10.9315 18.1663 10.4785 17.6264C10.115 17.1932 11.1789 15.4667 12.7314 14.164C14.0493 13.0582 15.5479 12.7779 16.0309 13.3535C16.5139 13.9291 15.9776 15.3563 14.6597 16.4622Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.61094 13.398C9.58547 15.0548 10.8976 17.1841 9.98706 18.2692C9.05874 19.3756 6.1285 18.6811 4.397 17.2282C2.71224 15.8145 1.96554 13.8274 2.90255 12.7107C3.83956 11.594 5.92617 11.9843 7.61094 13.398ZM5.03979 16.4622C6.40267 17.6058 8.768 18.1663 9.22102 17.6264C9.58452 17.1932 8.52056 15.4667 6.96815 14.164C5.65026 13.0582 4.15159 12.7779 3.6686 13.3535C3.1856 13.9291 3.72189 15.3563 5.03979 16.4622Z" fill="black"/>
</svg>
`;

const FlowerBud = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M17.1559 7.80414C18.7548 7.97683 20 9.34178 20 11C20 12.6582 18.7548 14.0232 17.1559 14.1959C17.2775 14.5362 17.3438 14.9031 17.3438 15.2857C17.3438 17.0609 15.9167 18.5 14.1562 18.5C13.0475 18.5 12.0711 17.9292 11.5 17.0631C10.9289 17.9292 9.95245 18.5 8.84375 18.5C7.08334 18.5 5.65625 17.0609 5.65625 15.2857C5.65625 14.9031 5.72253 14.5362 5.84415 14.1959C4.24521 14.0232 3 12.6582 3 11C3 9.34178 4.24521 7.97683 5.84415 7.80414C5.72253 7.46383 5.65625 7.09686 5.65625 6.71429C5.65625 4.93909 7.08334 3.5 8.84375 3.5C9.95245 3.5 10.9289 4.07081 11.5 4.9369C12.0711 4.07081 13.0475 3.5 14.1563 3.5C15.9167 3.5 17.3438 4.93909 17.3438 6.71429C17.3438 7.09686 17.2775 7.46383 17.1559 7.80414Z" fill="currentColor"/>
</g>
<path d="M13 10C13 11.6569 11.6569 13 10 13C8.34315 13 7 11.6569 7 10C7 8.34315 8.34315 7 10 7C11.6569 7 13 8.34315 13 10Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15.9436 13.3714C17.4272 12.9576 18.5 11.5957 18.5 10C18.5 8.40432 17.4272 7.04239 15.9436 6.62862C15.981 6.42276 16 6.21259 16 6C16 4.067 14.433 2.5 12.5 2.5C11.541 2.5 10.6476 2.889 10 3.55019C9.35243 2.889 8.45901 2.5 7.5 2.5C5.567 2.5 4 4.067 4 6C4 6.21259 4.01902 6.42276 4.05638 6.62862C2.57281 7.04239 1.5 8.40432 1.5 10C1.5 11.5957 2.57281 12.9576 4.05638 13.3714C4.01902 13.5772 4 13.7874 4 14C4 15.933 5.567 17.5 7.5 17.5C8.45901 17.5 9.35243 17.111 10 16.4498C10.6476 17.111 11.541 17.5 12.5 17.5C14.433 17.5 16 15.933 16 14C16 13.7874 15.981 13.5772 15.9436 13.3714ZM14.8528 6.84769C14.7429 7.15259 14.9477 7.47985 15.2699 7.51436C16.5325 7.64958 17.5 8.71964 17.5 10C17.5 11.2804 16.5325 12.3504 15.2699 12.4856C14.9477 12.5202 14.7429 12.8474 14.8528 13.1523C14.9498 13.4215 15 13.707 15 14C15 15.3807 13.8807 16.5 12.5 16.5C11.6522 16.5 10.8773 16.0753 10.4164 15.3821C10.2185 15.0845 9.78147 15.0845 9.58363 15.3821C9.1227 16.0753 8.3478 16.5 7.5 16.5C6.11929 16.5 5 15.3807 5 14C5 13.707 5.05022 13.4215 5.14723 13.1523C5.25711 12.8474 5.05234 12.5202 4.73009 12.4856C3.46751 12.3504 2.5 11.2804 2.5 10C2.5 8.71964 3.46751 7.64958 4.73009 7.51436C5.05234 7.47985 5.25711 7.15259 5.14723 6.84769C5.05022 6.57848 5 6.29304 5 6C5 4.61929 6.11929 3.5 7.5 3.5C8.3478 3.5 9.1227 3.9247 9.58363 4.61794C9.78147 4.91549 10.2185 4.91549 10.4164 4.61794C10.8773 3.9247 11.6522 3.5 12.5 3.5C13.8807 3.5 15 4.61929 15 6C15 6.29304 14.9498 6.57848 14.8528 6.84769Z" fill="black"/>
</svg>
`;

const Folder = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M12.2187 7.5H17.5C18.8807 7.5 20 8.61929 20 10V17C20 18.3807 18.8807 19.5 17.5 19.5H6.5C5.11929 19.5 4 18.3807 4 17L4 7.5C4 6.11929 5.11929 5 6.5 5H9.33935C10.2365 5 11.0649 5.48072 11.51 6.25965L12.2187 7.5Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15.5 5.5H10.2187L9.50996 4.25965C9.06486 3.48072 8.2365 3 7.33935 3H4.5C3.11929 3 2 4.11929 2 5.5V15C2 16.3807 3.11929 17.5 4.5 17.5H15.5C16.8807 17.5 18 16.3807 18 15V8C18 6.61929 16.8807 5.5 15.5 5.5ZM4.5 16.5C3.67157 16.5 3 15.8284 3 15V5.5C3 4.67157 3.67157 4 4.5 4H7.33935C7.87764 4 8.37466 4.28843 8.64172 4.75579L9.49445 6.24807C9.58347 6.40386 9.74914 6.5 9.92857 6.5H15.5C16.3284 6.5 17 7.17157 17 8V15C17 15.8284 16.3284 16.5 15.5 16.5H4.5Z" fill="black"/>
</svg>
`;

const Gear = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.5576 3.25C11.8544 3.25 12.1233 3.42509 12.2434 3.69656L12.6859 4.69656C12.7301 4.79661 12.7507 4.89918 12.7508 4.99917C13.1878 5.12648 13.6082 5.30097 14.0052 5.5189C14.0662 5.45819 14.1393 5.40664 14.2239 5.36799L15.1947 4.92456C15.4795 4.79445 15.8152 4.85501 16.0366 5.07643L16.8744 5.91414C17.0843 6.12405 17.1506 6.43801 17.0436 6.71489L16.6493 7.73483C16.6098 7.83694 16.5518 7.92404 16.4811 7.99487C16.6991 8.39186 16.8735 8.81226 17.0008 9.24925C17.0869 9.24944 17.175 9.2647 17.2621 9.29718L18.2621 9.67007C18.5555 9.77948 18.7501 10.0597 18.7501 10.3728V11.5575C18.7501 11.8544 18.575 12.1233 18.3035 12.2434L17.3035 12.6858C17.2034 12.7301 17.1008 12.7506 17.0008 12.7508C16.8735 13.1877 16.6991 13.6081 16.4811 14.0051C16.5419 14.0661 16.5934 14.1392 16.6321 14.2239L17.0755 15.1946C17.2056 15.4795 17.1451 15.8152 16.9236 16.0366L16.0859 16.8743C15.876 17.0842 15.5621 17.1505 15.2852 17.0435L14.2652 16.6492C14.1631 16.6098 14.076 16.5517 14.0052 16.4811C13.6082 16.699 13.1878 16.8735 12.7508 17.0008C12.7506 17.0868 12.7354 17.1749 12.7029 17.262L12.33 18.262C12.2206 18.5554 11.9404 18.75 11.6273 18.75H10.4426C10.1457 18.75 9.87678 18.5749 9.75668 18.3034L9.31427 17.3034C9.27001 17.2034 9.24946 17.1009 9.2493 17.0009C8.81229 16.8736 8.39186 16.6991 7.99485 16.4812C7.93388 16.5418 7.86078 16.5934 7.7762 16.632L6.80542 17.0754C6.52059 17.2055 6.1849 17.145 5.96348 16.9236L5.12577 16.0859C4.91586 15.876 4.84951 15.562 4.95655 15.2851L5.35082 14.2652C5.39027 14.1631 5.44827 14.0761 5.51888 14.0052C5.30093 13.6082 5.12644 13.1878 4.99912 12.7508C4.91315 12.7505 4.82508 12.7353 4.73802 12.7028L3.73802 12.3299C3.44461 12.2205 3.25006 11.9403 3.25006 11.6272V10.4425C3.25006 10.1456 3.42515 9.87672 3.69662 9.75662L4.69662 9.31421C4.79664 9.26996 4.89916 9.24941 4.99912 9.24924C5.12643 8.81222 5.30093 8.39178 5.51888 7.99476C5.4582 7.9338 5.40668 7.8607 5.36806 7.77614L4.92462 6.80536C4.79452 6.52053 4.85507 6.18484 5.07649 5.96341L5.9142 5.12571C6.12411 4.9158 6.43807 4.84945 6.71495 4.95649L7.73489 5.35076C7.83696 5.39022 7.92403 5.44822 7.99485 5.51884C8.39186 5.30091 8.81229 5.12642 9.24931 4.99912C9.24951 4.91313 9.26477 4.82504 9.29724 4.73796L9.67013 3.73796C9.77954 3.44455 10.0597 3.25 10.3729 3.25H11.5576Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.23223 11.5178C8.69772 11.9833 9.32837 12.25 10 12.25C10.6716 12.25 11.3023 11.9833 11.7678 11.5178C12.2333 11.0523 12.5 10.4216 12.5 9.75C12.5 9.07837 12.2333 8.44772 11.7678 7.98223C11.3023 7.51674 10.6716 7.25 10 7.25C9.32837 7.25 8.69772 7.51674 8.23223 7.98223C7.76674 8.44772 7.5 9.07837 7.5 9.75C7.5 10.4216 7.76674 11.0523 8.23223 11.5178ZM11.0607 10.8107C10.7808 11.0905 10.4037 11.25 10 11.25C9.59632 11.25 9.21915 11.0905 8.93934 10.8107C8.65953 10.5308 8.5 10.1537 8.5 9.75C8.5 9.34632 8.65953 8.96915 8.93934 8.68934C9.21915 8.40953 9.59632 8.25 10 8.25C10.4037 8.25 10.7808 8.40953 11.0607 8.68934C11.3405 8.96915 11.5 9.34632 11.5 9.75C11.5 10.1537 11.3405 10.5308 11.0607 10.8107Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.2161 3.52261L12.9469 4.23706C12.5759 4.03836 12.1853 3.8775 11.7804 3.75738L11.3109 2.34254C11.2431 2.13803 11.0519 2 10.8364 2H9.05934C8.83506 2 8.63822 2.14934 8.57781 2.36533L8.18566 3.76755C7.78153 3.88997 7.39185 4.05304 7.02195 4.25387L5.68911 3.58516C5.49652 3.48853 5.26369 3.52615 5.11133 3.67851L3.85477 4.93507C3.69618 5.09366 3.6626 5.33845 3.77261 5.53389L4.48706 6.80311C4.28836 7.17412 4.1275 7.56472 4.00738 7.9696L2.59254 8.43906C2.38803 8.50692 2.25 8.69815 2.25 8.91362V10.6907C2.25 10.9149 2.39934 11.1118 2.61533 11.1722L4.01755 11.5643C4.13997 11.9685 4.30304 12.3581 4.50387 12.7281L3.83516 14.0609C3.73853 14.2535 3.77615 14.4863 3.92851 14.6387L5.18507 15.8952C5.34366 16.0538 5.58845 16.0874 5.78389 15.9774L7.05311 15.2629C7.42412 15.4616 7.81472 15.6225 8.2196 15.7426L8.68906 17.1575C8.75692 17.362 8.94815 17.5 9.16362 17.5H10.9407C11.1649 17.5 11.3618 17.3507 11.4222 17.1347L11.8143 15.7324C12.2185 15.61 12.6081 15.447 12.9781 15.2461L14.3109 15.9148C14.5035 16.0115 14.7363 15.9738 14.8887 15.8215L16.1452 14.5649C16.3038 14.4063 16.3374 14.1616 16.2274 13.9661L15.5129 12.6969C15.7116 12.3259 15.8725 11.9353 15.9926 11.5304L17.4075 11.0609C17.612 10.9931 17.75 10.8019 17.75 10.5864V8.80934C17.75 8.58506 17.6007 8.38822 17.3847 8.32781L15.9824 7.93566C15.86 7.53153 15.697 7.14185 15.4961 6.77195L16.1648 5.43911C16.2615 5.24652 16.2238 5.01369 16.0715 4.86133L14.8149 3.60477C14.6563 3.44618 14.4116 3.4126 14.2161 3.52261ZM13.1916 5.24689L14.3761 4.58012L15.1092 5.31325L14.4821 6.56313C14.4052 6.71642 14.4122 6.89843 14.5007 7.04534C14.7659 7.48564 14.9652 7.96281 15.0913 8.46333C15.1351 8.63728 15.2687 8.77443 15.4415 8.82274L16.75 9.18869V10.2255L15.4233 10.6657C15.2606 10.7197 15.1369 10.8533 15.0955 11.0197C14.9711 11.5207 14.7734 11.9986 14.5097 12.4397C14.4176 12.5937 14.4151 12.7852 14.5031 12.9416L15.1699 14.1261L14.4368 14.8592L13.1869 14.2321C13.0336 14.1552 12.8516 14.1622 12.7047 14.2507C12.2644 14.5159 11.7872 14.7152 11.2867 14.8413C11.1127 14.8851 10.9756 15.0187 10.9273 15.1915L10.5613 16.5H9.52452L9.08432 15.1733C9.03032 15.0106 8.89668 14.8869 8.73025 14.8455C8.22926 14.7211 7.75144 14.5234 7.31028 14.2597C7.15629 14.1676 6.96478 14.1651 6.80844 14.2531L5.62394 14.9199L4.89081 14.1868L5.5179 12.9369C5.59481 12.7836 5.58779 12.6016 5.49929 12.4547C5.23408 12.0144 5.03476 11.5372 4.9087 11.0367C4.86489 10.8627 4.73126 10.7256 4.5585 10.6773L3.25 10.3113V9.27452L4.57666 8.83432C4.73942 8.78032 4.86314 8.64668 4.90447 8.48025C5.02886 7.97926 5.22658 7.50144 5.49033 7.06028C5.58239 6.90629 5.58489 6.71478 5.49689 6.55844L4.83012 5.37394L5.56325 4.64081L6.81313 5.2679C6.96642 5.34481 7.14843 5.33779 7.29534 5.24929C7.73564 4.98408 8.21281 4.78476 8.71333 4.6587C8.88728 4.61489 9.02443 4.48126 9.07274 4.3085L9.43869 3H10.4755L10.9157 4.32666C10.9697 4.48942 11.1033 4.61314 11.2697 4.65447C11.7707 4.77886 12.2486 4.97658 12.6897 5.24033C12.8437 5.33239 13.0352 5.33489 13.1916 5.24689Z" fill="black"/>
</svg>
`;

const Gift = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path opacity="0.8" fill-rule="evenodd" clip-rule="evenodd" d="M20 8C20 7.44772 19.5523 7 19 7H5C4.44771 7 4 7.44772 4 8V9.58065V19C4 19.5523 4.44771 20 5 20H19C19.5523 20 20 19.5523 20 19V8Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M3 5H17C17.5523 5 18 5.44772 18 6V17C18 17.5523 17.5523 18 17 18H3C2.44771 18 2 17.5523 2 17V6C2 5.44772 2.44771 5 3 5ZM17 17V6H3V17H17Z" fill="black"/>
<rect x="9.5" y="5.5" width="1" height="12" fill="black"/>
<rect x="2" y="10.5" width="16" height="1" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.94332 1.55446C10.0682 2.53232 10.7304 4.55547 9.97846 5.42046C9.228 6.28377 7.60446 5.69065 6.31908 4.5733C5.22456 3.62184 4.85022 2.1743 5.60673 1.30404C6.36324 0.43377 7.8488 0.603005 8.94332 1.55446ZM6.97514 3.81859C7.87157 4.59784 9.00773 5.0129 9.22375 4.7644C9.52349 4.41959 9.04968 2.97193 8.28726 2.30917C7.56243 1.67908 6.69193 1.57992 6.36144 1.96009C6.03096 2.34027 6.25031 3.1885 6.97514 3.81859Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.2984 1.55446C10.1735 2.53232 9.51134 4.55547 10.2633 5.42046C11.0137 6.28377 12.6373 5.69065 13.9226 4.5733C15.0172 3.62184 15.3915 2.1743 14.635 1.30404C13.8785 0.43377 12.3929 0.603005 11.2984 1.55446ZM13.2666 3.81859C12.3702 4.59784 11.234 5.0129 11.018 4.7644C10.7182 4.41959 11.192 2.97193 11.9545 2.30917C12.6793 1.67908 13.5498 1.57992 13.8803 1.96009C14.2108 2.34027 13.9914 3.1885 13.2666 3.81859Z" fill="black"/>
</svg>
`;

const Grab = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M4 8C3.44772 8 3 7.55228 3 7C3 6.44772 3.44772 6 4 6H18.4231C18.9754 6 19.4231 6.44772 19.4231 7C19.4231 7.55228 18.9754 8 18.4231 8H4Z" fill="currentColor"/>
<path d="M4 11.75C3.44772 11.75 3 11.3023 3 10.75C3 10.1977 3.44772 9.75 4 9.75H18.4231C18.9754 9.75 19.4231 10.1977 19.4231 10.75C19.4231 11.3023 18.9754 11.75 18.4231 11.75H4Z" fill="currentColor"/>
<path d="M4 15C3.44772 15 3 14.5523 3 14C3 13.4477 3.44772 13 4 13H18.4231C18.9754 13 19.4231 13.4477 19.4231 14C19.4231 14.5523 18.9754 15 18.4231 15H4Z" fill="currentColor"/>
</g>
<path d="M3 7C2.72386 7 2.5 6.77614 2.5 6.5C2.5 6.22386 2.72386 6 3 6H18C18.2761 6 18.5 6.22386 18.5 6.5C18.5 6.77614 18.2761 7 18 7H3Z" fill="black"/>
<path d="M3 10.25C2.72386 10.25 2.5 10.0261 2.5 9.75C2.5 9.47386 2.72386 9.25 3 9.25H18C18.2761 9.25 18.5 9.47386 18.5 9.75C18.5 10.0261 18.2761 10.25 18 10.25H3Z" fill="black"/>
<path d="M3 13.5C2.72386 13.5 2.5 13.2761 2.5 13C2.5 12.7239 2.72386 12.5 3 12.5H18C18.2761 12.5 18.5 12.7239 18.5 13C18.5 13.2761 18.2761 13.5 18 13.5H3Z" fill="black"/>
</svg>
`;

const Hamburger = `<svg width="20" height="21" viewBox="0 0 20 21" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M19 7.61295C19 8.82615 18.3152 9.53685 17.0629 9.82065C16.1919 10.018 15.4053 10.0307 13.0284 9.96263C12.1035 9.93615 11.59 9.92566 11 9.92566C10.4101 9.92566 9.89655 9.93615 8.97167 9.96263C6.59468 10.0307 5.80815 10.018 4.93716 9.82065C3.68479 9.53685 3.00002 8.82615 3.00002 7.61295C3.00002 4.86393 6.5032 3.00001 11 3.00001C15.4968 3.00001 19 4.86393 19 7.61295Z" fill="currentColor"/>
<path d="M2.99673 18.3736C2.99673 19.3218 3.61135 19.8234 4.67144 19.9543C5.36314 20.0397 5.79286 20.0187 7.96666 19.8485C9.24942 19.748 10.0846 19.7033 10.9967 19.7033C11.9089 19.7033 12.744 19.748 14.0268 19.8485C16.2006 20.0187 16.6303 20.0397 17.322 19.9543C18.3821 19.8234 18.9967 19.3218 18.9967 18.3736C18.9967 16.4071 16.9454 16.0076 11.7021 15.9972C11.5147 15.9968 11.3647 15.9967 11.029 15.9967H10.9967H10.9645C10.6288 15.9967 10.4787 15.9968 10.2914 15.9972C5.04811 16.0076 2.99673 16.4071 2.99673 18.3736Z" fill="currentColor"/>
<path d="M3.75362 12.6139C3.2765 12.8921 2.66422 12.7308 2.38608 12.2536C2.10793 11.7765 2.26924 11.1642 2.74637 10.8861C3.47019 10.4641 4.2537 10.25 5.07961 10.25C5.6526 10.25 5.99872 10.3503 6.50625 10.5899L6.51855 10.5957C6.79134 10.7244 6.88012 10.75 7.125 10.75C7.36062 10.75 7.42729 10.7298 7.6615 10.6099L7.67334 10.6038C8.15762 10.3559 8.50471 10.25 9.08553 10.25C9.6762 10.25 10.025 10.3589 10.5119 10.6147L10.516 10.6168C10.7383 10.7336 10.7906 10.75 11 10.75C11.209 10.75 11.2609 10.7338 11.4821 10.6174L11.4866 10.615C11.9731 10.3591 12.3224 10.25 12.9137 10.25C13.4978 10.25 13.844 10.3556 14.3363 10.6056C14.5816 10.7302 14.6469 10.75 14.875 10.75C15.1046 10.75 15.1737 10.7292 15.4191 10.6061L15.4254 10.603C15.9204 10.3547 16.2663 10.25 16.8478 10.25C17.6616 10.25 18.4569 10.4591 19.2218 10.8683C19.7087 11.1288 19.8923 11.7348 19.6317 12.2218C19.3712 12.7087 18.7652 12.8923 18.2782 12.6317C17.7971 12.3743 17.3242 12.25 16.8478 12.25C16.6285 12.25 16.5632 12.2698 16.3219 12.3908C15.8163 12.6443 15.4658 12.75 14.875 12.75C14.2827 12.75 13.9323 12.6435 13.4363 12.3916L13.4308 12.3889C13.1945 12.2689 13.1326 12.25 12.9137 12.25C12.6967 12.25 12.6419 12.2671 12.4178 12.385L12.4132 12.3874C11.9299 12.6417 11.5843 12.75 11 12.75C10.4156 12.75 10.0701 12.6418 9.58594 12.3874L9.58189 12.3853C9.35691 12.2671 9.30206 12.25 9.08553 12.25C8.87053 12.25 8.81148 12.268 8.58493 12.384L8.57308 12.3901C8.08075 12.6422 7.72416 12.75 7.125 12.75C6.53523 12.75 6.18108 12.648 5.66488 12.4043L5.65261 12.3985C5.38837 12.2738 5.30618 12.25 5.07961 12.25C4.60962 12.25 4.17339 12.3692 3.75362 12.6139Z" fill="currentColor"/>
<path d="M3.99999 15.25C3.44771 15.25 2.99999 14.8023 2.99999 14.25C2.99999 13.6977 3.44771 13.25 3.99999 13.25H18C18.5523 13.25 19 13.6977 19 14.25C19 14.8023 18.5523 15.25 18 15.25H3.99999Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.67144 18.2043C2.61135 18.0734 1.99673 17.5718 1.99673 16.6236C1.99673 14.6571 4.04811 14.2576 9.29138 14.2472C9.47874 14.2468 9.62876 14.2467 9.96451 14.2467H9.99673H10.029C10.3647 14.2467 10.5147 14.2468 10.7021 14.2472C15.9454 14.2576 17.9967 14.6571 17.9967 16.6236C17.9967 17.5718 17.3821 18.0734 16.322 18.2043C15.6303 18.2897 15.2006 18.2687 13.0268 18.0985C11.744 17.998 10.9089 17.9533 9.99673 17.9533C9.08459 17.9533 8.24942 17.998 6.96666 18.0985C4.79286 18.2687 4.36314 18.2897 3.67144 18.2043ZM9.29336 15.2472C4.87383 15.2559 2.99673 15.6216 2.99673 16.6236C2.99673 16.985 3.18209 17.1363 3.794 17.2118C4.38562 17.2849 4.81523 17.2639 6.88859 17.1015C8.19533 16.9992 9.05242 16.9533 9.99673 16.9533C10.9411 16.9533 11.7981 16.9992 13.1049 17.1015C15.1782 17.2639 15.6078 17.2849 16.1995 17.2118C16.8114 17.1363 16.9967 16.985 16.9967 16.6236C16.9967 15.6216 15.1196 15.2559 10.7001 15.2472C10.5136 15.2468 10.3644 15.2467 10.029 15.2467H9.99673H9.96451C9.62909 15.2467 9.47984 15.2468 9.29336 15.2472Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M16.0629 8.07065C17.3152 7.78685 18 7.07615 18 5.86295C18 3.11393 14.4968 1.25001 10 1.25001C5.5032 1.25001 2.00002 3.11393 2.00002 5.86295C2.00002 7.07615 2.68479 7.78685 3.93716 8.07065C4.80815 8.26803 5.59468 8.28067 7.97167 8.21263C8.89655 8.18615 9.41008 8.17566 10 8.17566C10.59 8.17566 11.1035 8.18615 12.0284 8.21263C14.4053 8.28067 15.1919 8.26803 16.0629 8.07065ZM10 2.25001C14.0176 2.25001 17 3.83684 17 5.86295C17 6.56612 16.6711 6.90746 15.8419 7.09538C15.0897 7.26583 14.3284 7.27806 12.057 7.21304C11.1231 7.18631 10.6021 7.17566 10 7.17566C9.39788 7.17566 8.87696 7.18631 7.94306 7.21304C5.67158 7.27806 4.91031 7.26583 4.15817 7.09538C3.32891 6.90746 3.00002 6.56612 3.00002 5.86295C3.00002 3.83684 5.98241 2.25001 10 2.25001Z" fill="black"/>
<path d="M2.50181 10.432C2.26325 10.571 1.95711 10.4904 1.81804 10.2518C1.67896 10.0132 1.75962 9.70711 1.99818 9.56804C2.64599 9.19039 3.34268 9 4.07961 9C4.566 9 4.84614 9.0812 5.29285 9.29203L5.30514 9.29783C5.63877 9.45531 5.7939 9.5 6.125 9.5C6.45151 9.5 6.59066 9.45793 6.8894 9.30496L6.90124 9.29889C7.32109 9.0839 7.59617 9 8.08553 9C8.58266 9 8.85797 9.08598 9.27941 9.30735C9.57128 9.46065 9.69687 9.5 10 9.5C10.3028 9.5 10.4281 9.46073 10.7149 9.30988L10.7194 9.30749C11.1403 9.0861 11.4159 9 11.9137 9C12.4065 9 12.6817 9.08395 13.11 9.30142L13.1154 9.30418C13.4193 9.45849 13.5559 9.5 13.875 9.5C14.1949 9.5 14.3343 9.45796 14.6432 9.30305L14.6495 9.29991C15.0811 9.08347 15.3568 9 15.8478 9C16.5773 9 17.292 9.18786 17.9859 9.55914C18.2294 9.68941 18.3211 9.9924 18.1909 10.2359C18.0606 10.4794 17.7576 10.5711 17.5141 10.4409C16.962 10.1455 16.4086 10 15.8478 10C15.5379 10 15.4025 10.041 15.0978 10.1938L15.0915 10.197C14.6556 10.4155 14.3755 10.5 13.875 10.5C13.3738 10.5 13.0946 10.4152 12.6626 10.1958L12.6572 10.1931C12.3569 10.0406 12.2239 10 11.9137 10C11.6031 10 11.4747 10.0401 11.185 10.1925L11.1804 10.1949C10.7626 10.4147 10.4904 10.5 10 10.5C9.50938 10.5 9.23718 10.4147 8.81845 10.1948L8.8144 10.1927C8.52393 10.0401 8.39559 10 8.08553 10C7.77908 10 7.64802 10.04 7.35703 10.189L7.34519 10.195C6.91739 10.4141 6.63328 10.5 6.125 10.5C5.62146 10.5 5.33365 10.4171 4.8783 10.2022L4.86602 10.1964C4.54096 10.0429 4.39279 10 4.07961 10C3.52065 10 2.99759 10.1429 2.50181 10.432Z" fill="black"/>
<path d="M3 13C2.72386 13 2.5 12.7761 2.5 12.5C2.5 12.2239 2.72386 12 3 12H17C17.2761 12 17.5 12.2239 17.5 12.5C17.5 12.7761 17.2761 13 17 13H3Z" fill="black"/>
<path d="M6.09999 5.24999C6.09999 5.58136 5.83136 5.84999 5.49999 5.84999C5.16862 5.84999 4.89999 5.58136 4.89999 5.24999C4.89999 4.91862 5.16862 4.64999 5.49999 4.64999C5.83136 4.64999 6.09999 4.91862 6.09999 5.24999Z" fill="black"/>
<path d="M8.59999 4.24999C8.59999 4.58136 8.33136 4.84999 7.99999 4.84999C7.66862 4.84999 7.39999 4.58136 7.39999 4.24999C7.39999 3.91862 7.66862 3.64999 7.99999 3.64999C8.33136 3.64999 8.59999 3.91862 8.59999 4.24999Z" fill="black"/>
<path d="M10.6 5.74999C10.6 6.08136 10.3314 6.34999 9.99999 6.34999C9.66862 6.34999 9.39999 6.08136 9.39999 5.74999C9.39999 5.41862 9.66862 5.14999 9.99999 5.14999C10.3314 5.14999 10.6 5.41862 10.6 5.74999Z" fill="black"/>
<path d="M12.6 4.24999C12.6 4.58136 12.3314 4.84999 12 4.84999C11.6686 4.84999 11.4 4.58136 11.4 4.24999C11.4 3.91862 11.6686 3.64999 12 3.64999C12.3314 3.64999 12.6 3.91862 12.6 4.24999Z" fill="black"/>
<path d="M15.1 5.24999C15.1 5.58136 14.8314 5.84999 14.5 5.84999C14.1686 5.84999 13.9 5.58136 13.9 5.24999C13.9 4.91862 14.1686 4.64999 14.5 4.64999C14.8314 4.64999 15.1 4.91862 15.1 5.24999Z" fill="black"/>
</svg>
`;

const Headphone = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M18.8801 17.0685C18.7061 17.5927 18.1402 17.8766 17.616 17.7027C17.5878 17.6933 17.5602 17.6828 17.5334 17.6712C16.9918 18.4839 16.0621 19.014 15.0129 18.9998L14.9967 18.9995C14.4466 18.989 14.0083 18.5362 14.0158 17.9861L14.0699 13.9865C14.0774 13.4321 14.5345 12.9897 15.0888 13.0002C16.0593 13.0186 16.9138 13.4961 17.4485 14.222C17.4827 13.8743 17.5 13.5218 17.5 13.166C17.5 8.71008 14.7442 5.75354 11 5.75354C7.25581 5.75354 4.5 8.71008 4.5 13.166C4.5 13.5555 4.52075 13.941 4.56163 14.3208C5.10693 13.5321 6.02251 13.0206 7.05335 13.0345L7.06957 13.0348C7.61963 13.0452 8.05794 13.498 8.0505 14.0481L7.99636 18.0478C7.98886 18.6021 7.53178 19.0446 6.97747 19.0341C5.93738 19.0143 5.03048 18.4673 4.50772 17.6523C4.46816 17.6716 4.42688 17.6884 4.38399 17.7027C3.85981 17.8766 3.29387 17.5927 3.11994 17.0685C2.71209 15.8394 2.5 14.5199 2.5 13.166C2.5 7.63571 6.11859 3.75354 11 3.75354C15.8814 3.75354 19.5 7.63571 19.5 13.166C19.5 14.5199 19.2879 15.8394 18.8801 17.0685Z" fill="currentColor"/>
</g>
<path d="M17.4055 14.911C17.3185 15.1731 17.0356 15.3151 16.7735 15.2281C16.5114 15.1411 16.3694 14.8582 16.4564 14.5961C16.8135 13.5197 17 12.3598 17 11.166C17 6.44149 14.0285 3.25354 10 3.25354C5.9715 3.25354 3 6.44149 3 11.166C3 12.3598 3.18645 13.5197 3.54361 14.5961C3.63058 14.8582 3.48861 15.1411 3.22652 15.2281C2.96443 15.3151 2.68146 15.1731 2.5945 14.911C2.20355 13.7328 2 12.4665 2 11.166C2 5.9043 5.40289 2.25354 10 2.25354C14.5971 2.25354 18 5.9043 18 11.166C18 12.4665 17.7965 13.7328 17.4055 14.911Z" fill="black"/>
<path d="M5.97747 17.034C4.32744 17.0027 3.01262 15.6444 3.03496 13.9942L3.03526 13.9719C3.05752 12.3274 4.40876 11.0122 6.05335 11.0345C6.06146 11.0346 6.06146 11.0346 6.06958 11.0347C6.61963 11.0452 7.05795 11.498 7.0505 12.0481L6.99636 16.0477C6.98886 16.6021 6.53179 17.0446 5.97747 17.034Z" fill="black"/>
<path d="M14.0888 11.0001C15.7388 11.0315 17.0536 12.3898 17.0313 14.0399L17.031 14.0622C17.0087 15.7068 15.6575 17.022 14.0129 16.9997C14.0048 16.9996 14.0048 16.9996 13.9967 16.9994C13.4466 16.989 13.0083 16.5362 13.0158 15.9861L13.0699 11.9864C13.0774 11.4321 13.5345 10.9896 14.0888 11.0001Z" fill="black"/>
</svg>
`;

const Heart = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path opacity="0.8" fill-rule="evenodd" clip-rule="evenodd" d="M12 7.49228C13.4641 4.87207 18.5 5.78701 18.5 9.57245C18.5 12.1012 16.3333 14.4103 12 16.5C7.66667 14.4103 5.5 12.1012 5.5 9.57245C5.5 5.78701 10.5359 4.87207 12 7.49228Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.2172 15.9503C14.7048 13.7863 17 11.3401 17 8.57242C17 4.75701 12.1396 3.22618 10 5.63238C7.86037 3.22618 3 4.75701 3 8.57242C3 11.3401 5.29522 13.7863 9.78282 15.9503L10 16.0551L10.2172 15.9503ZM10.4365 6.73615C11.7451 4.39411 16 5.49881 16 8.57242C16 10.8221 14.0325 12.9584 10 14.9438C5.96748 12.9584 4 10.8221 4 8.57242C4 5.49881 8.25486 4.39411 9.56352 6.73615C9.56352 6.73615 9.78176 7.03407 10 7.03407C10.2182 7.03407 10.4365 6.73615 10.4365 6.73615Z" fill="black"/>
</svg>
`;

const House = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M3.88889 11H2.5C2.03934 11 1.82377 10.4299 2.16919 10.1251L10.6692 2.62508C10.8582 2.45831 11.1418 2.45831 11.3308 2.62508L19.8308 10.1251C20.1762 10.4299 19.9607 11 19.5 11H18.1111V18C18.1111 18.2761 17.8873 18.5 17.6111 18.5H4.38889C4.11274 18.5 3.88889 18.2761 3.88889 18V11Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M0.999997 10H2.38889V17C2.38889 17.2761 2.61274 17.5 2.88889 17.5H16.1111C16.3873 17.5 16.6111 17.2761 16.6111 17V10H18C18.4607 10 18.6762 9.42986 18.3308 9.12508L9.83081 1.62508C9.6418 1.45831 9.3582 1.45831 9.16919 1.62508L0.669186 9.12508C0.323766 9.42986 0.539337 10 0.999997 10ZM2.88889 9H2.32238L9.5 2.66681L16.6776 9H16.1111C15.835 9 15.6111 9.22386 15.6111 9.5V16.5H3.38889V9.5C3.38889 9.22386 3.16503 9 2.88889 9Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.7083 11.5H8.20833C7.65604 11.5 7.20833 11.9477 7.20833 12.5V16.5C7.20833 17.0523 7.65604 17.5 8.20833 17.5H10.7083C11.2606 17.5 11.7083 17.0523 11.7083 16.5V12.5C11.7083 11.9477 11.2606 11.5 10.7083 11.5ZM8.20833 16.5V12.5H10.7083V16.5H8.20833Z" fill="black"/>
</svg>
`;

const Info = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle opacity="0.8" cx="12" cy="11" r="7" fill="currentColor"/>
<path d="M9.5 9C9.5 8.72386 9.72386 8.5 10 8.5C10.2761 8.5 10.5 8.72386 10.5 9V14C10.5 14.2761 10.2761 14.5 10 14.5C9.72386 14.5 9.5 14.2761 9.5 14V9Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M3 10C3 13.866 6.13401 17 10 17C13.866 17 17 13.866 17 10C17 6.13401 13.866 3 10 3C6.13401 3 3 6.13401 3 10ZM16 10C16 13.3137 13.3137 16 10 16C6.68629 16 4 13.3137 4 10C4 6.68629 6.68629 4 10 4C13.3137 4 16 6.68629 16 10Z" fill="black"/>
<circle cx="10" cy="6.75" r="0.75" fill="black"/>
</svg>
`;

const Internet = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M11.5 20C6.80558 20 3 16.1944 3 11.5C3 6.80558 6.80558 3 11.5 3C16.1944 3 20 6.80558 20 11.5C20 16.1944 16.1944 20 11.5 20Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 10C1.5 14.6944 5.30558 18.5 10 18.5C14.6944 18.5 18.5 14.6944 18.5 10C18.5 5.30558 14.6944 1.5 10 1.5C5.30558 1.5 1.5 5.30558 1.5 10ZM17.5 10C17.5 14.1421 14.1421 17.5 10 17.5C5.85786 17.5 2.5 14.1421 2.5 10C2.5 5.85786 5.85786 2.5 10 2.5C14.1421 2.5 17.5 5.85786 17.5 10Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.5 10C6.5 14.3955 7.94179 18 10 18C12.0582 18 13.5 14.3955 13.5 10C13.5 5.60448 12.0582 2 10 2C7.94179 2 6.5 5.60448 6.5 10ZM12.5 10C12.5 13.8887 11.2555 17 10 17C8.7445 17 7.5 13.8887 7.5 10C7.5 6.11125 8.7445 3 10 3C11.2555 3 12.5 6.11125 12.5 10Z" fill="black"/>
<path d="M3.7345 5.31155L4.40527 4.56989C4.51174 4.66618 4.6261 4.76016 4.74797 4.85146C6.06562 5.83869 8.14634 6.44072 10.4133 6.44072C12.3459 6.44072 14.1501 6.00426 15.4683 5.25028C15.7894 5.06668 16.0765 4.8668 16.3253 4.65423L16.9749 5.41453C16.6772 5.66892 16.3387 5.9045 15.9648 6.11833C14.4882 6.96291 12.5131 7.44072 10.4133 7.44072C7.94222 7.44072 5.65143 6.77791 4.14836 5.65176C4.0022 5.54226 3.8641 5.42876 3.7345 5.31155Z" fill="black"/>
<path d="M3.7345 14.6991L4.40527 15.4407C4.51174 15.3444 4.6261 15.2505 4.74797 15.1592C6.06562 14.1719 8.14634 13.5699 10.4133 13.5699C12.3459 13.5699 14.1501 14.0064 15.4683 14.7603C15.7894 14.9439 16.0765 15.1438 16.3253 15.3564L16.9749 14.5961C16.6772 14.3417 16.3387 14.1061 15.9648 13.8923C14.4882 13.0477 12.5131 12.5699 10.4133 12.5699C7.94222 12.5699 5.65143 13.2327 4.14836 14.3589C4.0022 14.4684 3.8641 14.5819 3.7345 14.6991Z" fill="black"/>
<path d="M2 10.5V9.5H18V10.5H2Z" fill="black"/>
</svg>
`;

const Key = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M14.5 9V11.6111C14.5 11.7409 14.4495 11.8656 14.3592 11.9589L13.3562 12.9949L14.3541 13.9958C14.4475 14.0895 14.5 14.2164 14.5 14.3488V15.124C14.5 15.3033 14.404 15.4689 14.2483 15.558L13.5323 15.9677L14.3177 16.6139C14.4331 16.7089 14.5 16.8505 14.5 17C14.5 18.3807 13.3807 19.5 12 19.5C10.6193 19.5 9.5 18.3807 9.5 17V9C9.5 8.91628 9.50413 8.83304 9.51233 8.75051C8.27138 7.92679 7.5 6.53091 7.5 5C7.5 2.51472 9.51472 0.5 12 0.5C14.4853 0.5 16.5 2.51472 16.5 5C16.5 6.53091 15.7286 7.92679 14.4877 8.75051C14.4959 8.83304 14.5 8.91628 14.5 9Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.5 11.6111V9C12.5 8.91628 12.4959 8.83304 12.4877 8.75051C13.7286 7.92679 14.5 6.53091 14.5 5C14.5 2.51472 12.4853 0.5 10 0.5C7.51472 0.5 5.5 2.51472 5.5 5C5.5 6.53091 6.27138 7.92679 7.51233 8.75051C7.50413 8.83304 7.5 8.91628 7.5 9V17C7.5 18.3807 8.61929 19.5 10 19.5C11.3807 19.5 12.5 18.3807 12.5 17C12.5 16.8505 12.4331 16.7089 12.3177 16.6139L11.5323 15.9677L12.2483 15.558C12.404 15.4689 12.5 15.3033 12.5 15.124V14.3488C12.5 14.2164 12.4475 14.0895 12.3541 13.9958L11.3562 12.9949L12.3592 11.9589C12.4495 11.8656 12.5 11.7409 12.5 11.6111ZM11.4529 8.625C11.484 8.74626 11.5 8.87186 11.5 9V11.4087L10.296 12.6522C10.1063 12.8481 10.1086 13.1599 10.3012 13.353L11.5 14.5555V14.834L10.4069 15.4595C10.1032 15.6332 10.0674 16.0572 10.3375 16.2795L11.4836 17.2226C11.3761 17.9455 10.7528 18.5 10 18.5C9.17157 18.5 8.5 17.8284 8.5 17V9C8.5 8.87186 8.51595 8.74626 8.54713 8.625C8.60381 8.40454 8.50444 8.17362 8.30537 8.06323C7.20003 7.45024 6.5 6.28681 6.5 5C6.5 3.067 8.067 1.5 10 1.5C11.933 1.5 13.5 3.067 13.5 5C13.5 6.28681 12.8 7.45024 11.6946 8.06323C11.4956 8.17362 11.3962 8.40454 11.4529 8.625Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 5.5C10.8284 5.5 11.5 4.82843 11.5 4C11.5 3.17157 10.8284 2.5 10 2.5C9.17157 2.5 8.5 3.17157 8.5 4C8.5 4.82843 9.17157 5.5 10 5.5ZM10 3.5C10.2761 3.5 10.5 3.72386 10.5 4C10.5 4.27614 10.2761 4.5 10 4.5C9.72386 4.5 9.5 4.27614 9.5 4C9.5 3.72386 9.72386 3.5 10 3.5Z" fill="black"/>
</svg>
`;

const KniveFork = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M15.9048 0.834176C13.6721 1.99181 12.5 3.63951 12.5 5.71735C12.5 7.67355 13.5465 9.03178 15.5 9.69569V11.2007C15.0516 11.46 14.75 11.9448 14.75 12.5V17.5C14.75 18.3284 15.4216 19 16.25 19C17.0784 19 17.75 18.3284 17.75 17.5V12.5C17.75 11.9448 17.4484 11.46 17 11.2007V9.15088C17.0002 9.13999 17.0002 9.12912 17 9.11828V1.5C17 0.93764 16.404 0.575323 15.9048 0.834176ZM5.78272 2.46257C5.80339 2.04888 6.15551 1.73026 6.56921 1.75093C6.98291 1.7716 7.30152 2.12373 7.28085 2.53742C7.19904 4.17489 7.28398 5.28369 7.49964 5.80358C7.59363 6.03015 7.74212 6.16691 8 6.22214V2.5C8 2.08579 8.33579 1.75 8.75 1.75C9.16421 1.75 9.5 2.08579 9.5 2.5V6.22209C9.75773 6.16682 9.90616 6.03008 10.0001 5.80358C10.2158 5.28369 10.3007 4.17489 10.2189 2.53742C10.1982 2.12373 10.5169 1.7716 10.9306 1.75093C11.3442 1.73026 11.6964 2.04888 11.717 2.46257C11.8093 4.30918 11.7108 5.59435 11.3856 6.37832C11.0497 7.1881 10.3862 7.64523 9.5 7.73386V11.2007C9.94835 11.46 10.25 11.9448 10.25 12.5V17.5C10.25 18.3284 9.57843 19 8.75 19C7.92157 19 7.25 18.3284 7.25 17.5V12.5C7.25 11.9448 7.55165 11.46 8 11.2007V7.73389C7.11368 7.64531 6.45006 7.18817 6.11412 6.37832C5.78892 5.59435 5.69046 4.30918 5.78272 2.46257Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.2791 1.05145C12.1208 2.11457 11 3.61133 11 5.50647C11 7.32619 12.0372 8.557 14 9.13733V11C14 11.2761 14.2239 11.5 14.5 11.5C14.7761 11.5 15 11.2761 15 11V8.76362C15.0002 8.75649 15.0002 8.74939 15 8.74231V1.49999C15 1.1296 14.6113 0.88779 14.2791 1.05145ZM12 5.50647C12 4.23782 12.6491 3.19236 14 2.34771V8.08786C12.6365 7.61052 12 6.7667 12 5.50647Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M13 12.5V17.5C13 18.3284 13.6716 19 14.5 19C15.3284 19 16 18.3284 16 17.5V12.5C16 11.6716 15.3284 11 14.5 11C13.6716 11 13 11.6716 13 12.5ZM14.5 18C14.2239 18 14 17.7761 14 17.5V12.5C14 12.2239 14.2239 12 14.5 12C14.7761 12 15 12.2239 15 12.5V17.5C15 17.7761 14.7761 18 14.5 18Z" fill="black"/>
<path d="M4.53241 2.47505C4.54619 2.19925 4.78094 1.98684 5.05674 2.00062C5.33253 2.0144 5.54494 2.24915 5.53116 2.52495C5.44761 4.19727 5.53481 5.33547 5.76872 5.89937C5.95181 6.34075 6.31286 6.53348 6.97128 6.49561C7.24697 6.47975 7.48331 6.69038 7.49917 6.96607C7.51503 7.24175 7.3044 7.4781 7.02872 7.49396C5.97051 7.55483 5.20281 7.14501 4.84504 6.28253C4.53809 5.54257 4.44189 4.2868 4.53241 2.47505Z" fill="black"/>
<path d="M9.46744 2.47505C9.45366 2.19925 9.21891 1.98684 8.94311 2.00062C8.66731 2.0144 8.45491 2.24915 8.46868 2.52495C8.55224 4.19727 8.46504 5.33547 8.23113 5.89937C8.04803 6.34075 7.68699 6.53348 7.02856 6.49561C6.75288 6.47975 6.51653 6.69038 6.50067 6.96607C6.48481 7.24175 6.69545 7.4781 6.97113 7.49396C8.02933 7.55483 8.79704 7.14501 9.15481 6.28253C9.46175 5.54257 9.55796 4.2868 9.46744 2.47505Z" fill="black"/>
<path d="M6.5 2.5C6.5 2.22386 6.72386 2 7 2C7.27614 2 7.5 2.22386 7.5 2.5V11.4998C7.5 11.7759 7.27614 11.9998 7 11.9998C6.72386 11.9998 6.5 11.7759 6.5 11.4998V2.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 12.5V17.5C5.5 18.3284 6.17157 19 7 19C7.82843 19 8.5 18.3284 8.5 17.5V12.5C8.5 11.6716 7.82843 11 7 11C6.17157 11 5.5 11.6716 5.5 12.5ZM7 18C6.72386 18 6.5 17.7761 6.5 17.5V12.5C6.5 12.2239 6.72386 12 7 12C7.27614 12 7.5 12.2239 7.5 12.5V17.5C7.5 17.7761 7.27614 18 7 18Z" fill="black"/>
</svg>
`;

const Letter = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect opacity="0.8" x="4.5" y="5.5" width="15" height="12" rx="1.5" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M17 4H3C2.72386 4 2.5 4.22386 2.5 4.5V15.5C2.5 15.7761 2.72386 16 3 16H17C17.2761 16 17.5 15.7761 17.5 15.5V4.5C17.5 4.22386 17.2761 4 17 4ZM3.5 15V5H16.5V15H3.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M17.3242 4.88066L10.2792 10.8807C10.0914 11.0406 9.81512 11.0397 9.62838 10.8786L2.6734 4.87859C2.32251 4.57588 2.53659 4 3 4H17C17.465 4 17.6782 4.57917 17.3242 4.88066ZM15.6418 5H4.34504L9.95708 9.84146L15.6418 5Z" fill="black"/>
</svg>
`;

const LockClosed = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8 9.64494V6.5C8 4.567 9.567 3 11.5 3C13.433 3 15 4.567 15 6.5V9.64494C16.4457 10.0752 17.5 11.4145 17.5 13V16C17.5 17.933 15.933 19.5 14 19.5H9C7.067 19.5 5.5 17.933 5.5 16V13C5.5 11.4145 6.55426 10.0752 8 9.64494ZM9.5 9.5V6.5C9.5 5.39543 10.3954 4.5 11.5 4.5C12.6046 4.5 13.5 5.39543 13.5 6.5V9.5H9.5Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.5 12.5C7.5 13.6046 8.39543 14.5 9.5 14.5C10.6046 14.5 11.5 13.6046 11.5 12.5C11.5 11.3954 10.6046 10.5 9.5 10.5C8.39543 10.5 7.5 11.3954 7.5 12.5ZM10.5 12.5C10.5 13.0523 10.0523 13.5 9.5 13.5C8.94772 13.5 8.5 13.0523 8.5 12.5C8.5 11.9477 8.94772 11.5 9.5 11.5C10.0523 11.5 10.5 11.9477 10.5 12.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M12 7.5H7C5.067 7.5 3.5 9.067 3.5 11V14C3.5 15.933 5.067 17.5 7 17.5H12C13.933 17.5 15.5 15.933 15.5 14V11C15.5 9.067 13.933 7.5 12 7.5ZM4.5 11C4.5 9.61929 5.61929 8.5 7 8.5H12C13.3807 8.5 14.5 9.61929 14.5 11V14C14.5 15.3807 13.3807 16.5 12 16.5H7C5.61929 16.5 4.5 15.3807 4.5 14V11Z" fill="black"/>
<path d="M7 8C7 8.27614 6.77614 8.5 6.5 8.5C6.22386 8.5 6 8.27614 6 8V4.5C6 2.567 7.567 1 9.5 1C11.433 1 13 2.567 13 4.5V8C13 8.27614 12.7761 8.5 12.5 8.5C12.2239 8.5 12 8.27614 12 8V4.5C12 3.11929 10.8807 2 9.5 2C8.11929 2 7 3.11929 7 4.5V8Z" fill="black"/>
</svg>
`;

const LockOpen = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M9.5 9.5H14C15.933 9.5 17.5 11.067 17.5 13V16C17.5 17.933 15.933 19.5 14 19.5H9C7.067 19.5 5.5 17.933 5.5 16V13C5.5 11.4145 6.55426 10.0752 8 9.64494V6.75C8 4.6928 9.55173 3 11.5 3C13.4483 3 15 4.6928 15 6.75V7C15 7.41421 14.6642 7.75 14.25 7.75C13.8358 7.75 13.5 7.41421 13.5 7V6.75C13.5 5.49349 12.5893 4.5 11.5 4.5C10.4107 4.5 9.5 5.49349 9.5 6.75V9.5Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.5 12.5C7.5 13.6046 8.39543 14.5 9.5 14.5C10.6046 14.5 11.5 13.6046 11.5 12.5C11.5 11.3954 10.6046 10.5 9.5 10.5C8.39543 10.5 7.5 11.3954 7.5 12.5ZM10.5 12.5C10.5 13.0523 10.0523 13.5 9.5 13.5C8.94772 13.5 8.5 13.0523 8.5 12.5C8.5 11.9477 8.94772 11.5 9.5 11.5C10.0523 11.5 10.5 11.9477 10.5 12.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M12 7.5H7C5.067 7.5 3.5 9.067 3.5 11V14C3.5 15.933 5.067 17.5 7 17.5H12C13.933 17.5 15.5 15.933 15.5 14V11C15.5 9.067 13.933 7.5 12 7.5ZM4.5 11C4.5 9.61929 5.61929 8.5 7 8.5H12C13.3807 8.5 14.5 9.61929 14.5 11V14C14.5 15.3807 13.3807 16.5 12 16.5H7C5.61929 16.5 4.5 15.3807 4.5 14V11Z" fill="black"/>
<path d="M7 8C7 8.27614 6.77614 8.5 6.5 8.5C6.22386 8.5 6 8.27614 6 8V4.5C6 2.567 7.567 1 9.5 1C11.433 1 13 2.567 13 4.5V5.5C13 5.77614 12.7761 6 12.5 6C12.2239 6 12 5.77614 12 5.5V4.5C12 3.11929 10.8807 2 9.5 2C8.11929 2 7 3.11929 7 4.5V8Z" fill="black"/>
</svg>
`;

const Loop = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 9.5C5.5 12.5376 7.96243 15 11 15C11.9892 15 12.9174 14.7389 13.7194 14.2818C13.7801 14.381 13.8534 14.4748 13.9393 14.5607L16.9393 17.5607C17.5251 18.1464 18.4749 18.1464 19.0607 17.5607C19.6464 16.9749 19.6464 16.0251 19.0607 15.4393L16.0607 12.4393C15.9748 12.3534 15.881 12.2801 15.7818 12.2194C16.2389 11.4174 16.5 10.4892 16.5 9.5C16.5 6.46243 14.0376 4 11 4C7.96243 4 5.5 6.46243 5.5 9.5Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.82842 4.82838C2.8758 6.781 2.8758 9.94683 4.82842 11.8994C6.78104 13.8521 9.94686 13.8521 11.8995 11.8994C13.8521 9.94683 13.8521 6.781 11.8995 4.82838C9.94687 2.87576 6.78104 2.87576 4.82842 4.82838ZM11.1924 11.1923C9.63028 12.7544 7.09762 12.7544 5.53553 11.1923C3.97343 9.63024 3.97343 7.09758 5.53553 5.53549C7.09762 3.97339 9.63028 3.97339 11.1924 5.53549C12.7545 7.09758 12.7545 9.63024 11.1924 11.1923Z" fill="black"/>
<path d="M11.1924 12.6274C10.8019 12.2369 10.8019 11.6037 11.1924 11.2132C11.583 10.8227 12.2161 10.8227 12.6066 11.2132L15.4351 14.0416C15.8256 14.4321 15.8256 15.0653 15.4351 15.4558C15.0445 15.8463 14.4114 15.8463 14.0209 15.4558L11.1924 12.6274Z" fill="black"/>
</svg>
`;

const LoopMinus = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.82847 5.8284C4.48532 8.17155 4.48532 11.9705 6.82847 14.3137C8.68527 16.1705 11.4563 16.5559 13.6926 15.4699C13.7507 15.5614 13.8197 15.648 13.8995 15.7279L17.4351 19.2634C18.0209 19.8492 18.9706 19.8492 19.5564 19.2634C20.1422 18.6776 20.1422 17.7279 19.5564 17.1421L16.0209 13.6066C16.0013 13.587 15.9813 13.568 15.9609 13.5498C17.6322 11.2064 17.4165 7.93118 15.3137 5.8284C12.9706 3.48526 9.17161 3.48526 6.82847 5.8284Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.18202 5.18193C3.03414 7.32982 3.03414 10.8122 5.18202 12.9601C7.3299 15.108 10.8123 15.108 12.9602 12.9601C15.1081 10.8122 15.1081 7.32982 12.9602 5.18193C10.8123 3.03405 7.3299 3.03405 5.18202 5.18193ZM12.2531 12.253C10.4957 14.0104 7.64648 14.0104 5.88913 12.253C4.13177 10.4956 4.13177 7.6464 5.88913 5.88904C7.64648 4.13168 10.4957 4.13168 12.2531 5.88904C14.0104 7.6464 14.0104 10.4956 12.2531 12.253Z" fill="black"/>
<path d="M12 14.1213C11.6095 13.7308 11.6095 13.0976 12 12.7071C12.3905 12.3166 13.0237 12.3166 13.4142 12.7071L17.2028 16.4957C17.5933 16.8862 17.5933 17.5193 17.2028 17.9099C16.8123 18.3004 16.1791 18.3004 15.7886 17.9099L12 14.1213Z" fill="black"/>
<path d="M6.70709 9.41418C6.43095 9.41418 6.20709 9.19033 6.20709 8.91418C6.20709 8.63804 6.43095 8.41418 6.70709 8.41418H11.1924C11.4685 8.41418 11.6924 8.63804 11.6924 8.91418C11.6924 9.19033 11.4685 9.41418 11.1924 9.41418H6.70709Z" fill="black"/>
</svg>
`;

const LoopPlus = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.82847 5.8284C4.48532 8.17155 4.48532 11.9705 6.82847 14.3137C8.68527 16.1705 11.4563 16.5559 13.6926 15.4699C13.7507 15.5614 13.8197 15.648 13.8995 15.7279L17.4351 19.2634C18.0209 19.8492 18.9706 19.8492 19.5564 19.2634C20.1422 18.6776 20.1422 17.7279 19.5564 17.1421L16.0209 13.6066C16.0013 13.587 15.9813 13.568 15.9609 13.5498C17.6322 11.2064 17.4165 7.93118 15.3137 5.8284C12.9706 3.48526 9.17161 3.48526 6.82847 5.8284Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.18202 5.18193C3.03414 7.32982 3.03414 10.8122 5.18202 12.9601C7.3299 15.108 10.8123 15.108 12.9602 12.9601C15.1081 10.8122 15.1081 7.32982 12.9602 5.18193C10.8123 3.03405 7.3299 3.03405 5.18202 5.18193ZM12.2531 12.253C10.4957 14.0104 7.64648 14.0104 5.88913 12.253C4.13177 10.4956 4.13177 7.6464 5.88913 5.88904C7.64648 4.13168 10.4957 4.13168 12.2531 5.88904C14.0104 7.6464 14.0104 10.4956 12.2531 12.253Z" fill="black"/>
<path d="M12 14.1213C11.6095 13.7308 11.6095 13.0976 12 12.7071C12.3905 12.3166 13.0237 12.3166 13.4142 12.7071L17.2028 16.4957C17.5933 16.8862 17.5933 17.5193 17.2028 17.9099C16.8123 18.3004 16.1791 18.3004 15.7886 17.9099L12 14.1213Z" fill="black"/>
<path d="M7.20709 9.66418C6.93095 9.66418 6.70709 9.44033 6.70709 9.16418C6.70709 8.88804 6.93095 8.66418 7.20709 8.66418H11.2071C11.4832 8.66418 11.7071 8.88804 11.7071 9.16418C11.7071 9.44033 11.4832 9.66418 11.2071 9.66418H7.20709Z" fill="black"/>
<path d="M8.70709 7.16418C8.70709 6.88804 8.93095 6.66418 9.20709 6.66418C9.48323 6.66418 9.70709 6.88804 9.70709 7.16418V11.1642C9.70709 11.4403 9.48323 11.6642 9.20709 11.6642C8.93095 11.6642 8.70709 11.4403 8.70709 11.1642V7.16418Z" fill="black"/>
</svg>
`;

const Magnet = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.13174 4.64646C8.327 4.4512 8.64358 4.4512 8.83884 4.64646L11.8693 7.67692C12.0646 7.87218 12.0646 8.18876 11.8693 8.38403L7.62666 12.6267C7.15245 13.1009 7.15245 13.8697 7.62666 14.3439C8.10087 14.8181 8.86971 14.8181 9.34392 14.3439L13.5866 10.1013C13.7818 9.90602 14.0984 9.90602 14.2937 10.1013L17.3241 13.1317C17.5194 13.327 17.5194 13.6436 17.3241 13.8388L13.0815 18.0815C10.5431 20.6199 6.42751 20.6199 3.8891 18.0815C1.35069 15.5431 1.35069 11.4275 3.8891 8.8891L8.13174 4.64646Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.4012 8.4285C13.8884 8.22339 13.639 7.64142 13.8441 7.12864L15.1943 3.75317L16.7526 4.27261L17.5714 2.56719C17.8105 2.06932 18.4079 1.85949 18.9057 2.09853C19.4036 2.33757 19.6134 2.93496 19.3744 3.43283L17.7926 6.72744L16.3509 6.24688L15.7011 7.87142C15.496 8.3842 14.914 8.63362 14.4012 8.4285Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.13174 3.64646C7.327 3.4512 7.64358 3.4512 7.83884 3.64646L10.8693 6.67692C11.0646 6.87218 11.0646 7.18876 10.8693 7.38403L6.62666 11.6267C6.15245 12.1009 6.15245 12.8697 6.62666 13.3439C7.10087 13.8181 7.86971 13.8181 8.34392 13.3439L12.5866 9.10128C12.7818 8.90602 13.0984 8.90602 13.2937 9.10128L16.3241 12.1317C16.5194 12.327 16.5194 12.6436 16.3241 12.8388L12.0815 17.0815C9.54308 19.6199 5.42751 19.6199 2.8891 17.0815C0.350692 14.5431 0.350691 10.4275 2.8891 7.8891L7.13174 3.64646ZM7.48529 4.70712L3.59621 8.59621C1.44832 10.7441 1.44832 14.2265 3.59621 16.3744C5.74409 18.5223 9.2265 18.5223 11.3744 16.3744L15.2635 12.4853L12.9401 10.1619L9.05103 14.051C8.1863 14.9158 6.78429 14.9158 5.91955 14.051C5.05482 13.1863 5.05482 11.7843 5.91955 10.9196L9.80864 7.03047L7.48529 4.70712Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.48531 10.0608L4.45485 7.03038L5.16196 6.32327L8.19241 9.35373L7.48531 10.0608Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.9401 15.5157L9.90965 12.4852L10.6168 11.7781L13.6472 14.8086L12.9401 15.5157Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.5869 6.96424C12.3305 6.86169 12.2058 6.5707 12.3083 6.31431L13.4834 3.37658L15.0126 3.88629L16.0221 1.78358C16.1417 1.53465 16.4404 1.42973 16.6893 1.54925C16.9382 1.66877 17.0431 1.96746 16.9236 2.2164L15.5326 5.11371L14.0617 4.62343L13.2368 6.6857C13.1343 6.94209 12.8433 7.0668 12.5869 6.96424Z" fill="black"/>
</svg>
`;

const Map = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path opacity="0.8" fill-rule="evenodd" clip-rule="evenodd" d="M15.6891 9.53422C16.5519 9.83406 17.252 10.5354 17.5489 11.4595L18.8501 15.5097C19.3619 17.1027 18.5207 18.8206 16.9712 19.3467C16.6722 19.4483 16.3594 19.5 16.0445 19.5H7.95468C6.32285 19.5 5 18.14 5 16.4624C5 16.1387 5.05033 15.8171 5.14907 15.5097L6.45027 11.4595C6.74724 10.5352 7.44769 9.83367 8.31081 9.53397C8.11499 8.90123 8 8.29712 8 7.78555C8 5.41871 9.79086 3.5 12 3.5C14.2091 3.5 16 5.41871 16 7.78555C16 8.29719 15.885 8.90139 15.6891 9.53422Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 8.5C11.1046 8.5 12 7.60457 12 6.5C12 5.39543 11.1046 4.5 10 4.5C8.89543 4.5 8 5.39543 8 6.5C8 7.60457 8.89543 8.5 10 8.5ZM10 5.5C10.5523 5.5 11 5.94772 11 6.5C11 7.05228 10.5523 7.5 10 7.5C9.44772 7.5 9 7.05228 9 6.5C9 5.94772 9.44772 5.5 10 5.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 6.28555C5.5 8.95892 8.15253 13.5 10 13.5C11.8475 13.5 14.5 8.95892 14.5 6.28555C14.5 3.64998 12.4933 1.5 10 1.5C7.50672 1.5 5.5 3.64998 5.5 6.28555ZM13.5 6.28555C13.5 8.47937 11.1515 12.5 10 12.5C8.84852 12.5 6.5 8.47937 6.5 6.28555C6.5 4.18744 8.075 2.5 10 2.5C11.925 2.5 13.5 4.18744 13.5 6.28555Z" fill="black"/>
<path d="M13.4351 9.14065C13.1784 9.03882 13.0529 8.74818 13.1547 8.4915C13.2565 8.23482 13.5472 8.10929 13.8038 8.21112C14.6228 8.53604 15.2624 9.20622 15.5442 10.0514L16.8775 14.0514C17.4014 15.6232 16.552 17.3222 14.9801 17.8461C14.6742 17.9481 14.3539 18.0001 14.0314 18.0001H5.96857C4.31171 18.0001 2.96857 16.6569 2.96857 15.0001C2.96857 14.6776 3.02055 14.3573 3.12252 14.0514L4.45585 10.0514C4.74265 9.19096 5.40021 8.51244 6.23914 8.19446C6.49735 8.09659 6.78602 8.22657 6.88389 8.48479C6.98176 8.74301 6.85178 9.03167 6.59356 9.12954C6.03409 9.3416 5.59577 9.7939 5.40453 10.3676L4.0712 14.3676C4.00322 14.5715 3.96857 14.7851 3.96857 15.0001C3.96857 16.1046 4.864 17.0001 5.96857 17.0001H14.0314C14.2464 17.0001 14.46 16.9654 14.6639 16.8974C15.7118 16.5481 16.2781 15.4155 15.9288 14.3676L14.5955 10.3676C14.4076 9.80406 13.9813 9.35735 13.4351 9.14065Z" fill="black"/>
</svg>
`;

const Microphone = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.5 2.5C10.1193 2.5 9 3.61929 9 5V9C9 10.3807 10.1193 11.5 11.5 11.5C12.8807 11.5 14 10.3807 14 9V5C14 3.61929 12.8807 2.5 11.5 2.5ZM7 18C7 18.7917 8.66602 19 11.5 19C14.334 19 16 18.7917 16 18C16 17.3102 14.7355 17.0633 12.5357 17.0112V15.4228C15.3326 15.0011 17.5 12.9009 17.5 10.3V8.5C17.5 7.94772 17.0523 7.5 16.5 7.5C15.9477 7.5 15.5 7.94772 15.5 8.5V10.3C15.5 12.0249 13.744 13.5 11.5 13.5C9.25601 13.5 7.5 12.0249 7.5 10.3V8.5C7.5 7.94772 7.05228 7.5 6.5 7.5C5.94772 7.5 5.5 7.94772 5.5 8.5V10.3C5.5 12.923 7.70437 15.0368 10.5357 15.4332V17.0095C8.29194 17.058 7 17.3028 7 18Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.75 4.25C7.75 3.00736 8.75736 2 10 2C11.2426 2 12.25 3.00736 12.25 4.25V7.75C12.25 8.99264 11.2426 10 10 10C8.75736 10 7.75 8.99264 7.75 7.75V4.25Z" fill="black"/>
<path d="M10 17C7.51962 17 6 16.7829 6 16C6 15.2171 7.51962 15 10 15C12.4804 15 14 15.2171 14 16C14 16.7829 12.4804 17 10 17Z" fill="black"/>
<path d="M9.5 12.5L10.5 12.5V16H9.5L9.5 12.5Z" fill="black"/>
<path d="M14 7.5C14 7.22386 14.2239 7 14.5 7C14.7761 7 15 7.22386 15 7.5V9.15C15 11.5713 12.7456 13.5 10 13.5C7.25438 13.5 5 11.5713 5 9.15V7.5C5 7.22386 5.22386 7 5.5 7C5.77614 7 6 7.22386 6 7.5V9.15C6 10.9813 7.77506 12.5 10 12.5C12.2249 12.5 14 10.9813 14 9.15V7.5Z" fill="black"/>
</svg>
`;

const Minus = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M6.5 12.5C5.67157 12.5 5 11.8284 5 11C5 10.1716 5.67157 9.5 6.5 9.5H16.5C17.3284 9.5 18 10.1716 18 11C18 11.8284 17.3284 12.5 16.5 12.5H6.5Z" fill="currentColor"/>
</g>
<path d="M5 10.5C4.72386 10.5 4.5 10.2761 4.5 10C4.5 9.72386 4.72386 9.5 5 9.5H15C15.2761 9.5 15.5 9.72386 15.5 10C15.5 10.2761 15.2761 10.5 15 10.5H5Z" fill="black"/>
</svg>
`;

const Monitor = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M8.5315 18.75C8.51094 18.6701 8.5 18.5863 8.5 18.5V16H3.5C2.67157 16 2 15.3284 2 14.5V4.5C2 3.67157 2.67157 3 3.5 3H18.5C19.3284 3 20 3.67157 20 4.5V14.5C20 15.3284 19.3284 16 18.5 16H13.5V18.5C13.5 18.5863 13.4891 18.6701 13.4685 18.75H15.5C15.7761 18.75 16 18.9739 16 19.25C16 19.5261 15.7761 19.75 15.5 19.75H6.5C6.22386 19.75 6 19.5261 6 19.25C6 18.9739 6.22386 18.75 6.5 18.75H8.5315Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M17.5 1.5H2.5C1.39543 1.5 0.5 2.39543 0.5 3.5V13.5C0.5 14.6046 1.39543 15.5 2.5 15.5H17.5C18.6046 15.5 19.5 14.6046 19.5 13.5V3.5C19.5 2.39543 18.6046 1.5 17.5 1.5ZM1.5 3.5C1.5 2.94772 1.94772 2.5 2.5 2.5H17.5C18.0523 2.5 18.5 2.94772 18.5 3.5V13.5C18.5 14.0523 18.0523 14.5 17.5 14.5H2.5C1.94772 14.5 1.5 14.0523 1.5 13.5V3.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.5 14.5H8.5C7.94772 14.5 7.5 14.9477 7.5 15.5V18C7.5 18.5523 7.94772 19 8.5 19H11.5C12.0523 19 12.5 18.5523 12.5 18V15.5C12.5 14.9477 12.0523 14.5 11.5 14.5ZM8.5 18V15.5H11.5V18H8.5Z" fill="black"/>
<path d="M5.5 19C5.22386 19 5 18.7761 5 18.5C5 18.2239 5.22386 18 5.5 18H14.5C14.7761 18 15 18.2239 15 18.5C15 18.7761 14.7761 19 14.5 19H5.5Z" fill="black"/>
<path d="M2.5 3H17.5C17.7761 3 18 3.22386 18 3.5V12.5C18 12.7761 17.7761 13 17.5 13H2.5C2.22386 13 2 12.7761 2 12.5V3.5C2 3.22386 2.22386 3 2.5 3Z" fill="black"/>
</svg>
`;

const Monitor2 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 4.5C2 3.67157 2.67157 3 3.5 3H18.5C19.3284 3 20 3.67157 20 4.5V14.5C20 15.3284 19.3284 16 18.5 16H13.5V18.5C13.5 18.5863 13.4891 18.6701 13.4685 18.75H15.5C15.7761 18.75 16 18.9739 16 19.25C16 19.5261 15.7761 19.75 15.5 19.75H6.5C6.22386 19.75 6 19.5261 6 19.25C6 18.9739 6.22386 18.75 6.5 18.75H8.5315C8.51094 18.6701 8.5 18.5863 8.5 18.5V16H3.5C2.67157 16 2 15.3284 2 14.5V4.5Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M17.5 1.5H2.5C1.39543 1.5 0.5 2.39543 0.5 3.5V13.5C0.5 14.6046 1.39543 15.5 2.5 15.5H17.5C18.6046 15.5 19.5 14.6046 19.5 13.5V3.5C19.5 2.39543 18.6046 1.5 17.5 1.5ZM1.5 3.5C1.5 2.94772 1.94772 2.5 2.5 2.5H17.5C18.0523 2.5 18.5 2.94772 18.5 3.5V13.5C18.5 14.0523 18.0523 14.5 17.5 14.5H2.5C1.94772 14.5 1.5 14.0523 1.5 13.5V3.5Z" fill="black"/>
<path d="M10 14C9.58579 14 9.25 13.6642 9.25 13.25C9.25 12.8358 9.58579 12.5 10 12.5C10.4142 12.5 10.75 12.8358 10.75 13.25C10.75 13.6642 10.4142 14 10 14Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.5 14.5H8.5C7.94772 14.5 7.5 14.9477 7.5 15.5V18C7.5 18.5523 7.94772 19 8.5 19H11.5C12.0523 19 12.5 18.5523 12.5 18V15.5C12.5 14.9477 12.0523 14.5 11.5 14.5ZM8.5 18V15.5H11.5V18H8.5Z" fill="black"/>
<path d="M5.5 19C5.22386 19 5 18.7761 5 18.5C5 18.2239 5.22386 18 5.5 18H14.5C14.7761 18 15 18.2239 15 18.5C15 18.7761 14.7761 19 14.5 19H5.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M19 12H1V11H19V12Z" fill="black"/>
</svg>
`;

const Moon = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M12.6123 3.47407C11.1462 4.11939 10.0652 5.42476 9.7254 7.02351C9.15 9.73052 10.8735 12.3901 13.5744 12.9642C15.7487 13.4263 17.9491 12.3945 19.0014 10.4699C19.2458 10.0229 19.9239 10.185 19.9398 10.6941C19.9612 11.3759 19.9002 12.0618 19.7559 12.7406C18.7782 17.3406 14.2633 20.2788 9.67122 19.3027C5.07917 18.3266 2.14967 13.8061 3.12742 9.20615C4.047 4.87987 8.1173 1.98618 12.4718 2.52015C12.9761 2.582 13.0774 3.26938 12.6123 3.47407Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.2754 6.02351C8.61522 4.42476 9.69616 3.11939 11.1623 2.47407C11.6274 2.26938 11.5261 1.582 11.0218 1.52015C6.6673 0.98618 2.597 3.87987 1.67742 8.20615C0.699672 12.8061 3.62918 17.3266 8.22122 18.3027C12.8133 19.2788 17.3282 16.3406 18.3059 11.7406C18.4502 11.0618 18.5112 10.3759 18.4898 9.69414C18.4739 9.18497 17.7958 9.02293 17.5514 9.4699C16.4991 11.3945 14.2987 12.4263 12.1244 11.9642C9.42351 11.3901 7.70001 8.73052 8.2754 6.02351ZM2.65557 8.41406C3.35101 5.14227 6.0879 2.79892 9.27325 2.49127C8.28445 3.33513 7.57861 4.49189 7.29725 5.81559C6.60712 9.0624 8.67496 12.2533 11.9165 12.9423C13.9291 13.3701 15.9599 12.7316 17.3629 11.3577C17.3519 11.4161 17.3402 11.4744 17.3278 11.5327C16.4648 15.5929 12.4805 18.1857 8.42914 17.3246C4.37773 16.4634 1.79256 12.4742 2.65557 8.41406Z" fill="black"/>
</svg>
`;

const Motorcycle = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.3215 7.38391C14.8993 8.08318 16 9.66305 16 11.5V14C16 15.1046 15.1046 16 14 16H13.4146C13.4699 16.1564 13.5 16.3247 13.5 16.5V18.5C13.5 19.3284 12.8284 20 12 20H11C10.1716 20 9.5 19.3284 9.5 18.5V16.5C9.5 16.3247 9.53008 16.1564 9.58535 16H9C7.89543 16 7 15.1046 7 14L7 11.5C7 9.66305 8.10067 8.08318 9.67849 7.38391C8.96207 6.83567 8.5 5.9718 8.5 5C8.5 3.34315 9.84315 2 11.5 2C13.1569 2 14.5 3.34315 14.5 5C14.5 5.9718 14.0379 6.83567 13.3215 7.38391Z" fill="currentColor"/>
</g>
<path d="M12.75 12C12.75 12.5523 12.3023 13 11.75 13C11.1977 13 10.75 12.5523 10.75 12C10.75 11.4477 11.1977 11 11.75 11C12.3023 11 12.75 11.4477 12.75 12Z" fill="black"/>
<path d="M9.25 12C9.25 12.5523 8.80228 13 8.25 13C7.69772 13 7.25 12.5523 7.25 12C7.25 11.4477 7.69772 11 8.25 11C8.80228 11 9.25 11.4477 9.25 12Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 7C11.6569 7 13 5.65685 13 4C13 2.34315 11.6569 1 10 1C8.34315 1 7 2.34315 7 4C7 5.65685 8.34315 7 10 7ZM10 2C11.1046 2 12 2.89543 12 4C12 5.10457 11.1046 6 10 6C8.89543 6 8 5.10457 8 4C8 2.89543 8.89543 2 10 2Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.5 14H9.5C8.67157 14 8 14.6716 8 15.5V17.5C8 18.3284 8.67157 19 9.5 19H10.5C11.3284 19 12 18.3284 12 17.5V15.5C12 14.6716 11.3284 14 10.5 14ZM9 15.5C9 15.2239 9.22386 15 9.5 15H10.5C10.7761 15 11 15.2239 11 15.5V17.5C11 17.7761 10.7761 18 10.5 18H9.5C9.22386 18 9 17.7761 9 17.5V15.5Z" fill="black"/>
<path d="M15.5 3.75C15.0858 3.75 14.75 3.41421 14.75 3C14.75 2.58579 15.0858 2.25 15.5 2.25H17.5C17.9142 2.25 18.25 2.58579 18.25 3C18.25 3.41421 17.9142 3.75 17.5 3.75H15.5Z" fill="black"/>
<path d="M2.5 3.75C2.08579 3.75 1.75 3.41421 1.75 3C1.75 2.58579 2.08579 2.25 2.5 2.25H4.5C4.91421 2.25 5.25 2.58579 5.25 3C5.25 3.41421 4.91421 3.75 4.5 3.75H2.5Z" fill="black"/>
<path d="M4.10634 3.36382L4.40831 2.39368L8.10634 3.13621L7.80437 4.10635L4.10634 3.36382Z" fill="black"/>
<path d="M11.8937 3.13618L12.1956 4.10632L15.8937 3.36379L15.5917 2.39365L11.8937 3.13618Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.5 10.5C14.5 8.01472 12.4853 6 10 6C7.51472 6 5.5 8.01472 5.5 10.5V13C5.5 14.1046 6.39543 15 7.5 15H12.5C13.6046 15 14.5 14.1046 14.5 13V10.5ZM6.5 10.5C6.5 8.567 8.067 7 10 7C11.933 7 13.5 8.567 13.5 10.5V13C13.5 13.5523 13.0523 14 12.5 14H7.5C6.94772 14 6.5 13.5523 6.5 13V10.5Z" fill="black"/>
</svg>
`;

const MusicNoteDouble = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.25 3.80991C8.25 3.29388 8.64265 2.86259 9.15642 2.8143L18.1564 1.96834C18.7431 1.9132 19.25 2.3747 19.25 2.96395V4.00002V5.14521V16C19.25 17.3807 17.9069 18.5 16.25 18.5C14.5931 18.5 13.25 17.3807 13.25 16C13.25 14.6193 14.5931 13.5 16.25 13.5C16.6006 13.5 16.9372 13.5501 17.25 13.6423V6.24933L10.25 6.94384V17C10.25 18.3807 8.90685 19.5 7.25 19.5C5.59315 19.5 4.25 18.3807 4.25 17C4.25 15.6193 5.59315 14.5 7.25 14.5C7.60064 14.5 7.93722 14.5501 8.25 14.6423V6.03814V5.00002V3.80991Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15.1388 1.37578L8.13875 1.89638C7.35564 1.95462 6.75 2.60698 6.75 3.39225V4.12892C6.75038 4.1583 6.75058 4.17298 6.75115 4.18766C6.75173 4.20233 6.75268 4.21699 6.7546 4.24631C6.81943 5.0722 7.5415 5.68915 8.36739 5.62432L15.3674 5.07481C16.1479 5.01354 16.75 4.36231 16.75 3.57941V2.87165C16.7493 2.81599 16.7493 2.81597 16.7459 2.76046L16.7459 2.7604C16.6844 1.93426 15.9649 1.31434 15.1388 1.37578ZM7.75 4.12892V3.39225C7.75 3.1305 7.95188 2.91304 8.21292 2.89363L15.2129 2.37303C15.4883 2.35255 15.7281 2.55919 15.7486 2.83457C15.7492 2.84383 15.7495 2.84846 15.7497 2.8531C15.7498 2.85773 15.7499 2.86237 15.75 2.87165V3.57941C15.75 3.84037 15.5493 4.05745 15.2891 4.07787L8.28913 4.62738C8.01383 4.649 7.77314 4.44334 7.75153 4.16805C7.75026 4.1485 7.75026 4.1485 7.75 4.12892Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.75 16C1.75 17.4083 3.1146 18.5 4.75 18.5C6.3854 18.5 7.75 17.4083 7.75 16C7.75 14.5917 6.3854 13.5 4.75 13.5C3.1146 13.5 1.75 14.5917 1.75 16ZM6.75 16C6.75 16.8008 5.87602 17.5 4.75 17.5C3.62398 17.5 2.75 16.8008 2.75 16C2.75 15.1992 3.62398 14.5 4.75 14.5C5.87602 14.5 6.75 15.1992 6.75 16Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.6699 16.8046C12.2259 17.2495 12.9663 17.5 13.75 17.5C15.3854 17.5 16.75 16.4083 16.75 15C16.75 13.5917 15.3854 12.5 13.75 12.5C12.1146 12.5 10.75 13.5917 10.75 15C10.75 15.6971 11.0905 16.3411 11.6699 16.8046ZM15.75 15C15.75 15.8008 14.876 16.5 13.75 16.5C13.1896 16.5 12.6702 16.3242 12.2946 16.0238C11.9423 15.742 11.75 15.3782 11.75 15C11.75 14.1992 12.624 13.5 13.75 13.5C14.876 13.5 15.75 14.1992 15.75 15Z" fill="black"/>
<path d="M6.75 3.5C6.75 3.22386 6.97386 3 7.25 3C7.52614 3 7.75 3.22386 7.75 3.5V16C7.75 16.2761 7.52614 16.5 7.25 16.5C6.97386 16.5 6.75 16.2761 6.75 16V3.5Z" fill="black"/>
<path d="M15.75 3.5C15.75 3.22386 15.9739 3 16.25 3C16.5261 3 16.75 3.22386 16.75 3.5V15C16.75 15.2761 16.5261 15.5 16.25 15.5C15.9739 15.5 15.75 15.2761 15.75 15V3.5Z" fill="black"/>
</svg>
`;

const MusicNoteSingle = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.531 2.33645C15.8538 5.27397 18 7.40061 18 8.94299C18 10.4353 17.1791 11.6422 15.6041 12.5261C15.168 12.7708 14.6824 12.2944 14.9188 11.8537C15.3256 11.0953 15.1916 10.2468 14.4579 9.23688C14.0063 8.6153 13.438 8.09236 12.75 7.66769V15.6389C12.75 15.6558 12.7496 15.6726 12.7487 15.6893C12.7496 15.7141 12.75 15.7389 12.75 15.7639C12.75 17.2459 11.2709 18.3889 9.5 18.3889C7.72914 18.3889 6.25 17.2459 6.25 15.7639C6.25 14.2818 7.72914 13.1389 9.5 13.1389C9.94085 13.1389 10.3636 13.2097 10.75 13.339V6.43384V5.63886V2.75C10.75 2.34864 11.1991 2.11086 11.531 2.33645Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M16.75 7.80413C16.75 6.26176 14.6038 4.13512 10.281 1.19759C9.94906 0.972008 9.5 1.20978 9.5 1.61114V5.29498C9.5 5.51063 9.63826 5.70198 9.84301 5.76969C11.3174 6.25731 12.434 7.03285 13.2079 8.09803C13.9416 9.10793 14.0756 9.95646 13.6688 10.7148C13.4324 11.1555 13.918 11.632 14.3541 11.3872C15.9291 10.5034 16.75 9.29646 16.75 7.80413ZM10.5 4.94056V2.56389C13.9918 5.01467 15.75 6.82274 15.75 7.80413C15.75 8.5504 15.4721 9.19993 14.8955 9.76443C14.8758 9.04 14.5787 8.28357 14.0169 7.51024C13.1776 6.35503 12.0012 5.49802 10.5 4.94056Z" fill="black"/>
<path d="M9.5 4.5C9.5 4.22386 9.72386 4 10 4C10.2761 4 10.5 4.22386 10.5 4.5V15C10.5 15.2761 10.2761 15.5 10 15.5C9.72386 15.5 9.5 15.2761 9.5 15V4.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.5 15C4.5 16.4083 5.8646 17.5 7.5 17.5C9.1354 17.5 10.5 16.4083 10.5 15C10.5 13.5917 9.1354 12.5 7.5 12.5C5.8646 12.5 4.5 13.5917 4.5 15ZM9.5 15C9.5 15.8008 8.62602 16.5 7.5 16.5C6.37398 16.5 5.5 15.8008 5.5 15C5.5 14.1992 6.37398 13.5 7.5 13.5C8.62602 13.5 9.5 14.1992 9.5 15Z" fill="black"/>
</svg>
`;

const Open = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect opacity="0.8" x="7" y="6" width="11" height="11" rx="1" fill="currentColor"/>
<path d="M14.5 14.5V11.25C14.5 10.9739 14.7239 10.75 15 10.75C15.2761 10.75 15.5 10.9739 15.5 11.25V15C15.5 15.2761 15.2761 15.5 15 15.5H5C4.72386 15.5 4.5 15.2761 4.5 15V5C4.5 4.72386 4.72386 4.5 5 4.5H8.75C9.02614 4.5 9.25 4.72386 9.25 5C9.25 5.27614 9.02614 5.5 8.75 5.5H5.5V14.5H14.5Z" fill="black"/>
<path d="M10.3536 10.3536C10.1583 10.5488 9.84171 10.5488 9.64645 10.3536C9.45118 10.1583 9.45118 9.84171 9.64645 9.64645L14.6464 4.64645C14.8417 4.45118 15.1583 4.45118 15.3536 4.64645C15.5488 4.84171 15.5488 5.15829 15.3536 5.35355L10.3536 10.3536Z" fill="black"/>
<path d="M15.5 8.5C15.5 8.77614 15.2761 9 15 9C14.7239 9 14.5 8.77614 14.5 8.5V5C14.5 4.72386 14.7239 4.5 15 4.5C15.2761 4.5 15.5 4.72386 15.5 5V8.5Z" fill="black"/>
<path d="M11.5 5.5C11.2239 5.5 11 5.27614 11 5C11 4.72386 11.2239 4.5 11.5 4.5H15C15.2761 4.5 15.5 4.72386 15.5 5C15.5 5.27614 15.2761 5.5 15 5.5H11.5Z" fill="black"/>
</svg>
`;

const PaintPallet = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M10.5896 5.93864C14.3891 6.95671 16.6954 10.711 15.7246 14.3342C14.6313 18.4146 9.42662 21.6777 6.84274 18.8947C6.01967 18.0082 5.80843 17.0333 5.95296 15.7336C5.97792 15.5091 5.99947 15.3622 6.06577 14.9399C6.22776 13.9081 6.22599 13.5002 6.01192 13.1518C5.80534 12.8155 5.43446 12.7294 4.33401 12.7156C4.28019 12.7149 4.28019 12.7149 4.22591 12.7142C2.67773 12.6922 1.92684 12.4348 1.54351 11.3506C0.274887 7.76224 6.32303 4.79543 10.5896 5.93864Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.8426 4.43006C13.3311 4.40927 12.8607 4.09221 12.5375 3.48435C11.9801 2.43603 11.8585 0.917407 12.6482 0.497495C13.438 0.0775839 14.6289 1.02762 15.1863 2.07593C15.4869 2.64121 15.5076 3.17152 15.2927 3.59351C15.4711 3.68323 15.6244 3.82716 15.7253 4.01687C15.7308 4.02728 15.7362 4.03778 15.7413 4.04837L19.8336 12.4482C19.9869 12.7628 19.8635 13.1423 19.5545 13.3065C19.2452 13.471 18.8612 13.3618 18.6847 13.0592L13.9771 4.98894C13.8746 4.81319 13.8318 4.61905 13.8426 4.43006Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.7246 13.3342C15.6954 9.71095 13.3891 5.95668 9.58956 4.93861C5.32303 3.7954 -0.725113 6.76221 0.543511 10.3505C0.926836 11.4348 1.67773 11.6922 3.22591 11.7141L3.33401 11.7156C4.43446 11.7294 4.80534 11.8155 5.01192 12.1517C5.22599 12.5002 5.22776 12.9081 5.06577 13.9399C4.99947 14.3622 4.97792 14.509 4.95296 14.7336C4.80843 16.0333 5.01967 17.0081 5.84274 17.8946C8.42662 20.6776 13.6313 17.4146 14.7246 13.3342ZM1.48632 10.0172C0.577621 7.44693 5.70337 4.93259 9.33074 5.90454C12.6082 6.78273 14.5833 9.99776 13.7587 13.0753C12.8355 16.5206 8.47174 19.2565 6.57558 17.2142C5.98161 16.5745 5.83147 15.8816 5.94683 14.8441C5.96952 14.64 5.98985 14.5015 6.05367 14.095C6.2538 12.8202 6.25136 12.2589 5.86397 11.6283C5.3993 10.8719 4.80502 10.734 3.34657 10.7156L3.24008 10.7142C2.08097 10.6978 1.67812 10.5597 1.48632 10.0172Z" fill="black"/>
<path d="M4.75 9.5C4.05964 9.5 3.5 8.94036 3.5 8.25C3.5 7.55964 4.05964 7 4.75 7C5.44036 7 6 7.55964 6 8.25C6 8.94036 5.44036 9.5 4.75 9.5Z" fill="black"/>
<path d="M8.75 9.5C8.05964 9.5 7.5 8.94036 7.5 8.25C7.5 7.55964 8.05964 7 8.75 7C9.44036 7 10 7.55964 10 8.25C10 8.94036 9.44036 9.5 8.75 9.5Z" fill="black"/>
<path d="M11.25 12.5C10.5596 12.5 10 11.9404 10 11.25C10 10.5596 10.5596 10 11.25 10C11.9404 10 12.5 10.5596 12.5 11.25C12.5 11.9404 11.9404 12.5 11.25 12.5Z" fill="black"/>
<path d="M9.75 16C9.05964 16 8.5 15.4404 8.5 14.75C8.5 14.0596 9.05964 13.5 9.75 13.5C10.4404 13.5 11 14.0596 11 14.75C11 15.4404 10.4404 16 9.75 16Z" fill="black"/>
<path d="M13.3707 3.60451C13.8605 3.34411 14.466 3.52923 14.7253 4.01686C14.7308 4.02727 14.7362 4.03777 14.7413 4.04836L18.8336 12.4482C18.9869 12.7628 18.8635 13.1422 18.5545 13.3065C18.2452 13.471 17.8612 13.3618 17.6847 13.0592L12.9771 4.98893C12.6993 4.5127 12.8602 3.90144 13.3364 3.62364C13.3477 3.61704 13.3592 3.61066 13.3707 3.60451Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.5375 3.48434C12.0238 4.39897 12.8434 4.65522 13.6347 4.23444C14.4262 3.81362 14.6726 2.99053 14.1863 2.07592C13.6289 1.0276 12.438 0.0775719 11.6482 0.497483C10.8585 0.917395 10.9801 2.43602 11.5375 3.48434ZM12.4204 3.01486C12.2581 2.70947 12.1315 2.26269 12.1007 1.8773C12.0806 1.62643 12.1063 1.45889 12.1151 1.40204C12.1171 1.38903 12.1182 1.38181 12.1176 1.38073C12.1183 1.38172 12.1245 1.38462 12.1356 1.38985C12.1866 1.41372 12.3408 1.48594 12.5391 1.64416C12.8414 1.88525 13.141 2.24 13.3034 2.54539C13.5316 2.97464 13.4668 3.19118 13.1653 3.3515C12.8641 3.51165 12.6488 3.44435 12.4204 3.01486Z" fill="black"/>
</svg>
`;

const Pen = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M4.79643 11.7244L14.8744 1.64643C15.0696 1.45117 15.3862 1.45117 15.5815 1.64643L19.4706 5.53552C19.6658 5.73078 19.6658 6.04736 19.4706 6.24262L9.39263 16.3206C9.31739 16.3958 9.22012 16.4451 9.11495 16.4612L4.52042 17.1667C4.18664 17.2179 3.89908 16.9304 3.95033 16.5966L4.65578 12.002C4.67192 11.8969 4.7212 11.7996 4.79643 11.7244Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.0815 0.853583L3.00354 10.9315C2.92831 11.0068 2.87903 11.104 2.86289 11.2092L2.15744 15.8037C2.10619 16.1375 2.39374 16.4251 2.72753 16.3738L7.32206 15.6684C7.42723 15.6522 7.5245 15.6029 7.59973 15.5277L17.6777 5.44978C17.8729 5.25452 17.8729 4.93793 17.6777 4.74267L13.7886 0.853583C13.5933 0.658321 13.2767 0.658321 13.0815 0.853583ZM3.24927 15.282L3.82645 11.5228L13.435 1.91424L16.617 5.09622L7.00843 14.7048L3.24927 15.282Z" fill="black"/>
<path d="M10.8539 4.06103L11.5603 3.35332L15.0968 6.88369L14.3903 7.59141L10.8539 4.06103Z" fill="black"/>
</svg>
`;

const Person = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M11.5 9.5C13.433 9.5 15 7.933 15 6C15 4.067 13.433 2.5 11.5 2.5C9.567 2.5 8 4.067 8 6C8 7.933 9.567 9.5 11.5 9.5Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M18 16.688C18 13.098 15.09 10.5 11.5 10.5C7.91 10.5 5 13.098 5 16.688L5.002 18.5C5.002 18.7652 5.10736 19.0196 5.29489 19.2071C5.48243 19.3946 5.73678 19.5 6.002 19.5H17C17.2652 19.5 17.5196 19.3946 17.7071 19.2071C17.8946 19.0196 18 18.7652 18 18.5V16.687V16.688Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.5 6C7.5 4.61929 8.61929 3.5 10 3.5C11.3807 3.5 12.5 4.61929 12.5 6C12.5 7.38071 11.3807 8.5 10 8.5C8.61929 8.5 7.5 7.38071 7.5 6ZM10 2.5C8.067 2.5 6.5 4.067 6.5 6C6.5 7.933 8.067 9.5 10 9.5C11.933 9.5 13.5 7.933 13.5 6C13.5 4.067 11.933 2.5 10 2.5ZM10.0162 9.5C6.51061 9.5 3.5 12.0794 3.5 15.5L3.50205 18.0004C3.50227 18.2766 3.72631 18.5002 4.00245 18.5C4.2786 18.4998 4.50227 18.2757 4.50204 17.9996L4.5 15.4998C4.50011 12.7253 6.96426 10.5 10.0162 10.5C13.0645 10.5 15.5 12.7221 15.5 15.5V18C15.5 18.2761 15.7239 18.5 16 18.5C16.2761 18.5 16.5 18.2761 16.5 18V15.5C16.5 12.0827 13.5254 9.5 10.0162 9.5Z" fill="black"/>
</svg>
`;

const Phone = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M12.4389 11.7743L13.0208 11.1924C14.1924 10.0208 16.0919 10.0208 17.2635 11.1924L18.6777 12.6066C19.8492 13.7782 19.8492 15.6777 18.6777 16.8492L15.872 19.6549C15.5932 19.9337 15.1766 20.0227 14.8082 19.882C8.31797 17.4042 3.87437 12.9301 1.50011 6.5696C1.36316 6.20273 1.45296 5.78968 1.72986 5.51278L4.53553 2.70711C5.7071 1.53554 7.6066 1.53554 8.77817 2.70711L10.1924 4.12132C11.364 5.2929 11.364 7.19239 10.1924 8.36396L9.61167 8.94467C10.4942 9.94935 11.4366 10.8925 12.4389 11.7743Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.8744 9.54594L11.9632 10.4571C10.6931 9.37249 9.51512 8.19356 8.42915 6.9201L9.33883 6.01041C10.3151 5.0341 10.3151 3.45119 9.33883 2.47488L7.92462 1.06066C6.94831 0.0843525 5.36539 0.0843525 4.38908 1.06066L1.58341 3.86634C1.44496 4.00479 1.40006 4.21131 1.46854 4.39474C3.79255 10.6206 8.13044 14.9883 14.4866 17.4149C14.6707 17.4852 14.879 17.4408 15.0184 17.3014L17.8241 14.4957C18.8004 13.5194 18.8004 11.9365 17.8241 10.9602L16.4099 9.54594C15.4336 8.56963 13.8507 8.56963 12.8744 9.54594ZM17.117 11.6673C17.7028 12.2531 17.7028 13.2028 17.117 13.7886L14.542 16.3636C8.72054 14.0584 4.73058 10.0434 2.5194 4.34456L5.09619 1.76777C5.68198 1.18198 6.63172 1.18198 7.21751 1.76777L8.63172 3.18198C9.21751 3.76777 9.21751 4.71752 8.63172 5.3033L7.39779 6.53723C7.21532 6.71971 7.20169 7.01108 7.36633 7.20979C8.66924 8.78233 10.1049 10.2191 11.6731 11.5199C11.8718 11.6848 12.1633 11.6712 12.3459 11.4887L13.5815 10.2531C14.1673 9.66726 15.117 9.66726 15.7028 10.2531L17.117 11.6673Z" fill="black"/>
</svg>
`;

const PhotoCamera = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M7.76225 7.5L8.17154 6.23204C8.50479 5.19965 9.46583 4.5 10.5507 4.5L13.4489 4.5C14.5337 4.5 15.4947 5.19965 15.828 6.23204L16.2373 7.5H17.5C18.8807 7.5 20 8.61929 20 10V16C20 17.3807 18.8807 18.5 17.5 18.5H6.5C5.11929 18.5 4 17.3807 4 16L4 10C4 8.61929 5.11929 7.5 6.5 7.5H7.76225Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.17154 5.23204L5.76225 6.5H4.5C3.11929 6.5 2 7.61929 2 9V15C2 16.3807 3.11929 17.5 4.5 17.5H15.5C16.8807 17.5 18 16.3807 18 15V9C18 7.61929 16.8807 6.5 15.5 6.5H14.2373L13.828 5.23204C13.4947 4.19965 12.5337 3.5 11.4489 3.5H8.55067C7.46583 3.5 6.50479 4.19965 6.17154 5.23204ZM4.5 7.5H6.49027L7.12319 5.53922C7.32314 4.91979 7.89976 4.5 8.55067 4.5H11.4489C12.0998 4.5 12.6764 4.91979 12.8763 5.53922L13.5093 7.5H15.5C16.3284 7.5 17 8.17157 17 9V15C17 15.8284 16.3284 16.5 15.5 16.5H4.5C3.67157 16.5 3 15.8284 3 15V9C3 8.17157 3.67157 7.5 4.5 7.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M7 11.5C7 13.1569 8.34315 14.5 10 14.5C11.6569 14.5 13 13.1569 13 11.5C13 9.84315 11.6569 8.5 10 8.5C8.34315 8.5 7 9.84315 7 11.5ZM12 11.5C12 12.6046 11.1046 13.5 10 13.5C8.89543 13.5 8 12.6046 8 11.5C8 10.3954 8.89543 9.5 10 9.5C11.1046 9.5 12 10.3954 12 11.5Z" fill="black"/>
</svg>
`;

const Pill = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.06498 4.42894C7.66633 2.8276 10.2626 2.8276 11.864 4.42894L17.663 10.2279C19.2643 11.8293 19.2643 14.4256 17.663 16.0269C16.0616 17.6283 13.4653 17.6283 11.864 16.0269L6.06498 10.2279C4.46364 8.62659 4.46364 6.03029 6.06498 4.42894Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15.8492 10.1924L9.48529 3.82843C7.92319 2.26633 5.39053 2.26633 3.82843 3.82843C2.26634 5.39052 2.26634 7.92318 3.82843 9.48528L10.1924 15.8492C11.7545 17.4113 14.2872 17.4113 15.8492 15.8492C17.4113 14.2871 17.4113 11.7545 15.8492 10.1924ZM4.53554 4.53553C5.70711 3.36396 7.60661 3.36396 8.77818 4.53553L15.1421 10.8995C16.3137 12.0711 16.3137 13.9706 15.1421 15.1421C13.9706 16.3137 12.0711 16.3137 10.8995 15.1421L4.53554 8.77817C3.36397 7.6066 3.36397 5.70711 4.53554 4.53553Z" fill="black"/>
<path d="M13.0369 7.58066L12.7944 8.55081C11.5929 8.25043 10.571 8.39641 9.693 8.98176C8.82365 9.56133 8.23928 10.6688 7.96219 12.337L6.97571 12.1731C7.29422 10.2556 8.00765 8.90348 9.1383 8.14971C10.2603 7.40173 11.5718 7.21437 13.0369 7.58066Z" fill="black"/>
</svg>
`;

const Pinpoint = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M12.5 19.5C9.72259 19.5 5.5 12.6249 5.5 8.62313C5.5 4.69121 8.63188 1.5 12.5 1.5C16.3681 1.5 19.5 4.69121 19.5 8.62313C19.5 12.6249 15.2774 19.5 12.5 19.5Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 11C11.6569 11 13 9.65685 13 8C13 6.34315 11.6569 5 10 5C8.34315 5 7 6.34315 7 8C7 9.65685 8.34315 11 10 11ZM10 6C11.1046 6 12 6.89543 12 8C12 9.10457 11.1046 10 10 10C8.89543 10 8 9.10457 8 8C8 6.89543 8.89543 6 10 6Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M3 8.12313C3 12.1249 7.22259 19 10 19C12.7774 19 17 12.1249 17 8.12313C17 4.19121 13.8681 1 10 1C6.13188 1 3 4.19121 3 8.12313ZM16 8.12313C16 11.6434 12.0959 18 10 18C7.90411 18 4 11.6434 4 8.12313C4 4.73934 6.68841 2 10 2C13.3116 2 16 4.73934 16 8.12313Z" fill="black"/>
</svg>
`;

const PinpointOff = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M12.5 19.5C9.72259 19.5 5.5 12.6249 5.5 8.62313C5.5 4.69121 8.63188 1.5 12.5 1.5C16.3681 1.5 19.5 4.69121 19.5 8.62313C19.5 12.6249 15.2774 19.5 12.5 19.5Z" fill="currentColor"/>
</g>
<path d="M1.64645 1.85355C1.45118 1.65829 1.45118 1.34171 1.64645 1.14645C1.84171 0.951183 2.15829 0.951183 2.35355 1.14645L18.8536 17.6464C19.0488 17.8417 19.0488 18.1583 18.8536 18.3536C18.6583 18.5488 18.3417 18.5488 18.1464 18.3536L1.64645 1.85355Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 11C11.6569 11 13 9.65685 13 8C13 6.34315 11.6569 5 10 5C8.34315 5 7 6.34315 7 8C7 9.65685 8.34315 11 10 11ZM10 6C11.1046 6 12 6.89543 12 8C12 9.10457 11.1046 10 10 10C8.89543 10 8 9.10457 8 8C8 6.89543 8.89543 6 10 6Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M3 8.12313C3 12.1249 7.22259 19 10 19C12.7774 19 17 12.1249 17 8.12313C17 4.19121 13.8681 1 10 1C6.13188 1 3 4.19121 3 8.12313ZM16 8.12313C16 11.6434 12.0959 18 10 18C7.90411 18 4 11.6434 4 8.12313C4 4.73934 6.68841 2 10 2C13.3116 2 16 4.73934 16 8.12313Z" fill="black"/>
</svg>
`;

const Plus = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.5 4.5C10.6716 4.5 10 5.17157 10 6V9.5H6.5C5.67157 9.5 5 10.1716 5 11C5 11.8284 5.67157 12.5 6.5 12.5H10V16C10 16.8284 10.6716 17.5 11.5 17.5C12.3284 17.5 13 16.8284 13 16V12.5H16.5C17.3284 12.5 18 11.8284 18 11C18 10.1716 17.3284 9.5 16.5 9.5H13V6C13 5.17157 12.3284 4.5 11.5 4.5Z" fill="currentColor"/>
</g>
<path d="M5 10.5C4.72386 10.5 4.5 10.2761 4.5 10C4.5 9.72386 4.72386 9.5 5 9.5H15C15.2761 9.5 15.5 9.72386 15.5 10C15.5 10.2761 15.2761 10.5 15 10.5H5Z" fill="black"/>
<path d="M9.5 5C9.5 4.72386 9.72386 4.5 10 4.5C10.2761 4.5 10.5 4.72386 10.5 5V15C10.5 15.2761 10.2761 15.5 10 15.5C9.72386 15.5 9.5 15.2761 9.5 15V5Z" fill="black"/>
</svg>
`;

const Power = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M11.5 20C7.63401 20 4.5 16.866 4.5 13C4.5 9.13401 7.63401 6 11.5 6C15.366 6 18.5 9.13401 18.5 13C18.5 16.866 15.366 20 11.5 20Z" fill="currentColor"/>
</g>
<path d="M4.47659 5.45962C4.70925 5.22366 5.08914 5.22098 5.3251 5.45364C5.56106 5.6863 5.56373 6.06619 5.33107 6.30215C4.22977 7.41907 3.60002 8.92906 3.60002 10.5422C3.60002 13.8535 6.24345 16.5344 9.50002 16.5344C12.7566 16.5344 15.4 13.8535 15.4 10.5422C15.4 8.92906 14.7703 7.41907 13.669 6.30215C13.4363 6.06619 13.439 5.6863 13.675 5.45364C13.9109 5.22098 14.2908 5.22366 14.5235 5.45962C15.8444 6.79928 16.6 8.61113 16.6 10.5422C16.6 14.5125 13.4232 17.7344 9.50002 17.7344C5.5769 17.7344 2.40002 14.5125 2.40002 10.5422C2.40002 8.61113 3.15566 6.79928 4.47659 5.45962Z" fill="black"/>
<path d="M8.87805 1.25002C8.87805 0.918654 9.14668 0.650024 9.47805 0.650024C9.80942 0.650024 10.0781 0.918654 10.0781 1.25002V8.33477C10.0781 8.66614 9.80942 8.93477 9.47805 8.93477C9.14668 8.93477 8.87805 8.66614 8.87805 8.33477L8.87805 1.25002Z" fill="black"/>
</svg>
`;

const Printer = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect opacity="0.8" x="2" y="7.5" width="18" height="11" rx="3" fill="currentColor"/>
<path d="M4.5 2C4.5 1.44772 4.94772 1 5.5 1H14.5C15.0523 1 15.5 1.44772 15.5 2V6.5H4.5V2Z" fill="white"/>
<path d="M5 6.5H4V2.1C4 1.23445 4.61204 0.5 5.41667 0.5H14.5833C15.388 0.5 16 1.23445 16 2.1V6.5H15V2.1C15 1.75052 14.7912 1.5 14.5833 1.5H5.41667C5.20877 1.5 5 1.75052 5 2.1V6.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M16 6H4C2.34315 6 1 7.34315 1 9V14C1 15.6569 2.34315 17 4 17H16C17.6569 17 19 15.6569 19 14V9C19 7.34315 17.6569 6 16 6ZM2 9C2 7.89543 2.89543 7 4 7H16C17.1046 7 18 7.89543 18 9V14C18 15.1046 17.1046 16 16 16H4C2.89543 16 2 15.1046 2 14V9Z" fill="black"/>
<path d="M15.5 17.5313C15.5 18.0835 15.0523 18.5312 14.5 18.5312H5.5C4.94771 18.5312 4.5 18.0835 4.5 17.5312V11.9687L15.5 11.9688V17.5313Z" fill="white"/>
<path d="M15 11.9688H16V17.2188C16 18.1894 15.412 19.0312 14.5833 19.0312H5.41667C4.58798 19.0312 4 18.1894 4 17.2188V11.9687H5V17.2188C5 17.6979 5.23283 18.0312 5.41667 18.0312H14.5833C14.7672 18.0312 15 17.6979 15 17.2188V11.9688Z" fill="black"/>
<path d="M13.5 15.5C13.7761 15.5 14 15.7239 14 16C14 16.2761 13.7761 16.5 13.5 16.5H6.5C6.22386 16.5 6 16.2761 6 16C6 15.7239 6.22386 15.5 6.5 15.5H13.5Z" fill="black"/>
<path d="M13.5 13.5C13.7761 13.5 14 13.7239 14 14C14 14.2761 13.7761 14.5 13.5 14.5L6.5 14.5C6.22386 14.5 6 14.2761 6 14C6 13.7239 6.22386 13.5 6.5 13.5H13.5Z" fill="black"/>
</svg>
`;

const Refresh = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle opacity="0.8" cx="12" cy="10.5" r="6.5" fill="currentColor"/>
<path d="M5.25375 14.5962C5.05848 14.4009 5.05848 14.0843 5.25375 13.8891C5.44901 13.6938 5.76559 13.6938 5.96085 13.8891C6.98597 14.9142 8.37095 15.5 9.84994 15.5C12.8875 15.5 15.3499 13.0376 15.3499 10C15.3499 9.72386 15.5738 9.5 15.8499 9.5C16.1261 9.5 16.3499 9.72386 16.3499 10C16.3499 13.5899 13.4398 16.5 9.84994 16.5C8.103 16.5 6.46454 15.807 5.25375 14.5962Z" fill="black"/>
<path d="M13.1311 12.416C12.9013 12.5691 12.5909 12.507 12.4377 12.2772C12.2846 12.0475 12.3467 11.737 12.5764 11.5839L15.5768 9.58388C15.8066 9.43072 16.117 9.49282 16.2702 9.72259C16.4233 9.95237 16.3612 10.2628 16.1315 10.416L13.1311 12.416Z" fill="black"/>
<path d="M18.266 12.7226C18.4192 12.9523 18.3571 13.2628 18.1273 13.4159C17.8976 13.5691 17.5871 13.507 17.434 13.2773L15.434 10.2773C15.2808 10.0475 15.3429 9.73706 15.5726 9.58388C15.8024 9.43071 16.1128 9.49279 16.266 9.72256L18.266 12.7226Z" fill="black"/>
<path d="M14.3536 5.20471C14.5488 5.39997 14.5488 5.71655 14.3536 5.91182C14.1583 6.10708 13.8417 6.10708 13.6464 5.91182C12.6213 4.8867 11.2364 4.3009 9.75736 4.3009C6.71979 4.3009 4.25736 6.76334 4.25736 9.8009C4.25736 10.077 4.0335 10.3009 3.75736 10.3009C3.48122 10.3009 3.25736 10.077 3.25736 9.8009C3.25736 6.21105 6.16751 3.3009 9.75736 3.3009C11.5043 3.3009 13.1428 3.99391 14.3536 5.20471Z" fill="black"/>
<path d="M6.47621 7.38482C6.70598 7.23166 7.01642 7.29376 7.16958 7.52353C7.32274 7.75331 7.26064 8.06374 7.03086 8.2169L4.03049 10.2169C3.80071 10.3701 3.49028 10.308 3.33712 10.0782C3.18396 9.84841 3.24606 9.53798 3.47584 9.38482L6.47621 7.38482Z" fill="black"/>
<path d="M1.34128 7.07822C1.18811 6.84846 1.25019 6.53803 1.47996 6.38485C1.70972 6.23167 2.02016 6.29376 2.17333 6.52352L4.17333 9.52352C4.32651 9.75329 4.26442 10.0637 4.03466 10.2169C3.8049 10.3701 3.49446 10.308 3.34128 10.0782L1.34128 7.07822Z" fill="black"/>
</svg>
`;

const Reload = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle opacity="0.8" cx="12" cy="11.5" r="6.5" fill="currentColor"/>
<path d="M13.3745 5.0382C13.6027 5.19368 13.6616 5.50473 13.5062 5.73294C13.3507 5.96115 13.0396 6.02011 12.8114 5.86463C11.9888 5.30418 11.0178 5 10 5C7.23858 5 5 7.23858 5 10C5 12.7614 7.23858 15 10 15C12.7614 15 15 12.7614 15 10C15 9.72386 15.2239 9.5 15.5 9.5C15.7761 9.5 16 9.72386 16 10C16 13.3137 13.3137 16 10 16C6.68629 16 4 13.3137 4 10C4 6.68629 6.68629 4 10 4C11.2202 4 12.3871 4.36553 13.3745 5.0382Z" fill="black"/>
<path d="M12.7691 11.5851C12.5365 11.7339 12.2273 11.6659 12.0785 11.4333C11.9297 11.2006 11.9976 10.8914 12.2302 10.7426L15.7121 8.51555C15.9447 8.36676 16.2539 8.43472 16.4027 8.66734C16.5515 8.89997 16.4835 9.20917 16.2509 9.35796L12.7691 11.5851Z" fill="black"/>
<path d="M17.9468 12.1141C18.0593 12.3663 17.946 12.6619 17.6939 12.7744C17.4417 12.8869 17.146 12.7737 17.0335 12.5215L15.5254 9.14069C15.4129 8.8885 15.5261 8.59286 15.7783 8.48036C16.0305 8.36786 16.3261 8.4811 16.4386 8.73329L17.9468 12.1141Z" fill="black"/>
</svg>
`;

const Scissors = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.5 19.5C8.15685 19.5 9.5 18.1569 9.5 16.5C9.5 15.8457 9.29051 15.2403 8.93495 14.7472C9.14795 14.7656 9.36732 14.6933 9.53033 14.5303L11.25 12.8107L16.9697 18.5303C17.2626 18.8232 17.7374 18.8232 18.0303 18.5303C18.3232 18.2374 18.3232 17.7626 18.0303 17.4697L12.3107 11.75L18.0303 6.03033C18.3232 5.73744 18.3232 5.26256 18.0303 4.96967C17.7374 4.67678 17.2626 4.67678 16.9697 4.96967L11.25 10.6893L9.53033 8.96967C9.43881 8.87815 9.32953 8.81523 9.21358 8.7809C9.39727 8.39245 9.5 7.95822 9.5 7.5C9.5 5.84315 8.15685 4.5 6.5 4.5C4.84315 4.5 3.5 5.84315 3.5 7.5C3.5 9.15685 4.84315 10.5 6.5 10.5C7.19572 10.5 7.83613 10.2632 8.34501 9.86575C8.37798 9.92472 8.41953 9.98019 8.46967 10.0303L10.1893 11.75L8.46967 13.4697C8.30666 13.6327 8.23438 13.8521 8.25281 14.065C7.75974 13.7095 7.15434 13.5 6.5 13.5C4.84315 13.5 3.5 14.8431 3.5 16.5C3.5 18.1569 4.84315 19.5 6.5 19.5Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 8.5C7.15685 8.5 8.5 7.15685 8.5 5.5C8.5 3.84315 7.15685 2.5 5.5 2.5C3.84315 2.5 2.5 3.84315 2.5 5.5C2.5 7.15685 3.84315 8.5 5.5 8.5ZM5.5 3.5C6.60457 3.5 7.5 4.39543 7.5 5.5C7.5 6.60457 6.60457 7.5 5.5 7.5C4.39543 7.5 3.5 6.60457 3.5 5.5C3.5 4.39543 4.39543 3.5 5.5 3.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 18.5C7.15685 18.5 8.5 17.1569 8.5 15.5C8.5 13.8431 7.15685 12.5 5.5 12.5C3.84315 12.5 2.5 13.8431 2.5 15.5C2.5 17.1569 3.84315 18.5 5.5 18.5ZM5.5 13.5C6.60457 13.5 7.5 14.3954 7.5 15.5C7.5 16.6046 6.60457 17.5 5.5 17.5C4.39543 17.5 3.5 16.6046 3.5 15.5C3.5 14.3954 4.39543 13.5 5.5 13.5Z" fill="black"/>
<path d="M16.9784 15.7823C17.1764 15.9748 17.1809 16.2913 16.9885 16.4893C16.796 16.6874 16.4795 16.6919 16.2814 16.4994L7.40465 7.87265C7.20662 7.6802 7.2021 7.36365 7.39455 7.16562C7.587 6.96759 7.90355 6.96306 8.10159 7.15552L16.9784 15.7823Z" fill="black"/>
<path d="M7.14645 13.1464C6.95118 13.3417 6.95118 13.6583 7.14645 13.8536C7.34171 14.0488 7.65829 14.0488 7.85355 13.8536L16.8536 4.85355C17.0488 4.65829 17.0488 4.34171 16.8536 4.14645C16.6583 3.95118 16.3417 3.95118 16.1464 4.14645L7.14645 13.1464Z" fill="black"/>
</svg>
`;

const Send = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M1.87428 9.45439C1.40175 9.33081 1.36853 8.67265 1.82621 8.50212L17.5413 2.6468C17.9274 2.50295 18.3121 2.86161 18.1955 3.2568L13.4507 19.3421C13.3137 19.8065 12.6626 19.8245 12.5001 19.3684L9.69715 11.5002L1.87428 9.45439Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M0.874275 7.45439L8.69715 9.50024L11.5001 17.3684C11.6626 17.8245 12.3137 17.8065 12.4507 17.3421L17.1955 1.2568C17.3121 0.861613 16.9274 0.502948 16.5413 0.646803L0.82621 6.50212C0.368533 6.67265 0.401753 7.33081 0.874275 7.45439ZM2.65726 6.88705L15.9534 1.93302L11.9263 15.5851L9.55044 8.91561C9.49494 8.7598 9.36597 8.64152 9.20594 8.59967L2.65726 6.88705Z" fill="black"/>
<path d="M16 1.29291L16.7071 2.00001L9 9.70712L8.29289 9.00001L16 1.29291Z" fill="black"/>
</svg>
`;

const ShareAndroid = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.17451 14.2075C6.82435 14.3942 6.42453 14.5 6 14.5C4.61929 14.5 3.5 13.3807 3.5 12C3.5 10.6193 4.61929 9.5 6 9.5C6.52196 9.5 7.00656 9.65996 7.40745 9.93353L12.5011 6.92362C12.5415 5.57825 13.6448 4.5 15 4.5C16.3807 4.5 17.5 5.61929 17.5 7C17.5 8.38071 16.3807 9.5 15 9.5C14.1422 9.5 13.3853 9.06794 12.935 8.40957L8.34206 11.1236C8.44417 11.3963 8.5 11.6916 8.5 12C8.5 12.3894 8.41096 12.7581 8.25213 13.0866L12.9102 15.6274C13.3571 14.9483 14.1262 14.5 15 14.5C16.3807 14.5 17.5 15.6193 17.5 17C17.5 18.3807 16.3807 19.5 15 19.5C13.6574 19.5 12.562 18.4416 12.5025 17.1137L7.17451 14.2075Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5 12.5C6.38071 12.5 7.5 11.3807 7.5 10C7.5 8.61929 6.38071 7.5 5 7.5C3.61929 7.5 2.5 8.61929 2.5 10C2.5 11.3807 3.61929 12.5 5 12.5ZM5 8.5C5.82843 8.5 6.5 9.17157 6.5 10C6.5 10.8284 5.82843 11.5 5 11.5C4.17157 11.5 3.5 10.8284 3.5 10C3.5 9.17157 4.17157 8.5 5 8.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14 7.5C15.3807 7.5 16.5 6.38071 16.5 5C16.5 3.61929 15.3807 2.5 14 2.5C12.6193 2.5 11.5 3.61929 11.5 5C11.5 6.38071 12.6193 7.5 14 7.5ZM14 3.5C14.8284 3.5 15.5 4.17157 15.5 5C15.5 5.82843 14.8284 6.5 14 6.5C13.1716 6.5 12.5 5.82843 12.5 5C12.5 4.17157 13.1716 3.5 14 3.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14 17.5C15.3807 17.5 16.5 16.3807 16.5 15C16.5 13.6193 15.3807 12.5 14 12.5C12.6193 12.5 11.5 13.6193 11.5 15C11.5 16.3807 12.6193 17.5 14 17.5ZM14 13.5C14.8284 13.5 15.5 14.1716 15.5 15C15.5 15.8284 14.8284 16.5 14 16.5C13.1716 16.5 12.5 15.8284 12.5 15C12.5 14.1716 13.1716 13.5 14 13.5Z" fill="black"/>
<path d="M6.75437 9.18048L6.24564 8.31955L11.7456 5.06955L12.2544 5.93048L6.75437 9.18048Z" fill="black"/>
<path d="M12 14.8779L12.4789 14L6.97885 11L6.5 11.8779L12 14.8779Z" fill="black"/>
</svg>
`;

const ShareIos = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path opacity="0.8" fill-rule="evenodd" clip-rule="evenodd" d="M15.5 9H16.5C17.6046 9 18.5 9.75767 18.5 10.6923V18.3077C18.5 19.2423 17.6046 20 16.5 20H8.5C7.39543 20 6.5 19.2423 6.5 18.3077L6.5 10.6923C6.5 9.75767 7.39543 9 8.5 9H9.5" fill="currentColor"/>
<path d="M9.99832 2.50008C9.99828 2.22394 10.2221 2.00004 10.4982 2C10.7744 1.99996 10.9983 2.22378 10.9983 2.49992L11 12.9999C11 13.2761 10.7762 13.5 10.5001 13.5C10.2239 13.5 10 13.2762 9.99999 13.0001L9.99832 2.50008Z" fill="black"/>
<path d="M10.8201 2.8841C11.0322 2.70732 11.0609 2.39203 10.8841 2.1799C10.7073 1.96776 10.392 1.93909 10.1799 2.11588L7.1799 4.61588C6.96776 4.79266 6.9391 5.10794 7.11588 5.32008C7.29266 5.53222 7.60794 5.56088 7.82008 5.3841L10.8201 2.8841Z" fill="black"/>
<path d="M10.1799 2.8841C9.96775 2.70732 9.93909 2.39203 10.1159 2.1799C10.2927 1.96776 10.6079 1.93909 10.8201 2.11588L13.8201 4.61588C14.0322 4.79266 14.0609 5.10794 13.8841 5.32008C13.7073 5.53222 13.392 5.56088 13.1799 5.3841L10.1799 2.8841Z" fill="black"/>
<path d="M13.2483 9C12.9722 9 12.7483 8.77614 12.7483 8.5C12.7483 8.22386 12.9722 8 13.2483 8L14.165 8C15.4361 8 16.4983 8.89134 16.4983 10.0385V16.9615C16.4983 18.1087 15.4361 19 14.165 19H6.83165C5.5605 19 4.49832 18.1087 4.49832 16.9615L4.49832 10.0385C4.49832 8.89134 5.5605 8 6.83165 8H7.74832C8.02446 8 8.24832 8.22386 8.24832 8.5C8.24832 8.77614 8.02446 9 7.74832 9H6.83165C6.07777 9 5.49832 9.48625 5.49832 10.0385L5.49832 16.9615C5.49832 17.5138 6.07777 18 6.83165 18H14.165C14.9189 18 15.4983 17.5138 15.4983 16.9615L15.4983 10.0385C15.4983 9.48625 14.9189 9 14.165 9H13.2483Z" fill="black"/>
</svg>
`;

const Smartphone = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M6 2.58333C6 1.70888 6.67157 1 7.5 1H16.5C17.3284 1 18 1.70888 18 2.58333V18.4167C18 19.2911 17.3284 20 16.5 20H7.5C6.67157 20 6 19.2911 6 18.4167V2.58333Z" fill="currentColor"/>
</g>
<path d="M5.5 2.54C5.5 2.24177 5.72386 2 6 2H14C14.2761 2 14.5 2.24177 14.5 2.54V14.96C14.5 15.2582 14.2761 15.5 14 15.5H6C5.72386 15.5 5.5 15.2582 5.5 14.96V2.54Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M4 2.08333C4 1.20888 4.67157 0.5 5.5 0.5H14.5C15.3284 0.5 16 1.20888 16 2.08333V17.9167C16 18.7911 15.3284 19.5 14.5 19.5H5.5C4.67157 19.5 4 18.7911 4 17.9167V2.08333ZM5.5 1.55556C5.22386 1.55556 5 1.79185 5 2.08333V17.9167C5 18.2082 5.22386 18.4444 5.5 18.4444H14.5C14.7761 18.4444 15 18.2082 15 17.9167V2.08333C15 1.79185 14.7761 1.55556 14.5 1.55556H5.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M9 17C9 16.4477 9.44772 16 10 16C10.5523 16 11 16.4477 11 17C11 17.5523 10.5523 18 10 18C9.44772 18 9 17.5523 9 17Z" fill="black"/>
</svg>
`;

const SmartphoneNotch = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M6 2.5C6 1.67157 6.67157 1 7.5 1H16.5C17.3284 1 18 1.67157 18 2.5V18.5C18 19.3284 17.3284 20 16.5 20H7.5C6.67157 20 6 19.3284 6 18.5V2.5Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 0.5C4.67157 0.5 4 1.17157 4 2V18C4 18.8284 4.67157 19.5 5.5 19.5H14.5C15.3284 19.5 16 18.8284 16 18V2C16 1.17157 15.3284 0.5 14.5 0.5H5.5ZM5 2C5 1.72386 5.22386 1.5 5.5 1.5H7V2.5C7 2.77614 7.22386 3 7.5 3H12.5C12.7761 3 13 2.77614 13 2.5V1.5H14.5C14.7761 1.5 15 1.72386 15 2V18C15 18.2761 14.7761 18.5 14.5 18.5H5.5C5.22386 18.5 5 18.2761 5 18V2Z" fill="black"/>
</svg>
`;

const Smartphone2 = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path opacity="0.8" d="M7.63636 1H16.3636C17.2674 1 18 1.67157 18 2.5V18.5C18 19.3284 17.2674 20 16.3636 20H7.63636C6.73262 20 6 19.3284 6 18.5V2.5C6 1.67157 6.73262 1 7.63636 1Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.5 0.5H5.5C4.67157 0.5 4 1.17157 4 2V18C4 18.8284 4.67157 19.5 5.5 19.5H14.5C15.3284 19.5 16 18.8284 16 18V2C16 1.17157 15.3284 0.5 14.5 0.5ZM5 2C5 1.72386 5.22386 1.5 5.5 1.5H14.5C14.7761 1.5 15 1.72386 15 2V18C15 18.2761 14.7761 18.5 14.5 18.5H5.5C5.22386 18.5 5 18.2761 5 18V2Z" fill="black"/>
<path d="M10 18C9.44772 18 9 17.5523 9 17C9 16.4477 9.44772 16 10 16C10.5523 16 11 16.4477 11 17C11 17.5523 10.5523 18 10 18Z" fill="black"/>
</svg>
`;

const SoftDrink = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M8.58933 4.5L15.411 4.5C16.5155 4.5 17.411 5.39543 17.411 6.5C17.411 6.58078 17.4061 6.66148 17.3963 6.74167L16.179 16.7417C16.0569 17.7454 15.2048 18.5 14.1937 18.5H9.80944C8.79855 18.5 7.9466 17.7457 7.82417 16.7422L6.60405 6.74223C6.47027 5.64579 7.25066 4.6485 8.3471 4.51472C8.42747 4.50492 8.50836 4.5 8.58933 4.5Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.411 4.5H6.58933C6.50836 4.5 6.42747 4.50492 6.3471 4.51472C5.25066 4.6485 4.47027 5.64579 4.60405 6.74223L5.82417 16.7422C5.9466 17.7457 6.79855 18.5 7.80944 18.5H12.1937C13.2048 18.5 14.0569 17.7454 14.179 16.7417L15.3963 6.74167C15.4061 6.66148 15.411 6.58078 15.411 6.5C15.411 5.39543 14.5155 4.5 13.411 4.5ZM6.46822 5.50736C6.5084 5.50246 6.54885 5.5 6.58933 5.5H13.411C13.9633 5.5 14.411 5.94772 14.411 6.5C14.411 6.54039 14.4085 6.58074 14.4036 6.62084L13.1864 16.6208C13.1253 17.1227 12.6992 17.5 12.1937 17.5H7.80944C7.304 17.5 6.87802 17.1228 6.81681 16.6211L5.59669 6.62111C5.5298 6.07289 5.92 5.57425 6.46822 5.50736Z" fill="black"/>
<path d="M8.97789 14.647C8.89668 14.911 8.61688 15.0591 8.35295 14.9779C8.08902 14.8967 7.9409 14.6169 8.02211 14.353L12.0221 1.35295C12.1033 1.08902 12.3831 0.940897 12.647 1.02211C12.911 1.10332 13.0591 1.38311 12.9779 1.64704L8.97789 14.647Z" fill="black"/>
<path d="M5.5 10C5.22386 10 5 9.77614 5 9.5C5 9.22386 5.22386 9 5.5 9H14.5C14.7761 9 15 9.22386 15 9.5C15 9.77614 14.7761 10 14.5 10H5.5Z" fill="black"/>
<path d="M12.3787 1.98507C12.1108 1.91809 11.948 1.64663 12.0149 1.37873C12.0819 1.11083 12.3534 0.947951 12.6213 1.01492L16.6213 2.01493C16.8892 2.0819 17.052 2.35337 16.9851 2.62126C16.9181 2.88916 16.6466 3.05204 16.3787 2.98507L12.3787 1.98507Z" fill="black"/>
</svg>
`;

const SpeakerHigh = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.29521 13.5409H3C2.72386 13.5409 2.5 13.317 2.5 13.0409V7.84091C2.5 7.56476 2.72386 7.34091 3 7.34091H6.39936L10.6718 3.62282C10.9953 3.34123 11.5 3.57105 11.5 3.99999V17C11.5 17.4298 10.9936 17.6593 10.6704 17.376L6.29521 13.5409Z" fill="currentColor"/>
<path d="M13.6518 13.7584C13.2329 14.1184 12.6016 14.0707 12.2416 13.6518C11.8816 13.2329 11.9294 12.6016 12.3482 12.2416C12.3761 12.2176 12.4039 12.1914 12.4312 12.1631C12.5494 12.0405 12.6575 11.8815 12.747 11.6934C12.9093 11.3524 13 10.9391 13 10.5C13 9.80772 12.7732 9.19154 12.4312 8.83698C12.4039 8.80862 12.3761 8.78242 12.3482 8.75842C11.9294 8.39845 11.8816 7.76709 12.2416 7.34823C12.6016 6.92938 13.2329 6.88164 13.6518 7.24161C13.7274 7.30658 13.8004 7.37561 13.8707 7.44846C14.5888 8.19298 15 9.31015 15 10.5C15 11.2325 14.8448 11.9396 14.553 12.5528C14.3731 12.9309 14.143 13.2692 13.8707 13.5516C13.8004 13.6244 13.7274 13.6935 13.6518 13.7584Z" fill="currentColor"/>
<path d="M14.5485 16.8362C14.0866 17.1391 13.4667 17.0103 13.1638 16.5484C12.8609 16.0866 12.9897 15.4667 13.4516 15.1638C13.6081 15.0612 13.7594 14.951 13.9049 14.8339C14.0503 14.7168 14.1899 14.5928 14.323 14.4624C14.456 14.3321 14.5824 14.1955 14.7017 14.0532C14.821 13.911 14.933 13.7633 15.0374 13.6105C15.1417 13.4579 15.2383 13.3004 15.3267 13.1386C15.415 12.977 15.4952 12.8112 15.5669 12.6419C15.6384 12.4728 15.7014 12.3004 15.7557 12.125C15.8097 11.9502 15.855 11.7727 15.8913 11.5928C15.9275 11.4138 15.9547 11.2326 15.9729 11.0496C15.9909 10.8679 16 10.6846 16 10.5C16 10.3154 15.9909 10.1321 15.9729 9.95036C15.9547 9.76741 15.9275 9.5862 15.8913 9.40717C15.855 9.2273 15.8097 9.04974 15.7557 8.87497C15.7014 8.69959 15.6384 8.52714 15.5669 8.35813C15.4952 8.18878 15.415 8.02302 15.3267 7.86141C15.2383 7.69962 15.1417 7.54212 15.0374 7.38948C14.933 7.2367 14.821 7.08893 14.7017 6.94674C14.5824 6.80444 14.456 6.66786 14.323 6.53754C14.1899 6.40715 14.0503 6.28316 13.9049 6.16607C13.7594 6.04894 13.6081 5.93883 13.4516 5.83618C12.9897 5.53328 12.8609 4.91335 13.1638 4.45154C13.4667 3.98973 14.0866 3.86091 14.5485 4.16381C14.7592 4.30203 14.9629 4.45032 15.159 4.6081C15.355 4.76592 15.5431 4.93308 15.7226 5.10894C15.9022 5.28486 16.0729 5.46933 16.2342 5.66164C16.3956 5.85405 16.5473 6.05413 16.6887 6.26116C16.8303 6.46829 16.9614 6.68217 17.0816 6.90207C17.2018 7.12203 17.311 7.34779 17.4087 7.57861C17.5063 7.80921 17.5923 8.04464 17.6664 8.28415C17.7402 8.52295 17.8021 8.76558 17.8517 9.01133C17.9011 9.25581 17.9383 9.50315 17.9631 9.75269C17.9876 10.0001 18 10.2494 18 10.5C18 10.7506 17.9876 10.9999 17.9631 11.2473C17.9383 11.4968 17.9011 11.7442 17.8517 11.9887C17.8021 12.2344 17.7402 12.477 17.6664 12.7158C17.5923 12.9553 17.5063 13.1908 17.4087 13.4214C17.311 13.6522 17.2018 13.878 17.0816 14.0979C16.9614 14.3178 16.8303 14.5317 16.6887 14.7388C16.5473 14.9458 16.3956 15.1459 16.2342 15.3383C16.0729 15.5307 15.9022 15.7151 15.7226 15.891C15.5431 16.0669 15.355 16.2341 15.159 16.3919C14.9629 16.5497 14.7592 16.698 14.5485 16.8362Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M9.67176 2.12282L5.39936 5.84091H2C1.72386 5.84091 1.5 6.06476 1.5 6.34091V11.5409C1.5 11.817 1.72386 12.0409 2 12.0409H5.29521L9.67042 15.876C9.99362 16.1593 10.5 15.9298 10.5 15.5V2.49999C10.5 2.07105 9.99534 1.84123 9.67176 2.12282ZM5.88379 6.74498L9.5 3.59795V14.3968L6.01411 11.3413C5.93704 11.1645 5.76073 11.0409 5.55556 11.0409H2.5V6.84091H5.39356C5.55132 6.89541 5.73636 6.87329 5.88379 6.74498Z" fill="black"/>
<path d="M13.3259 11.8792C13.1165 12.0592 12.8008 12.0353 12.6208 11.8259C12.4408 11.6165 12.4647 11.3008 12.6741 11.1208C12.7139 11.0866 12.753 11.0497 12.7911 11.0102C12.9478 10.8477 13.0864 10.6438 13.1985 10.4082C13.3931 9.99922 13.5 9.51248 13.5 9.00001C13.5 8.18332 13.2271 7.44189 12.7911 6.98984C12.753 6.95036 12.7139 6.91345 12.6741 6.87921C12.4647 6.69923 12.4408 6.38354 12.6208 6.17412C12.8008 5.96469 13.1165 5.94082 13.3259 6.12081C13.3896 6.17553 13.4512 6.23386 13.5108 6.29558C14.1349 6.94261 14.5 7.93454 14.5 9.00001C14.5 9.65916 14.3609 10.2928 14.1015 10.8379C13.9442 11.1685 13.7446 11.462 13.5108 11.7044C13.4512 11.7662 13.3896 11.8245 13.3259 11.8792Z" fill="black"/>
<path d="M14.2742 14.9181C14.0433 15.0695 13.7334 15.0051 13.5819 14.7742C13.4305 14.5433 13.4949 14.2334 13.7258 14.0819C13.8958 13.9704 14.0602 13.8507 14.2184 13.7234C14.3765 13.5961 14.5282 13.4614 14.6729 13.3196C14.8175 13.1779 14.955 13.0293 15.0848 12.8745C15.2146 12.7198 15.3366 12.5589 15.4502 12.3926C15.5638 12.2263 15.669 12.0547 15.7654 11.8784C15.8617 11.7022 15.9492 11.5215 16.0273 11.3367C16.1054 11.1523 16.1742 10.9641 16.2333 10.7727C16.2923 10.5819 16.3418 10.3881 16.3814 10.1918C16.4209 9.99639 16.4506 9.79864 16.4704 9.59904C16.4901 9.40092 16.5 9.20109 16.5 9C16.5 8.7989 16.4901 8.59907 16.4704 8.40095C16.4506 8.20135 16.4209 8.00361 16.3814 7.80821C16.3418 7.61187 16.2923 7.41805 16.2333 7.22727C16.1742 7.03585 16.1054 6.84766 16.0273 6.66326C15.9492 6.47854 15.8617 6.29778 15.7654 6.12158C15.669 5.94526 15.5638 5.77367 15.4502 5.60741C15.3366 5.44106 15.2146 5.28022 15.0848 5.12547C14.955 4.97066 14.8175 4.82212 14.6729 4.68039C14.5282 4.53864 14.3765 4.40386 14.2184 4.27658C14.0602 4.14929 13.8958 4.02963 13.7258 3.91809C13.4949 3.76664 13.4305 3.45668 13.5819 3.22577C13.7334 2.99487 14.0433 2.93045 14.2742 3.0819C14.4714 3.21123 14.662 3.34998 14.8454 3.4976C15.0288 3.64523 15.2048 3.8016 15.3727 3.96609C15.5406 4.13062 15.7003 4.30311 15.8511 4.48292C16.0019 4.66278 16.1437 4.84978 16.2759 5.04324C16.4081 5.23675 16.5306 5.43654 16.6429 5.64191C16.7551 5.84728 16.8571 6.05804 16.9483 6.27349C17.0393 6.4887 17.1196 6.70838 17.1887 6.93186C17.2576 7.15465 17.3153 7.38101 17.3616 7.6103C17.4077 7.83841 17.4424 8.06922 17.4655 8.30211C17.4885 8.53306 17.5 8.76588 17.5 9C17.5 9.23411 17.4885 9.46693 17.4655 9.69788C17.4424 9.93077 17.4077 10.1616 17.3616 10.3897C17.3153 10.619 17.2576 10.8453 17.1887 11.0681C17.1196 11.2916 17.0393 11.5113 16.9483 11.7265C16.8571 11.9419 16.7551 12.1527 16.6429 12.3581C16.5306 12.5635 16.4081 12.7632 16.2759 12.9567C16.1437 13.1502 16.0019 13.3372 15.8511 13.5171C15.7003 13.6969 15.5406 13.8694 15.3727 14.0339C15.2048 14.1984 15.0288 14.3548 14.8454 14.5024C14.662 14.65 14.4714 14.7888 14.2742 14.9181Z" fill="black"/>
</svg>
`;

const SpeakerLow = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.29521 13.5409H3C2.72386 13.5409 2.5 13.317 2.5 13.0409V7.84091C2.5 7.56476 2.72386 7.34091 3 7.34091H6.39936L10.6718 3.62282C10.9953 3.34123 11.5 3.57105 11.5 3.99999V17C11.5 17.4298 10.9936 17.6593 10.6704 17.376L6.29521 13.5409Z" fill="currentColor"/>
<path d="M13.6518 13.7584C13.2329 14.1184 12.6016 14.0707 12.2416 13.6518C11.8816 13.2329 11.9293 12.6016 12.3482 12.2416C12.3761 12.2176 12.4038 12.1914 12.4312 12.1631C12.5494 12.0405 12.6575 11.8815 12.747 11.6934C12.9092 11.3524 13 10.9391 13 10.5C13 9.80772 12.7732 9.19154 12.4312 8.83698C12.4038 8.80862 12.3761 8.78242 12.3482 8.75842C11.9293 8.39845 11.8816 7.76709 12.2416 7.34823C12.6016 6.92938 13.2329 6.88164 13.6518 7.24161C13.7274 7.30658 13.8004 7.37561 13.8706 7.44846C14.5888 8.19298 15 9.31015 15 10.5C15 11.2325 14.8447 11.9396 14.553 12.5528C14.373 12.9309 14.143 13.2692 13.8706 13.5516C13.8004 13.6244 13.7274 13.6935 13.6518 13.7584Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M9.67176 2.12282L5.39936 5.84091H2C1.72386 5.84091 1.5 6.06476 1.5 6.34091V11.5409C1.5 11.817 1.72386 12.0409 2 12.0409H5.29521L9.67042 15.876C9.99362 16.1593 10.5 15.9298 10.5 15.5V2.49999C10.5 2.07105 9.99534 1.84123 9.67176 2.12282ZM5.88379 6.74498L9.5 3.59795V14.3968L6.01411 11.3413C5.93704 11.1645 5.76073 11.0409 5.55556 11.0409H2.5V6.84091H5.39356C5.55132 6.89541 5.73636 6.87329 5.88379 6.74498Z" fill="black"/>
<path d="M13.3259 11.8792C13.1165 12.0592 12.8008 12.0353 12.6208 11.8259C12.4408 11.6165 12.4647 11.3008 12.6741 11.1208C12.714 11.0866 12.753 11.0497 12.7911 11.0102C12.9478 10.8477 13.0864 10.6438 13.1985 10.4082C13.3931 9.99922 13.5 9.51248 13.5 9.00001C13.5 8.18332 13.2271 7.44189 12.7911 6.98984C12.753 6.95036 12.714 6.91345 12.6741 6.87921C12.4647 6.69923 12.4408 6.38354 12.6208 6.17412C12.8008 5.96469 13.1165 5.94082 13.3259 6.12081C13.3896 6.17553 13.4513 6.23386 13.5108 6.29558C14.1349 6.94261 14.5 7.93454 14.5 9.00001C14.5 9.65916 14.3609 10.2928 14.1015 10.8379C13.9442 11.1685 13.7446 11.462 13.5108 11.7044C13.4513 11.7662 13.3896 11.8245 13.3259 11.8792Z" fill="black"/>
</svg>
`;

const SpeakerOff = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.29521 13.5409H3C2.72386 13.5409 2.5 13.317 2.5 13.0409V7.84091C2.5 7.56476 2.72386 7.34091 3 7.34091H6.39936L10.6718 3.62282C10.9953 3.34123 11.5 3.57105 11.5 3.99999V17C11.5 17.4298 10.9936 17.6593 10.6704 17.376L6.29521 13.5409Z" fill="currentColor"/>
<path d="M13.6518 13.7584C13.2329 14.1184 12.6016 14.0707 12.2416 13.6518C11.8816 13.2329 11.9293 12.6016 12.3482 12.2416C12.3761 12.2176 12.4038 12.1914 12.4312 12.1631C12.5494 12.0405 12.6575 11.8815 12.747 11.6934C12.9092 11.3524 13 10.9391 13 10.5C13 9.80772 12.7732 9.19154 12.4312 8.83698C12.4038 8.80862 12.3761 8.78242 12.3482 8.75842C11.9293 8.39845 11.8816 7.76709 12.2416 7.34823C12.6016 6.92938 13.2329 6.88164 13.6518 7.24161C13.7274 7.30658 13.8004 7.37561 13.8706 7.44846C14.5888 8.19298 15 9.31015 15 10.5C15 11.2325 14.8447 11.9396 14.553 12.5528C14.373 12.9309 14.143 13.2692 13.8706 13.5516C13.8004 13.6244 13.7274 13.6935 13.6518 13.7584Z" fill="currentColor"/>
<path d="M14.5484 16.8362C14.0866 17.1391 13.4667 17.0103 13.1638 16.5484C12.8609 16.0866 12.9897 15.4667 13.4515 15.1638C13.608 15.0612 13.7593 14.951 13.9048 14.8339C14.0503 14.7168 14.1899 14.5928 14.3229 14.4624C14.456 14.3321 14.5824 14.1955 14.7017 14.0532C14.8209 13.911 14.933 13.7633 15.0374 13.6105C15.1417 13.4579 15.2382 13.3004 15.3267 13.1386C15.415 12.977 15.4952 12.8112 15.5669 12.6419C15.6384 12.4728 15.7014 12.3004 15.7556 12.125C15.8097 11.9502 15.855 11.7727 15.8913 11.5928C15.9274 11.4138 15.9547 11.2326 15.9729 11.0496C15.9909 10.8679 16 10.6846 16 10.5C16 10.3154 15.9909 10.1321 15.9729 9.95036C15.9547 9.76741 15.9274 9.5862 15.8913 9.40717C15.855 9.2273 15.8097 9.04974 15.7556 8.87497C15.7014 8.69959 15.6384 8.52714 15.5669 8.35813C15.4952 8.18878 15.415 8.02302 15.3267 7.86141C15.2382 7.69962 15.1417 7.54212 15.0374 7.38948C14.933 7.2367 14.8209 7.08893 14.7017 6.94674C14.5824 6.80444 14.456 6.66786 14.3229 6.53754C14.1899 6.40715 14.0503 6.28316 13.9048 6.16607C13.7593 6.04894 13.608 5.93883 13.4515 5.83618C12.9897 5.53328 12.8609 4.91335 13.1638 4.45154C13.4667 3.98973 14.0866 3.86091 14.5484 4.16381C14.7592 4.30203 14.9629 4.45032 15.1589 4.6081C15.355 4.76592 15.5431 4.93308 15.7226 5.10894C15.9022 5.28486 16.0729 5.46933 16.2342 5.66164C16.3955 5.85405 16.5473 6.05413 16.6887 6.26116C16.8302 6.46829 16.9614 6.68217 17.0816 6.90207C17.2018 7.12203 17.311 7.34779 17.4087 7.57861C17.5063 7.80921 17.5923 8.04464 17.6664 8.28415C17.7402 8.52295 17.8021 8.76558 17.8517 9.01133C17.9011 9.25581 17.9383 9.50315 17.9631 9.75269C17.9876 10.0001 18 10.2494 18 10.5C18 10.7506 17.9876 10.9999 17.9631 11.2473C17.9383 11.4968 17.9011 11.7442 17.8517 11.9887C17.8021 12.2344 17.7402 12.477 17.6664 12.7158C17.5923 12.9553 17.5063 13.1908 17.4087 13.4214C17.311 13.6522 17.2018 13.878 17.0816 14.0979C16.9614 14.3178 16.8302 14.5317 16.6887 14.7388C16.5473 14.9458 16.3955 15.1459 16.2342 15.3383C16.0729 15.5307 15.9022 15.7151 15.7226 15.891C15.5431 16.0669 15.355 16.2341 15.1589 16.3919C14.9629 16.5497 14.7592 16.698 14.5484 16.8362Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M9.67176 2.12282L5.39936 5.84091H2C1.72386 5.84091 1.5 6.06476 1.5 6.34091V11.5409C1.5 11.817 1.72386 12.0409 2 12.0409H5.29521L9.67042 15.876C9.99362 16.1593 10.5 15.9298 10.5 15.5V2.49999C10.5 2.07105 9.99534 1.84123 9.67176 2.12282ZM5.88379 6.74498L9.5 3.59795V14.3968L6.01411 11.3413C5.93704 11.1645 5.76073 11.0409 5.55556 11.0409H2.5V6.84091H5.39356C5.55132 6.89541 5.73636 6.87329 5.88379 6.74498Z" fill="black"/>
<path d="M13.3259 11.8792C13.1165 12.0592 12.8008 12.0353 12.6208 11.8259C12.4408 11.6165 12.4647 11.3008 12.6741 11.1208C12.714 11.0866 12.753 11.0497 12.7911 11.0102C12.9478 10.8477 13.0864 10.6438 13.1985 10.4082C13.3931 9.99922 13.5 9.51248 13.5 9.00001C13.5 8.18332 13.2271 7.44189 12.7911 6.98984C12.753 6.95036 12.714 6.91345 12.6741 6.87921C12.4647 6.69923 12.4408 6.38354 12.6208 6.17412C12.8008 5.96469 13.1165 5.94082 13.3259 6.12081C13.3896 6.17553 13.4513 6.23386 13.5108 6.29558C14.1349 6.94261 14.5 7.93454 14.5 9.00001C14.5 9.65916 14.3609 10.2928 14.1015 10.8379C13.9442 11.1685 13.7446 11.462 13.5108 11.7044C13.4513 11.7662 13.3896 11.8245 13.3259 11.8792Z" fill="black"/>
<path d="M14.2743 14.9181C14.0433 15.0695 13.7334 15.0051 13.5819 14.7742C13.4305 14.5433 13.4949 14.2334 13.7258 14.0819C13.8959 13.9704 14.0603 13.8507 14.2184 13.7234C14.3765 13.5961 14.5282 13.4614 14.6729 13.3196C14.8175 13.1779 14.9551 13.0293 15.0849 12.8745C15.2146 12.7198 15.3366 12.5589 15.4502 12.3926C15.5638 12.2263 15.6691 12.0547 15.7654 11.8784C15.8618 11.7022 15.9492 11.5215 16.0274 11.3367C16.1054 11.1523 16.1742 10.9641 16.2334 10.7727C16.2924 10.5819 16.3418 10.3881 16.3814 10.1918C16.4209 9.99639 16.4506 9.79864 16.4704 9.59904C16.4901 9.40092 16.5 9.20109 16.5 9C16.5 8.7989 16.4901 8.59907 16.4704 8.40095C16.4506 8.20135 16.4209 8.00361 16.3814 7.80821C16.3418 7.61187 16.2924 7.41805 16.2334 7.22727C16.1742 7.03585 16.1054 6.84766 16.0274 6.66326C15.9492 6.47854 15.8618 6.29778 15.7654 6.12158C15.6691 5.94526 15.5638 5.77367 15.4502 5.60741C15.3366 5.44106 15.2146 5.28022 15.0849 5.12547C14.9551 4.97066 14.8175 4.82212 14.6729 4.68039C14.5282 4.53864 14.3765 4.40386 14.2184 4.27658C14.0603 4.14929 13.8959 4.02963 13.7258 3.91809C13.4949 3.76664 13.4305 3.45668 13.5819 3.22577C13.7334 2.99487 14.0433 2.93045 14.2743 3.0819C14.4714 3.21123 14.6621 3.34998 14.8454 3.4976C15.0289 3.64523 15.2048 3.8016 15.3727 3.96609C15.5407 4.13062 15.7003 4.30311 15.8511 4.48292C16.0019 4.66278 16.1437 4.84978 16.2759 5.04324C16.4081 5.23675 16.5306 5.43654 16.6429 5.64191C16.7552 5.84728 16.8571 6.05804 16.9483 6.27349C17.0394 6.4887 17.1196 6.70838 17.1887 6.93186C17.2576 7.15465 17.3154 7.38101 17.3617 7.6103C17.4077 7.83841 17.4424 8.06922 17.4655 8.30211C17.4885 8.53306 17.5 8.76588 17.5 9C17.5 9.23411 17.4885 9.46693 17.4655 9.69788C17.4424 9.93077 17.4077 10.1616 17.3617 10.3897C17.3154 10.619 17.2576 10.8453 17.1887 11.0681C17.1196 11.2916 17.0394 11.5113 16.9483 11.7265C16.8571 11.9419 16.7552 12.1527 16.6429 12.3581C16.5306 12.5635 16.4081 12.7632 16.2759 12.9567C16.1437 13.1502 16.0019 13.3372 15.8511 13.5171C15.7003 13.6969 15.5407 13.8694 15.3727 14.0339C15.2048 14.1984 15.0289 14.3548 14.8454 14.5024C14.6621 14.65 14.4714 14.7888 14.2743 14.9181Z" fill="black"/>
<path d="M1.68216 3.38598C1.469 3.21043 1.4385 2.89532 1.61405 2.68216C1.78959 2.469 2.10471 2.4385 2.31787 2.61405L19.3179 16.614C19.531 16.7896 19.5615 17.1047 19.386 17.3179C19.2104 17.531 18.8953 17.5615 18.6822 17.386L1.68216 3.38598Z" fill="black"/>
</svg>
`;

const Square = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M8 7H16C16.2761 7 16.5 7.22386 16.5 7.5V15.5C16.5 15.7761 16.2761 16 16 16H8C7.72386 16 7.5 15.7761 7.5 15.5V7.5C7.5 7.22386 7.72386 7 8 7Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14 5.5H6C5.72386 5.5 5.5 5.72386 5.5 6V14C5.5 14.2761 5.72386 14.5 6 14.5H14C14.2761 14.5 14.5 14.2761 14.5 14V6C14.5 5.72386 14.2761 5.5 14 5.5ZM6.5 13.5V6.5H13.5V13.5H6.5Z" fill="black"/>
</svg>
`;

const Star = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.5 15.8995L6.86475 18L7.39781 12.8702L4 9.03851L8.96471 7.96859L11.5 3.5L14.0353 7.96859L19 9.03851L15.6022 12.8702L16.1353 18L11.5 15.8995Z" fill="currentColor" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.57112 17.4554L10 15.4484L14.4289 17.4554C14.7806 17.6148 15.1725 17.3324 15.1326 16.9483L14.6222 12.0373L17.8741 8.37025C18.1279 8.08399 17.9793 7.63033 17.6053 7.54973L12.8596 6.52701L10.4349 2.25327C10.2433 1.91558 9.75671 1.91558 9.56511 2.25327L7.14037 6.52701L2.39466 7.54973C2.02066 7.63033 1.87206 8.08399 2.1259 8.37025L5.37774 12.0373L4.86742 16.9483C4.82751 17.3324 5.21944 17.6148 5.57112 17.4554ZM9.79362 14.4441L5.95214 16.1849L6.39513 11.9218C6.40962 11.7824 6.36491 11.6433 6.2719 11.5384L3.44185 8.34701L7.57004 7.45737C7.70936 7.42735 7.82925 7.33929 7.89958 7.21533L10 3.51324L12.1004 7.21533C12.1707 7.33929 12.2906 7.42735 12.43 7.45737L16.5581 8.34701L13.7281 11.5384C13.6351 11.6433 13.5904 11.7824 13.6049 11.9218L14.0479 16.1849L10.2064 14.4441C10.0752 14.3846 9.92479 14.3846 9.79362 14.4441Z" fill="black"/>
</svg>
`;

const Sun = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M14 10.5C14 12.433 12.433 14 10.5 14C8.567 14 7 12.433 7 10.5C7 8.567 8.567 7 10.5 7C12.433 7 14 8.567 14 10.5Z" fill="currentColor"/>
<path d="M1 10.5C1 9.94772 1.44772 9.5 2 9.5H4C4.55228 9.5 5 9.94772 5 10.5C5 11.0523 4.55228 11.5 4 11.5H2C1.44772 11.5 1 11.0523 1 10.5Z" fill="currentColor"/>
<path d="M16 10.5C16 9.94772 16.4477 9.5 17 9.5H19C19.5523 9.5 20 9.94772 20 10.5C20 11.0523 19.5523 11.5 19 11.5H17C16.4477 11.5 16 11.0523 16 10.5Z" fill="currentColor"/>
<path d="M14.5 14.5C14.8905 14.1095 15.5237 14.1095 15.9142 14.5L17.3284 15.9142C17.719 16.3047 17.719 16.9379 17.3284 17.3284C16.9379 17.7189 16.3047 17.7189 15.9142 17.3284L14.5 15.9142C14.1095 15.5237 14.1095 14.8905 14.5 14.5Z" fill="currentColor"/>
<path d="M3.5 3.49999C3.89052 3.10946 4.52369 3.10946 4.91421 3.49999L6.32843 4.9142C6.71895 5.30472 6.71895 5.93789 6.32843 6.32841C5.9379 6.71894 5.30474 6.71894 4.91421 6.32841L3.5 4.9142C3.10947 4.52367 3.10947 3.89051 3.5 3.49999Z" fill="currentColor"/>
<path d="M10.5 16C11.0523 16 11.5 16.4477 11.5 17V19C11.5 19.5523 11.0523 20 10.5 20C9.94772 20 9.5 19.5523 9.5 19V17C9.5 16.4477 9.94772 16 10.5 16Z" fill="currentColor"/>
<path d="M10.5 1C11.0523 1 11.5 1.44772 11.5 2V4C11.5 4.55228 11.0523 5 10.5 5C9.94772 5 9.5 4.55228 9.5 4V2C9.5 1.44772 9.94772 1 10.5 1Z" fill="currentColor"/>
<path d="M17.3284 3.50001C17.719 3.89054 17.719 4.5237 17.3284 4.91423L15.9142 6.32844C15.5237 6.71897 14.8905 6.71897 14.5 6.32844C14.1095 5.93792 14.1095 5.30475 14.5 4.91423L15.9142 3.50001C16.3047 3.10949 16.9379 3.10949 17.3284 3.50001Z" fill="currentColor"/>
<path d="M6.32843 14.5C6.71895 14.8905 6.71895 15.5237 6.32843 15.9142L4.91422 17.3284C4.52369 17.719 3.89053 17.719 3.5 17.3284C3.10948 16.9379 3.10948 16.3048 3.5 15.9142L4.91422 14.5C5.30474 14.1095 5.93791 14.1095 6.32843 14.5Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10 13.5C11.933 13.5 13.5 11.933 13.5 10C13.5 8.067 11.933 6.5 10 6.5C8.067 6.5 6.5 8.067 6.5 10C6.5 11.933 8.067 13.5 10 13.5ZM10 7.5C11.3807 7.5 12.5 8.61929 12.5 10C12.5 11.3807 11.3807 12.5 10 12.5C8.61929 12.5 7.5 11.3807 7.5 10C7.5 8.61929 8.61929 7.5 10 7.5Z" fill="black"/>
<rect x="1" y="10.5" width="1" height="3" rx="0.5" transform="rotate(-90 1 10.5)" fill="black"/>
<rect x="16" y="10.5" width="1" height="3" rx="0.5" transform="rotate(-90 16 10.5)" fill="black"/>
<rect x="14" y="14.7071" width="1" height="3" rx="0.5" transform="rotate(-45 14 14.7071)" fill="black"/>
<rect x="3" y="3.70709" width="1" height="3" rx="0.5" transform="rotate(-45 3 3.70709)" fill="black"/>
<rect x="9.5" y="16" width="1" height="3" rx="0.5" fill="black"/>
<rect x="9.5" y="1" width="1" height="3" rx="0.5" fill="black"/>
<rect x="16.1213" y="3" width="1" height="3" rx="0.5" transform="rotate(45 16.1213 3)" fill="black"/>
<rect x="5.12132" y="14" width="1" height="3" rx="0.5" transform="rotate(45 5.12132 14)" fill="black"/>
</svg>
`;

const Syringe = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M9.55475 18.4941C9.84765 18.787 9.84765 19.2619 9.55475 19.5547C9.26186 19.8476 8.78699 19.8476 8.49409 19.5547L6.01777 17.0784L5.32844 17.7678L6.16943 18.6088C6.46232 18.9016 6.46232 19.3765 6.16943 19.6694C5.87653 19.9623 5.40166 19.9623 5.10877 19.6694L2.28034 16.841C1.98745 16.5481 1.98745 16.0732 2.28034 15.7803C2.57323 15.4874 3.04811 15.4874 3.341 15.7803L4.26778 16.7071L4.95711 16.0178L2.53034 13.591C2.23745 13.2981 2.23745 12.8232 2.53034 12.5303C2.82323 12.2374 3.29811 12.2374 3.591 12.5303L4.65892 13.5983C4.73279 13.2219 4.91552 12.8627 5.20712 12.5711L12.1858 5.59241C12.5661 5.21212 13.0835 5.00102 13.6213 5.00673L14.9961 5.02136C15.2664 5.02423 15.524 5.08071 15.7586 5.18073L18.4697 2.46967C18.7626 2.17678 19.2374 2.17678 19.5303 2.46967C19.8232 2.76256 19.8232 3.23744 19.5303 3.53033L16.8177 6.24297C16.9132 6.46896 16.9684 6.71627 16.9743 6.97596L17.0062 8.38307C17.0185 8.92907 16.8071 9.45638 16.4209 9.84256L9.44976 16.8137C9.15816 17.1053 8.79893 17.288 8.42257 17.3619L9.55475 18.4941Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.20713 11.5711C2.42608 12.3521 2.42608 13.6184 3.20713 14.3995L4.62134 15.8137C5.40239 16.5947 6.66872 16.5947 7.44977 15.8137L14.4209 8.84254C14.8071 8.45636 15.0186 7.92906 15.0062 7.38305L14.9743 5.97595C14.9499 4.89756 14.0747 4.03281 12.9961 4.02134L11.6213 4.00672C11.0835 4.001 10.5661 4.2121 10.1858 4.59239L3.20713 11.5711ZM13.7138 8.13544L6.74266 15.1066C6.35214 15.4971 5.71897 15.4971 5.32845 15.1066L3.91423 13.6924C3.52371 13.3018 3.52371 12.6687 3.91423 12.2782L10.8929 5.2995C11.083 5.10936 11.3417 5.0038 11.6106 5.00666L12.9855 5.02128C13.5248 5.02702 13.9624 5.45939 13.9746 5.99859L14.0064 7.40569C14.0126 7.67869 13.9069 7.94235 13.7138 8.13544Z" fill="black"/>
<path d="M9.52082 12.1066C9.71608 12.3019 9.71608 12.6185 9.52082 12.8137C9.32556 13.009 9.00898 13.009 8.81371 12.8137L7.3995 11.3995C7.20424 11.2042 7.20424 10.8877 7.3995 10.6924C7.59476 10.4971 7.91134 10.4971 8.10661 10.6924L9.52082 12.1066Z" fill="black"/>
<path d="M3.56397 17.7635C3.75923 17.9587 3.75923 18.2753 3.56397 18.4706C3.36871 18.6658 3.05213 18.6658 2.85687 18.4706L0.328438 15.9421C0.133176 15.7469 0.133176 15.4303 0.328438 15.235C0.5237 15.0398 0.840283 15.0398 1.03554 15.235L3.56397 17.7635Z" fill="black"/>
<path d="M7.35355 17.6464C7.54882 17.8417 7.54882 18.1583 7.35355 18.3535C7.15829 18.5488 6.84171 18.5488 6.64645 18.3535L0.646447 12.3535C0.451185 12.1583 0.451185 11.8417 0.646447 11.6464C0.841709 11.4512 1.15829 11.4512 1.35355 11.6464L7.35355 17.6464Z" fill="black"/>
<path d="M11.6422 9.98527C11.8374 10.1805 11.8374 10.4971 11.6422 10.6924C11.4469 10.8876 11.1303 10.8876 10.9351 10.6924L9.52084 9.27816C9.32558 9.0829 9.32558 8.76632 9.52084 8.57106C9.7161 8.37579 10.0327 8.37579 10.2279 8.57106L11.6422 9.98527Z" fill="black"/>
<path d="M2 17.4571L1.29289 16.75L3.75 14.2929L4.45711 15L2 17.4571Z" fill="black"/>
<path d="M16.8536 1.35354C17.0488 1.15828 17.3654 1.15828 17.5607 1.35354C17.7559 1.5488 17.7559 1.86538 17.5607 2.06065L14.5607 5.06065C14.3654 5.25591 14.0488 5.25591 13.8536 5.06065C13.6583 4.86538 13.6583 4.5488 13.8536 4.35354L16.8536 1.35354Z" fill="black"/>
</svg>
`;

const TShirt = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M4.83164 10.4263L3.66594 11.0085C3.37505 11.1538 3.02504 10.9872 2.95445 10.6697L2.01194 6.43208C1.97476 6.26493 2.02571 6.09038 2.14696 5.96947L4.39316 3.7297C4.86179 3.26241 5.49659 3 6.15839 3L8.16531 3C8.40867 3 8.61669 3.17521 8.65804 3.41503C8.94393 5.07298 9.69694 5.82353 10.9981 5.82353C12.2993 5.82353 13.053 5.0728 13.34 3.41473C13.3815 3.17505 13.5894 3 13.8327 3H15.84C16.5015 3 17.136 3.26216 17.6046 3.72907L19.8529 5.96934C19.9743 6.09033 20.0253 6.26507 19.988 6.43237L19.0435 10.6677C18.9728 10.9847 18.6232 11.1512 18.3325 11.0064L17.1663 10.4254V17.5C17.1663 18.8807 16.047 20 14.6663 20H7.33164C5.95093 20 4.83164 18.8807 4.83164 17.5V10.4263Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M2.66811 10.0085L3.83381 9.42628V16.5C3.83381 17.8807 4.95309 19 6.33381 19H13.6685C15.0492 19 16.1685 17.8807 16.1685 16.5V9.42537L17.3347 10.0064C17.6254 10.1512 17.9749 9.9847 18.0456 9.66766L18.9902 5.43237C19.0275 5.26507 18.9765 5.09033 18.8551 4.96934L16.6068 2.72907C16.1382 2.26216 15.5037 2 14.8422 2H12.8348C12.5916 2 12.3836 2.17505 12.3422 2.41473C12.0552 4.0728 11.3015 4.82353 10.0002 4.82353C8.69911 4.82353 7.9461 4.07298 7.66021 2.41503C7.61885 2.17521 7.41084 2 7.16748 2H5.16056C4.49876 2 3.86396 2.26241 3.39532 2.7297L1.14913 4.96947C1.02787 5.09038 0.976925 5.26493 1.0141 5.43208L1.95662 9.66975C2.02721 9.98715 2.37721 10.1538 2.66811 10.0085ZM5.16056 3H6.75927C7.1952 4.84 8.2974 5.82353 10.0002 5.82353C11.7031 5.82353 12.8058 4.84005 13.2428 3H14.8422C15.2391 3 15.6198 3.1573 15.9009 3.43744L17.9542 5.4834L17.2087 8.82637L15.8915 8.17011C15.5591 8.0045 15.1685 8.24627 15.1685 8.61765V16.5C15.1685 17.3284 14.4969 18 13.6685 18H6.33381C5.50538 18 4.83381 17.3284 4.83381 16.5V8.61765C4.83381 8.24605 4.44283 8.0043 4.11039 8.17034L2.79382 8.82792L2.04995 5.48341L4.10142 3.43782C4.3826 3.15745 4.76348 3 5.16056 3Z" fill="black"/>
<path d="M12 10.5C11.7239 10.5 11.5 10.2761 11.5 10C11.5 9.72386 11.7239 9.5 12 9.5H14C14.2761 9.5 14.5 9.72386 14.5 10C14.5 10.2761 14.2761 10.5 14 10.5H12Z" fill="black"/>
</svg>
`;

const Taxi = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M13 3.5C13 2.67157 12.3284 2 11.5 2C10.6716 2 10 2.67157 10 3.5C10 3.67532 10.0301 3.84361 10.0854 4H7.67116C6.75343 4 5.95346 4.62459 5.73088 5.51493L4.59959 10.0401C3.6869 10.2256 3 11.0326 3 12V15C3 15.8061 3.4769 16.5008 4.16396 16.8174C4.05913 17.0222 4 17.2542 4 17.5V18.5C4 19.3284 4.67157 20 5.5 20C6.32843 20 7 19.3284 7 18.5V17.5C7 17.3247 6.96992 17.1564 6.91465 17H16.0854C16.0301 17.1564 16 17.3247 16 17.5V18.5C16 19.3284 16.6716 20 17.5 20C18.3284 20 19 19.3284 19 18.5V17.5C19 17.2542 18.9409 17.0222 18.836 16.8174C19.5231 16.5008 20 15.8061 20 15V12C20 11.0326 19.3131 10.2256 18.4004 10.0401L17.2691 5.51493C17.0465 4.62459 16.2466 4 15.3288 4H12.9146C12.9699 3.84361 13 3.67532 13 3.5Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.17116 3C5.25343 3 4.45346 3.62459 4.23088 4.51493L3.09959 9.04009C2.1869 9.22556 1.5 10.0326 1.5 11V14C1.5 15.1046 2.39543 16 3.5 16H16.5C17.6046 16 18.5 15.1046 18.5 14V11C18.5 10.0326 17.8131 9.22556 16.9004 9.04009L15.7691 4.51493C15.5465 3.62459 14.7466 3 13.8288 3H6.17116ZM3.5 10C3.72943 10 3.92943 9.84385 3.98507 9.62127L5.20102 4.75746C5.31231 4.3123 5.7123 4 6.17116 4H13.8288C14.2877 4 14.6877 4.3123 14.799 4.75746L16.0149 9.62127C16.0706 9.84385 16.2706 10 16.5 10C17.0523 10 17.5 10.4477 17.5 11V14C17.5 14.5523 17.0523 15 16.5 15H3.5C2.94772 15 2.5 14.5523 2.5 14V11C2.5 10.4477 2.94772 10 3.5 10Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15 14C15.8284 14 16.5 13.3284 16.5 12.5C16.5 11.6716 15.8284 11 15 11C14.1716 11 13.5 11.6716 13.5 12.5C13.5 13.3284 14.1716 14 15 14ZM15 12C15.2761 12 15.5 12.2239 15.5 12.5C15.5 12.7761 15.2761 13 15 13C14.7239 13 14.5 12.7761 14.5 12.5C14.5 12.2239 14.7239 12 15 12Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5 14C5.82843 14 6.5 13.3284 6.5 12.5C6.5 11.6716 5.82843 11 5 11C4.17157 11 3.5 11.6716 3.5 12.5C3.5 13.3284 4.17157 14 5 14ZM5 12C5.27614 12 5.5 12.2239 5.5 12.5C5.5 12.7761 5.27614 13 5 13C4.72386 13 4.5 12.7761 4.5 12.5C4.5 12.2239 4.72386 12 5 12Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 16.5C5.5 15.6716 4.82843 15 4 15C3.17157 15 2.5 15.6716 2.5 16.5V17.5C2.5 18.3284 3.17157 19 4 19C4.82843 19 5.5 18.3284 5.5 17.5V16.5ZM3.5 16.5C3.5 16.2239 3.72386 16 4 16C4.27614 16 4.5 16.2239 4.5 16.5V17.5C4.5 17.7761 4.27614 18 4 18C3.72386 18 3.5 17.7761 3.5 17.5V16.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M17.5 16.5C17.5 15.6716 16.8284 15 16 15C15.1716 15 14.5 15.6716 14.5 16.5V17.5C14.5 18.3284 15.1716 19 16 19C16.8284 19 17.5 18.3284 17.5 17.5V16.5ZM15.5 16.5C15.5 16.2239 15.7239 16 16 16C16.2761 16 16.5 16.2239 16.5 16.5V17.5C16.5 17.7761 16.2761 18 16 18C15.7239 18 15.5 17.7761 15.5 17.5V16.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.6476 5H7.35207C6.66122 5 6.05971 5.47186 5.89521 6.14284L5.4049 8.14284C5.37624 8.25973 5.36176 8.37965 5.36176 8.5C5.36176 9.32843 6.03333 10 6.86176 10H13.1379C13.2582 10 13.3781 9.98552 13.495 9.95686C14.2996 9.7596 14.792 8.94744 14.5947 8.14284L14.1044 6.14284C13.9399 5.47186 13.3384 5 12.6476 5ZM6.86645 6.38095C6.92128 6.15729 7.12179 6 7.35207 6H12.6476C12.8779 6 13.0784 6.15729 13.1332 6.38095L13.6235 8.38095C13.6893 8.64915 13.5251 8.91987 13.2569 8.98562C13.218 8.99517 13.178 9 13.1379 9H6.86176C6.58561 9 6.36176 8.77614 6.36176 8.5C6.36176 8.45988 6.36658 8.41991 6.37614 8.38095L6.86645 6.38095Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.5 2.5C11.5 1.67157 10.8284 1 10 1C9.17157 1 8.5 1.67157 8.5 2.5C8.5 3.32843 9.17157 4 10 4C10.8284 4 11.5 3.32843 11.5 2.5ZM9.5 2.5C9.5 2.22386 9.72386 2 10 2C10.2761 2 10.5 2.22386 10.5 2.5C10.5 2.77614 10.2761 3 10 3C9.72386 3 9.5 2.77614 9.5 2.5Z" fill="black"/>
</svg>
`;

const Television = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12 5.42442L13.9143 3.03148C14.539 2.25061 15.7103 3.18765 15.0857 3.96852L13.4605 6H16C17.6569 6 19 7.34315 19 9V14C19 15.6569 17.6569 17 16 17H8.5C6.84315 17 5.5 15.6569 5.5 14V9C5.5 7.34315 6.84315 6 8.5 6H10.5395L8.91435 3.96852C8.28965 3.18765 9.46096 2.25061 10.0857 3.03148L12 5.42442Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.25 9V14C3.25 15.6569 4.59315 17 6.25 17H13.75C15.4069 17 16.75 15.6569 16.75 14V9C16.75 7.34315 15.4069 6 13.75 6H6.25C4.59315 6 3.25 7.34315 3.25 9ZM6.25 16C5.14543 16 4.25 15.1046 4.25 14V9C4.25 7.89543 5.14543 7 6.25 7H13.75C14.8546 7 15.75 7.89543 15.75 9V14C15.75 15.1046 14.8546 16 13.75 16H6.25Z" fill="black"/>
<path d="M9.85957 5.68765L11.8596 3.18765C12.276 2.66707 13.0569 3.29177 12.6404 3.81235L10.6404 6.31235C10.224 6.83293 9.4431 6.20823 9.85957 5.68765Z" fill="black"/>
<path d="M8.85957 6.31235L6.85957 3.81235C6.4431 3.29177 7.22397 2.66707 7.64044 3.18765L9.64044 5.68765C10.0569 6.20823 9.27603 6.83293 8.85957 6.31235Z" fill="black"/>
</svg>
`;

const TextBubble = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path opacity="0.8" fill-rule="evenodd" clip-rule="evenodd" d="M4 8C4 6.89543 4.89543 6 6 6H18C19.1046 6 20 6.89543 20 8V14.1024C20 15.207 19.1046 16.1024 18 16.1024H10.4508C10.4508 16.1024 8.36316 18 7.70388 18C7.04461 18 6.64753 16.1024 6.64753 16.1024H6C4.89543 16.1024 4 15.207 4 14.1024V8Z" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 12.1024C1.5 13.4832 2.61929 14.6024 4 14.6024H4.24871C4.55632 15.8396 4.99016 16.5 5.70388 16.5C6.3065 16.5 7.22282 15.8804 8.64333 14.6024H16C17.3807 14.6024 18.5 13.4832 18.5 12.1024V6C18.5 4.61929 17.3807 3.5 16 3.5H4C2.61929 3.5 1.5 4.61929 1.5 6V12.1024ZM2.5 12.1024V6C2.5 5.17157 3.17157 4.5 4 4.5H16C16.8284 4.5 17.5 5.17157 17.5 6V12.1024C17.5 12.9309 16.8284 13.6024 16 13.6024H8.25749L8.11447 13.7325C6.8338 14.8965 5.96021 15.5 5.70388 15.5C5.61157 15.5 5.35398 15.0373 5.13693 14L5.05373 13.6024H4C3.17157 13.6024 2.5 12.9309 2.5 12.1024Z" fill="black"/>
<circle cx="7" cy="9" r="1" fill="black"/>
<circle cx="10" cy="9" r="1" fill="black"/>
<circle cx="13" cy="9" r="1" fill="black"/>
</svg>
`;

const Times = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.13197 6.47653C5.56672 7.08215 5.59945 8.03134 6.20507 8.59659L8.78016 11L6.20507 13.4034C5.59945 13.9687 5.56672 14.9179 6.13197 15.5235C6.69722 16.1291 7.6464 16.1618 8.25203 15.5966L10.9786 13.0518L13.7051 15.5966C14.3107 16.1618 15.2599 16.1291 15.8251 15.5235C16.3904 14.9179 16.3577 13.9687 15.752 13.4034L13.1769 11L15.752 8.59659C16.3577 8.03134 16.3904 7.08215 15.8251 6.47653C15.2599 5.8709 14.3107 5.83817 13.7051 6.40342L10.9786 8.94818L8.25203 6.40342C7.6464 5.83817 6.69722 5.8709 6.13197 6.47653Z" fill="currentColor"/>
</g>
<path d="M6.85355 13.8536C6.65829 14.0488 6.34171 14.0488 6.14645 13.8536C5.95118 13.6583 5.95118 13.3417 6.14645 13.1464L13.1464 6.14645C13.3417 5.95118 13.6583 5.95118 13.8536 6.14645C14.0488 6.34171 14.0488 6.65829 13.8536 6.85355L6.85355 13.8536Z" fill="black"/>
<path d="M6.14645 6.85355C5.95118 6.65829 5.95118 6.34171 6.14645 6.14645C6.34171 5.95118 6.65829 5.95118 6.85355 6.14645L13.8536 13.1464C14.0488 13.3417 14.0488 13.6583 13.8536 13.8536C13.6583 14.0488 13.3417 14.0488 13.1464 13.8536L6.14645 6.85355Z" fill="black"/>
</svg>
`;

const Tool = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M13.3009 7.83234L18.6032 14.1514C19.4907 15.209 19.3527 16.7859 18.2951 17.6734C17.2374 18.5609 15.6605 18.423 14.773 17.3653L9.47069 11.0463C9.34745 10.8994 9.23887 10.7414 9.14621 10.5746C7.79248 10.6159 6.43651 10.0062 5.50129 8.89166C4.31872 7.48233 4.058 5.56096 4.81272 4.02998C4.97237 3.70613 5.41213 3.65308 5.64421 3.92966L7.38568 6.00506C7.56318 6.2166 7.87856 6.24419 8.0901 6.06669L8.67137 5.57895C8.88291 5.40145 8.9105 5.08607 8.733 4.87453L6.99153 2.79913C6.75944 2.52254 6.88806 2.09868 7.23471 1.99769C8.87349 1.52029 10.7204 2.11069 11.903 3.52002C12.8501 4.64882 13.2119 6.1123 12.9169 7.45073C13.0559 7.56585 13.1844 7.69351 13.3009 7.83234Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.8763 7.57355C11.7599 7.43472 11.6313 7.30706 11.4924 7.19194C11.7874 5.85352 11.4256 4.39003 10.4784 3.26123C9.29583 1.85191 7.44893 1.2615 5.81015 1.73891C5.46349 1.83989 5.33488 2.26376 5.56697 2.54034L7.30844 4.61574C7.48594 4.82728 7.45834 5.14266 7.24681 5.32016L6.66554 5.8079C6.454 5.9854 6.13862 5.95781 5.96112 5.74627L4.21965 3.67087C3.98757 3.39429 3.54781 3.44734 3.38816 3.77119C2.63344 5.30217 2.89416 7.22354 4.07673 8.63287C5.01195 9.74742 6.36792 10.3571 7.72164 10.3158C7.81431 10.4826 7.92289 10.6406 8.04613 10.7875L13.3484 17.1065C14.2359 18.1642 15.8128 18.3022 16.8705 17.4146C17.9282 16.5271 18.0661 14.9503 17.1786 13.8926L11.8763 7.57355ZM4.84278 7.99008C4.10835 7.11483 3.82676 5.99906 4.02334 4.99264L5.19508 6.38906C5.72758 7.02367 6.67371 7.10645 7.30832 6.57395L7.8896 6.0862C8.52421 5.5537 8.60698 4.60757 8.07448 3.97296L6.90274 2.57653C7.92801 2.55771 8.97793 3.02877 9.71236 3.90402C10.5257 4.87332 10.7896 6.14369 10.4446 7.24405C10.377 7.45967 10.4625 7.69383 10.653 7.81527C10.8248 7.92473 10.979 8.0599 11.1103 8.21634L16.4126 14.5354C16.9451 15.17 16.8623 16.1161 16.2277 16.6486C15.5931 17.1811 14.647 17.0983 14.1145 16.4637L8.81217 10.1447C8.6765 9.98302 8.56748 9.80114 8.48889 9.60585C8.40467 9.39659 8.19075 9.26963 7.96671 9.29595C6.83357 9.42906 5.64661 8.94805 4.84278 7.99008Z" fill="black"/>
</svg>
`;

const Train = `<svg width="20" height="21" viewBox="0 0 20 21" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M19 5.00002C19 3.06702 17.433 1.50002 15.5 1.50002L8.5 1.50002C6.567 1.50002 5 3.06703 5 5.00002V11.9553C5 13.1404 5.59619 14.2188 6.54298 14.8573L5.56608 18.7649C5.43214 19.3007 5.7579 19.8436 6.29369 19.9776C6.82949 20.1115 7.37242 19.7858 7.50637 19.25L7.68667 18.5288H16.3858L16.5661 19.25C16.7 19.7858 17.243 20.1115 17.7788 19.9776C18.3146 19.8436 18.6403 19.3007 18.5064 18.7649L17.5188 14.8147C18.4297 14.1714 19 13.1144 19 11.9553L19 5.00002ZM15.8858 16.5288L15.6406 15.5482C14.4282 15.8493 13.2144 16 12 16C10.8084 16 9.61734 15.8549 8.42762 15.565L8.18667 16.5288H15.8858Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M17 4.5C17 2.567 15.433 1 13.5 1L6.5 1C4.567 1 3 2.56701 3 4.5V11.4552C3 12.9896 3.99941 14.3451 5.4652 14.7988C6.97486 15.266 8.48696 15.5 10 15.5C11.513 15.5 13.0252 15.266 14.5348 14.7988C16.0006 14.3451 17 12.9896 17 11.4552L17 4.5ZM4 11.4552V4.5C4 3.11929 5.11929 2 6.5 2L13.5 2C14.8807 2 16 3.11929 16 4.5L16 11.4552C16 12.5512 15.2862 13.5194 14.2392 13.8435C12.8242 14.2814 11.4116 14.5 10 14.5C8.58839 14.5 7.17585 14.2814 5.76086 13.8435C4.71386 13.5194 4 12.5512 4 11.4552Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.5 13C7.32843 13 8 12.3284 8 11.5C8 10.6716 7.32843 10 6.5 10C5.67157 10 5 10.6716 5 11.5C5 12.3284 5.67157 13 6.5 13ZM6.5 11C6.77614 11 7 11.2239 7 11.5C7 11.7761 6.77614 12 6.5 12C6.22386 12 6 11.7761 6 11.5C6 11.2239 6.22386 11 6.5 11Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.5 13C14.3284 13 15 12.3284 15 11.5C15 10.6716 14.3284 10 13.5 10C12.6716 10 12 10.6716 12 11.5C12 12.3284 12.6716 13 13.5 13ZM13.5 11C13.7761 11 14 11.2239 14 11.5C14 11.7761 13.7761 12 13.5 12C13.2239 12 13 11.7761 13 11.5C13 11.2239 13.2239 11 13.5 11Z" fill="black"/>
<path d="M15.5318 18.6757C15.6288 18.9342 15.917 19.0652 16.1756 18.9683C16.4341 18.8713 16.5651 18.5831 16.4682 18.3245L14.9682 14.3245C14.8712 14.066 14.583 13.935 14.3244 14.0319C14.0659 14.1289 13.9349 14.4171 14.0318 14.6757L15.5318 18.6757Z" fill="black"/>
<path d="M5.53183 14.3245C5.62879 14.0659 5.917 13.9349 6.17556 14.0319C6.43412 14.1288 6.56512 14.417 6.46816 14.6756L4.96816 18.6756C4.8712 18.9341 4.58299 19.0651 4.32443 18.9682C4.06587 18.8712 3.93487 18.583 4.03183 18.3245L5.53183 14.3245Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15 5C15 3.89543 14.1046 3 13 3H7C5.89543 3 5 3.89543 5 5V7.56491C5 8.45546 5.58882 9.23873 6.4443 9.48616C7.62792 9.82852 8.81358 10 10 10C11.1864 10 12.3721 9.82852 13.5557 9.48615C14.4112 9.23871 15 8.45545 15 7.56491L15 5ZM6 7.56491V5C6 4.44772 6.44772 4 7 4H13C13.5523 4 14 4.44772 14 5L14 7.56491C14 8.01018 13.7056 8.40181 13.2779 8.52553C12.1836 8.84204 11.0914 9 10 9C8.90857 9 7.81637 8.84204 6.72215 8.52554C6.29441 8.40182 6 8.01019 6 7.56491Z" fill="black"/>
<path d="M5.25 17.5C4.97386 17.5 4.75 17.2761 4.75 17C4.75 16.7239 4.97386 16.5 5.25 16.5H15.25C15.5261 16.5 15.75 16.7239 15.75 17C15.75 17.2761 15.5261 17.5 15.25 17.5H5.25Z" fill="black"/>
</svg>
`;

const Trash = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<rect x="7" y="7" width="10" height="11.5" rx="1" fill="currentColor"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.0156 4.25C10.1393 3.2647 10.982 2.5 11.9998 2.5C13.0176 2.5 13.8603 3.2647 13.984 4.25H17C17.4142 4.25 17.75 4.58579 17.75 5C17.75 5.41421 17.4142 5.75 17 5.75H7C6.58579 5.75 6.25 5.41421 6.25 5C6.25 4.58579 6.58579 4.25 7 4.25H10.0156Z" fill="currentColor"/>
</g>
<path d="M8.5 14.999C8.5 15.2752 8.27614 15.499 8 15.499C7.72386 15.499 7.5 15.2752 7.5 14.999V8.99902C7.5 8.72288 7.72386 8.49902 8 8.49902C8.27614 8.49902 8.5 8.72288 8.5 8.99902V14.999Z" fill="black"/>
<path d="M10.5 14.999C10.5 15.2752 10.2761 15.499 10 15.499C9.72386 15.499 9.5 15.2752 9.5 14.999V8.99902C9.5 8.72288 9.72386 8.49902 10 8.49902C10.2761 8.49902 10.5 8.72288 10.5 8.99902V14.999Z" fill="black"/>
<path d="M12.5 14.999C12.5 15.2752 12.2761 15.499 12 15.499C11.7239 15.499 11.5 15.2752 11.5 14.999V8.99902C11.5 8.72288 11.7239 8.49902 12 8.49902C12.2761 8.49902 12.5 8.72288 12.5 8.99902V14.999Z" fill="black"/>
<path d="M11.5004 4.4989H11.4994H8.50073C8.50073 3.67169 9.1738 2.99951 10.0001 2.99951C10.8268 2.99951 11.4998 3.67169 11.5004 4.49792V4.4989Z" fill="black"/>
<path d="M4.5 4.99902C4.22386 4.99902 4 4.77517 4 4.49902C4 4.22288 4.22386 3.99902 4.5 3.99902H15.5C15.7761 3.99902 16 4.22288 16 4.49902C16 4.77517 15.7761 4.99902 15.5 4.99902H4.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.5 5.5H5.5C5.22386 5.5 5 5.72386 5 6V17C5 17.2761 5.22386 17.5 5.5 17.5H14.5C14.7761 17.5 15 17.2761 15 17V6C15 5.72386 14.7761 5.5 14.5 5.5ZM6 16.5V6.5H14V16.5H6Z" fill="black"/>
</svg>
`;

const TriangleDown = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M12.076 16.265L7.07599 8.265C6.86785 7.93198 7.10728 7.5 7.49999 7.5L17.5 7.5C17.8927 7.5 18.1321 7.93198 17.924 8.265L12.924 16.265C12.7282 16.5783 12.2718 16.5783 12.076 16.265Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.57601 7.265L9.57601 15.265C9.77184 15.5783 10.2282 15.5783 10.424 15.265L15.424 7.265C15.6321 6.93198 15.3927 6.5 15 6.5L5.00001 6.5C4.60729 6.5 4.36787 6.93198 4.57601 7.265ZM14.0979 7.5L10 14.0566L5.90213 7.5L14.0979 7.5Z" fill="black"/>
</svg>
`;

const TriangleLeft = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M7.735 10.576L15.735 5.57599C16.068 5.36785 16.5 5.60728 16.5 5.99999V16C16.5 16.3927 16.068 16.6321 15.735 16.424L7.735 11.424C7.42167 11.2282 7.42167 10.7718 7.735 10.576Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.735 4.57599L5.735 9.57599C5.42167 9.77183 5.42167 10.2282 5.735 10.424L13.735 15.424C14.068 15.6321 14.5 15.3927 14.5 15V4.99999C14.5 4.60728 14.068 4.36785 13.735 4.57599ZM13.5 5.90212V14.0979L6.9434 9.99999L13.5 5.90212Z" fill="black"/>
</svg>
`;

const TriangleRight = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M17.265 11.424L9.265 16.424C8.93198 16.6321 8.5 16.3927 8.5 16L8.5 6.00001C8.5 5.60729 8.93198 5.36787 9.265 5.57601L17.265 10.576C17.5783 10.7718 17.5783 11.2282 17.265 11.424Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.265 15.424L15.265 10.424C15.5783 10.2282 15.5783 9.77184 15.265 9.57601L7.265 4.57601C6.93198 4.36787 6.5 4.60729 6.5 5.00001L6.5 15C6.5 15.3927 6.93198 15.6321 7.265 15.424ZM7.5 14.0979L7.5 5.90213L14.0566 10L7.5 14.0979Z" fill="black"/>
</svg>
`;

const TriangleUp = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M12.924 6.735L17.924 14.735C18.1321 15.068 17.8927 15.5 17.5 15.5H7.50001C7.10729 15.5 6.86787 15.068 7.07601 14.735L12.076 6.735C12.2718 6.42167 12.7282 6.42167 12.924 6.735Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15.424 13.735L10.424 5.735C10.2282 5.42167 9.77184 5.42167 9.57601 5.735L4.57601 13.735C4.36787 14.068 4.60729 14.5 5.00001 14.5H15C15.3927 14.5 15.6321 14.068 15.424 13.735ZM5.90213 13.5L10 6.9434L14.0979 13.5H5.90213Z" fill="black"/>
</svg>
`;

const Truck = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M9 6H18C19.1046 6 20 6.89543 20 8V15C20 15.7009 19.6395 16.3175 19.0938 16.6747C19.1946 16.9302 19.25 17.2086 19.25 17.5C19.25 18.7426 18.2426 19.75 17 19.75C15.7574 19.75 14.75 18.7426 14.75 17.5C14.75 17.3282 14.7693 17.1608 14.8058 17H10.1942C10.2307 17.1608 10.25 17.3282 10.25 17.5C10.25 18.7426 9.24264 19.75 8 19.75C6.75736 19.75 5.75 18.7426 5.75 17.5C5.75 17.3282 5.76927 17.1608 5.80575 17H3C1.89543 17 1 16.1046 1 15V13L1.79907 10.4103C2.05777 9.5719 2.83274 9 3.71016 9H7V8C7 6.89543 7.89543 6 9 6Z" fill="currentColor"/>
</g>
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 16.5C5.5 17.6046 6.39543 18.5 7.5 18.5C8.60457 18.5 9.5 17.6046 9.5 16.5C9.5 15.3954 8.60457 14.5 7.5 14.5C6.39543 14.5 5.5 15.3954 5.5 16.5ZM8.5 16.5C8.5 17.0523 8.05228 17.5 7.5 17.5C6.94772 17.5 6.5 17.0523 6.5 16.5C6.5 15.9477 6.94772 15.5 7.5 15.5C8.05228 15.5 8.5 15.9477 8.5 16.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M14.5 16.5C14.5 17.6046 15.3954 18.5 16.5 18.5C17.6046 18.5 18.5 17.6046 18.5 16.5C18.5 15.3954 17.6046 14.5 16.5 14.5C15.3954 14.5 14.5 15.3954 14.5 16.5ZM17.5 16.5C17.5 17.0523 17.0523 17.5 16.5 17.5C15.9477 17.5 15.5 17.0523 15.5 16.5C15.5 15.9477 15.9477 15.5 16.5 15.5C17.0523 15.5 17.5 15.9477 17.5 16.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M17 4.5H9C7.89543 4.5 7 5.39543 7 6.5V13.5C7 14.6046 7.89543 15.5 9 15.5H17C18.1046 15.5 19 14.6046 19 13.5V6.5C19 5.39543 18.1046 4.5 17 4.5ZM8 6.5C8 5.94772 8.44772 5.5 9 5.5H17C17.5523 5.5 18 5.94772 18 6.5V13.5C18 14.0523 17.5523 14.5 17 14.5H9C8.44772 14.5 8 14.0523 8 13.5V6.5Z" fill="black"/>
<path d="M10.25 8.5C9.97386 8.5 9.75 8.27614 9.75 8C9.75 7.72386 9.97386 7.5 10.25 7.5H15.75C16.0261 7.5 16.25 7.72386 16.25 8C16.25 8.27614 16.0261 8.5 15.75 8.5H10.25Z" fill="black"/>
<path d="M10.25 10.5C9.97386 10.5 9.75 10.2761 9.75 10C9.75 9.72386 9.97386 9.5 10.25 9.5H15.75C16.0261 9.5 16.25 9.72386 16.25 10C16.25 10.2761 16.0261 10.5 15.75 10.5H10.25Z" fill="black"/>
<path d="M10.25 12.5C9.97386 12.5 9.75 12.2761 9.75 12C9.75 11.7239 9.97386 11.5 10.25 11.5H15.75C16.0261 11.5 16.25 11.7239 16.25 12C16.25 12.2761 16.0261 12.5 15.75 12.5H10.25Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M6 7.5H2.71016C1.83274 7.5 1.05777 8.0719 0.79907 8.91032L0 11.5V13.5C0 14.6046 0.89543 15.5 2 15.5H6C7.10457 15.5 8 14.6046 8 13.5V9.5C8 8.39543 7.10457 7.5 6 7.5ZM1 13.5V11.6508L1.75462 9.20516C1.88397 8.78595 2.27145 8.5 2.71016 8.5H6C6.55228 8.5 7 8.94772 7 9.5V13.5C7 14.0523 6.55228 14.5 6 14.5H2C1.44772 14.5 1 14.0523 1 13.5Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.5 9.59998H2.79046C2.56147 9.59998 2.36175 9.75553 2.30568 9.97754L2.01522 11.1276L2 11.25V12.1C2 12.3761 2.22386 12.6 2.5 12.6H4.5C4.77614 12.6 5 12.3761 5 12.1V10.1C5 9.82383 4.77614 9.59998 4.5 9.59998ZM3 11.6V11.3122L3.17988 10.6H4V11.6H3Z" fill="black"/>
</svg>
`;

const Umbrella = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path fill-rule="evenodd" clip-rule="evenodd" d="M17.9981 12.5153C18.9261 12.5188 19.5 11.9301 19.5 11.0154C19.5 7.0875 16.7194 3.97003 12.9593 3.56093C12.9858 3.4711 13 3.37602 13 3.27761V1.75319C13 1.2009 12.5523 0.753185 12 0.753185C11.4477 0.753185 11 1.2009 11 1.75319V3.27761C11 3.38558 11.0171 3.48955 11.0488 3.58695C7.33672 4.09084 4.50003 7.19551 4.50003 11.0154C4.50003 11.9278 5.08439 12.4886 5.98532 12.5151C6.31258 12.5248 6.55493 12.3522 6.82207 12.0417C6.90381 11.9466 6.98714 11.8388 7.09085 11.6965C7.12065 11.6556 7.19647 11.5498 7.25954 11.4618C7.30106 11.4039 7.33705 11.3537 7.35074 11.3348C7.70851 10.8408 7.94601 10.6044 8.10482 10.5703C8.14153 10.5625 8.28045 10.6412 8.65736 10.9395C9.26019 11.4167 9.58816 11.5908 10.0821 11.5086C10.3878 11.4577 10.6512 11.3234 11 11.0815V17.5154L11.007 17.6336C11.1723 19.0224 12.0411 19.8735 13.3863 19.8735C14.8907 19.8735 15.6111 18.6746 15.6111 16.8352C15.6111 16.283 15.1634 15.8352 14.6111 15.8352C14.0588 15.8352 13.6111 16.283 13.6111 16.8352C13.6111 17.7136 13.515 17.8735 13.3863 17.8735C13.1119 17.8735 13.0488 17.8241 13 17.4533V11.0846C13.3651 11.3385 13.6132 11.4623 13.9249 11.5097C14.4159 11.5843 14.7331 11.4038 15.342 10.899C15.7196 10.5861 15.8664 10.4984 15.8998 10.5052C16.041 10.5341 16.2788 10.7801 16.6432 11.2976C16.6485 11.305 16.6662 11.3304 16.6903 11.3649C16.7545 11.4567 16.8637 11.6131 16.9034 11.6687C17.0064 11.8132 17.0903 11.9244 17.1723 12.022C17.4371 12.3372 17.6752 12.514 17.9981 12.5153Z" fill="currentColor"/>
</g>
<path d="M9.5 10.5C9.5 10.2239 9.72386 10 10 10C10.2761 10 10.5 10.2239 10.5 10.5L10.4963 17.0563C10.5797 17.7343 10.8603 18 11.4601 18C11.981 18 12.25 17.5673 12.25 16.4249C12.25 16.1488 12.4739 15.9249 12.75 15.9249C13.0261 15.9249 13.25 16.1488 13.25 16.4249C13.25 18.0494 12.6591 19 11.4601 19C10.3401 19 9.64721 18.3439 9.5 17.1174V10.5Z" fill="black"/>
<path d="M9.50006 1.76538C9.50006 1.48924 9.72392 1.26538 10.0001 1.26538C10.2762 1.26538 10.5001 1.48924 10.5001 1.76538V3.28981C10.5001 3.56595 10.2762 3.78981 10.0001 3.78981C9.72392 3.78981 9.50006 3.56595 9.50006 3.28981L9.50006 1.76538Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15.9982 12.2653C16.9261 12.2688 17.5001 11.6801 17.5001 10.7654C17.5001 6.54833 14.2949 3.26538 10.1136 3.26538C5.89319 3.26538 2.50006 6.58764 2.50006 10.7654C2.50006 11.6778 3.08442 12.2386 3.98535 12.2652C4.31262 12.2748 4.55496 12.1022 4.8221 11.7917C4.90384 11.6966 4.98717 11.5888 5.09088 11.4465C5.12068 11.4056 5.1965 11.2998 5.25957 11.2118C5.30109 11.1539 5.33708 11.1037 5.35077 11.0848C5.70855 10.5908 5.94604 10.3544 6.10486 10.3204C6.14156 10.3125 6.28048 10.3912 6.65739 10.6896C7.26022 11.1667 7.58819 11.3408 8.08215 11.2586C8.39286 11.2069 8.65993 11.069 9.0175 10.8194C9.07317 10.7805 9.11973 10.7472 9.21734 10.6768C9.64505 10.3685 9.83443 10.2681 10.0081 10.2653C10.1616 10.2628 10.3455 10.361 10.7763 10.6744L10.8594 10.7347C11.3049 11.0568 11.5748 11.2065 11.9249 11.2597C12.416 11.3344 12.7331 11.1538 13.3421 10.649C13.7196 10.3361 13.8665 10.2484 13.8998 10.2552C14.041 10.2841 14.2788 10.5301 14.6432 11.0476C14.6485 11.055 14.6662 11.0804 14.6902 11.1148C14.7544 11.2066 14.8637 11.363 14.9034 11.4187C15.0064 11.5633 15.0903 11.6744 15.1723 11.772C15.4371 12.0872 15.6752 12.2641 15.9982 12.2653ZM10.1136 4.26538C13.7372 4.26538 16.5001 7.09531 16.5001 10.7654C16.5001 11.1328 16.3695 11.2667 16.002 11.2653C16.0328 11.2654 15.9656 11.1728 15.7999 10.9448C15.7136 10.8259 15.6006 10.6703 15.4608 10.4718C14.9354 9.72575 14.5989 9.37758 14.1003 9.27554C13.6207 9.17736 13.3697 9.32723 12.7039 9.87915C12.3325 10.187 12.1617 10.2842 12.0752 10.2711C11.9357 10.2498 11.7634 10.1543 11.4453 9.92431L11.3645 9.86567C10.7453 9.41534 10.4509 9.25803 9.99198 9.26545C9.53482 9.27283 9.23301 9.43277 8.63259 9.86557C8.53642 9.93494 8.49504 9.96456 8.44516 9.99937C8.20097 10.1698 8.0431 10.2513 7.91797 10.2722C7.81814 10.2888 7.64863 10.1988 7.278 9.90544C6.61491 9.38063 6.36876 9.24107 5.89527 9.34256C5.39709 9.44935 5.05101 9.7939 4.54088 10.4982C4.42013 10.665 4.32023 10.7997 4.24073 10.907C4.04883 11.1658 3.97573 11.2644 4.01477 11.2656C3.63946 11.2546 3.50006 11.1208 3.50006 10.7654C3.50006 7.14471 6.4408 4.26538 10.1136 4.26538Z" fill="black"/>
</svg>
`;

const Wifi = `<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<g opacity="0.8">
<path d="M14.6961 12.2821C15.0926 12.6665 15.1024 13.2996 14.7179 13.6961C14.3335 14.0926 13.7004 14.1024 13.3039 13.7179C13.273 13.688 13.2391 13.6581 13.2022 13.6285C13.0406 13.4986 12.8292 13.3788 12.5791 13.2796C12.1265 13.1001 11.5793 13 11 13C10.086 13 9.26716 13.2511 8.79777 13.6285C8.76089 13.6581 8.72699 13.688 8.69613 13.7179C8.29964 14.1024 7.66655 14.0926 7.28209 13.6961C6.89762 13.2996 6.90738 12.6665 7.30387 12.2821C7.37977 12.2085 7.46015 12.1377 7.54472 12.0697C8.39422 11.3868 9.65538 11 11 11C11.8267 11 12.6239 11.1459 13.3163 11.4204C13.7456 11.5907 14.131 11.809 14.4553 12.0697C14.5399 12.1377 14.6202 12.2085 14.6961 12.2821Z" fill="currentColor"/>
<path d="M17.2128 9.68869C17.6002 10.0824 17.595 10.7155 17.2013 11.1029C16.8076 11.4902 16.1745 11.485 15.7872 11.0913C15.6908 10.9934 15.5866 10.898 15.4751 10.8056C15.362 10.712 15.2416 10.6216 15.1142 10.5349C14.9855 10.4473 14.8498 10.3636 14.7078 10.2842C14.5647 10.2042 14.4152 10.1287 14.2601 10.058C14.104 9.9869 13.9424 9.92084 13.7758 9.86013C13.6085 9.79914 13.4364 9.74364 13.2601 9.6939C13.0833 9.64404 12.9026 9.60002 12.7185 9.56207C12.5345 9.52413 12.3472 9.49229 12.1573 9.46673C11.968 9.44124 11.7762 9.42202 11.5824 9.40919C11.3899 9.39644 11.1956 9.39001 11 9.39001C10.8044 9.39001 10.6101 9.39644 10.4176 9.40919C10.2238 9.42202 10.032 9.44124 9.84266 9.46673C9.65277 9.49229 9.46552 9.52413 9.28146 9.56207C9.09736 9.60002 8.91666 9.64404 8.73993 9.6939C8.56364 9.74364 8.39152 9.79914 8.22416 9.86013C8.0576 9.92084 7.89597 9.9869 7.73987 10.058C7.58477 10.1287 7.43534 10.2042 7.29217 10.2842C7.15018 10.3636 7.01455 10.4473 6.88581 10.5349C6.75842 10.6216 6.63797 10.712 6.52494 10.8056C6.41338 10.898 6.30922 10.9934 6.21284 11.0913C5.82551 11.485 5.19237 11.4902 4.79868 11.1029C4.40498 10.7155 4.39983 10.0824 4.78716 9.68869C4.93166 9.54182 5.0859 9.40053 5.24924 9.26525C5.41113 9.13118 5.58183 9.0031 5.76069 8.8814C5.93819 8.76061 6.12361 8.6462 6.31623 8.53851C6.50766 8.4315 6.70608 8.3312 6.91079 8.23795C7.11446 8.14517 7.32421 8.05944 7.53934 7.98104C7.75355 7.90297 7.97295 7.83222 8.19683 7.76905C8.41971 7.70617 8.64688 7.65083 8.87767 7.60326C9.10719 7.55594 9.34013 7.51634 9.57585 7.48461C9.80999 7.45309 10.0467 7.42936 10.2855 7.41356C10.522 7.39789 10.7604 7.39001 11 7.39001C11.2396 7.39001 11.478 7.39789 11.7145 7.41356C11.9533 7.42936 12.19 7.45309 12.4241 7.48461C12.6599 7.51634 12.8928 7.55594 13.1223 7.60326C13.3531 7.65083 13.5803 7.70617 13.8032 7.76905C14.0271 7.83222 14.2464 7.90297 14.4607 7.98104C14.6758 8.05944 14.8855 8.14517 15.0892 8.23795C15.2939 8.3312 15.4923 8.4315 15.6838 8.53851C15.8764 8.6462 16.0618 8.76061 16.2393 8.8814C16.4182 9.0031 16.5889 9.13118 16.7508 9.26525C16.9141 9.40053 17.0683 9.54182 17.2128 9.68869Z" fill="currentColor"/>
<path d="M19.2454 7.22201C19.6136 7.63366 19.5783 8.26584 19.1667 8.63403C18.755 9.00221 18.1228 8.96697 17.7546 8.55532C17.6133 8.3973 17.4611 8.24398 17.2987 8.09599C17.1352 7.94702 16.9614 7.80363 16.7782 7.66645C16.5939 7.5285 16.4001 7.397 16.1977 7.27253C15.9944 7.14748 15.7825 7.02968 15.5629 6.91965C15.3426 6.80922 15.1147 6.70676 14.8801 6.61271C14.6448 6.51841 14.4031 6.43268 14.1558 6.35591C13.9082 6.27907 13.6552 6.21129 13.3976 6.15288C13.1404 6.09455 12.8788 6.04562 12.6136 6.00636C12.3494 5.96723 12.0818 5.93773 11.8116 5.91805C11.5433 5.89851 11.2725 5.88866 11 5.88866C10.7275 5.88866 10.4568 5.89851 10.1884 5.91805C9.91819 5.93773 9.65062 5.96723 9.38638 6.00636C9.12121 6.04562 8.85962 6.09455 8.60238 6.15288C8.34479 6.21129 8.0918 6.27907 7.84422 6.35591C7.59687 6.43268 7.35518 6.51841 7.11995 6.61271C6.88536 6.70676 6.65746 6.80922 6.43708 6.91965C6.2175 7.02968 6.00564 7.14748 5.80229 7.27253C5.59988 7.397 5.40615 7.5285 5.22185 7.66645C5.03857 7.80363 4.86484 7.94702 4.70132 8.09599C4.53888 8.24398 4.38671 8.3973 4.24538 8.55532C3.87719 8.96697 3.24501 9.00221 2.83335 8.63403C2.4217 8.26584 2.38646 7.63366 2.75464 7.22201C2.94178 7.01278 3.14198 6.81106 3.35441 6.61753C3.56577 6.42498 3.78906 6.24069 4.02339 6.06529C4.2567 5.89067 4.50075 5.725 4.75463 5.56888C5.00757 5.41334 5.27004 5.26739 5.54111 5.13157C5.81132 4.99617 6.08986 4.87094 6.37575 4.75633C6.66085 4.64203 6.95304 4.53839 7.25138 4.4458C7.54872 4.35351 7.85193 4.27227 8.1601 4.20239C8.46682 4.13284 8.77822 4.0746 9.09344 4.02793C9.40671 3.98154 9.72353 3.94661 10.0431 3.92334C10.3598 3.90027 10.679 3.88866 11 3.88866C11.321 3.88866 11.6402 3.90027 11.9569 3.92334C12.2765 3.94661 12.5933 3.98154 12.9066 4.02793C13.2218 4.0746 13.5332 4.13284 13.8399 4.20239C14.1481 4.27227 14.4513 4.35351 14.7486 4.4458C15.047 4.53839 15.3392 4.64203 15.6243 4.75633C15.9102 4.87094 16.1887 4.99617 16.4589 5.13157C16.73 5.26739 16.9925 5.41334 17.2454 5.56888C17.4993 5.725 17.7433 5.89067 17.9766 6.06529C18.211 6.24069 18.4342 6.42498 18.6456 6.61753C18.858 6.81106 19.0582 7.01278 19.2454 7.22201Z" fill="currentColor"/>
<path d="M13 16.25C13 17.3546 12.1046 18.25 11 18.25C9.89543 18.25 9 17.3546 9 16.25C9 15.1454 9.89543 14.25 11 14.25C12.1046 14.25 13 15.1454 13 16.25Z" fill="currentColor"/>
</g>
<path d="M13.3481 11.641C13.5463 11.8333 13.5512 12.1498 13.359 12.3481C13.1667 12.5463 12.8502 12.5512 12.6519 12.359C12.6098 12.3181 12.5643 12.278 12.5155 12.2388C12.3132 12.0762 12.0583 11.9317 11.7634 11.8148C11.2508 11.6116 10.6411 11.5 10 11.5C8.97837 11.5 8.04893 11.7851 7.4845 12.2388C7.43571 12.278 7.39018 12.3181 7.34807 12.359C7.14982 12.5512 6.83327 12.5463 6.64104 12.3481C6.44881 12.1498 6.45369 11.8333 6.65194 11.641C6.71658 11.5784 6.78533 11.5178 6.85798 11.4594C7.61245 10.8529 8.76304 10.5 10 10.5C10.7648 10.5 11.4996 10.6344 12.132 10.8852C12.5165 11.0377 12.8584 11.2314 13.142 11.4594C13.2147 11.5178 13.2834 11.5784 13.3481 11.641Z" fill="black"/>
<path d="M15.8564 9.03935C16.0501 9.2362 16.0475 9.55277 15.8507 9.74644C15.6538 9.9401 15.3372 9.93752 15.1436 9.74068C15.0352 9.63049 14.9185 9.52361 14.794 9.42049C14.6687 9.31677 14.5357 9.21697 14.3955 9.12153C14.2545 9.02564 14.1065 8.93426 13.9518 8.84781C13.7966 8.76102 13.6349 8.6793 13.4674 8.60299C13.2994 8.52647 13.1257 8.45549 12.947 8.39036C12.768 8.3251 12.584 8.26579 12.3958 8.21269C12.2076 8.15957 12.0153 8.11272 11.8195 8.07237C11.6241 8.03208 11.4254 7.9983 11.224 7.9712C11.0235 7.9442 10.8204 7.92385 10.6154 7.91028C10.4119 7.8968 10.2066 7.89001 10 7.89001C9.79341 7.89001 9.58811 7.8968 9.38457 7.91028C9.17957 7.92385 8.97652 7.9442 8.77596 7.9712C8.57461 7.9983 8.37593 8.03208 8.18051 8.07237C7.98474 8.11272 7.79242 8.15957 7.60416 8.21269C7.41597 8.26579 7.23203 8.3251 7.05296 8.39036C6.87425 8.45549 6.70059 8.52647 6.5326 8.60299C6.3651 8.6793 6.20342 8.76102 6.04818 8.84781C5.89354 8.93426 5.74546 9.02564 5.60453 9.12153C5.46427 9.21697 5.33126 9.31677 5.20602 9.42049C5.08151 9.52361 4.96483 9.63049 4.85642 9.74068C4.66276 9.93752 4.34618 9.9401 4.14934 9.74644C3.95249 9.55277 3.94991 9.2362 4.14358 9.03935C4.27605 8.90471 4.41777 8.77489 4.56817 8.65033C4.71784 8.52638 4.87598 8.40772 5.04197 8.29478C5.20728 8.18229 5.38025 8.07555 5.56021 7.97494C5.73958 7.87467 5.92575 7.78056 6.11806 7.69296C6.30984 7.60561 6.50756 7.52479 6.71054 7.45081C6.91304 7.37701 7.12062 7.31008 7.3326 7.25026C7.54395 7.19063 7.7595 7.13813 7.97862 7.09296C8.19677 7.04799 8.41829 7.01033 8.64256 6.98014C8.8655 6.95013 9.09101 6.92753 9.3185 6.91246C9.54404 6.89753 9.77138 6.89001 10 6.89001C10.2286 6.89001 10.456 6.89753 10.6815 6.91246C10.909 6.92753 11.1345 6.95013 11.3574 6.98014C11.5817 7.01033 11.8032 7.04799 12.0214 7.09296C12.2405 7.13813 12.4561 7.19063 12.6674 7.25026C12.8794 7.31008 13.087 7.37701 13.2895 7.45081C13.4924 7.52479 13.6902 7.60561 13.8819 7.69296C14.0742 7.78056 14.2604 7.87467 14.4398 7.97494C14.6198 8.07555 14.7927 8.18229 14.958 8.29478C15.124 8.40772 15.2822 8.52638 15.4318 8.65033C15.5822 8.77489 15.724 8.90471 15.8564 9.03935Z" fill="black"/>
<path d="M17.8727 6.55534C18.0568 6.76117 18.0392 7.07726 17.8333 7.26135C17.6275 7.44544 17.3114 7.42782 17.1273 7.22199C16.9745 7.05117 16.8104 6.88575 16.6354 6.72638C16.4599 6.56651 16.2738 6.4129 16.0778 6.26617C15.8812 6.11905 15.6749 5.979 15.4596 5.84662C15.2439 5.71395 15.0194 5.58911 14.7869 5.47264C14.5541 5.35597 14.3135 5.24781 14.0661 5.14862C13.8184 5.04932 13.5641 4.95911 13.304 4.87839C13.044 4.79769 12.7784 4.72654 12.5082 4.66526C12.2386 4.60413 11.9646 4.55287 11.6869 4.51176C11.4104 4.47082 11.1305 4.43996 10.848 4.41938C10.5675 4.39895 10.2846 4.38867 10 4.38867C9.71539 4.38867 9.43252 4.39895 9.15205 4.41938C8.86952 4.43996 8.58964 4.47082 8.31314 4.51176C8.03545 4.55287 7.76142 4.60413 7.4918 4.66526C7.22157 4.72654 6.95603 4.79769 6.69601 4.87839C6.43591 4.95911 6.18159 5.04932 5.9339 5.14862C5.68648 5.24781 5.44592 5.35597 5.21308 5.47264C4.98063 5.58911 4.75611 5.71395 4.54037 5.84662C4.32509 5.979 4.11878 6.11905 3.92223 6.26617C3.72619 6.4129 3.54007 6.56651 3.36459 6.72638C3.18965 6.88575 3.02547 7.05117 2.87269 7.22199C2.6886 7.42782 2.3725 7.44544 2.16668 7.26135C1.96085 7.07726 1.94323 6.76117 2.12732 6.55534C2.30301 6.35891 2.4912 6.1693 2.69113 5.98715C2.89053 5.80549 3.10143 5.63143 3.323 5.46559C3.54406 5.30013 3.77553 5.14301 4.01654 4.9948C4.25708 4.84688 4.5069 4.70797 4.7651 4.57859C5.02285 4.44944 5.28873 4.3299 5.56179 4.22043C5.83442 4.11113 6.11399 4.01197 6.39958 3.92333C6.68448 3.83491 6.97514 3.75703 7.27066 3.69002C7.56501 3.62327 7.86396 3.56736 8.16667 3.52254C8.46768 3.47797 8.77219 3.4444 9.07941 3.42202C9.38405 3.39983 9.69115 3.38867 10 3.38867C10.3089 3.38867 10.616 3.39983 10.9206 3.42202C11.2278 3.4444 11.5323 3.47797 11.8333 3.52254C12.1361 3.56736 12.435 3.62327 12.7293 3.69002C13.0249 3.75703 13.3155 3.83491 13.6004 3.92333C13.886 4.01197 14.1656 4.11113 14.4382 4.22043C14.7113 4.3299 14.9772 4.44944 15.2349 4.57859C15.4931 4.70797 15.7429 4.84688 15.9835 4.9948C16.2245 5.14301 16.456 5.30013 16.677 5.46559C16.8986 5.63143 17.1095 5.80549 17.3089 5.98715C17.5088 6.1693 17.697 6.35891 17.8727 6.55534Z" fill="black"/>
<path d="M11.75 15.25C11.75 16.2165 10.9665 17 10 17C9.0335 17 8.25 16.2165 8.25 15.25C8.25 14.2835 9.0335 13.5 10 13.5C10.9665 13.5 11.75 14.2835 11.75 15.25Z" fill="black"/>
</svg>
`;

/** Do not edit! This file is auto-generated. */
const print = {
    'airplane': Airplane,
    'angle-down': AngleDown,
    'angle-left': AngleLeft,
    'angle-right': AngleRight,
    'angle-up': AngleUp,
    'battery': Battery,
    'bell': Bell,
    'bell-off': BellOff,
    'bicycle': Bicycle,
    'bluetooth': Bluetooth,
    'book': Book,
    'bookmark': Bookmark,
    'building': Building,
    'calculator': Calculator,
    'calendar': Calendar,
    'camera': Camera,
    'can': Can,
    'car': Car,
    'cart': Cart,
    'checkmark': Checkmark,
    'circle': Circle,
    'clipboard': Clipboard,
    'clock': Clock,
    'cloud': Cloud,
    'cloud-down': CloudDown,
    'cloud-up': CloudUp,
    'coctail': Coctail,
    'color-picker': ColorPicker,
    'contract': Contract,
    'controller': Controller,
    'credit-card': CreditCard,
    'cup': Cup,
    'division': Division,
    'dots-x': DotsX,
    'dots-y': DotsY,
    'dress': Dress,
    'duplicate': Duplicate,
    'electricity': Electricity,
    'exclamation': Exclamation,
    'expand': Expand,
    'eye': Eye,
    'eye-closed': EyeClosed,
    'eye-off': EyeOff,
    'file': File,
    'film-frame': FilmFrame,
    'flag': Flag,
    'flower': Flower,
    'flower-bud': FlowerBud,
    'folder': Folder,
    'gear': Gear,
    'gift': Gift,
    'grab': Grab,
    'hamburger': Hamburger,
    'headphone': Headphone,
    'heart': Heart,
    'house': House,
    'info': Info,
    'internet': Internet,
    'key': Key,
    'knive-fork': KniveFork,
    'letter': Letter,
    'lock-closed': LockClosed,
    'lock-open': LockOpen,
    'loop': Loop,
    'loop-minus': LoopMinus,
    'loop-plus': LoopPlus,
    'magnet': Magnet,
    'map': Map,
    'microphone': Microphone,
    'minus': Minus,
    'monitor': Monitor,
    'monitor2': Monitor2,
    'moon': Moon,
    'motorcycle': Motorcycle,
    'music-note-double': MusicNoteDouble,
    'music-note-single': MusicNoteSingle,
    'open': Open,
    'paint-pallet': PaintPallet,
    'pen': Pen,
    'person': Person,
    'phone': Phone,
    'photo-camera': PhotoCamera,
    'pill': Pill,
    'pinpoint': Pinpoint,
    'pinpoint-off': PinpointOff,
    'plus': Plus,
    'power': Power,
    'printer': Printer,
    'refresh': Refresh,
    'reload': Reload,
    'scissors': Scissors,
    'send': Send,
    'share-android': ShareAndroid,
    'share-ios': ShareIos,
    'smartphone': Smartphone,
    'smartphone-notch': SmartphoneNotch,
    'smartphone2': Smartphone2,
    'soft-drink': SoftDrink,
    'speaker-high': SpeakerHigh,
    'speaker-low': SpeakerLow,
    'speaker-off': SpeakerOff,
    'square': Square,
    'star': Star,
    'sun': Sun,
    'syringe': Syringe,
    't-shirt': TShirt,
    'taxi': Taxi,
    'television': Television,
    'text-bubble': TextBubble,
    'times': Times,
    'tool': Tool,
    'train': Train,
    'trash': Trash,
    'triangle-down': TriangleDown,
    'triangle-left': TriangleLeft,
    'triangle-right': TriangleRight,
    'triangle-up': TriangleUp,
    'truck': Truck,
    'umbrella': Umbrella,
    'wifi': Wifi,
};

/**
 * @returns {{ r: number, g: number, b: number, a?: number }} { r: [0-255], g: [0-255], b: [0-255}<, a: [0-100]>}
 */
function hexToRgba(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('Expected a string');
    }
    hex = hex.replace(/^#/, '');
    if (hex.length === 3) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    else if (hex.length === 4) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
    }
    const num = parseInt(hex, 16);
    return hex.length > 6
        ? {
            r: (num >> 24) & 255,
            g: (num >> 16) & 255,
            b: (num >> 8) & 255,
            a: Math.round((num & 255) / 2.55),
        }
        : { r: num >> 16, g: (num >> 8) & 255, b: num & 255 };
}
const reRGBA = /^\s*rgb(a)?\s*\((\s*(\d+)\s*,\s*?){2}(\d+)\s*,?\s*([01]?\.?\d*?)?\s*\)\s*$/;
/**
 * @returns {{ r: number, g: number, b: number, a?: number }} { r: [0-255], g: [0-255], b: [0-255}<, a: [0-100]>}
 */
function textToRgba(color) {
    if (typeof color !== 'string') {
        throw new TypeError('Expected a string');
    }
    const m = reRGBA.exec(color);
    if (m) {
        const rgb = {
            r: Math.max(255, parseInt(m[2], 10)),
            g: Math.max(255, parseInt(m[3], 10)),
            b: Math.max(255, parseInt(m[4], 10)),
        };
        if (m[1]) {
            rgb.a = Math.max(1, parseFloat(m[5]));
        }
        return rgb;
    }
    return hexToRgba(color);
}

/**
 * Returns a Pepicon SVG as a string so you can inject it into your HTML.
 *
 * The icon name as per the reference at https://pepicons.com
 * @param options options
 * @returns {string} The SVG content as string
 */
function pepiconSvgString(options) {
    const { name, type, color, opacity, size, stroke } = options || {};
    let svgString = type === 'pop' ? pop[name] : print[name];
    if (!svgString) {
        console.error(`Pepicon ${name} of type ${type} not found!`);
        return '';
    }
    if (!/style="/.test(svgString)) {
        svgString = svgString.replace('<svg ', '<svg style="" ');
    }
    if (stroke) {
        svgString = svgString.replace(/#000000|#000|black/g, stroke);
    }
    const rgbOrHexColor = (color === null || color === void 0 ? void 0 : color.startsWith('rgb')) || (color === null || color === void 0 ? void 0 : color.startsWith('#'));
    if (color && !rgbOrHexColor) {
        svgString = svgString.replace(/style="/, `style="color:${color};`);
    }
    let _opacity = opacity;
    if (color && rgbOrHexColor) {
        const { r, g, b, a } = textToRgba(color);
        const _color = `rgb(${r},${g},${b})`;
        svgString = svgString.replace(/style="/, `style="color:${_color};`);
        if (opacity === undefined) {
            _opacity = a === undefined ? 1 : a / 100;
        }
    }
    if (_opacity !== undefined && _opacity < 1) {
        if (type === 'pop') {
            svgString = svgString.replace(/style="/, `style="opacity:${_opacity};`);
        }
        else {
            svgString = svgString.replace(/opacity="\.8"/g, `opacity="${_opacity}"`);
        }
    }
    if (size || size === 0) {
        const _size = size === 'sm'
            ? '20px'
            : size === 'md'
                ? '24px'
                : size === 'lg'
                    ? '30px'
                    : size === 'xl'
                        ? '36px'
                        : typeof size === 'number'
                            ? `${size}px`
                            : size;
        svgString = svgString
            .replace(/style="/, `style="width:${_size};height:${_size};`)
            .replace(/width="[0-9]+" height="[0-9]+"/, `width="${_size}" height="${_size}"`);
    }
    return svgString;
}




/***/ }),

/***/ "f2bf":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("f498");
var isObject = __webpack_require__("7526");

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "f3e4":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("7526");

module.exports = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  } return it;
};


/***/ }),

/***/ "f498":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof global == 'object' && global) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("7d15")))

/***/ }),

/***/ "f8a5":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "f96b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function (fn, limit = 250) {
  let wait = false,
      result;
  return function ()
  /* ...args */
  {
    if (wait === false) {
      wait = true;
      setTimeout(() => {
        wait = false;
      }, limit);
      result = fn.apply(this, arguments);
    }

    return result;
  };
});

/***/ }),

/***/ "fa46":
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__("abdf").f;
var has = __webpack_require__("f1a7");
var wellKnownSymbol = __webpack_require__("7d53");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ "fbf7":
/***/ (function(module, exports) {

// a string of all valid unicode whitespaces
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "fdad":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "ff5c":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("8bb2");
var toLength = __webpack_require__("b495");

// `ToIndex` abstract operation
// https://tc39.es/ecma262/#sec-toindex
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length or index');
  return length;
};


/***/ }),

/***/ "ff89":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__("72df");
var getPrototypeOf = __webpack_require__("0e39");
var createNonEnumerableProperty = __webpack_require__("5b12");
var has = __webpack_require__("f1a7");
var wellKnownSymbol = __webpack_require__("7d53");
var IS_PURE = __webpack_require__("0e93");

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ "ffad":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ariaHidden; });
/* harmony import */ var _utils_cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("6459");

const ariaHidden = {
  'aria-hidden': 'true'
};
/* harmony default export */ __webpack_exports__["b"] = (Object(_utils_cache_js__WEBPACK_IMPORTED_MODULE_0__[/* getPropCacheMixin */ "c"])('$attrs', 'qAttrs'));

/***/ })

}]);
//# sourceMappingURL=vendor.32b2f07e.js.map